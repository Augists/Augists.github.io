<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Augists-ZDCZ</title>
  
  <subtitle>LESS is MORE</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://augists.top/"/>
  <updated>2025-07-27T15:04:53.887Z</updated>
  <id>https://augists.top/</id>
  
  <author>
    <name>Augists</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Load Balance Algorithm Analysis (What Is the Fair in Lb?)</title>
    <link href="https://augists.top/NOTES/LB/LB%20Algorithms%20Sharing/"/>
    <id>https://augists.top/NOTES/LB/LB%20Algorithms%20Sharing/</id>
    <published>2025-07-27T06:14:52.000Z</published>
    <updated>2025-07-27T15:04:53.887Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h1 id="Load-Balance-Algorithms"><a href="#Load-Balance-Algorithms" class="headerlink" title="Load Balance Algorithms"></a>Load Balance Algorithms</h1><div class="note info">            <p>写在最前：LB 算法的更新是一直在考虑如何才算是公平性的问题。它想讨论的是在不同层面（角度）的公平性和不同场景下的公平性，例如当你考虑到从 LB 还是后端服务器的角度考虑问题，亦或是不同服务器之间的性能差异、连接状态的差异，又或是在后端的扩缩容场景、跨不同地域场景？等</p><p>应该说 LB 算法之间没有绝对的好坏之分，而是根据场景需求选择最合适的方法</p><p>比较好的方式是评估哪台服务器有能力继续及时的处理请求，我们可以通过一些方式或指标来评判谁当前更有能力或更能及时的进行处理，将下一个新连接交给它。怎么判断谁现在更有能力或更能及时处理呢？</p><ul><li>当前 CPU 负载</li><li>已有的连接数量</li><li>网络连接空闲</li><li>[发散] 服务器主动提出想要接收 (或任务窃取)</li></ul>          </div><h2 id="基础公平（雨露均沾）"><a href="#基础公平（雨露均沾）" class="headerlink" title="基础公平（雨露均沾）"></a>基础公平（雨露均沾）</h2><ul><li>RR (Round Robin，轮询)</li></ul><p>按照所有 rs 组成的队列，遍历的选择下一个还未调度的 RS，保证了最基础的调度公平但不考虑任何可能的差异</p><h2 id="从服务器间存在差异的角度"><a href="#从服务器间存在差异的角度" class="headerlink" title="从服务器间存在差异的角度"></a>从服务器间存在差异的角度</h2><p>后端服务器本身在处理时必定有一些性能差异。相比于收集 RS 还有多少任务要处理，或是持续统计所有 RS 的 CPU 占用率，肯定是直接由 RS 性能来定义权重最为简单高效</p><p>权重需要动态可调。对业务来说，新上线的 RS 可以自行动态的由低到高的缓慢修改其权重来实现预热等一些需求，或是新增 RS 的权重相应拉高来保证它在开始时有更多的任务去处理来快速分担其他 RS 的压力等</p><h3 id="I-WRR"><a href="#I-WRR" class="headerlink" title="(I)WRR"></a>(I)WRR</h3><p>对每个 RS 都相应的配置其权重，优先选择当前权重最高的 RS 进行调度</p><ul><li>WRR (Weighted Round Robin，加权轮询)</li></ul><p>传统的 WRR 是以队列的层面看待，相当于为每个 RS 开辟一个发送队列，批量的将与权重数量相当的包直接转发给选择的 RS。它的好处也是可以批量处理，但是这对 LB 来说没有必要</p><p>简单的改进是以单个数据包的层面进行划分。对每个数据包来说选择当前权重最大的 RS 进行转发并更新其当前权重 </p><ul><li>IWRR (Interleaved WRR，交错的加权轮询)</li></ul><p>IWRR 尽量强调了轮询的处理，保证调度初期是以轮询的方式选择，直到其当前权重到 0 就直接跳过</p><p><strong>问题：</strong>权重差</p><ol><li>WRR 的权重配置中如果出现相差较多的权重差，就会导致某一段时间里做出<strong>连续相同</strong>的调度选择。这对 LB 来说是比较致命的，从 RS 的角度考虑，这一台较高会在短时间内打入大量的新连接 -&gt; <strong>平滑</strong>处理，打散高权重的连续调度</li><li>一整轮<strong>调度中间的权重更新</strong>会导致重新开始的调度，从更长的时间线上看会加剧连续调度的问题 -&gt; <strong>权重延迟更新</strong>，只更新 RS 权重但不修改当前权重值，会使得新权重在下一轮才会被感知到</li></ol><h3 id="SWRR"><a href="#SWRR" class="headerlink" title="SWRR"></a>SWRR</h3><ul><li>SWRR (Smooth Weighted Round Robin，平滑加权轮询)</li></ul><p>为了能打散高权重的连续调度，希望能有一种方法把连续调度尽可能平滑的插入到别的位置里</p><p>预先计算总权重</p><p>对于每一次选择：</p><ol><li>选择当前权重最高的 RS 调度</li><li>选择的 RS 当前权重减去总权重，加速抹平权重间的差值</li><li>为了保证当权权重之和仍然等于总权重，为每个 RS 的当前权重增加其定义的权重</li></ol><p><strong>问题：</strong>调度时间开销和相同调度选择</p><ol><li>每次调度需要遍历所有的 RS 找到当前权重最大的一个，查找调度<strong>时间开销</strong>为 O(N) 或 O(logN)（如果选择用例如最小堆维护，就需要额外花时间维护堆），更新当前权重 O(N) -&gt; <strong>预先计算</strong>调度顺序，调度时可以直接 O(1) 选择</li><li><strong>集群</strong>中每一个单机和单机中每一个 WORKER 都会做出相同的调度选择，使得从整体上来看（或从 RS 的角度看）LB 会做出多次连续重复的调度 -&gt; 调度顺序<strong>随机</strong>初始位置</li><li>其他优化方案参见 Nginx 章节</li></ol><h3 id="VNSWRR"><a href="#VNSWRR" class="headerlink" title="VNSWRR"></a>VNSWRR</h3><ul><li>VNSWRR (Virtual Node Smooth Weighted Round Robin，虚拟节点平滑加权轮询)</li></ul><p>对于 SWRR，预先计算好完整的调度顺序表，并在一开始选择随机的 idx 开始调度，从而打散刚启动时集群整体的连续相同调度</p><p><strong>Step + Unordered List 优化</strong></p><p>预先计算完整的调度顺序表在 RS 数量较多的时候会消耗较长的时间，而这段时间被认为是无法开始调度的</p><p>通过分 Step 计算来压缩一开始计算调度顺序表的时间，直到后续调度需要时再计算下一个 Step 的调度顺序，直到计算完完整的调度顺序表。但是这就导致随机 idx 只能在一个 Step 的范围内选择</p><p>打乱 RS 列表顺序，使相同权重的 RS 在计算调度顺序时会有更为随机的选择，从而使得在 Step 内的 idx 随机扩大到 Step 结尾的相同权重部分（由于 RS 权重配置中及 VNSWRR 调度顺序计算的过程中相同权重的出现很正常，随机范围扩大）</p><p><strong>Step 步长大小选择</strong></p><p>实验统计结果确定</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image1.png" alt="图片"></p><p>每一轮调度计算控制在 100k 纳秒以内</p><table><thead><tr><th><strong>rs num</strong></th><th><strong>step</strong></th></tr></thead><tbody><tr><td>&lt;= 200</td><td>128</td></tr><tr><td>&lt;= 300</td><td>64</td></tr><tr><td>&lt;= 400</td><td>32</td></tr><tr><td>more</td><td>16</td></tr></tbody></table><p><strong>GCD 优化</strong></p><p>调度顺序表的长度取决于总权重，但实际上会以所有 RS 权重的最小公倍数为一轮（实际上权重本来就可以除最大公约数进行约分，等效权重），所以只需要存放 GCD 后的总权重长度</p><p><strong>问题：</strong>分步计算、权重更新和乱序算法</p><ol><li>分布计算会在<strong>前几次调度时计算</strong>下一个 Step 的调度顺序表 -&gt; 改为 next_idx 快到 next_init_idx 时再计算下一个 Step，<strong>打散调度顺序的计算</strong></li><li>每次有 RS 的<strong>权重更新</strong>都会导致调度顺序表需要重新计算。如果有频繁的权重更新，会使得调度顺序表的计算开销被放大 -&gt; 问题1的解决方案能部分保证<strong>不会连续的计算</strong> Step 内调度顺序 + 调度顺序的计算现在放在 CTRL 线程，因读写锁与 WORKER 的调度互斥，改为 <strong>RCU</strong> 机制使计算时的调度可以继续用旧的调度顺序表来做调度选择？ + <strong>全局完整</strong>的调度顺序表计算（阻塞 CTRL 线程），WORKER 本地只随机 next_idx？</li><li>当前的<strong>乱序算法</strong>是将所有 RS 以随机顺序挨个添加到新的临时链表里，O(N^2) -&gt; 参考<strong>洗牌算法</strong>，BV1tNKfz1Eqc<ol><li>每张牌给随机值，按照随机值排序，时间 O(NlogN)，空间 O(N) 但可以和 Maglev 一致性哈希共用偏好数组</li><li>新版 Fisher-Yates 算法：依赖数组 O(1) 取值。维护牌堆数组的洗好和未洗两部分，每次将未洗的最后一张牌 last_idx 与随机未洗位置 random_idx (0 ~ last_idx) 的牌 O(1) 交换，并将最后一张 last_idx 当作洗好的部分。最终可以 O(N) 时间随机洗牌 -&gt; 需要额外存储一个 RS 数组用来取 random_idx</li></ol></li></ol><h2 id="从数据包间存在长短差异的角度"><a href="#从数据包间存在长短差异的角度" class="headerlink" title="从数据包间存在长短差异的角度"></a>从数据包间存在长短差异的角度</h2><p>数据包之间会有长短（尽管这在 LB 认为是一致的），它可能影响的更多是收发包的时间开销（假设 RS 正在大量收包甚至接近超过处理能力范围，RS 的收包成为瓶颈。因为 LB 不需要考虑这种情况，所以只做简单介绍）</p><p>参考上一章的权重分配，这里将数据包的大小作为权重的影响因素。刚发送了长数据包的 RS 不应成为下一次的选择</p><h3 id="DWRR"><a href="#DWRR" class="headerlink" title="DWRR"></a>DWRR</h3><ul><li>DWRR (Deflicit Weighted Round Robin，赤字轮询)</li></ul><p>赤字计数器表示此轮可以发送的最大字节数，如果其大于等于数据包大小则此轮可以发送（并将计数器减掉数据包大小），否则放到下一轮考虑。赤字计数器每轮均等增加或按照权重配置增加。对应到 LB 是为所有 RS 维护赤字计数器，每轮增加权重值，并选择下一个计数器值大于数据包大小的 RS 调度</p><p><strong>不同的 WRR 算法对比</strong></p><table><thead><tr><th><strong>Algorithm Compare</strong></th><th></th><th></th></tr></thead><tbody><tr><td>(I)WRR (Packet number level)</td><td>循环调度的<strong>周期短</strong> (RR IWRR)<br />实现简单，不需要维护太多信息<br />可以让<strong>权重延迟更新</strong>，不需要立刻响应权重变化</td><td>大报文获得的实际<strong>带宽</strong>要大于小报文<br /><strong>权重差值</strong>较大会导致最后大量新连接连续打到同一个 RS</td></tr><tr><td>DWRR (Bandwidth level)</td><td>考虑<strong>报文长度</strong>带来的带宽分配问题</td><td>LB 不需要考虑报文长度和带宽分配</td></tr><tr><td>SWRR (Packet level)</td><td><strong>平滑</strong>解决连续打到同一个 RS 的问题</td><td>每次调度都需要查找并维护，<strong>O(N)</strong><br />初始时以及动态调整权重时，所有 WORKER <strong>相同序列</strong>调度压力同一个 RS</td></tr><tr><td>VNSWRR (RS level)</td><td>预先计算调度顺序，<strong>O(1)</strong> 调度<br /><strong>打散</strong>初始时和调整权重时到 RS 的流量<br /><strong>分步 step</strong> 更新减缓调度计算开销</td><td>WORKER 之间<strong>不共享</strong>，每个单独计算一遍调度顺序表<br />next_idx <strong>随机范围</strong>不是完整的调度顺序表长度</td></tr></tbody></table><h2 id="从服务器连接状态的角度"><a href="#从服务器连接状态的角度" class="headerlink" title="从服务器连接状态的角度"></a>从服务器连接状态的角度</h2><p>相比于预定义的权重信息，统计当前的连接状态可以更灵活的处理 RS 的调度选择问题</p><p>因为 LB 以集群方式部署，本身从 RS 上收集会更能表示其真实的已有的连接状态，但是需要改造 RS 以例如 Sidecar 模式额外的收集信息且对 RS 造成了额外的开销。对 LB 更优的方式是在自己集群内进行全局的统计</p><h3 id="minConn"><a href="#minConn" class="headerlink" title="minConn"></a>minConn</h3><ul><li>minConn (最小连接数)</li></ul><p>维护对所有 RS 的连接数统计（借会话同步来收集其他 LB 机器上的连接数信息），每次选择当前连接数最少的 RS 调度。通过维护连接数最小堆的方式 O(1) 的选择调度并 O(logN) 的维护。但是由于 WORKER 之间不共享，需要额外的定时任务来收集所有 WORKER 的连接数信息更新到每一个 WORKER 本地，且面对大量的连接数更新，直接重建堆；由于集群内不共享，需要依靠会话同步的方式来获取其他机器的连接数统计</p><p><strong>问题：</strong>WORKER 间不共享、集群内不共享（长短连接）和权重配置</p><p>既然应该选择全局（或者说从 RS 角度）的最小连接，在追求效率而<strong>不共享</strong>的 LB 就需要其他的方式来共享连接数信息。</p><ol><li>定时任务收集<strong>所有 WORKER</strong> 连接数信息和重建最小堆</li><li><strong>集群内</strong>会话同步只收集长连接，面对大量持续建立的新<strong>短连接</strong>没有办法建立全局视野</li><li>当前实现里 minConn 调度时不会考虑 RS 的<strong>权重分配</strong>，建立连接时只会将本 WORKER 连接数 + worker_cnt -&gt; 建立连接时连接数 + worker_cnt * weight，统计时也直接计算 conn_cnt * weight 来建堆（注意这里”权重”越低，”权重”越高 :) 或者改为除权重后向上取整</li></ol><h2 id="从完全随机的角度"><a href="#从完全随机的角度" class="headerlink" title="从完全随机的角度"></a>从完全随机的角度</h2><p>通过哈希的方式可以保证相同的明文值每次都会哈希为相同的密文（幂等性），可以额外的保证例如相同的 QUIC CID 转发到相同的 RS 进行处理，或是断开的连接依靠相同的五元组打回与上一次连接相同的 RS</p><p><strong>公平性</strong>依靠哈希算法的<strong>散列程度</strong></p><h3 id="哈希取模"><a href="#哈希取模" class="headerlink" title="哈希取模"></a>哈希取模</h3><ul><li>hash</li></ul><p>根据某一个特定的值进行哈希（随机打散），再对 RS 数量取模</p><p>LB 本身存储 RS 是以链表和哈希桶的方式，需要再额外以数组形式存储调度顺序表以保证 O(1) 的调度选择</p><p><strong>问题：</strong>可以看到其调度公平的影响因素为哈希算法和 RS 数量</p><ol><li>首先需要保证哈希明文的唯一和哈希结果尽量分散，尤其当 <strong>RS 数量较少</strong>的时候，若再遇到哈希碰撞就会导致很明显的调度不均 -&gt; <strong>填充虚拟节点</strong></li><li><strong>RS 数量变化</strong>会导致之前哈希的结果都发生改变 -&gt; <strong>一致性哈希</strong>降低影响</li></ol><p>从原本的 mod N 哈希方式来看，只有当 hash(k) 的结果对变更前后的两个数量的余数相等时才可能一致</p><p>例如 rs num 从 4 变成 5，则 0, 1, 2, 3, 20, 21, 22, 23, …，以两个数量的最小公约数 (least common multiple, LCM) 为一轮，即对 m 和 n，只有 $\frac{min(m, n)}{LCM(m, n)}$ 不变</p><p>而在一致性哈希中，哈希表槽位数的改变平均只需要对 $\dfrac{K}{n}$ 个关键字重新映射，其中 K 是关键字数量，n 时槽位数</p><h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><p>考虑到扩缩容是很常见的事情，一致性哈希希望能减小扩缩容带来的影响</p><p>但是对 LB 来说，大多数只需要选择出调度的结果，并不需要对之前的调度结果负责（已由连接状态记录）。但是在 QUIC CID Hash 场景下，哈希带来的影响就更有必要考虑了</p><h4 id="哈希环（割环法）"><a href="#哈希环（割环法）" class="headerlink" title="哈希环（割环法）"></a>哈希环（割环法）</h4><blockquote><p>1997</p></blockquote><ul><li>哈希环（割环法）</li></ul><p>哈希值映射到一个大圆环 (2^32) 空间内的槽位，查找时在圆环中顺时针查找映射过的槽位</p><p>当往一个哈希环中新增一个槽位时，只有被新增槽位拦下来的哈希结果的映射结果是变化的</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image3.jpeg" alt="图片"></p><p>当从一个哈希环中移除一个槽位时，被删除槽位的映射会转交给下一槽位，其他槽位不受影响</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image4.jpeg" alt="图片"></p><p>在实际应用中，还可以对槽位（节点）添加<strong>权重</strong>，通过构建很多指向真实节点的虚拟节点，也叫影子节点。通常采用一个节点创建 40 个影子节点，节点越多映射分布越均匀。影子节点之间是平权的，选中影子节点，就代表选中了背后的真实节点。权重越大的节点，影子节点越多，被选中的概率就越大。但是需要注意的是，影子节点增加了内存消耗和查询开销，权重的调整也会带来数据迁移的工作</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image5.jpeg" alt="图片"></p><p><strong>优势：</strong>一致性哈希和权重分配</p><p><strong>问题：</strong>调度查找开销和额外空间开销</p><ol><li>调度时需要在哈希环中顺序的查找到槽位（或虚拟节点），造成额外的<strong>查找开销</strong> -&gt; 预先填充整个哈希环，应该可以看作 O(1) 调度查找</li><li>需要开辟大量<strong>空间</strong>用来做哈希环和影子节点</li><li>哈希环算法的映射结果不是很均匀，当有 100 个影子节点时，映射结果的分布的标准差约 10%；当有 1000 个影子节点时，降低到约 3.2% </li></ol><blockquote><p><a href="https://dgryski.medium.com/consistent-hashing-algorithmic-tradeoffs-ef6b8e2fcae8#890d">一致性哈希：算法均衡 by Damian Gryski</a></p></blockquote><blockquote><p>实际的实现方式：</p><ol><li><p>建立以影子节点 hash 值排序的虚拟节点链表，并在这基础上以类似跳表的形式加速查询时 hash 定位影子节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hash_ring &#123;</span><br><span class="line">len;  <span class="comment">// shadow_node length = sum(node * weight * shadow_cnt)</span></span><br><span class="line">shadow_node <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line">shadow_node &#123;</span><br><span class="line">*rs;</span><br><span class="line">hash;</span><br><span class="line">*next_shadow_node;</span><br><span class="line">&#125;</span><br><span class="line">jump_list[level][] = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>跳表的层数和删除，逻辑复杂</p></li><li><p>改为用数组存储虚拟节点表，同样以影子节点的 hash 值排序。查找时对查询的 key hash 值二分查找，简化逻辑（普遍选择的做法）<br>查询同样是 O(logN)</p></li><li><p>平铺预填充，对 hash 值范围进行限制，将 RS 指针直接填充到 hash 范围大小的数组里 O(1) 查找<br>如果是 32bits 的哈希范围，就代表需要开辟 sizeof(ptr) * pow(2, 32) 大小的数组，4 字节指针时总存储约为 17GB。但如果是 16bits (65536)，就只需要 256KB</p></li></ol></blockquote><h4 id="Jump-Hash-跳跃一致性哈希"><a href="#Jump-Hash-跳跃一致性哈希" class="headerlink" title="Jump Hash 跳跃一致性哈希"></a>Jump Hash 跳跃一致性哈希</h4><ul><li>Jump Hash 跳跃一致性哈希</li></ul><blockquote><p>A Fast, Minimal Memory, Consistent Hash Algorithm<br><a href="https://arxiv.org/abs/1406.2294">https://arxiv.org/abs/1406.2294</a><br>2014</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">JumpConsistentHash</span><span class="params">(<span class="keyword">uint64_t</span> key, <span class="keyword">int32_t</span> num_buckets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> b = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; num_buckets) &#123;</span><br><span class="line">        b = j;</span><br><span class="line">        key = key * <span class="number">2862933555777941757U</span>LL + <span class="number">1</span>;</span><br><span class="line">        j = (b + <span class="number">1</span>) * (<span class="keyword">double</span>(<span class="number">1L</span>L &lt;&lt; <span class="number">31</span>) / <span class="keyword">double</span>((key &gt;&gt; <span class="number">33</span>) + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当槽位数量发生变化时，可以直接计算有多少个哈希结果需要重新映射。通过伪随机数来决定一个哈希结果每次要不要跳到新的槽位中去，最终只需要保证新的桶中有 key_cnt / slot_cnt 个从前面槽位移动过来的 key 即可保证最小化重新映射</p><p>由于是通过伪随机的方式，并将哈希 key 作为伪随机数种子，对于给定的哈希槽位数量，key 的映射结果都是唯一确定的</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image6.jpeg" alt="图片"></p><p>「伪随机哈希优化」</p><p>在上面的实现里，需要判断 N 次伪随机值来确定是否要跳跃到当前的最大桶上，计算哈希所需要花费的时间时间 O(N)。但是注意到元素只有很小的概率会移动，它只会在桶增加时移动，且每次移动都必然移动到最新的桶里，即如果一个元素移动到 b 号桶（从 0 开始计号）里，必然是因为桶增加到 b+1 个导致。所以我们只需要求出下一次移动的目标 j，即可跳过 b+2 … j 次伪随机的步骤</p><p>下一次移动到 j 意味着 b+2 … j 都伪随机到了不移动。另我们知道当桶增加到 N 个时元素的移动概率为 1/N，不移动的概率为 (N-1)/N。所以元素移动到 j 的概率 Pj 为<br>$$<br>Pj = (b+1)(b+2)(b+3)…(j-1) / (b+2)(b+3)(b+4)…j = (b + 1) / j\<br>j = (b + 1) / Pj<br>$$<br>那么我们可以改变思路，将 Pj 作为伪随机的值 r，就可以直接通过伪随机值来获取 j 了<br>$$<br>j = floor((b + 1) / r)<br>$$<br>优化前的代码为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">consistent_hash</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> num_buckets)</span> </span>&#123;</span><br><span class="line">    srand(key);</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">2</span>; n &lt;= num_buckets; ++n) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">double</span>)rand() / RAND_MAX &lt; <span class="number">1.0</span> / n)</span><br><span class="line">            b = n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后的代码为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">consistent_hash</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> num_buckets)</span> </span>&#123;</span><br><span class="line">    srand(key);</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; num_buckets) &#123;</span><br><span class="line">        b = j;</span><br><span class="line">        r = (<span class="keyword">double</span>)rand() / RAND_MAX;</span><br><span class="line">        j = <span class="built_in">floor</span>((b + <span class="number">1</span>) / r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终将跳跃一致性哈希算法的时间优化到 O(logN) </p><p><strong>优势：</strong>在执行速度、内存消耗、映射均匀性上都比哈希环算法更好，时间可以由 O(N) 优化至 O(logN)</p><p><strong>问题：</strong></p><ol><li>无法自定义槽位标号，必须从 0 开始，意味着需要 rs_buf 数组</li><li>只能在<strong>尾部增删</strong>节点，导致删除中间节点 i 需要先把后面所有的 [i:] 都删掉，再把 [i+1:] 的添加回来 -&gt; LB 不需要持久化连接（维护已建立过的连接 key）不需要管</li></ol><blockquote><p>实际的实现方式：</p><ol><li><p>在负载均衡调度的场景下，如果一个连接建立后断开，下一次又来建立连接，就要看是否需要重回到之前的调度，这也是一致性哈希想要控制的问题。如果不需要对持久化做 100% 保证，那么跳跃一致性哈希就不需要维护 key 的移动，仅仅需要使用  <code>JumpConsistentHash</code> 选择出调度的 RS 即可</p><p>RS_idx &lt;- JumpConsistentHash &lt;- key(srcIP or QUIC cid), RS_num</p></li></ol></blockquote><h4 id="Multi-Probe-一致性哈希-MPCH"><a href="#Multi-Probe-一致性哈希-MPCH" class="headerlink" title="Multi-Probe 一致性哈希 (MPCH)"></a>Multi-Probe 一致性哈希 (MPCH)</h4><ul><li>Multi-Probe 一致性哈希</li></ul><blockquote><p>Multi-Probe Consistent Hashing</p><p><a href="https://arxiv.org/abs/1505.00062">https://arxiv.org/abs/1505.00062</a></p><p>2015</p></blockquote><p>目标：灵活调节节点大小和降低方差</p><p>基本思想是在哈希环的基础上查找时对 key 进行 k 次哈希，返回所有哈希查询中距离最近的节点。k 的值由所需的方差决定。对于峰均值比 1.05（负载最重的节点最多比平均值高 5%），k 为 21。作为对比，哈希环算法需要 700lnN 个副本。对于 100 个节点，这相当于超过 1MB 内存</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image7.jpeg" alt="图片"></p><h4 id="Maglev-一致性哈希"><a href="#Maglev-一致性哈希" class="headerlink" title="Maglev 一致性哈希"></a>Maglev 一致性哈希</h4><ul><li>Maglev 一致性哈希</li></ul><blockquote><p>Maglev: A Fast and Reliable Software Network Load Balancer</p><p><a href="https://research.google/pubs/maglev-a-fast-and-reliable-software-network-load-balancer/">https://research.google/pubs/maglev-a-fast-and-reliable-software-network-load-balancer/</a></p><p>2016</p></blockquote><p>建立一个槽位查找表，对输入 key 哈希取余就可以映射到一个槽位。计算查找表需要为每个槽位生成一个偏好序列 Permutation，按照偏好序列中数字的顺序，每个槽位轮流填充查找表。如果填充的目标位置已被占用，则顺延该序列的下一个目标位置填充</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image8.jpeg" alt="图片"></p><p>伪代码</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image9.png" alt="图片"></p><p>由于存储了偏好序列表，槽位的变动对查找表的影响就是可控的了</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image10.jpeg" alt="图片"></p><p>生成偏好序列的方式有很多，只需要保证其随机和均匀。查找表的长度 M 应是一个质数，这样可以减少哈希碰撞和聚集，让分布更均匀。查找表建立时间 O(MlogM)，最坏 O(M^2)</p><p>如果想要实现<strong>带权重</strong>的 Maglev 哈希，可以通过改变槽位间填表的相对频率来实现加权</p><blockquote><p>关于时间复杂度计算，可以参考 <a href="https://writings.sh/post/consistent-hashing-algorithms-part-4-maglev-consistent-hash#maglev哈希的复杂度分析">Maglev 哈希的复杂度分析</a></p></blockquote><p>「随机生成偏好序列 permutation」</p><p>Google 方法是，取两个无关的哈希函数 h1 h2，给槽位 b 生成时，先用哈希计算 offset 和 skip<br>$$<br>offset = h1(b) % M\<br>skip = h2(b) % (M-1) + 1<br>$$<br>然后对每个 j，计算<br>$$<br>permutation[j] = (offset + j * skip) % M<br>$$<br>这里通过类似二次哈希的方法，使用两个独立无关的哈希函数来减少映射结果的碰撞次数，提高随机性。但是这要求 M 必须是质数，才能保证与 skip 互质，最终遍历完整个 M</p><p>「槽位增删分析」</p><blockquote><p>Experiments in Google Paper Section 5.3</p></blockquote><p>实验设置：1000 台后端服务器，对每个 k-failure 重新生成查找表并检查入口变化，重复 200 次取平均值</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image11.png" alt="图片"></p><p>按照实验结果，M = 65537，k = 5 时，只有约 1180 个入口会变化 (约 1.8%)</p><blockquote><p>Google 论文中说核心关注的两个问题是：</p><ol><li><strong>load balancing</strong>: each backend will receive an almost equal number of connections.</li><li><strong>minimal disruption</strong>: when the set of backends changes, a connection will likely be sent to the same backend as it was before<br>其中第一个是最为关键的，同时 Maglev 每个 VIP 绑定到后端的几百个服务器，每个都需要很大的 lookup table。并且，尽管想要最小化一致性哈希在扩缩容场景下的变化，但因为有 connections’ affinity 亲和性 (conntrack) （且连接复用的 reset 也是被允许的），少量的槽位增删干扰也是可以接受的</li></ol></blockquote><p><strong>优势：</strong>O(1) 的调度查找、均匀且一致性的哈希映射和可以增加权重的影响</p><p><strong>问题：</strong></p><ol><li>需要<strong>额外存储</strong>每个槽位的偏好序列和槽位查找表 (rs_buf)</li><li>虽然避免了全局重新映射，但是没有做到最小化的重新映射</li><li>Google 的测试里，65537 大小的查找表生成时间为 1.8ms，655373 大小的查找表生成时间为 22.9ms</li></ol><h4 id="AnchorHash-一致性哈希"><a href="#AnchorHash-一致性哈希" class="headerlink" title="AnchorHash 一致性哈希"></a>AnchorHash 一致性哈希</h4><blockquote><p>AnchorHash: A Scalable Consistent Hash<br><a href="https://arxiv.org/abs/1812.09674">https://arxiv.org/abs/1812.09674</a><br>2020</p></blockquote><ul><li>AnchorHash 一致性哈希</li></ul><blockquote><p>池化+标记的思想，通过复用来减少重映射</p></blockquote><p>想解决槽位增删时的高迁移成本和平衡性下降问题</p><p>预先定义固定大小 a（预期可能达到的最大节点规模）的虚拟节点集合为锚点集，工作节点是锚点集的子集</p><p>当对 key 分配时，</p><ol><li>先用 H1(key) 映射到锚点集的一个桶 b</li><li>如果桶 b 是工作节点，则直接分配</li><li>否则启动回填过程<ol><li>用另一个哈希 H2(key) 计算一个起始点</li><li>在锚点集按顺序查找下一个是工作节点的桶 b’</li></ol></li></ol><p>设计了一个 next 数组用来表示当前桶不可用时应该从哪找下一个候选桶，在节点增删时维护 next 指针</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/anchorHash_removal.png" alt="anchorHash removal"></p><p>GetBucket 时间为 $1+ln(\dfrac{a}{w})$</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image12.jpeg" alt="图片"></p><p>M: Mapper from anchor A to rs S</p><p>R: Removed label</p><p><strong>优势：</strong></p><ol><li>删除节点时，只影响直接映射到该节点桶以及通过回填路径依赖该桶的 key</li><li>存储固定大小的数组记录，不需要虚拟节点</li><li>查找通常只需要一次初始哈希和平均不到一次回填跳转</li><li>不会因为其他节点的增删而影响当前节点的映射 key</li><li>负载平衡性高较均匀，键分配到工作节点的方差较低</li></ol><p><strong>问题：</strong></p><ol><li>额外的内存开销来存储三个 O(a) 数组 workers, removed, next</li><li>新增节点只接收映射到它自身桶的新键和未来因其他节点离开而回填的键，不会立即分担现有节点的负载</li><li>需要维护 next 指针的逻辑较为复杂</li></ol><h4 id="DxHash-一致性哈希"><a href="#DxHash-一致性哈希" class="headerlink" title="DxHash 一致性哈希"></a>DxHash 一致性哈希</h4><blockquote><p>DxHash: A Scalable Consistent Hashing Based on the Pseudo-Random Sequence</p><p>arxiv.org/pdf/2107.07930</p><p>2021</p></blockquote><ul><li>DxHash 一致性哈希</li></ul><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/DxHash.png" alt=""></p><p>NSArray 是长度为大于 <code>RS_num</code> 的最小 $2^n$ 值，例如 RS 是 4 台，则 NSArray 长度为 8</p><p>通过伪随机数机制来保证同一个 key 有固定有序且无羡长度的服务器序列</p><blockquote><p> Minimal Disruption: the changed node is either the original or the destination of the remapped keys.</p></blockquote><p>为了防止无限长的服务器序列一直映射不到活动节点，DxHash 对搜索的次数限制到 8n，n 为 cluster size<br>$$<br>P = (\frac{n - 1}{n})^{8n}<br>$$<br>当 n 足够大时，P 接近 $\dfrac{1}{e^8}$，约为 0.03%，作者认为概率足够小</p><p>NSArray 不够时进行两倍扩容+节点迁移</p><p>![](<a href="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/DxHash">https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/DxHash</a> Scaling.png)</p><p>可以以类似切片的形式来保证不会需要节点迁移</p><p>「质疑」作者没有讲 NSArray 扩容后出现的大量变化的重映射问题</p><blockquote><p>When the cluster reaches its maximum capacity and all items in the NSArray are active, DxHash behaves as a classic hash algorithm that maps objects to nodes with a single calculation.</p></blockquote><p>权重通过虚拟节点层实现</p><h4 id="一致性哈希算法对比"><a href="#一致性哈希算法对比" class="headerlink" title="一致性哈希算法对比"></a>一致性哈希算法对比</h4><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image13.jpeg" alt="图片"></p><p>不同节点数量时单次查询的时间（纳秒）</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image14.jpeg" alt="图片"></p><ul><li>𝑉：ring 中每个物理节点对应的虚拟节点个数</li><li>𝑊：集群中的 working 节点数目</li><li>𝑃：Multi-probe 中的探针(哈希)个数</li><li>𝑀：Maglev 中每个节点在查询表中的位置数</li><li>𝐴：集群中的所有节点数(包括 working 和非 working 的节点)</li></ul><table><thead><tr><th></th><th>均匀性</th><th>最小化重新映射</th><th>时间复杂度</th><th>加权映射</th></tr></thead><tbody><tr><td>哈希环</td><td>还行</td><td>✅</td><td>O(logN) 或 O(1)</td><td>✅</td></tr><tr><td>跳跃一致性哈希</td><td>✅</td><td>✅</td><td>O(logN)</td><td>✅</td></tr><tr><td>Maglev 哈希</td><td>✅</td><td>还行</td><td>O(1)</td><td>✅</td></tr></tbody></table><h3 id="Rendezvous-哈希"><a href="#Rendezvous-哈希" class="headerlink" title="Rendezvous 哈希"></a>Rendezvous 哈希</h3><blockquote><p>1997</p></blockquote><ul><li>Rendezvous Hash</li></ul><p>「核心思想」</p><p>如果只是对服务器 ID 进行哈希，那么当修改服务器的数量时，所有的哈希值都会发生变化。当对目标服务器的选择和服务器的数量没有直接关系时，就可以避免服务器的增删带来的影响</p><p>「算法思路」</p><p>为每个 key 生成一个随机有序的服务器列表，并选择列表中的第一个作为目标服务器</p><p>如果选择的第一台服务器下线时，只需要将 key 转移到列表中的第二台服务器并作为新的第一台服务器即可</p><ol><li>对每个服务器计算 key:rs_id 哈希来生成一组整数哈希值</li><li>基于该哈希值对服务器进行排序，得到一个随机排列的服务器列表</li></ol><p>对于有权重分配的场景，可以基于 w / lnh(x) 排序，h(x) 哈希范围在 [0, 1]</p><p><strong>优势：</strong></p><ol><li>将服务器选择<strong>和数量完全解绑</strong>，并提供了第二选择服务器，解决了哈希级联故障转移的问题</li><li>没有额外的<strong>内存存储开销</strong></li></ol><p><strong>问题：</strong>调度的时间开销和扩容影响第一选择</p><ol><li>Rendezvous 哈希进行调度时需要对所有 RS 进行哈希计算并排序，<strong>时间开销</strong> O(NlogN)。实际上在取 RS 哈希时应该先检查存活，所以只需要 O(N) 查找哈希值最大的一个即可</li><li>扩容时新服务器可能成为一些已有 key 的第一选择，所以<strong>很难维护第一选择的不变</strong>。在分布式存储场景下需要重新校验所有 key，但在缓存和负载均衡场景下影响可以接受</li></ol><p>「变体」</p><p>调度时间优化至 O(logN)。把原始节点分成若干个虚拟组，虚拟组一层一层组成一个“骨架”，然后在虚拟组中按照 Rendezvous 哈希计算出最大的节点，从而得到下一层的虚拟组，再在下一层的虚拟组中按同样的方法计算，直到找到最下方的真实节点</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image15.gif" alt="图片"></p><p>「扩展思考」</p><p>对每个 RS 都计算哈希并排序的时间开销较高，可以改为直接以 key 哈希后进行切分，每 MAX_RS_NUM (1024 10bits) 为一组，顺序判断对应的 RS 是否存在并存活，维护 RS 数组且在删除时不向前移动补齐。或是提供第二种哈希算法作为备选</p><p>目的：提供第二选择，而非在 rs_buf 中顺序的向后查找</p><h3 id="Locality-Sensitive-哈希-LSH"><a href="#Locality-Sensitive-哈希-LSH" class="headerlink" title="Locality Sensitive 哈希 (LSH)"></a>Locality Sensitive 哈希 (LSH)</h3><blockquote><p><a href="https://randorithms.com/2019/09/19/Visual-LSH.html">LSH 位置敏感哈希入门</a></p></blockquote><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image16.png" alt="图片"></p><p>「进阶」</p><p>Multi-Probe LSH</p><p>核心思想是使用一个严格挑选的探测序列来检测多个可能包含最近邻点的桶，增大找到近邻点的概率。实验证明，在保证相同时间效率的情况下，减少了一个数量级的哈希表数量；在保证相同的搜索质量的情况下，减少了查询时间，同时少用了 5-8 倍的哈希表。 </p><p>「扩展思考」</p><p>LSH 在这里引入是因为它会将相似的 key 更有可能计算出相同的哈希结果（即发生哈希碰撞），在以地理位置等进行划分的场景下可能会有用，这里不做详细介绍 </p><h2 id="产品实现"><a href="#产品实现" class="headerlink" title="产品实现"></a>产品实现</h2><h3 id="Bilibili"><a href="#Bilibili" class="headerlink" title="Bilibili"></a>Bilibili</h3><p>LB 1.0</p><ul><li>WRR<ul><li>问题<ul><li>无法快速摘除有问题的节点</li><li>无法均衡后端负载</li><li>无法降低总体延迟</li></ul></li></ul></li></ul><p>LB 2.0</p><ul><li><p>动态感知的 WRR</p><ul><li><p>方式</p><ul><li>利用每次 RPC 请求返回的 Response <strong>夹带 CPU 使用率</strong></li><li>每隔一段时间整体调整一次节点的权重分数</li></ul><p>$$<br>peer.score = success_rate \div (lantency \times cpuUsage)<br>$$</p></li><li><p>问题</p><ul><li>信息滞后和分布式带来的羊群效应 (VNSWRR 想解决的问题)</li></ul></li></ul></li></ul><p>LB 3.0</p><ul><li>带<strong>时间衰减</strong>的 Exponentially Weighted Moving Average 带系数的滑动平均值，实时更新延迟、成功率等信息，尽可能获取最新的信息</li><li>引入 best of two random choices 算法，加入<strong>随机性</strong>，在信息延迟较高的场景有效果</li><li>引入 inflight 作为参考，<strong>平衡坏节点流量</strong>，inflight 越高被调度到的机会越少</li></ul><blockquote><p>The power of two choices in randomized load balancing [Papaer]</p></blockquote><p>计算权重分数 $success \times metaWeight \div (cpu \times math.Sqrt(lag) \times (inflight + 1))$</p><ul><li>success: 客户端成功率</li><li>metaWeight: 在服务发现中设置的权重</li><li>cpu: 服务端最近一段时间内的 cpu 使用率</li><li>lag: 请求延迟</li><li>inflight: 当前正在处理的请求数</li></ul><p>lag 计算</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&amp;设置上次测算的时间点</span></span><br><span class="line">stamp := atomic.SwapInt64(&amp;pc.stamp, now)</span><br><span class="line"><span class="comment">// 获得时间间隔</span></span><br><span class="line">td := now - stamp</span><br><span class="line"><span class="comment">// 获得时间衰减系数</span></span><br><span class="line">w := math.Exp(<span class="keyword">float64</span>(-td) / <span class="keyword">float64</span>(tau))</span><br><span class="line"><span class="comment">// 获得延迟</span></span><br><span class="line">lag := now - start</span><br><span class="line">oldLag := atomic.LoadUint64(&amp;pc.lag)</span><br><span class="line"><span class="comment">// 计算出平均延迟</span></span><br><span class="line">lag = <span class="keyword">int64</span>(<span class="keyword">float64</span>(oldLag) * w + <span class="keyword">float64</span>(lag) * (<span class="number">1.0</span> - w))</span><br><span class="line">atomic.StoreUint64(&amp;pc.lag, <span class="keyword">uint64</span>(lag))</span><br></pre></td></tr></table></figure><p>best of two 算法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a := rand.Intn(<span class="built_in">len</span>(p.conns))</span><br><span class="line">b := rand.Intn(<span class="built_in">len</span>(p.conns) - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> b &gt;= a &#123;</span><br><span class="line">    b = b + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">nodeA := p.conns[a]</span><br><span class="line">nodeB := p.conns[b]</span><br><span class="line"><span class="keyword">if</span> nodeA.load() * nodeB.health() * nodeB.Weight &gt; nodeB.load() * nodeA.health() * nodeA.Weight &#123;</span><br><span class="line">    pick_node = nodeB</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pick_node = nodeA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="美团-MGW"><a href="#美团-MGW" class="headerlink" title="美团 MGW"></a>美团 MGW</h3><ul><li>CHash (srcIP)<ul><li>哈希环：因为 MGW 是以集群的形式存在的，当多个应用服务器发生上线下线操作时，反馈到不同的 MGW 节点上就有可能会出现顺序不一致的问题，因此无论不同的 MGW 节点产生何种应用服务器上下线顺序，都需要保证最终的映射关系一致，因为如果不一致就导致相同客户端的连接会被不同的 MGW 节点调度到不同的应用服务器上，也就违背了源 IP  Hash 调度器的原则</li><li>分享文档提到了 Maglev</li></ul></li></ul><blockquote><p>RS 平滑下线：保证此 RS 已有连接正常工作，但不会往上面调度新的连接。当所有已有连接结束以后，MGW 会上报一个结束的状态，用户就可以根据这个结束的状态对 RS 进行升级操作，升级后再调用上线接口让这个 RS 器进行正常的服务</p></blockquote><blockquote><p>故障切换：交换机侧全部使用物理接口并且服务器侧对接口进行断电时，交换机会瞬间将流量切换到其他机器上，是 0 丢包的。但是网卡驱动是跑在主程序里面的，当主程序挂掉以后，就无法再对网口执行断电操作了，因此为了解决这个问题，主进程会捕获异常信号，当发现异常时就对网卡进行断电操作，在断电操作结束以后再继续将信号发给系统进行处理</p></blockquote><blockquote><p>恢复与扩容：MGW 上线有一个预上线的中间状态，不让交换机感知到自己上线（不会把流量切过来），先进行 CT 同步</p><ol><li>由于集群中并没有一个主控节点来维护一个全局的状态，如果 request 报丢失或者 session 同步的数据丢失的话，那新上线节点就没办法维护一个全局的 session 状态。但是考虑到所有节点都维护着一个全局的 session 表，因此所有节点拥有的 session 数量都是相同的，那么就可以在所有节点每次做完批量同步以后发送一个 finish 消息，finish 消息中带着自己拥有的 session 数量。当新上线节点收到 finish 消息以后，便会以自己的 session 数量与 finish 中的数量做对比。当达到数量要求以后，新上线节点就控制自己进行上线操作。否则在等待一定的超时时间以后，重新进行一次批量同步操作，直到达到要求为止</li><li>在进行批量同步操作时，如果出现了新建连接，那么新建连接就不会通过批量同步同步到新上线的机器上。如果新建连接特别多，就会导致新上线机器一直达不到要求。因此，需要保证处于预上线状态的机器能接收到增量同步数据，因为新建连接可以通过增量同步同步出来。通过增量同步和批量同步就可以保证新上线机器可以最终获得一个全局的 session 表</li></ol></blockquote><h3 id="Huawei"><a href="#Huawei" class="headerlink" title="Huawei"></a>Huawei</h3><ul><li>WRR<ul><li><strong>依次</strong>将请求分发给不同的服务器。权重大的后端服务器被分配的概率高，相同权重的服务器处理相同数目的连接数</li><li>短连接</li><li>会话保持类型：源 IP</li></ul></li><li>W-minConn<ul><li>给每个服务器分配不同的权重，使其能够<strong>接受相应权值数的服务请求</strong></li><li>长连接，<strong>实时监控</strong>连接数变化，降低峰值负载</li><li>只能统计 LB 与 RS 之间的连接，RS 整体连接数无法获取；新增 RS 时可能导致过载</li><li>会话保持类型：源 IP</li></ul></li><li>sip hash<ul><li>一致性哈希</li><li>用来保持用户状态或会话的应用</li><li>已默认支持源 IP 会话保持</li></ul></li><li>QUIC cid hash<ul><li>会话保持类型：源 IP</li></ul></li></ul><blockquote><p>注意到 DGW 里之前也支持全调度算法的 sticky，最后限制了只有完全随机的 sip hash 可以有 sticky。可以想象例如 WRR 调度新连接时并不会考虑之前有多少 sticky 连接，这会导致权重之间的差异被无限放大</p><p>相当于不是按照<strong>连接级别</strong>在调度，而是按照<strong>客户端</strong>的级别</p><p>但是在一致性哈希上，会话保持是有意义的，它为之前调度过的源 IP 持久化调度选择，从而防止如扩缩容、cid 变更等带来的 CT 失效</p></blockquote><h3 id="Aliyun"><a href="#Aliyun" class="headerlink" title="Aliyun"></a>Aliyun</h3><ul><li>RR</li><li>WRR</li><li>W-minConn</li><li>CHash (srcIP, 4-tuple, QUIC ID)</li></ul><blockquote><p>阿里云只在 CHash 部分提到了会话保持（哈希特性自带），并没有说明有提供类似 sticky 的保持能力。扩缩容时会导致一部分请求需要重新分配</p><p>虽然 NLB 和 CLB 支持 QUIC ID 哈希，但仅支持 Q10、Q29 版本</p></blockquote><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ul><li>WRR 默认和兜底，其他调度算法一直尝试失败会改为默认算法<ul><li><code>nginx/src/http/ngx_http_upstream_round_robin.c : ngx_http_upstream_get_peer</code></li></ul></li><li>least-connect (W-minConn)<ul><li><code>nginx/src/http/modules/ngx_http_upstream_least_conn_module.c : ngx_http_upstream_get_least_conn_peer</code></li></ul></li><li>W-ip-hash (srcIP)<ul><li><code>nginx/src/http/modules/ngx_http_upstream_ip_hash_module.c : ngx_http_upstream_get_ip_hash_peer</code></li></ul></li><li>W-chash 哈希环<ul><li><code>nginx/src/http/modules/ngx_http_upstream_hash_module.c : ngx_http_upstream_update_chash</code></li></ul></li><li>random<ul><li><code>nginx/src/http/modules/ngx_http_upstream_random_module.c : ngx_http_upstream_peek_random_peer</code></li></ul></li><li>Fair Queueing 公平队列：根据后端节点服务器的响应时间来分配请求</li></ul><p>注意，文档中说只有 ip-hash 有会话保持</p><blockquote><p><strong>为什么 Nginx 实现的所有的调度算法都没有想要空间换时间，全部都是 O(N) 的查找？</strong></p><ol><li><strong>动态权重和状态</strong>：<ul><li><strong>核心原因-权重可变性：</strong>Nginx 支持运行时动态调整后端服务器的权重（weight）。这是管理员进行灰度发布、流量调整、临时降级等操作的核心手段。这会导致 <strong>O(1) 预计算失效。</strong>在权重频繁调整（即使是偶尔）或服务器数量（N）很大的场景下，这个重新计算的成本（O(N) 或 O(NlogN) 甚至更高）会变得非常高，并且可能发生在处理请求的关键路径上，造成延迟抖动</li><li><strong>状态感知算法</strong>：像 least_conn（最小连接数）和 least_time（最短响应时间）这类算法，其选择标准完全依赖于后端服务器的实时状态，无法预先计算出一个固定的调度序列</li></ul></li><li><strong>N 通常较小</strong>：<ul><li><strong>现实集群规模</strong>：在绝大多数实际部署中，一个 upstream 块（后端服务器组）包含的后端服务器数量 N 通常是有限的，一般在几十台到一两百台的量级。对于这个数量级，O(N) 的遍历在现代 CPU 上可能是纳秒到微秒级别。<strong>O(1) 优势不明显</strong>，O(1)  算法（如哈希表查找）带来的绝对时间节省非常有限，甚至可能因为哈希计算、可能的哈希冲突处理、缓存不友好等原因，其常数因子比简单的顺序遍历更大，导致实际性能反而不如  O(N) 遍历。顺序遍历对 CPU 缓存非常友好（线性访问内存）</li></ul></li><li><strong>内存效率</strong>：<ul><li><strong>预计算序列的内存开销</strong>：预生成完整的轮询序列（尤其是考虑权重时）需要额外的 O(S) 内存空间，其中 S 是所有服务器权重之和</li><li><strong>Nginx 的内存优化倾向</strong>：Nginx 以高性能和低内存消耗著称</li></ul></li><li><strong>算法简单性与鲁棒性</strong>：<ul><li><strong>实现简单</strong>：O(N) 的遍历算法实现起来相对简单、清晰，代码易于理解和维护</li><li><strong>鲁棒性好</strong>：简单的顺序遍历对后端服务器的动态变化（增、删、权重改、状态变）响应直接且自然。预计算序列在动态变化时需要复杂的更新或失效机制，容易引入边界条件错误</li></ul></li></ol><p>总结:<br>Nginx 在核心负载均衡算法（轮询、加权轮询、最小连接、最短时间）中选择 O(N) 的调度查找策略，是经过深思熟虑的权衡：</p><ul><li><strong>核心制约因素</strong>：支持动态权重和实时状态感知使得 O(1) 的预计算序列方案在动态更新时成本过高或不适用</li><li><strong>现实可行性</strong>：对于典型的后端服务器数量 (N)，O(N) 遍历的绝对时间开销非常低，在现代 CPU 上完全可以接受</li><li><strong>资源优化</strong>：避免了为 O(1) 选择而预计算序列或维护大型哈希表带来的显著额外内存消耗</li><li><strong>设计哲学</strong>：符合 Nginx 追求简单、高效（尤其是内存效率）和鲁棒性的设计原则<br>因此，尽管在纯算法理论上看 O(N) 不如 O(1) 或 O(log N)，但在 Nginx 负载均衡的具体上下文、约束条件（动态权重、状态感知）和典型部署规模下，O(N) 的遍历是一个非常合理且高效的工程选择。它用微小的、可接受的 CPU 时间增量，换取了算法的灵活性、低内存开销和对动态变化的自然支持</li></ul></blockquote><p><strong>「SWRR」</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># nginx/src/http/ngx_http_upstream_round_robin.c : ngx_http_upstream_get_peer</span></span><br><span class="line"><span class="keyword">for</span> (peer = rrp-&gt;peers-&gt;peer, i = <span class="number">0</span>;</span><br><span class="line">     peer;</span><br><span class="line">     peer = peer-&gt;next, i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (peer-&gt;down) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (peer-&gt;max_fails</span><br><span class="line">        &amp;&amp; peer-&gt;fails &gt;= peer-&gt;max_fails</span><br><span class="line">        &amp;&amp; now - peer-&gt;checked &lt;= peer-&gt;fail_timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (peer-&gt;max_conns &amp;&amp; peer-&gt;conns &gt;= peer-&gt;max_conns) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    peer-&gt;current_weight += peer-&gt;effective_weight;</span><br><span class="line">    total += peer-&gt;effective_weight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (peer-&gt;effective_weight &lt; peer-&gt;weight) &#123;</span><br><span class="line">        peer-&gt;effective_weight++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (best == <span class="literal">NULL</span> || peer-&gt;current_weight &gt; best-&gt;current_weight) &#123;</span><br><span class="line">        best = peer;</span><br><span class="line">        p = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">best-&gt;current_weight -= total;</span><br><span class="line"><span class="keyword">return</span> best;</span><br></pre></td></tr></table></figure><p><strong>问题：</strong></p><ol><li>可以看到 Nginx 仍然在使用 SWRR 算法，相比于 VNSWRR 它的优势在哪里？</li><li>注意到 24-26 行，是否意味着后续可以配置热更新权重并动态缓慢的更新有效权重？</li></ol><p>weight: 配置文件中的权重</p><p>effective_weight: 动态的有效权重，初始化为 weight。当和 RS 通信发生错误时减小，后续逐步恢复</p><p>「扩展思考」在系统初始时，通过将所有 effective_weight 初始化为 1 来放大随机效果（选 best 时也可以添加随机数判断 peer-&gt;current_weight == best-&gt;current_weight 时是否要替换 best = peer）</p><p>但是参考 <code>ngx_http_upstream_init_round_robin</code> 初始化中的赋值，都会有 peer.weight = peer.effective_weight = server.weight</p><p><strong>「W-chash」</strong></p><p>创建了 weight * 160 个影子节点，根据哈希值排序</p><p>抽离版实现可参考 <a href="https://github.com/dgryski/libchash/blob/master/chash.c">libchash/chash.c</a></p><p><strong>「ip-hash」</strong></p><p>对 IP 地址哈希后取模 RS 总权重，然后依次减掉每一个 RS 的权重看落在哪个 RS 里，从而将权重作为影响因素放入直接哈希</p><p><strong>「least-connect」</strong></p><p>顺序遍历 O(N) 查找连接数最小的 RS</p><p>出现相同的最小连接数时，回退到 SWRR 进行选择</p><p>比较连接数时，因为是遍历的两两比较，可以通过 peer-&gt;conns * best-&gt;weight &lt; best-&gt;conns * peer-&gt;weight 来考虑权重</p><h3 id="爱奇艺-DPVS"><a href="#爱奇艺-DPVS" class="headerlink" title="爱奇艺 DPVS"></a>爱奇艺 DPVS</h3><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image17.png" alt="图片"><br><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image18.png" alt="图片"></p><h3 id="Cloudflare-Unimog"><a href="#Cloudflare-Unimog" class="headerlink" title="Cloudflare Unimog"></a>Cloudflare Unimog</h3><p>自研硬件服务器，SDN 架构</p><p>可以根据 RS 的负载动态调整连接数量</p><p>机房内所有机器都安装了四层 LB，路由器无论把包发给哪台都会转发到正确的 RS 上</p><p>优势：</p><ol><li>LB 不需要做容量规划</li><li>最大限度防 DDoS</li><li>运维架构简单，所有机器都一样</li></ol><p>LB 之间不同步状态，连接保持方案类似 Maglev：所有 LB 自己决定，但保证对于相同的 4-tuple 会转发相同的 RS。所有 LB 都接收由控制平面统一下发的转发表，通过 4-tuple-hash 查表。转发表中每个 RS 可以设置多个 bucket（权重），RS 下线只修改对应 bucket</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image19.png" alt="图片"></p><p>由于没有 ct，它通过备份转发表 (second hop) 方式来继续先前的转发。当一个 RS 机器收到包时，先检查当前机器有没有这个 TCP socket，如果没有就转发到 second hop</p><blockquote><p>关于备份转发表存多久的问题，文章作者 kawabangga 问了 cf，解释是：</p><ul><li>删除实例在 Cloudflare 不太常见，更常见的是短暂移除，reboot，然后回到集群，几乎所有的机器每月都会重启一次，所以每一个连接在 24 小时之内都有 1/30 的几率被 reset</li><li>如果要移除的话，如文中所说，会进入到 drain state，在备表中，这个状态只会维持几分钟</li><li>简单来说，连接可以归为两类：short-lived 和 long-lived。几分钟足够所有 short-lived  连接结束了，剩下的都是 long-lived，如果 drain 状态  30min，可能会有部分连接正常结束，但是不会很多，大部分超过几分钟的连接会存在数小时甚至数天，继续等待也不会带来更多显著受益，但是会让操作效率大大降低，所以只等待几分钟</li></ul></blockquote><h3 id="GitHub-GLB"><a href="#GitHub-GLB" class="headerlink" title="GitHub GLB"></a>GitHub GLB</h3><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image20.jpeg" alt="图片"></p><p>「转发过程」</p><ol><li>根据 hash 查找转发表，找到对应的 2 个 RS，一个是主 RS 一个是备 RS，然后转发到主 RS</li><li>主 RS 收到包之后，检查这个包是不是属于自己机器上的连接，如果是，就交给协议栈处理，如果不是，就转发到备 RS（备 RS 的地址记录在 GLB 发过来的包中）</li></ol><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image21.jpeg" alt="图片"></p><p>「转发表」</p><ul><li>在 RS 修改的时候，只有变化的 RS 在表中会修改，没有变化的 RS 在表中的位置不变。即不能对整个表完全重新 hash</li><li>表的生成不依赖外部的状态</li><li>每一行的两个 RS 不应该相同</li><li>所有 RS 在表中出现的次数应该是大致相同的（负载均衡）</li></ul><p>实现方式是类似 Rendezvous hashing：对于每一行，将行号 + RS IP 进行 Hash 得到一个数字，作为“分数”，所有的 RS 在这一行按照分数排序，取前两名，作为主 RS 和 备 RS 放到表中。然后按照以下的四个条件来分析：</p><ul><li>如果添加 RS，那么只有新 RS 排名第一的相关的行需要修改，其他的行不会改变</li><li>生成这个表只会依赖 RS 的 IP</li><li>每一行的两个 RS 不可能相同，因为取的前两名</li><li>Hash 算法可以保证每一个 IP 当第一名的概率是几乎一样的</li></ul><p>不过要注意的是：在想要删除 RS 的时候，要交换主 RS 和 备 RS 的位置，这样，主 RS  换到备就不会有新连接了，等残留的连接都结束，就可以下线了；在添加 RS 的时候，每次只能添加一个，因为如果一次添加两个，那么这两个 RS 如果出现在同一行的第一名和第二名，之前的 RS 就会没来得及 drain 就没了，那么之前的 RS 的连接都会断掉</p><p><strong>优势：</strong></p><ol><li>提供第二选择</li><li>不需要保存数据</li><li>GLB 实例可以和 RS 同时做变化</li></ol><p><strong>问题：</strong></p><ol><li>要动 RS</li></ol><h3 id="Google-Maglev"><a href="#Google-Maglev" class="headerlink" title="Google Maglev"></a>Google Maglev</h3><p>DSR 转发模式，Maglev 不会做 NAT，通过 GRE 将二层包封装进 IP 包里（需要 MSS 预留空间）</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Blog/LB/lb/image22.png" alt="图片"></p><p>上图是包的转发流程，绿色的是包经过的路径</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><p>部分参考</p></blockquote><ul><li><a href="https://writings.sh/post/consistent-hashing-algorithms-part-1-the-problem-and-the-concept">一致性哈希算法 - 问题的提出 - 哈希环法 - 跳跃一致性哈希法 - Maglev 一致性哈希法</a></li><li><a href="https://dgryski.medium.com/consistent-hashing-algorithmic-tradeoffs-ef6b8e2fcae8#890d">Consistent Hashing: Algorithmic Tradeoffs 一致性哈希：算法权衡</a> 和 <a href="https://github.com/dgryski/libchash">libchash</a></li><li><a href="https://developer.aliyun.com/article/1629452">一致性哈希汇总</a></li><li><a href="https://github.com/RJ/ketama">ketama (源码)</a></li><li><a href="https://luyuhuang.tech/2021/06/13/jump-consistent-hash.html">Jump Consistent Hash 算法</a></li><li><a href="https://arxiv.org/abs/1406.2294">A Fast, Minimal Memory, Consistent Hash Algorithm (论文)</a></li><li><a href="https://arxiv.org/abs/1505.00062">Multi-Probe Consistent Hashing (论文)</a></li><li><a href="https://research.google/pubs/maglev-a-fast-and-reliable-software-network-load-balancer/">Maglev: A Fast and Reliable Software Network Load Balancer (论文)</a></li><li><a href="https://arxiv.org/abs/1812.09674">AnchorHash: A Scalable Consistent Hash (论文)</a></li><li><a href="https://github.com/anchorhash/cpp-anchorhash">AnchorHash (源码)</a></li><li><a href="https://arxiv.org/pdf/2107.07930">DxHash: A Scalable Consistent Hashing Based on the Pseudo-Random Sequence (论文)</a></li><li><a href="https://cloud.tencent.com/developer/article/2327298">Rendezvous hashing 算法介绍</a></li><li><a href="https://randorithms.com/2020/12/26/rendezvous-hashing.html">Rendezvous Hashing Explained (原文)</a></li><li><a href="https://github.com/clohfink/RendezvousHash">Rendezvous Hashing 源码和实验对比</a></li><li><a href="https://en.wikipedia.org/wiki/Rendezvous_hashing#O(log_n)_running_time_via_skeleton-based_hierarchical_rendezvous_hashing">Rendezvous Hashing 基于骨架的分层会合散列 O(logN) 优化</a></li><li><a href="https://randorithms.com/2019/09/19/Visual-LSH.html">LSH 位置敏感哈希入门</a></li><li><a href="https://amosbrocco.ch/pubs/paper03.pdf">Consistently Faster: A survey and fair comparison of consistent hashing algorithms</a></li><li><a href="https://www.kawabangga.com/posts/5301">四层负载均衡漫谈</a></li><li><a href="https://mp.weixin.qq.com/s/1U_XSqaGCcbsmGpW2DoVHQ">「Bilibili」RPC 负载均衡算法的演进之路</a></li><li><a href="https://tech.meituan.com/2017/01/05/mgw.html">「美团」MGW——美团点评高性能四层负载均衡</a></li><li><a href="https://support.huaweicloud.com/usermanual-elb/elb_ug_jt_0004.html">「华为云」配置会话保持提升访问效率</a></li><li><a href="https://www.alibabacloud.com/help/zh/slb/product-overview/introduction-to-load-balancing-scheduling-algorithm">「阿里云」负载均衡调度算法介绍</a></li><li><a href="https://github.com/nginx/nginx">「Nginx」Nginx 源码</a> 和 <a href="https://github.com/nginx/nginx/commit/52327e0627f49dbda1e8db695e63a4b0">Nginx SWRR Commit</a></li><li><a href="https://kb.linuxvirtualserver.org/wiki/Weighted_Round-Robin_Scheduling">「LVS」LVS WRR</a></li><li><a href="https://github.com/iqiyi/dpvs">「爱奇艺」DPVS (源码)</a></li><li><a href="https://blog.cloudflare.com/unimog-cloudflares-edge-load-balancer/">「Cloudflare」Unimog - Cloudflare’s edge load balancer</a></li><li><a href="https://github.blog/engineering/glb-director-open-source-load-balancer/">「GitHub」GLB: GitHub’s open source load balancer</a> 和 <a href="https://github.com/github/glb-director">GLB 源码</a></li><li><a href="https://www.kawabangga.com/posts/5759">「Google」四层负载均衡分析：Google Maglev</a></li></ul>          </div>]]></content>
    
    <summary type="html">
    
      负载均衡算法整理与分析——从LB公平性的角度考虑&lt;br&gt;从基础的加权轮训、最小连接到哈希的一致性对比&lt;br&gt;以及各家厂商的实现方案
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="LB" scheme="https://augists.top/tags/LB/"/>
    
      <category term="NETWORK" scheme="https://augists.top/tags/NETWORK/"/>
    
  </entry>
  
  <entry>
    <title>From Network Verification to NDD</title>
    <link href="https://augists.top/NOTES/PAPER/From-Network-Verification-to-NDD/"/>
    <id>https://augists.top/NOTES/PAPER/From-Network-Verification-to-NDD/</id>
    <published>2025-05-18T06:14:52.000Z</published>
    <updated>2025-05-22T09:07:45.680Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h1 id="从网络验证到-NDD"><a href="#从网络验证到-NDD" class="headerlink" title="从网络验证到 NDD"></a>从网络验证到 NDD</h1><p>作为一个偏门的小众领域，一直会有人问起说<strong>网络验证是什么？</strong>(Network Verification)。参考去年组会上的简单梳理，加上自己浅薄的理解，我也算是成功给大组里别的老师的同门讲明白了我们在做什么。这里只是简单的介绍这个研究方向，并且不涉及到论文层面的内容。</p><h2 id="想要解决什么问题？"><a href="#想要解决什么问题？" class="headerlink" title="想要解决什么问题？"></a>想要解决什么问题？</h2><p>通常网络服务提供商 (Internet Service Provider, ISP) 是有自己维护的组网，并且由骨干网串联起来，从而为用户提供网络连接。这也就意味着 ISP 以及 ISP 之间的网络对稳定性的要求会极高。除此之外，厂商也会自己组建大型数据中心等设施，会面临频繁的配置变更及动态扩缩容等的需求。所以，就需要一种方案，可以在配置网络时或配置变更时提前验证其准确性和鲁棒性，来为网络增加一层防护。。</p><blockquote><p>除此之外，从软件定义网络 (Software Defined Network, SDN) 的角度考虑，中央控制器作为选出的 Leader 可以获取到全局的拓扑等信息，是不是也可以在其下发之前做建模验证，来保证下发结果的合理性？</p></blockquote><p>想要验证的问题（举例）：</p><ul><li>任意两节点之间的可达性</li><li>节点转发表</li><li>任意 k 条链路断开之后的情况</li><li>……</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>所有的解决方案都是在做取舍，这里也不例外。从前到后，我们所验证的真实性在降低，解决方案的实际开发复杂性某种程度上在提升，但是应用的性能和人力开销也在降低。</p><h3 id="物理镜像"><a href="#物理镜像" class="headerlink" title="物理镜像"></a>物理镜像</h3><p>部署完全相同配置的镜像网络来做物理测试，直接在镜像网络中发送数据包、抓包分析等</p><h3 id="虚拟镜像-emulation"><a href="#虚拟镜像-emulation" class="headerlink" title="虚拟镜像 emulation"></a>虚拟镜像 emulation</h3><p>同物理镜像，但是使用虚拟机或容器的形式表示每一台网元设备。在容器之间建立同物理网络相同的连接，并真实的模拟数据包在网络中的转发，完整的根据协议的规划进行。</p><blockquote><p>开销大，速度慢</p></blockquote><h3 id="网络仿真-simulation"><a href="#网络仿真-simulation" class="headerlink" title="网络仿真 simulation"></a>网络仿真 simulation</h3><p>只模拟转发行为，通过算法直接计算最终的转发表</p><p>例如：真实网络中的协议大多通过扩散的方式传播，既然我们已经拿到了全局的拓扑和每个节点的配置信息，我们就可以找到一种方式尽快的模拟出网络稳定之后的转发表</p><p>这里我们以最为被广泛使用的 <a href="https://github.com/batfish/batfish">Batfish</a> 开源网络验证工具为例 (1.2k stars)，它将整个网络验证过程划分为了6步：</p><ol><li>解析 parsing：解析不同厂商的配置文件，通常是 <code>.cfg</code> 文件，记录着设备的所有功能定义，如端口启用、ip分配、协议配置等</li><li>提取 extraction：将上一步解析到的配置信息转为类对象存储，可以理解为对每个厂商都会定义其对应的配置解析类</li><li>转换 conversion：去除厂商特定的配置信息，以全局统一的方式存储配置信息，使其厂商无关</li><li>后处理 post-processing：解决配置解析中的问题，确保可以进行仿真计算</li><li>计算数据平面 data plane generation：计算 RIB，FIB，第一层到第三层overlay实际拓扑</li><li>分析转发 forwarding analysis：计算端口谓词等信息，建模转发行为</li></ol><h2 id="网络仿真-simulation-怎么做"><a href="#网络仿真-simulation-怎么做" class="headerlink" title="网络仿真 simulation 怎么做"></a>网络仿真 simulation 怎么做</h2><p>笼统来说，网络的仿真验证 simulation 会对每台设备的每个端口计算端口谓词 port predicate，也即为可以从这个端口上转发出去的包头空间 header space。这样的话，对从节点 A 到节点 B 的可达性也就转变成了从节点 A 到节点 B 的路径上，所有端口谓词的交集，表达了最终所有可以从 A 到 B 的包头空间，也即所有可以传递的数据包包头。因为一般情况下，后续所需要的验证会大量重复的利用前面所计算出的中间信息，那么我们也就需要一种方式可以更高效紧凑的表示出这部分信息。</p><h3 id="包头空间是什么"><a href="#包头空间是什么" class="headerlink" title="包头空间是什么"></a>包头空间是什么</h3><p>对于一个数据包来说，最基础的包头空间可以是 ip 五元组（srcIP, srcPort, dstIP, dstPort, protocol），以 ipv4 为例，我们就需要完整表示出两个 ip 地址的 32bit，两个端口的 16bit，协议的 8bit，共 104bit 的包头信息。比如在 Batfish 中，它的 BDDPacket 共表示了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FIRST_PACKET_VAR <span class="comment">// reserved for auxiliary variables before packet vars</span></span><br><span class="line">   + IP_LENGTH * <span class="number">4</span> <span class="comment">// primed/unprimed src/dst</span></span><br><span class="line">   + PORT_LENGTH * <span class="number">4</span> <span class="comment">// primed/unprimed src/dst</span></span><br><span class="line">   + IP_PROTOCOL_LENGTH</span><br><span class="line">   + ICMP_CODE_LENGTH</span><br><span class="line">   + ICMP_TYPE_LENGTH</span><br><span class="line">   + TCP_FLAG_LENGTH * <span class="number">8</span></span><br><span class="line">   + DSCP_LENGTH</span><br><span class="line">   + ECN_LENGTH</span><br><span class="line">   + FRAGMENT_OFFSET_LENGTH</span><br><span class="line">   + PACKET_LENGTH_LENGTH;</span><br></pre></td></tr></table></figure><p>如果想要表示 ipv6 地址，单单是一个 ip 就需要 128bit 的空间来表示。又或者想要表示链路状态等，又需要向内添加额外的 bit 位用来表示。</p><p>所以理论上我们所想要表示的包头空间是一个非常庞大的信息域。</p><h3 id="如何高效的表示"><a href="#如何高效的表示" class="headerlink" title="如何高效的表示"></a>如何高效的表示</h3><p>最开始的验证工具使用 Trie 前缀树的方式来表示。</p><h4 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h4><p>有关 Trie 树的相关信息可以参考 <a href="https://leetcode.cn/problems/implement-trie-prefix-tree">LeetCode 208</a>。对于我们想要表示的 01 串（包头空间）来说，字典树应该是一颗三叉树，分别代表 0，1，any。在每个中间节点上都有一个 <code>isEnd</code> 的标记位，用来表示当前节点可以是 01 串的终点，也即是这一段从根到当前节点的信息完整的表示了一段内容。这里以力扣的<a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solutions/717239/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500">原题 java 题解</a>（修改为三叉）为例展示 Trie 的存储和查询结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> Trie[<span class="number">3</span>];</span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = word[i];</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] word)</span> </span>&#123;</span><br><span class="line">        Trie node = searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(<span class="keyword">int</span>[] prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Trie <span class="title">searchPrefix</span><span class="params">(<span class="keyword">int</span>[] prefix)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = prefix[i];</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，Trie 树对 any 的表示是一条单独的路径，作为树结构也无法复用下层的子树。这会导致整颗树很胖，很冗余，查询和遍历都很复杂，需要一直判断当前节点是否已经标记了 <code>isEnd</code>。尽管 Trie 能表示出离散的空间，但是在网络验证工具的表达中，它将离散的同一等价类（具有相同转发行为的包）需要拆分表示。以 <a href="https://github.com/XJTU-NetVerify/sdn-lab4/tree/main/veriflow">Veriflow</a> 为例，它对 <code>TrieNode</code> 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* parent;</span><br><span class="line">    TrieNode* zeroBranch;</span><br><span class="line">    TrieNode* oneBranch;</span><br><span class="line">    TrieNode* wildcardBranch;</span><br><span class="line">    Trie* nextLevelTrie;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt; Rule, KHash&lt; Rule &gt;, KEqual&lt; Rule &gt; &gt;* ruleSet;</span><br><span class="line"></span><br><span class="line">    TrieNode();</span><br><span class="line">    ~TrieNode();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p> 可以看到，在 Veriflow 里，已经有了对域划分的思想。</p></blockquote><p>在对等价类的表示中，Trie 无法合并多个 range，只能将每个 range 当作一个等价类，从而产生了不必要的拆分。并且可以预想到，在对连续范围的非离散数据表示中，Trie 结构本身并不能很好的编码信息，只能将所有的可能性都进行表示。</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/veriflow%20ec.svg" alt="veriflow ec"></p><p>除此之外，Trie 结构本身也不适合作为逻辑计算的载体。在数据包传播过程中，从单个节点的视角来看，它是上游限制与本地信息的结合，并向下游继续传播的过程，中间不可避免需要涉及到对空间的限制计算。假如我们安排两个 Trie 存储的空间做交集或并集，就需要两个指针从根节点开始向下递归遍历，any 与 0 和 any 与 1 都会造成重新的树结构分裂，牵一发而动全身。</p><h4 id="SAT-SMT"><a href="#SAT-SMT" class="headerlink" title="SAT/SMT"></a>SAT/SMT</h4><p>布尔可满足性理论（Boolean satisfiability problem，SAT）是用来解决给定的真值方程式，询问是否存在一种解释可以满足给定的布尔公式。换句话说，它询问公式的变量是否可以被一致地替换为 TRUE 或 FALSE 的值，使得公式评估为 TRUE。如果这种情况成立，则该公式称为可满足的，否则为不可满足的。例如，公式 <code>a AND NOT b</code> 是可满足的，因为可以找到 <code>a = TRUE</code> 和 <code>b = FALSE</code> 的值，使得 <code>(a AND NOT b) =  TRUE</code>。相比之下，<code>a AND NOT a</code> 是不可满足的。</p><p>模理论可满足性（Satisfiability modulo theories，SMT）是确定一个数学公式是否可满足的问题。它将布尔可满足性问题（SAT）推广到更复杂的公式，这些公式涉及实数、整数以及各种数据结构，如列表、数组、位向量字符串等。SMT 求解器是旨在为实际输入子集解决 SMT 问题的工具。</p><p>通过 SMT 求解器的方式来对包头空间进行信息表示，可能着重于对包头空间的逻辑计算以及最终是否可满足的求解。但是在预想中，SMT 求解器需要将所有的可能解进行遍历尝试，直到确认存在一组可满足的解。并且随着需要表示信息变得复杂，以及在网络严重工具里解空间的扩张，SMT 可能并不是一种非常高效的建模方式。</p><blockquote><p>由于本人对这方面的接触比较少，只能确认在一些网络验证工具中会用 SMT 的方式建模自己需要验证的内容。</p></blockquote><h4 id="BDD"><a href="#BDD" class="headerlink" title="BDD"></a>BDD</h4><p>二元决策图（Binary Decision Diagram），可以视为一颗用于编码表示 01 信息的二叉树，我们可以定义它的 <code>Left/Low/Zero</code> 边代表 0，<code>Right/High/One</code> 边代表 1，any 可以用 0 1 两条边指向同一个子树来表示。如此这般，从一颗 BDD 树的根节点开始向下遍历到叶子节点即为一个 01 串。最终我们将所有叶子节点指向 <code>TRUE</code> 和 <code>FALSE</code> 两个全局的终结点，只有最终指向 <code>TRUE</code> 终结点的信息是我们所要编码的所有信息。</p><p>我们期望能通过 BDD 的结构对离散的包头空间进行紧凑表达，并且能方便的进行逻辑限制条件的计算。</p><p>在最初始的状态下，BDD 树呈现出下图的样子：</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/BDD%20Tree.png" alt="BDD Tree"></p><p>但是，可以注意到，它是可以被化简的。实际上，BDD 已经是 <strong>R</strong>educed <strong>O</strong>rdered BDD 的简称。在固定变量顺序的表示里，每个编码信息都会被化简后的 BDD 唯一的表示。它的化简约束如下：</p><blockquote><ul><li>(<strong>uniqueness</strong>) no two distinct nodes $u$ and $v$ have the same variable name and low- and high-successor</li><li>(<strong>non-redundant tests</strong>) no variable node $u$ has identical low- and high-successor</li></ul></blockquote><p>如图表示 BDD 的化简方法</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/robdd.svg" alt="robdd"></p><p>通过这种方式，我们就可以唯一的表示所有用到的不同的可能性（并复用），并方便的在他们之间进行逻辑计算，即在原树的基础上构建新的树冠。</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/bdd%20example.svg" alt="BDD example"></p><h4 id="NDD"><a href="#NDD" class="headerlink" title="NDD"></a>NDD</h4><p>在最初的表示方法 Trie 树中，已经尝试将划分域的思想应用到底层的表示结构中了。但是这显然在后面直接应用的形式化建模方式里被模糊处理了。其实，我们不止可以把划分域的思想放到网络验证工具里去匹配和约束，也应该在底层表示里将不同域的表示进行划分。由此，我们提出了 Network Decision Diagram，NDD 这种结构，想要更好的对网络验证过程中的包头空间进行建模表示。</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/ndd-drawio.png" alt="fig4"></p><p>核心点在于，原本 BDD 的表示空间是离散的所有可能性，但是由于在网络验证中所想要表示的信息较多，导致 BDD 结构的肿大。我们通过对每个域之间做解耦，使得 BDD 仅仅需要表示自己域（较少）的信息，从而可以很好的控制住肿大的问题，进而解决了很多 BDD 不够理想的情况。</p><p>详细的内容和实现可以移步我们<a href="https://xjtu-netverify.github.io/papers/2025-ndd-a-decision-diagram-for-network-verification/">网站</a>进行深入了解。</p><blockquote><p>NDD 的相关工作发表在 NSDI 2025 会议上，并获得了 Outstanding Paper 奖。</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><p><a href="https://dl.acm.org/doi/suppl/10.1145/3544216.3544264/suppl_file/p336-zhang-supp.pdf">Symbolic Router Execution – Public Review from Ennan Zhai</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">SAT wikipedia</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT wikipedia</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/151725312">SAT 与 SMT 简明入门</a></p></li><li><p><a href="https://github.com/XJTU-NetVerify/NDD">NDD</a></p></li></ul>          </div>]]></content>
    
    <summary type="html">
    
      我们有关 NDD 的工作被 NSDI 2025 接收并评为唯一一篇 Outstanding Paper，可喜可贺
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="NETWORK" scheme="https://augists.top/tags/NETWORK/"/>
    
      <category term="PAPER" scheme="https://augists.top/tags/PAPER/"/>
    
  </entry>
  
  <entry>
    <title>2024-Review</title>
    <link href="https://augists.top/SELF/REVIEW/2024-Review/"/>
    <id>https://augists.top/SELF/REVIEW/2024-Review/</id>
    <published>2024-12-28T07:04:36.000Z</published>
    <updated>2025-05-22T08:50:20.316Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h1 id="2024-Review"><a href="#2024-Review" class="headerlink" title="2024 Review"></a>2024 Review</h1><blockquote><p>写了这么多年的 review，也有必要再想想 review 的意义和这种形式是否应该有改变了。</p><p>我写 review 一方面是能在年中或是年底重新回看自己的这一年，总结和正视自己出现的问题，并且以一种不会让自己太尴尬的方式能暂存这一段时间的一些回忆；另一方面是让别人能快速的了解甚至理解我（经历、性格或是行为方式等），如果能从我的 review 里突然悟到什么或是有了新的规划和目标那是再好不过了。</p><p>形式上以前都是分享经历为主，很缺乏对方法和方法论的思考，缺少对遇到的事情或是处事的思考。今年十一和学弟一起出去玩，交流中突然感觉到自己好像越来越少的去思考一些事情，即便想过了也不会整理下来很快就遗忘了。今天是 11 月 15 日，晚上洗澡的时候想到要写这篇 review（但是洗完把想的一堆大道理全都给忘掉了）。我知道我写的 review 都会公开给所有人访问，可能我的父母会看到，家里的亲戚会看到，我的导师会看到，周围已经远隔天涯或常会见面的朋友会看到。review 是我重新审视自己的，但是我也会考虑一些东西是否可以或应该放到公共的面上。</p><p>这次 review 的大纲都是在洗澡的时候想的。或许是因为温度舒适湿气大的缘故，我发现这种场合能更开放和有效的思考，也可能是因为这个环境更像是回家了 :) 这两年花了一些时间去看看南方的城市，仅论城市不谈工作等其他因素的话，杭州是最干净的，深圳不热的时候是比较像家里的，苏州离上海不远又有自己的生活节奏，无锡也在试图让我感觉它是宜居之地。相比之下，上海有点脏乱，有一种莫名的秩序和阶级划分（在路边等 zyh 回消息但是突然被面前的公交车强制爱让我过马路），同时又足够多元和先进。南京是最脏乱的，白天的繁华过后是夜里小摊贩和满地的垃圾……</p></blockquote><center><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/%E6%B6%B5%E8%8B%B1%E6%A5%BC%E6%98%9F%E8%BD%A8%20signed.jpg" alt="涵英楼星轨 signed" width="500" /></center><h2 id="读研注定是孤独的。"><a href="#读研注定是孤独的。" class="headerlink" title="读研注定是孤独的。"></a>读研注定是孤独的。</h2><ul><li>在来创新港的一年半里，几乎所有的时间都是孤独的。或许是从最开始这一届只有我一个人开始就已经注定了这三年要这样度过，注定没有师兄师姐的道路可以学习，没有人能带着入门知道需要学什么，自己一个人去上课，一个人吃饭，一个人也不知道该玩什么。回看研一上的时间，我很难想象自己怎么度过这段迷茫无措的时间的，甚至是同一个大实验室的朋友也是研一下去给导当助教才得以认识，大组里基本都是陌生人。自己组里的师兄师姐不去工位的话，每天去工位真的就不太有认识的朋友了。</li><li>本科的时候虽然实验室里很乱，人很多，但是大家在一起氛围很好，经常还一起参加活动或是承办会议。我记得我经常会问的一个问题是，这个师兄/师姐是挂哪个老师名的？以及，虽说 wilna 里几十个歪果仁神出鬼没的，但是每年也会来组会讲一讲自己的家乡，开朗的还会给大家唱歌。相比之下，当组里的孟加拉人开始把所有工作都推脱给我，永远来看着我帮他找莫名其妙的 bug 的时候，就会让人生出厌烦。</li><li>比较幸运的是，我可以靠自己努力来缓解这种孤独。我开始扩张“扫街大队”，从最开始和认识的学长三个人一起，到后来越来越多的朋友加入。如今靠着大家的邀请，群成员已经超过 170 人了。不过随着任务愈加繁忙，“扫街大队”逐渐变成越来越普通的交流群，很少能约着一起出去拍拍了。除了拍拍照片，还试图拾起来已经四年没碰的二胡。高考的失利让我把与之相关的事物都深埋起来，很害怕去想：即便考砸多考两分又会是什么样。在中考直升的时候就已经放弃了走艺术的可能，高考又放弃了艺术特长生的降分，我以为我会和音乐渐行渐远了。说实话，想重拾起来很痛苦，你知道那是你曾经可以轻松拉下来的段落，你知道曾经的基本功都已经荒废掉了，你知道面对新曲子那种望而却步的无奈。你只能在后面默默的看着一块玩到大的弟弟去美国进修音乐，幼时一起的青梅竹马去中国院又出国学习扬琴，曾经的同门师弟又破格考入中央院。你想，可能真的会变成两个世界的人了吧，你越来越像一个普通人，即将赴入人海，这一次可能就无法体验另一种人生了。（之前计划的 music in life 博客写了一大半，但是因为来回折腾电脑把源文件搞丢了 :(，但是再让我重写自己的经历什么的又太做作</li><li>在生命的每个阶段里，从有比较清晰的认知开始，小学、初中、高中、大学以及后面的每一段，最后都会留存下至少一个能一直维持关系的朋友，即便很久不会联系一起聊天，但是当某一天想起，仍然可以打开聊天窗戳一戳，互相打扰。当然，到了后来，越来越渴望会有一个能长久相伴的人能互相理解、互相信任。以前我会主动走出自己的壁垒，相信我所遇到的人都是善良的，但是现在越来越想要躲在壁垒之后，畏惧且不能给予他人足够的信任。可能是成长的代价，也可能是见到的更多了，人终归是社会动物，充斥着复杂的利益和情感纠葛。让我觉得，人内向的性格通常也是在复杂社会中被打的遍体鳞伤之后退缩的畏惧反应。</li></ul><center><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/IMG_7450_%E6%94%B9%E8%89%B2%E9%BB%84_%E4%BA%8C%E6%AC%A1%E5%8F%A0%E5%8A%A0_%E8%83%8C%E6%99%AF%E5%8A%A0%E6%B7%B1.jpg" alt="IMG_7450_改色黄_二次叠加_背景加深" width="300"/></center><h2 id="成功的定义有很多，千人千面，我在每个时间的理解也会不同。现在我想，成功是自由。"><a href="#成功的定义有很多，千人千面，我在每个时间的理解也会不同。现在我想，成功是自由。" class="headerlink" title="成功的定义有很多，千人千面，我在每个时间的理解也会不同。现在我想，成功是自由。"></a>成功的定义有很多，千人千面，我在每个时间的理解也会不同。现在我想，成功是自由。</h2><ul><li><p>什么是自由？</p><ul><li><p>今年新关注了蓝战非，一个前半辈子打游戏当主播挣钱，后半辈子开始抛开一切全世界旅游的人。这可能是我对自由的终极定义。放一个蓝战非版本的 <a href="https://bilibili.com/BV1UDUXYbE4D">什么是自由</a></p><ul><li>从小到大，父母亲朋好友看过的影视作品都在告诉我们，我们应该要找一个体面的工作，买一个不错的房子，开一辆不错的车，再找一个不错的对象结婚，我们就能到达幸福的终点。但是我好像发现这条定律不适合我。所以我决定，从头开始，走出我自己的浪浪山，去遍世界的每一个角落，看看到底什么样的生活才适合我自己。</li><li>很多不理解都会问我，一个死胖子为什么那么喜欢户外运动，又爬山又徒步，去这又去那，其实是在逃避，逃避什么呢？逃避焦虑。现在互联网焦虑太多了，包括你身边的人都给你的焦虑太多了。人生其实跟爬山一样，不是一场比赛。快跟慢，你路上的风景都是一样的，它不是一场比赛，你不需要比谁优秀，你不需要比谁更牛逼，你只需要今天比昨天开心，今天想办法让明天开心。所以，蓝战非希望大家每天过得开开心心。</li><li>蓝战非你认为什么是自由？其实这个问题我想了好久好久，我终于得到了一个答案。我认为的自由不一定是你得到了什么，或者是你到达何处，是无论结局如何，做你自己喜欢的事情便是自由。勇敢迈出第一步，追逐自己内心的梦想，便是自由。</li><li>我们要跳出一个恶循环。当你遇到困难的适合，其实大部分情况就是遇到了恶循环，你必须想尽办法破壁，把恶循环给跳出去，生活就会慢慢的变好。</li></ul></li><li><p>自由是我可以买我很感兴趣的电子设备，在我觉得它不满足需求的时候卖掉换新。自由是我可以在自己想要节制饮食的时候叫上朋友吃一顿放纵餐。自由是我除开物质追求外，可以有自己的精神追求。</p></li><li><p>人确实很难有自由。时间是最宝贵的资源。我们在最想出去浪的时候缺少金钱支持，在有能力出去之后又莫得时间。在这个基础之下，码农好像确实是个不错的职业。前几年挣够钱，后几年可劲花。越早被裁，越早出去看看世界 :)</p></li></ul></li><li><p>为什么会想去工作？</p><ul><li>最初阴差阳错的乱填分到软院，开始接触到这个方向，我发现我是感兴趣的。一直以来，好奇心驱使我想要了解新的科技。所以在曾经没有踏足代码的时候，我必不会错过的盛会是每年的 CES。如今有幸能在知识的大圆里探出一个小尖，让我得以窥探当前世界这个 snapshot 之外的东西，的确能带来巨大的满足感。但是我一直很忌讳的是新兴的技术不能落地，我想要得到的是“人”对“技术”的正反馈。所以在本科做 WiFi 感知的时候，每次需要想一个合理的应用场景都会让我很痛苦。</li><li>工作是满足落地反馈的一种方式。人们都希望自己的付出能得到回报，当它有机会和工作绑定在一起带来正反馈的时候，就对我很有吸引力。</li><li>最近两周一直在反复发烧和犯肠胃炎，不禁会想如果工作之后生病怎么办。读研阶段时间上比较自由，导允许大家自由的安排时间，也不强制大家去工位，所以生病了可以选择休息，用其他时间再学习。但是工作之后，时间不再是自己选择和安排的。</li><li>工作能带给我什么？想清楚，工作只是一种获取价值的工具，除了钱我们从不奢求能从中得到什么。能让我发出“这辈子值了”的感慨的时刻是当我站在铁尺梁山顶遥看弯弯绕绕的盘山公路和远处魔鬼一样的灰黑色山峰的时候，而不会是我做的大项目上线了（或许主导的就不一样了）。谁也不会愿意当工具人，等价交换的可以是金钱，也可以是情绪价值。</li></ul></li></ul><center><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/%E7%81%AF%E5%A1%94%20signed.jpg" alt="灯塔 signed" width="300" /></center><h2 id="摄入和输出"><a href="#摄入和输出" class="headerlink" title="摄入和输出"></a>摄入和输出</h2><ul><li><p>我认为自己：缺乏持久和长期的摄入，也缺乏稳定的输出。</p></li><li><p>人总是会后悔，如果当时做了什么就好了，荒废了大片时光。但是人又很难抵制住各种诱惑，会被各种事物吸引了注意而分神。之前和朋友开玩笑：我们怎么能和一帮比我们更聪明的算法工程师抗衡，去抵制推荐流带来的诱惑呢？</p></li><li><p>学习是一件很难直接得到正反馈的过程，”心流“状态通常也只在自己很感兴趣的那方面才能有幸进入。当你有大片或是碎片的时间的时候，你会选择把它投入到学习这种长期才有汇报的无底洞里吗？不，当缺乏明确目标的时候，大部分人都不会。当这个目标不够明确，不够紧迫的时候，枯燥的学习绝不会是必须且必需的选择，我们应当很清楚这一点。说实话，我仍然没有找到合适的能让自己维持这种持久稳定摄入的方式。要学的太多了，海量的未知摆在面前的时候，是会畏惧向前迈步的。杂七杂八的事太多了，总是能在萌芽或是中途掐灭学习的小火苗，迫使你停下来转去做临时更重要的事情。新的想法太多了，既然让大脑开始活跃，你就不能阻止它冒出一个个的问号。</p></li><li><p>计算机是一门发展飞速的学科，每时每刻都在有新的技术、新的思想迸发出现。潮流中的我们很害怕被冲走，不进则是退。能坚持下来至少一种获取前沿的渠道是必不可少的。很感谢语哥，能在我无暇顾及 tg 新闻频道帮忙维护下来，稳定的筛选和输出有效的科技新闻；很感谢 koala，能定期整理和总结时下的优秀开源项目，让我们能够及时了解行业脉搏。人的精力是有限的，碎片化的模式大大冲击着人们获取有效信息的能力，在信息时代能做好取舍和精简反而成为一门很深的学问。</p></li><li><p>这个问题困扰了我很久：当面对一个新的问题时，我们是应该用 demo+ 迭代演进的模式还是一次成型且过程中不断修正。</p><ul><li>不知道是不是该称之为完美主义，我会觉得在开发中间有一种更好的想法的时候如果不去重构，继续沿着”错误“的方向前进很难受。当一个项目以 MVC 框架开头，中间发现更应该用微服务架构来实现的时候，就会痛苦的不想把已有的功能先实现出来。</li><li>前段时间看到原子能的视频里说的话，让我又重新审视自己对这两种模式的想法。这里贴出来，不做定论。</li></ul><blockquote><p> Make it work, make it right, and make it fast. Make it work first, then make it right, finally make it fast. </p><p><a href="https://www.bilibili.com/video/BV1GQU3YmEDG">软件开发的第一原则是把软件开发出来【让编程再次伟大#22】</a> </p></blockquote></li><li><p><a href="https://www.bilibili.com/video/BV1tf421Q7ze">不要做敲代码的孔乙己</a> 这个只贴出来，还没到这个层次。</p></li></ul><center><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/comet%20Augists.jpg" alt="comet Augists" width="300" /></center><h2 id="摄影的态度"><a href="#摄影的态度" class="headerlink" title="摄影的态度"></a>摄影的态度</h2><ul><li>摄影终究不是我谋生的手段，我对它的期望也没有放到像 Thomas 一样，从程序员转行职业摄影师。人们对审美的理解是不同的，所以，拍摄的照片也无需在意别人是否喜欢。但是，又有谁能真的置之身外呢？放大来说，我也羡慕别人拍的照片能被很多人点赞；嘴上说着所谓的签约或是各种虚名没什么意思；阴暗地看别人拍没什么营养的片子却能受到追捧。人终归是社会动物，会渴望别人给自己带来满足感，希望能得到其他人的认同。但是我也会用一些方法来弱化别人对我的认知的影响，比如把收到的消息提醒关掉，封存自己拍的一些照片，延后做修图和输出，拒绝使用各种平台等等。我希望它是一种纯粹的爱好，我可以欣赏别人的片子，也可以对着自己拍的照片嘿嘿偷笑，可以自己把它微喷输出出来摆在家里看，靠着我自己的一点努力让它成为纯粹的乐趣，而非讨好别人的工具。</li><li>以前我是绝不拍人的。<ul><li>第一是我自知很难真正把人拍好。现在的人像摄影在奇怪的地方卷向了同质化，大家好像真的是除了人像三要素（模特好看）之外，只会搞一个大光圈加上发丝光了，后来很少能见到像顾景拍的那样能让我感觉眼前一亮的人像片子了。论艺术大家远不及大师那样讲求布光等细节，论糖水又远不及黑糖给阿蛋天天拍的自然，论创意只能膜拜一晨老师的梦幻。我也只好勉强自己试一下氛围感，不出意外是完全没有思路，成片也有点羞于见人。很对不起模特小姐姐和巫老师愿意陪我一起尝试。</li><li>第二是我比较自闭，不知道该怎么表达。所以到现在一共没正经拍几次人像，基本上都需要拉上巫老师一起。他在前面夸，我在后面默默摁快门。害怕同质化可能是每一个热爱摄影的人绕不开的问题，同一个位置同一个场景，换个人来拍会一样吗？拍人的时候这恰恰会束缚住我，姿势不过那么几种组合，我摁的快门就会比别人拍的好看吗？每次需要拍人像前，这都会成为我的噩梦。至少在表达上已经在进步了，从最开始只顾着跟在巫老师后面，到现在敢提出去尝试另一个场景，还是满意自己的变化的 :)</li><li>人像摄影，我只是个没入门的门外汉，知道自己没水平还不得已诋毁它没意思。说回来，拍照片是娱乐自己，无法让自己满意的照片便是失败的。在拍人这件事上，我好像还很难让自己满意。</li></ul></li><li>既然我对这些平台都很有意见，为什么不做一个自己的“图虫”平台呢？过去的一段时间，我有在空闲时间和朋友一起试着做一个新的图片平台。从零开始提出需求，设计系统架构，一点点生成平台的各个细节，总结出核心的逻辑和商业前景，这个过程比我想象的更漫长更有挑战，我们也在一次次讨论中争吵，最后不得不在中途暂停，转去先提升自己，补全完整系统里仍然缺乏的知识。相比于本科做嘉禾连理的完整，这次在各方面遇到的阻力更大了。嘉禾连理的时候有成熟的框架，喜欢折腾的运维，目标明确的领头人，前瞻思维的产品策划，甚至还有专人负责商业化方向和洽谈（虽然很难评）。嘉禾连理能在一定程度上算成功，但是我好像一直只把它作为丰富的经历，而没有从中吸取和总结。使得这次想要开启一个新项目时可以说只是两个理工男在闷头自己搞，相比 Apple 早期缺少了 Jobs 的思维方式。平台项目还会重启，大家只是需要一段时间沉淀。</li></ul><center><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/DSCF4212-%E5%B7%B2%E5%A2%9E%E5%BC%BA-%E9%99%8D%E5%99%AA.jpg" alt="DSCF4212-已增强-降噪" width="300" /></center><h2 id="我对-AI-潮流的想法"><a href="#我对-AI-潮流的想法" class="headerlink" title="我对 AI 潮流的想法"></a>我对 AI 潮流的想法</h2><ul><li>说实话，我对 AI 的看法可能是和大部分人相冲的。我确实觉得大部分人不适合搞科研，尤其是在 AI 浪潮下很多人是被虚假的成果所蒙蔽的，对自己没有清晰准确的判断。</li><li>谁都知道搞 AI 好发论文，于是就一窝蜂的都冲上去。时代的大潮下，期刊会议的频率快了，接收的量多了，各行各业相关的不相关的都想要来分一杯羹。本科曾经有一门可能是密码学的课让我印象很深，不是因为我可以天天假扮 Alice 和 Bob 用奇怪的方式对话，这门课郭成老师要求大家挑一篇列表里的论文看完讲（如果我记错课程了莫怪）。我们抽了一篇同态加密的手写数字识别？并且发现它发在 CVPR workshop 上。老师解释：仅仅做安全太难产出了，加上 AI 能发的很快。也许在那一刻我对人工智能这个虚幻的概念就开始崩塌了，加上后来自己又投入了很多时间参与到深度学习里去，让我越来越厌恶这个方向和它所带来的附加特性。前段时间还因为坚持不用 GPT 不用代码辅助被朋友不理解。</li><li>高中语文课一直都有课前演讲，我仍然能记得那时候对人工智能完全不了解的我用网上看来的知识，拼凑起别人虚无缥缈的演讲，向自己班里的同学吹嘘这个 AI 多么牛，在不久的将来会多么有用。自己做过才能真正理解一些事情，才可以对它下定结论。很深刻的认识到，里面和外面看到的会是完全两个东西。当然，我更多的把它归因于人们对 AI 的过分吹捧，让它到了不属于的高度，俗称”捧杀“。我没有不承认 AI 的发展迅速给很多落地的应用带来生机，但是作为一个不可解释的黑盒，我会一直觉得它像一场泡沫，随时会被戳穿。当人们发现模型开始需要堆算力资源，堆更优质的数据集的时候，等，人工智能可能和人就相去甚远了。当然，我只是在旁边瞎评论的局外人，毕竟我也一直觉得数学和物理是依靠着一些基本的公理支撑的头重脚轻的大厦，随着世界向更高的维度或是更细微的组成等方向探索的时候，随时可能需要对这座大厦做一些修修补补，是吧。</li><li>我好像一直很喜欢往人少的地方去。专业分流的时候去网络系，即便本科在做深度学习也坚持想跳出来去网络验证组。（很有意思的事情是，当时保研的时候看方向和老师，我会把已经发表的论文里有 AI 的老师直接排除掉，结果来了一年多还是在组会听深度学习的讲）人少是一种规避竞争，也可以是逃避人潮，我需要强迫自己想，人多的就是正确的选择吗？跟随大众的选择我真的有机会从人潮中脱颖而出吗？从敲下第一行代码的时候到现在不过寥寥几年，起步晚该如何从一群摸爬滚打过那么久的人群中争到潮头？小众固然会有原因，在这场平衡性的博弈中选对自己更适合的一边才是最重要的。</li></ul><center><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/4-1.jpg" alt="4-1" width="300" /></center><h2 id="Jty-的多巴胺理论"><a href="#Jty-的多巴胺理论" class="headerlink" title="Jty 的多巴胺理论"></a>Jty 的多巴胺理论</h2><blockquote><p>一切所谓的爱好都是为了获取多巴胺。</p></blockquote><p>可能真的是，一切的自我满足、社交活动、爱好娱乐归根结底，所有的快乐本质都是多巴胺。自我调节的方式太多：游戏、影音、运动……但是落到结果上，人是否应该用且仅用那一种最高效获取多巴胺的方式来生活？</p><p>我们几个人在兰州就这个争了好久，挺有意思，但是不是很想写它。留给大家自己想想吧。</p><center><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/kaorou.jpg" alt="kaorou" width="300" /></center><h2 id="流程处理的生活模式"><a href="#流程处理的生活模式" class="headerlink" title="流程处理的生活模式"></a>流程处理的生活模式</h2><p>程序是流程处理，人的生活亦是如此。虽然说不想成为一个机器人，但是在某种程度上固定的生活节奏可能会帮助我过的更好一点。每天起床去体脂秤上站半分钟，用洗漱和冲淋让自己清醒，打开电脑做一道题；每天花一些时间来维持理应的知识摄入，固定的时间段内做固定的事情。或许会需要持续的优化生活的流程，但是这种方式无疑能让我每天完成一些不愿主动做但应该坚持做的事情。小时候喜欢制定详细的计划但是不执行，其实原因很大一部分在于时间上的固定。理想情况下我们总会想要几点起床，那么就会从几点到几点开始做什么事情。但是死板的规律和教条是逆反心理的，谁也不会保证自己能想机器一样在规定的时间就必须做规定的事情，生活总是会充满变化。所以，可能流程式的处理生活更符合人的生活方式。优化生活程序在某种意义上就是向每天推送的消息队列里添加事务，分身乏术的我们或许真的可以固定下每天都要进行的流程，让它变成一种潜意识的行为队列。</p><center><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/%E5%90%88%E6%88%90%20signed.jpg" alt="合成 signed" width="300" /></center><h2 id="工具-方法-方法论"><a href="#工具-方法-方法论" class="headerlink" title="工具 方法 方法论"></a>工具 方法 方法论</h2><p>第一次听到这个表述是高中办的经验分享会，诺大的体育馆里坐满了人，不知道有多少人会震惊于”工具 方法 方法论“这一套，它确实点透了当时还在摸鱼的我。俗语讲：授人以鱼不如授人以渔，但是没人告诉你你应该想为什么要打渔，别的方式行不行，打渔方法怎么用才好，怎么才能产出自己的打渔方法。</p><p>组里招了本科生已经有一个多月了，最开始确实愁什么都需要教；需要讲换用什么 IDE，怎么连接服务器用；然后是为什么要用服务器，这个东西的什么方法很高效。渐渐已经可以从工具层面进入到方法，再到能形成自己的方法论去寻找新的方法了，甚是欣慰。其实无论是在 NAOSI 还是新闻筛选频道等，都是工具的分享，甚至很少会到方法层面。你可能会去关注今天群里别人发的新终端模拟器有什么功能和特性，但是很少会想有没有别的也拥有这种特性或是做的更好，他们是基于什么原因想要去做这个新的终端模拟器呢？</p><p>今年上半年去兴庆给导做 SDN 课程助教（没机会报学硕的必修学分，明年得提一下这个事情了），经常问着问着我就突然冒出来个问题，这里用的什么图结构算法（Dijkstra），为什么前面需要做非负的判断。很有意思，虽然都是大三的本科生甚至因为交大的课程安排，他们学完这个应该也没有过去特别久，但是一整个班很少有人能讲出来原因。那个周的验收整个班都去重新学了一遍这个算法，然后尝试把已经学过的知识与 SDN 课上机实验串联起来理解。很惭愧，本科的数据结构课我在忙着给校区打工做图，即便去蹭了于红老师的课也没有认真听。</p><p>这两天又遇到一个很有意思的例子，想了想放在这一 part。为什么会觉得开车很有意思呢？你可以试着把马路上的车辆想象成移动的分布式网络设备（ad-hoc？），我们时时刻刻都在进行着信息传递。当我想要变道，我需要向外发送一个请求变道的 REQUEST 包（转向灯，甚至是小探头），相应的后方车辆可能会做出各种回应，比如后方车辆减速拉远距离是允许变道的 REPLY 包，加速闪灯甚至摁喇叭都是 REJECT 包，甚至可能冒出来很多你不明意义的 UNKNOWN 包，迫使你从 REQUEST 回退到 RUNNING 状态。你车在实时的和周围新遇到的车辆组成临时的网络，互相之间进行着消息传递，要防止有拜占庭将军问题的恶意节点以外，同时你也需要更好的视角来防止遗漏掉周围网络的节点，隐匿在网络中的未知节点很可能也是准备发起攻击的恶意节点。还是会感谢大一能碰到樊鑫老师，让我意识到用计算机的思路去想事情有多么重要。科班的最大意义我想是培养你在遇到问题时能跳出来，想想计算机会怎么做 :)</p><center><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/%E5%9C%B0%E6%99%AF%E5%90%88%E6%88%90-%E7%AD%BE%E5%90%8D.jpg" alt="地景合成-签名" width="300" /></center><h2 id="我的需求是什么？我想要怎样的生活？"><a href="#我的需求是什么？我想要怎样的生活？" class="headerlink" title="我的需求是什么？我想要怎样的生活？"></a>我的需求是什么？我想要怎样的生活？</h2><p>我想要什么？或者说，我真的知道自己想要什么吗？见到太多的人其实根本搞不清楚自己的需求。小时候跟着大家去兴趣班，高考考个别人会夸的好大学，然后顺着潮流读个研。不知道自己想要什么是很恐怖的事情。</p><p>我们时常会规划自己的人生，也是给自己设下期待。期待能在年轻的时候找到自己喜欢的爱好，期待自己能中年时有为之拼搏的事业，期待自己年老后能欣慰看着后辈也有自己的期待。或许我们未来仍然无法逃避长江后浪推前浪的裁员，但可以培养出自己的爱好和副业，在中年危机的关头能从容不迫的转去做另一件自己喜欢的事情。我会很期待能天天端着超长焦去林子里打鸟的生活；或是经营一家自己的小饭店，可以经常邀请亲近的好友一起聊天；又或是可以和小孩一起教教他们用计算机的思维去思考事务。成功不是挣了多少有多大的房子，而是你可以自由的选择做自己想做的事情，面对困难永远有第二条路可以走。</p><p>现在好像开始会被催着找对象了，打电话的时候会提起可以多认识认识人，会被师兄夺命连环问 你对象呢，会看着别人羡慕。我比较羞于提及这件事，这段话反复删了写写了删 :( 明知道自己从来不注意外在形象，在生人面前也社恐的想往后缩，会紧张的连话都说不明白。一个 i 人已经很努力在结识更多的朋友了，但是在这一方面迫于自己的心理很难说能迈出一步。是会和别人想法不同，我不太能接受他们所谓的广撒网，靠基数来找到合适的人的想法。好难像 Links 一样拥有自己的小螃蟹，可能还是会缩在自己的角落里，默默看着别人幸福吧。</p><center><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/camera.jpg" alt="camera" width="500" /></center><h2 id="少说-多做"><a href="#少说-多做" class="headerlink" title="少说 多做"></a>少说 多做</h2><p>今年发生过一件事情我一直不愿意回忆，因为是违禁的，也不能在公开场合里解释。但它让我第一次这么清晰的认识到我们活在互联网是透明的，数据会记录下网络上的每一条发言的时间、前后文和屏幕后面的人，清晰且完整，甚至让人感到恐怖。我想你也知道，这里没有真正的删除，数据库的删除也不过是更改一下标记位，我们所创造的数据仍然不会超过存储的限额。这里的每一点善恶都被呈堂证供，“少说 多做”也是那段时间我一直在反复告诫自己的事情，因为你确实不会想象得到你多么普通的一句话却会被莫名牵扯到毫不相干的事情里，六度空间理论告诉我们每一件事情都会有着紧密的联系，即便你多么难理解他们是怎么能捆绑到一起的。ok，少说 :)</p><center><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/DJI_0834-%E5%B7%B2%E5%A2%9E%E5%BC%BA-NR-%E6%B3%9B%E9%BB%84-%E5%8F%A4%E5%85%B8%E6%9F%94%E7%84%A6-signed.jpg" alt="DJI_0834-已增强-NR-泛黄-古典柔焦-signed" width="500" /></center><h2 id="从参与办一场音乐会"><a href="#从参与办一场音乐会" class="headerlink" title="从参与办一场音乐会"></a>从参与办一场音乐会</h2><p>前段时间尝试转换身份，从 dv 的活转头去做了文化部的活，当上了艺术团音乐会的”大内总管“之一 :) 这东西当一次就行了，确实太累，还因为会在场间上台搬东西被麻麻看直播看到说太胖了 :( 第一次做，很多事情忙的顾头不顾尾，得去想如果是晓辰会怎么做。所幸音乐会没有出大问题，也得以认识了器乐团和合唱团的大家。比较可惜的是写了好久的 music in life 博客寄了，我的一通牢骚也没地方发泄。本科四年的断档确实很伤，让我觉得除开自娱自乐以外，我已经可以和音乐拜拜了。已经没有那么多精力像曾经一样投入到乐团里了，也不能像高中一样每天和楼下琴房对着拉。音乐可以是生活的调节剂，十余年的学习也让我有能力欣赏一部分美，即便知道不如从前我也仍然会为了自己的一些能力自豪；时隔许多年再次听《楚颂》仍然会像它刚出的时候听一样颅内高潮那么多次，回忆曾经一起去韩国文化交流我也不会想到还需要我照顾的师弟能第二个破格录取，现在再去要谱子仍然第一反应会想到已经”退休“了的田部长，甚至仍然能收到我的乐团朋友给我送的小礼物和祝福。</p><p>不知不觉就又变成了回忆录，还是看看当下。在大家都任务繁忙的时候，能认识这么多和民乐”无关“的人，满是崇敬。这里的人对音乐满腔热爱，我自知散漫，肯定是学不来的。所以更多的时候，我会选择当一名看客。可以在晚上排练厅断电之后站在陆师、马老师等身后听排练，可以在第一次见面沙龙看彤子和凌分队学长一起即兴，可以在音乐会排练人渐渐散去时的喧嚣里站在钢琴旁听蕾姐等人演奏圣诞快乐劳伦斯。人可以畏惧，可以逃避，但不能不感激。有机会在 Spotify 之外听到上百万的琴声流淌过也是一种满足。（当然，我生性愚笨，听不来音色 :) 倒是挺关心琴的音准的）</p><p>还会逃吗？会逃吧。打小就不喜欢站在聚光灯下被不知道和可能有的目光注视，以前在大乐团里也只需要帮忙做做简单的管理和开始前给琴调调音；也许本科去 dv 做幕后真的就是性格吸引呢？</p><center><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/DSC_3039.jpg" alt="DSC_3039" width="300" /></center><h2 id="我们的目标是：星辰大海！"><a href="#我们的目标是：星辰大海！" class="headerlink" title="我们的目标是：星辰大海！"></a>我们的目标是：星辰大海！</h2><p>某天和干事说 想去看星星，干事说我越来越像小蝴蝶 infp 了。MBTI 性格测试我做了两次，时间跨度比较久，但是结果还是稍有变化。</p><center><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/infp.jpg" alt="infp" width="500" /></center><p>以前不相信这些心理测试，认为自己介于对立性格的中间，可以在需要的时候切换，或者是<del>双重人格</del>。现在好像越来越鲜明的表现为这一种特定的 infp 了。自闭但是又不能忍受孤独，在创新港里闷住就很想多出去看看。本来选择来西安也是因为能离西北更近一些，方便玩。苦于越来越忙乱的杂事缠身，越来越少机会能出去看看。明年希望能更抓住机会多出去看看。人呐在有时间的时候没有金钱支持，未来有了钱又会没有时间。希望自己能趁还年轻，多去看看星辰大海！</p>          </div>]]></content>
    
    <summary type="html">
    
      Review these two years and think a lot
    
    </summary>
    
    
    
      <category term="REVIEW" scheme="https://augists.top/tags/REVIEW/"/>
    
  </entry>
  
  <entry>
    <title>Code Style and Format</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/code-format/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/code-format/</id>
    <published>2024-02-18T02:19:24.000Z</published>
    <updated>2025-05-22T08:50:20.324Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间一直在边看师兄代码边吐槽不规范，每一段每一行甚至行内的代码规范可能都不同。但是最近在接触的项目里还比较注重代码规范，反复的调试让人很崩溃。所以想写一篇专门讨论一下有关代码格式与规范，主要关注于格式化的方式（代码缩进等）而非类似<a href="https://github.com/alibaba/p3c">阿里巴巴 Java 代码规范黄山版</a>这样的编程规范</p><div class="note warning">            <p>比较幸运的是我在入门的时候走了一条更好的路——樊鑫老师要求所有人都去看 c bible 原本。刚上手的时候不会自己写，只能对着书里的示例代码敲来模仿，人家怎么写就怎么敲，所以就顺理成章的学会了 K&amp;R 的标准 c 语言代码规范。再到后来需要配置自己的编辑器，用自带的 <code>=</code> 和 <code>clang-format</code> 来做代码的格式化，粗浅的了解了一点不同的标准。再后来要写 golang，一种有着强制代码规范要求和工具的语言。可以说成长的道路上一直对代码规范有一定的限制让我没走歪路。</p><p>这里放一段《C 程序设计语言》里 <code>strtol</code> 示例代码。可以注意到库导入后的空行、函数和单行的代码注释的使用、空格的位置、括号位置、空执行时分号的位置等等信息。如果你想要寻找这类书籍资源可以随便访问<a href="https://github.com/PongsInk/LearningResource">一个仓库</a>来下载权威书籍的电子版本或购买纸质版。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* atoi: convert s to integer; version 2 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n, sign;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; <span class="built_in">isspace</span>(s[i]); i++) <span class="comment">/* skip white space */</span></span><br><span class="line">        ;</span><br><span class="line">    sign = (s[i] == <span class="string">&#x27;-&#x27;</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>) <span class="comment">/* skip sign */</span></span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; <span class="built_in">isdigit</span>(s[i]); i++)</span><br><span class="line">        n = <span class="number">10</span> * n + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> sign * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>          </div><p>在经历了最初始的模仿阶段后，就应该寻找合适且合规的代码格式化规范了。尽管很多语言都有自己的格式要求或格式化工具，但是这里还是需要推荐 <a href="https://clang.llvm.org/docs/ClangFormat.html"><code>clang-format</code></a> 这种相对更为原始的 cli 工具，也是因为它有着更加严格和成体系的风格选择和详细的配置选择。你可以在<a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html">这里</a>找到非常多官方的风格选项。</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Screen Shot 2024-02-19 at 22.56.52.png"/><p>你可以通过 <code>clang-format -style=llvm -dump-config &gt; .clang-format</code> 来选择一个生成或直接进行代码格式化的使用它们。同时这也是 <code>clang-format</code> 配置文件里最重要的根基，直接定下了代码规范整体的风格体系。这里用上面的示例代码展示 LLVM、Microsoft 和 GNU 代码风格的结果，因为代码较短且不具有很强的代表性，所以区别并不明显，希望读者能注意到它们之间的区别（这里主要体现在函数名一行和代码缩进）</p><ul><li>LLVM</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* atoi: convert s to integer; version 2 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, n, sign;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; <span class="built_in">isspace</span>(s[i]); i++) <span class="comment">/* skip white space */</span></span><br><span class="line">    ;</span><br><span class="line">  sign = (s[i] == <span class="string">&#x27;-&#x27;</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>) <span class="comment">/* skip sign */</span></span><br><span class="line">    i++;</span><br><span class="line">  <span class="keyword">for</span> (n = <span class="number">0</span>; <span class="built_in">isdigit</span>(s[i]); i++)</span><br><span class="line">    n = <span class="number">10</span> * n + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> sign * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Microsoft</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* atoi: convert s to integer; version 2 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n, sign;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; <span class="built_in">isspace</span>(s[i]); i++) <span class="comment">/* skip white space */</span></span><br><span class="line">        ;</span><br><span class="line">    sign = (s[i] == <span class="string">&#x27;-&#x27;</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>) <span class="comment">/* skip sign */</span></span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; <span class="built_in">isdigit</span>(s[i]); i++)</span><br><span class="line">        n = <span class="number">10</span> * n + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> sign * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>GNU</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* atoi: convert s to integer; version 2 */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">atoi (<span class="keyword">char</span> s[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i, n, sign;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; <span class="built_in">isspace</span> (s[i]); i++) <span class="comment">/* skip white space */</span></span><br><span class="line">    ;</span><br><span class="line">  sign = (s[i] == <span class="string">&#x27;-&#x27;</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>) <span class="comment">/* skip sign */</span></span><br><span class="line">    i++;</span><br><span class="line">  <span class="keyword">for</span> (n = <span class="number">0</span>; <span class="built_in">isdigit</span> (s[i]); i++)</span><br><span class="line">    n = <span class="number">10</span> * n + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> sign * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果读者有关注例如 <a href="https://github.com/torvalds/linux">Linux 内核源码</a> 的话，应该也能在文档里看到<a href="https://github.com/torvalds/linux/blob/master/Documentation/process/clang-format.rst">它对代码格式化风格的要求</a>。这里就以内核源码为例，它要求使用 <code>clang-format -i kernel/*.[ch]</code> 来对文件进行格式化，并且对每一部分代码都有更为详细的要求来保证代码风格的统一并防止不同人重复提交相同代码的不同格式化风格版本。</p><p>当然，你也可以直接使用（更推荐在了解了原始工具之后）IDE 提供的功能或类似 <a href="https://prettier.io/">Prettier</a> 这样的 code formatter 工具，它们对更多语言有着更好的适配和易用性。除此之外也有一些厂商的代码规范作为插件或文档提供出来，例如 <a href="https://github.com/batfish/batfish">Batfish</a> 就要求<a href="https://github.com/batfish/batfish/tree/master/docs/intellij_setup">必须在 IDEA 里安装使用 google-java-format 插件</a>（非常烦人的这个项目要求 clean import，去除未使用的导入且不能使用通配符，这让我的代码调试运行非常麻烦）。同时也可以关注例如 <a href="https://google.github.io/styleguide/">Google 提供的代码风格引导文档</a>，它对不同语言都有着更为明确的要求。</p><p>选择一个适合自己且更为通用的代码格式化风格和规范非常重要，不仅是让自己在敲代码的时候避免一些错误，也能让自己和别人更方便的阅读代码。曾经班里经常有人会拿着代码来问我，而每次我都纠结于毫无章法的代码格式，被迫打开电脑先用工具进行合理的风格化之后才能看得下去 :(</p><div class="note info">            <p>除了格式化风格，挑选一个适合自己的字体也非常重要。一种是使用大厂制作和推广的代码字体（例如 GitHub 之前推出的 <a href="https://monaspace.githubnext.com/">Monaspace</a>），它们可能对例如 <code>==</code> <code>=&gt;</code> 等编程中常见的字符有优化；另一种是使用 <a href="https://www.nerdfonts.com/">Nerd Fonts</a>，它们对一些图标的特殊字符有优化，可以更好的利用你的 cli 环境。</p>          </div>]]></content>
    
    <summary type="html">
    
      代码格式与规范 实战
    
    </summary>
    
    
    
      <category term="CODE" scheme="https://augists.top/tags/CODE/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Privacy and Anti-Social Engineering</title>
    <link href="https://augists.top/SELF/THINKING/Privacy-and-Anti-Social-Engineering/"/>
    <id>https://augists.top/SELF/THINKING/Privacy-and-Anti-Social-Engineering/</id>
    <published>2024-01-17T10:12:01.000Z</published>
    <updated>2025-05-22T08:50:20.326Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <div class="note info">            <p>好久没写博客了，去年的 review 还没有写，打算农历新年前等回家之后抽一两天写吧，先水一个我对当前网络背景下的隐私保护的想法（逃避看代码</p><p>现在记忆力差到会问师兄问题还没等他回答就已经忘记刚问的问题了，所以我现在也不记得为什么中午吃饭的时候就突然想到要写这个反社工的博客。Anyway，那就写写我对在当前的网络社会背景下我对隐私保护和社工的一点点想法吧</p>          </div><h2 id="什么是社工"><a href="#什么是社工" class="headerlink" title="什么是社工"></a>什么是社工</h2><p>首先要知道，社会工程学是什么？</p><div class="note info">            <p>社会工程学是指在信息安全方面操纵人的心理，使其采取行动或泄露机密信息。有别于社会科学中的社会工程，这是种以收集信息、欺诈或入侵系统为目的的信任骗局，已发展出各种技术手段，并可能用于犯罪。</p><p>—— wikipedia</p>          </div><p>简单来说，在网络无处不在的场景下，我想要去人肉一个人，在我通过各种手段获取它的信息的过程，就算是社工了。它通常有别于大家所想的黑客（Hacker）用技术手段破解系统拿信息，相对门槛可以说要低的多。</p><p>我最早接触到是和一个做安全工程师的哥哥聊天，再后来接触东西多了也尝试过社工库。感觉在这样一个用隐私换服务的网络社会，大家很难保护自己的信息不被泄漏。我也在社工库中查询过自己，与所了解到的完全相同，仅仅用免费开放出来的社工库信息就已经把自己扒的底裤都不剩了。</p><h2 id="隐私换服务的时代，怎么保护自己"><a href="#隐私换服务的时代，怎么保护自己" class="headerlink" title="隐私换服务的时代，怎么保护自己"></a>隐私换服务的时代，怎么保护自己</h2><p>不得不承认，大数据时代的服务就是要依靠个人隐私来换的。厂商需要更精准的推送，需要了解你的能力，需要你的位置来匹配等等。如果把这些信息都抹去，大家就又变回原始人了。鉴于流量等成本，也不可能由远端把所有信息都推送给你，再又主机本地进行筛选提供。换句话说，不是没了手机活不了，而是用隐私换服务支撑起了当今社会。</p><p>那么为了应对海量的信息泄漏，该怎么办呢？</p><p>首先要明确，没有任何的软件没有漏洞，没有任何的系统不可能被攻破，也没有任何一个数据库没有泄漏的可能。在维护<a href="https://t.me/Augists">新闻频道</a>的这么长时间里，已经转发过太多太多的信息泄漏事件了，即便它是由最权威的大厂亦或是有国家政府来背书。与学生最相关的例子可能就是前几年的学习通数据库被拖库了吧，整个数据库被大家肆意传，但里面的信息包括了你的帐号 密码 学校 手机号 学号等信息。社工可怕在可以像数据库 <code>join</code> 一样把不同地方获取到的信息合并，从而得到一个更全面的版本，就像我在社工库中通过我的学号拿到了我的姓名 手机号等信息，再用手机号获取到了多任机主的姓名 地址等，经过简单筛选就可以生成一个非常全面的 Augists 个人信息档案了。</p><p>那么，是不是我所有地方都提供假信息就可以了？</p><p>很明显，我们有大量的地方和场景要求我们必须提供真实的信息。本科作为班级的学委，我有全班每一个人在开学时提交过的详细个人信息表格，也有全年级的各种获奖等信息的汇总等，想要查询一个人的时候，通常只需要有学号，不需要利用战神发现的学生系统的漏洞就可以非常清楚的知道很多了。你又怎么敢确信我没有把手里的信息批量出卖给别人？</p><p>也许有的人会让自己每个社交平台都使用不同的名字。这肯定是有一定效果的方法，但是这一方面是给自己徒增成本，另一方面在核心串联信息的如手机号 身份证 常用邮箱等都没有办法做到保护，实际意义并没有那么大。当然，对付普通人可能就已经足够了。</p><div class="note info">            <p>想起来之前看到一个人说自己每个平台的帐号和密码都会和平台名字相关联。比如原本是叫 Augists，那么淘宝名字就是 AugistsTB，密码也以 <code>tb</code> 开头；京东就用 AugistsJD，密码以 <code>jd</code> 开头。非常值得借鉴学习，这样当你收到奇怪的信息泄漏短信的时候也能反向追踪到是什么平台将你的数据出卖了。</p><p>在密码管理上，除了 2FA 验证器和物理密钥，我自己使用的是多级的密码管理。简单可以区分为：可以出借帐号密码的 · 比较重要只有关系最近的人知道的 · 非常重要只有直系亲属可以知道的 · 必须只有自己知道的。当然，我也无法保证重要等级高的密码不会被无良代码人不加盐被拖库而暴露出去。我倾向于在有序的基础上建立无序规则，比如你可以把自己的名字写下来，然后生成一些随机数，通过如按位与 · 移位 · 交换 · 替换等方式让这一串看似完全无序的密钥有一定的仅自己知道的规律，然后强行记住它。当然，动态密码和 2FA 的方式也是非常推荐的。相比与我的 primary 和 backup 两个 YubiKey，2FA 验证器无论是方便程度还是安全性（指物理密钥丢失）都要更好。</p>          </div><p>我想的更合适的方式是：</p><ul><li>放弃抵抗，但塞入假信息。海量的数据也就意味着，并不存在严谨且高成本的真实数据筛选，事实上应该也没有筛选。你可以在平台上的一些地方使用假信息，使其污染流入的大数据库。这也是我认为最合理和可行的一种，尽管我想了很久都没有完全付诸实践。</li><li>临时或中间转发站。使用如 duckduckgo 提供的第三方隐私转发邮箱，使用可以抛弃的流量卡来注册一些不重要的帐号等方式。</li><li>对自己的 cookies · 权限等进行管理，只保留必须的使用。Google 也在今年开始了禁用 cookies 的方式来提供服务，开始探索新的隐私换服务方式。</li><li>去中心化的信息存储方式和组织结构。信息存储在每一部分只保留一点，只有当他们以某种特殊方式组合在一起时才对应着全部信息，这样在一定程度上也能让某一数据库被泄漏时的代价减小。在组织结构上，可以参考很久以前的<a href="https://augists.top/SELF/SHARING/STUDY/make-QQ-group-like-unix/">这篇博客的方式</a>，降低自己在整个结构中的权重。</li></ul><p>当然，以上只是抛砖引玉，提出一点不成熟的小想法。关于怎么保护自己信息我也还在探索，怎么与“隐私换服务”的方式共存。或许，大三的 yl 老师的某课上我提出的关于位置隐私保护的分级服务和分区服务取交集法真的能实现呢</p>          </div>]]></content>
    
    <summary type="html">
    
      隐私保护与对抗社会工程学
    
    </summary>
    
    
    
      <category term="THINKING" scheme="https://augists.top/tags/THINKING/"/>
    
  </entry>
  
  <entry>
    <title>An Introduction to Binary Decision Diagrams</title>
    <link href="https://augists.top/NOTES/PAPER/An-Introduction-to-Binary-Decision-Diagrams/"/>
    <id>https://augists.top/NOTES/PAPER/An-Introduction-to-Binary-Decision-Diagrams/</id>
    <published>2024-01-08T06:14:52.000Z</published>
    <updated>2025-07-27T14:22:22.470Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table T: u -&gt; (i, l, h)</span><br><span class="line">  init(T)                     initialize T to contain only 0 and 1</span><br><span class="line">  u &lt;- add(T, i, l, h)        allocate a new node u with attributes (i, l, h)</span><br><span class="line">  var(u), low(u), high(u)     lookup the attributes of u in T</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Table H: (i, l, h) -&gt; u</span><br><span class="line">  init(H)                     initialize H to be empty</span><br><span class="line">  b &lt;- member(H, i, l, h)     check if (i, l, h) is in H</span><br><span class="line">  u &lt;- lookup(H, i, l, h)     find H(i, l, h)</span><br><span class="line">  insert(H, i, l, h, u)       make (i, l, h) map to u in H</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MK[T, H](i, l, h)</span><br><span class="line">  if l &#x3D; h then return l            # if low &#x3D;&#x3D; high, pass the node and point to its child</span><br><span class="line">  else if member(H, i, l, h) then   # if node in H, return it and do not create a new one</span><br><span class="line">    return lookup(H, i, l, h)</span><br><span class="line">  else</span><br><span class="line">    u &lt;- add(T, i, l, h)            # create node in T and map in H</span><br><span class="line">    insert(H, i, l, h, u)</span><br><span class="line">    return u</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BUILD[T, H](t)</span><br><span class="line">function BUILD&#39;(t, i)               # i is the lowest index at first</span><br><span class="line">  if i &gt; n then                     # terminal node</span><br><span class="line">    if t is false then return 0 else return 1</span><br><span class="line">  else                              # build from bottom to top recurisively</span><br><span class="line">    v0 &lt;- BUILD&#39;(t[0&#x2F;xi], i + 1)</span><br><span class="line">    v1 &lt;- BUILD&#39;(t[1&#x2F;xi], i + 1)</span><br><span class="line">    return MK(i, v0, v1)</span><br><span class="line">end BUILD&#39;</span><br><span class="line"></span><br><span class="line">return BUILD&#39;(t, 1)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">APPLY[T, H](op, u1, u2)             # combine two ROBDDs? O(|u1||u2|)</span><br><span class="line">init(G)</span><br><span class="line"></span><br><span class="line">function APP(u1, u2)                # call from top to bottom, compute from bottom to top</span><br><span class="line">  if G(u1, u2) !&#x3D; empty then return G(u1, u2)</span><br><span class="line">  else if u1 in &#123;0, 1&#125; and u2 in &#123;0, 1&#125; then u &lt;- op(u1, u2)</span><br><span class="line">  else if var(u1) &#x3D; var(u2) then</span><br><span class="line">    u &lt;- MK(var(u1), APP(low(u1), low(u2)), APP(high(u1), high(u2)))</span><br><span class="line">  else if var(u1) &lt; var(u2) then</span><br><span class="line">    u &lt;- MK(var(u1), APP(low(u1), u2), APP(high(u1), u2))</span><br><span class="line">  else  # var(u1) &gt; var(u2)</span><br><span class="line">    u &lt;- MK(var(u2), APP(u1, low(u2)), APP(u1, high(u2)))</span><br><span class="line">  G(u1, u2) &lt;- u</span><br><span class="line">  return u</span><br><span class="line">end APP</span><br><span class="line"></span><br><span class="line">return APP(u1, u2)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RESTRICT[T, H](u, j, b)             # find the ROBDD for some condition, i.e., t[0&#x2F;x3, 1&#x2F;x5, 1&#x2F;x6]</span><br><span class="line">function res(u)</span><br><span class="line">  if var(u) &gt; j then return u</span><br><span class="line">  else if var(u) &lt; j then return MK(var(u), res(low(u)), res(high(u)))</span><br><span class="line">  else if b &#x3D; 0 then return res(low(u))</span><br><span class="line">  else  # var(u) &#x3D; j, b &#x3D; 1</span><br><span class="line">    return res(high(u))</span><br><span class="line">end res</span><br><span class="line"></span><br><span class="line">return res(u)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SATCOUNT[T](u)                      # determine the number of valid truth assignments</span><br><span class="line">function count(u)</span><br><span class="line">  if u &#x3D; 0 then res &lt;- 0</span><br><span class="line">  else if u &#x3D; 1 then res &lt;- 1</span><br><span class="line">  else res &lt;- 2^(var(low(u))-var(u)-1) * count(low(u)) + 2^(var(high(u))-var(u)-1) * count(high(u))</span><br><span class="line">  return res</span><br><span class="line">end count</span><br><span class="line"></span><br><span class="line">return 2^(var(u)-1) * count(u)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ANYSAT(u)                           # find a satisfying truth-assignment, find a path leading to 1 by DFS, prefering low-edges over high-edges</span><br><span class="line">  if u &#x3D; 0 then Error</span><br><span class="line">  else if u &#x3D; 1 then return []</span><br><span class="line">  else if low(u) &#x3D; 0 then return [x_var(u) -&gt; 1, ANYSAT(high(u))]</span><br><span class="line">  else return [x_var(u) -&gt; 0, ANYSAT(low(u))]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ALLSAT(u)                           # find all paths from a node u to the terminal 1</span><br><span class="line">  if u &#x3D; 0 then return &#123;&#125;</span><br><span class="line">  else if u &#x3D; 1 then return &#123;[]&#125;    # &#123;&#125; denotes swquences of truth assignments</span><br><span class="line">  else return</span><br><span class="line">    &#123;</span><br><span class="line">      add[x_var(u) -&gt; 0] in front of all truth-assignments in ALLSAT(low(u)),</span><br><span class="line">      add[x_var(u) -&gt; 1] in front of all truth-assignments in ALLSAT(hight(u))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SIMPLIFY(d, u)                      # simplify an ROBDD by trying to remove nodes based on a domain d</span><br><span class="line">function sim(d, u)</span><br><span class="line">  if d &#x3D; 0 then return 0</span><br><span class="line">  else if u &lt;&#x3D; 1 then return u</span><br><span class="line">  else if d &#x3D; 1 then</span><br><span class="line">    return MK(var(u), sim(d, low(u)), sim(d, high(u)))</span><br><span class="line">  else if var(d) &#x3D; var(u) then</span><br><span class="line">    if low(d) &#x3D; 0 then return sim(high(d), high(u))</span><br><span class="line">    else if high(d) &#x3D; 0 then return sim(low(d), low(u))</span><br><span class="line">    else</span><br><span class="line">      return MK(var(u), sim(low(d), low(u)), sim(high(d), high(u)))</span><br><span class="line">  else if var(d) &lt; var(u) then</span><br><span class="line">    return MK(var(d), sim(low(d), u), sim(high(d), u))</span><br><span class="line">  else</span><br><span class="line">    return MK(var(u), sim(d, low(u)), sim(d, high(u)))</span><br><span class="line">end sim</span><br><span class="line"></span><br><span class="line">return sim(d, u)</span><br></pre></td></tr></table></figure><table><thead><tr><th>method</th><th>time</th><th>note</th></tr></thead><tbody><tr><td>MK(i, u0, u1)</td><td><code>O(1)</code></td><td></td></tr><tr><td>BUILD(t)</td><td><code>O(2^n)</code></td><td></td></tr><tr><td>APPLY(op, u1, u2)</td><td><code>O(abs(u1) * abs(u2))</code></td><td></td></tr><tr><td>RESTRICT(u, j, b)</td><td><code>O(abs(u))</code></td><td></td></tr><tr><td>SATCOUNT(u)</td><td><code>O(abs(u))</code></td><td></td></tr><tr><td>ANYSAT(u)</td><td><code>O(abs(p))</code></td><td><code>p = ANYSAT(u), abs(p) = O(abs(u))</code></td></tr><tr><td>ALLSAT(u)</td><td><code>O(abs(r)*n)</code></td><td><code>r = ALLSAT(u), abs(r) = O(2^abs(u))</code></td></tr><tr><td>SIMPLIFY(d, u)</td><td><code>O(abs(d) * abs(u))</code></td><td></td></tr></tbody></table>          </div>]]></content>
    
    <summary type="html">
    
      Paper Note
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="NETWORK" scheme="https://augists.top/tags/NETWORK/"/>
    
      <category term="PAPER" scheme="https://augists.top/tags/PAPER/"/>
    
  </entry>
  
  <entry>
    <title>Code Coverage</title>
    <link href="https://augists.top/NOTES/Code-Coverage/"/>
    <id>https://augists.top/NOTES/Code-Coverage/</id>
    <published>2023-12-08T06:12:07.000Z</published>
    <updated>2025-05-22T08:50:20.306Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>Coverage Criteria</p><ul><li>Function coverage: each function or subroutine</li><li>Statement coverage: each statement</li><li>Edge coverage: every edge in the control-flow graph<ul><li>Branch coverage: each branch (also called DD-path) of each control structure (e.g. <code>case</code>)</li></ul></li><li>Condition coverage (predicate coverage): each boolean sub-expression evaluated both to true and false</li></ul><blockquote><p>condition coverage does not necessarily imply branch coverage if the programming language does not perform short-circuit evaluation</p><p>if a and b &lt;- a is false then the whole statement is false</p></blockquote><ul><li>Modified condition/decision coverage: combination of function coverage and branch coverage; every point of entry and exit has been invoked at least once and every decision has taken on all possible outcomes at least once (sometime used as a synonym for branch coverage)</li><li>Multiple condition coverage: all combinations of conditions inside each decision are tested (2^n)</li><li>Parameter value coverage (PVC): all the common values for parameters in a method are considered<ul><li>null</li><li>empty</li><li>whitespace (space, tab, newline)</li><li>valid string</li><li>invalid string</li><li>single-byte string</li><li>double-byte string</li></ul></li><li>Linear Code Sequence and Jump (LCSAJ) coverage (JJ-Path coverage): every LCSAJ/JJ-path executed</li><li>Path coverage: every possible route through a given part of the code executed</li><li>Entry/exit coverage: every possible call and return of the function executed</li><li>Loop coverage: every possible loop executed zero times, once, and more than once</li><li>State coverage: each state in a finite-state machine reached and explored</li><li>Data-flow coverage: each variable definition and its usage reached and explored</li></ul><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><ol><li>Find the right tool</li></ol><ul><li>Java: <a href="https://www.atlassian.com/software/clover">Atlassian Clover</a>, <a href="http://cobertura.github.io/cobertura/">Cobertura</a>, <a href="http://www.eclemma.org/jacoco/">JaCoCo</a><ul><li><a href="https://www.jacoco.org/jacoco/trunk/doc/">JaCoCo Documentation</a></li><li>Instructions<ul><li>single Java byte code instructions</li><li>the amount of code that has been executed or missed</li></ul></li><li>Branches<ul><li>the total number of <code>if</code> and <code>switch</code> branches in a method and determines the number of executed or missed branches</li><li>line highlight<ul><li>No coverage: No branches in the line has been executed (red diamond)</li><li>Partial coverage: Only a part of the branches in the line have been executed (yellow diamond)</li><li>Full coverage: All branches in the line have been executed (green diamond)</li></ul></li></ul></li><li>Cyclomatic Complexity<ul><li>the minimum number of paths that can, in (linear) combination, generate all possible paths through a method</li><li>the complexity value can serve as an indication for the number of unit test cases to fully cover a certain piece of software</li></ul></li><li>Lines<ul><li>at least one instruction that is assigned to this line has been executed</li><li>line highlight<ul><li>No coverage: No instruction in the line has been executed (red background)</li><li>Partial coverage: Only a part of the instruction in the line have been executed (yellow background)</li><li>Full coverage: All instructions in the line have been executed (green background)</li></ul></li></ul></li><li>Methods</li><li>Classes</li></ul></li><li>Javascript: <a href="https://github.com/gotwarlost/istanbul">istanbul</a></li><li>PHP: <a href="https://phpunit.de/">PHPUnit</a></li><li>Python: <a href="https://coverage.readthedocs.io/">Coverage.py</a><ul><li>using python trace function, a callback that the Python interpreter will invoke for every function call and line of Python executed</li><li><a href="https://nedbatchelder.com/text/trace-function.html">How C trace functions really work</a></li></ul></li><li>Ruby: <a href="https://github.com/colszowka/simplecov">SimpleCov</a></li></ul><p><a href="https://confluence.atlassian.com/clover/comparison-of-code-coverage-tools-681706101.html">comparison of tools</a></p><ol start="2"><li>What percentage of coverage should you aim for</li></ol><ul><li>With that being said it is generally accepted that 80% coverage is a good goal to aim for.</li><li>Don’t write tests that are hitting every line of the code instead of writing tests that are based on the business requirements of your application</li><li>Test from a user perspective and not just by looking at lines of code.</li></ul><ol start="3"><li>Focus on unit testing first</li><li>Use coverage reports to identify critical misses in testing</li><li>Make code coverage part of your continuous integration flow when you are ready</li><li>Good coverage does not equal good tests</li></ol>          </div>]]></content>
    
    <summary type="html">
    
      Organized notes on code coverage related content
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
  </entry>
  
  <entry>
    <title>Powerdevil Restart Loop Bug &#39;FIXED&#39;</title>
    <link href="https://augists.top/SELF/ERROR/Powerdevil-Restart-Loop-bug-FIXED/"/>
    <id>https://augists.top/SELF/ERROR/Powerdevil-Restart-Loop-bug-FIXED/</id>
    <published>2023-11-15T11:53:16.000Z</published>
    <updated>2025-05-22T08:50:20.314Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>最近遇到过几次 KDE 直接崩溃的情况，具体表现为后台的进城可以正常运行（音乐视频等正常播放），但是桌面环境卡死。在应该是第二次还是第三次的时候就想要不要找找系统的 log 看看，毕竟作为一个不够稳定且追求极致最新的系统，出现崩溃也是合理的</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/arch/20231118152719.png" alt=""></p><p>于是找到了 KSystemlog</p><div class="note info">            <p>KSystemLog show all logs of your system, grouped by General (Default system log, Authentication, Kernel, X.org…), and optional Services (Apache, Cups, etc, …). It includes many features to read nicely your log files:</p><ul><li>Colorize log lines depending on their severities</li><li>Tabbed view to allow displaying several logs at the same time</li><li>Auto display new lines logged</li><li>Detailed information for each log lines</li></ul>          </div><p>筛选了 Error 及以上的信息后，发现 systemd 里一直有一个 Powerdevil 在无限重启</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/arch/20231118160424.png" alt=""></p><p>所以就在搜索后尝试查看进程状态</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/arch/594053625b0d88196079c566f5e9b4f9.png" alt=""></p><p>可以看到发生错误与 ddcutil 和休眠有关系。可能需要提及的是，在前段时间每天使用 sleep 之后我发现 Arch 会越来越慢。当时为了保留 IDEA 的 debugger 状态不敢关机，导致后面卡成 PPT。后来在 NAOSI 群里聊起来，JC Zhang 说不要用 KDE 的 sleep，可以就用自动的 Lock。由于已经不记得装系统的时候对 Hibernate 等是否有什么配置，所以现在就直接放着关显示器了（现在改为降低显示器亮度）来达到不影响工作进度和省电的目的。</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/arch/d9e40f83e3bb3b921551a57ad9570232.png" alt=""></p><p>直接尝试运行 kde powerdevil 得到 <code>DBus session bus not found</code>，但是在 systemctl 里检查会看到是正常的 active 状态，运行它提供的指令也没有效果</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/arch/d7c1597cf6747553193b3423b1b4d469.png" alt=""></p><p>在 arch 手册里能检索到关于 <code>dbus-launch</code> 的文档</p><div class="note info">            <p>NAME</p><ul><li>dbus-launch - Utility to start a message bus from a shell script</li></ul><p>DESCRIPTION</p><ul><li>The dbus-launch command is used to start a session bus instance of dbus-daemon from a shell script. It would normally be called from a user’s login scripts. Unlike the daemon itself, dbus-launch exits, so backticks or the $() construct can be used to read information from dbus-launch.</li><li>With no arguments, dbus-launch will launch a session bus instance and print the address and PID of that instance to standard output.</li></ul>          </div><p>那么 D-Bus 是什么呢？</p><div class="note info">            <p>D-Bus is a message bus system, a simple way for applications to talk to one another. In addition to interprocess communication, D-Bus helps coordinate process lifecycle; it makes it simple and reliable to code a “single instance” application or daemon, and to launch applications and daemons on demand when their services are needed.</p>          </div><p>回到正题，可以搜到类似的情况普遍在 11-06（更早） 的系统更新后出现。对比 log 文件发现有一些也不完全相同。比较多的解决方案是通过版本降级</p><blockquote><p>ddcutil-1.4.1-1 (downgraded from ddcutil-2.0.0-1)<br>powerdevil-5.27.9-1 (downgraded from powerdevil-5.27.9-2)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -U https://archive.archlinux.org/packages/d/ddcutil/ddcutil-1.4.1-1-x86_64.pkg.tar.zst https://archive.archlinux.org/packages/p/powerdevil/powerdevil-5.27.9-1-x86_64.pkg.tar.zst</span><br></pre></td></tr></table></figure><p>梳理时间线大概是，<code>ddcutil</code> 释出了全新的 2.0 版本，全面采用了新版本的 API，对应 <code>powerdevil</code> 也升级来兼容新版本，但是在 KDE 上使用外接显示器对两者的兼容性仍然没有调好（似乎在 Gnome 上没有问题）。</p><p>同样，你可以用一些方法来临时 <code>kill</code> 掉它和重启（我记得是收到了报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">killall org_kde_powerdevil</span><br><span class="line">kstart5 /usr/lib/org_kde_powerdevil</span><br></pre></td></tr></table></figure><p>issue 提出者发了一个视频来解释他目前找到的最合适的方法</p><p><a href="https://www.youtube.com/watch?v=bFSd6QYerRM"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/arch/820ec0cf185e56e5d83ad3c5d92137d2.png" alt=""></a></p><p>简单来说就是修改 <code>/etc/xdg/autostart/powerdevil.desktop</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X-systemd-skip=<span class="literal">false</span></span><br><span class="line">X-KDE-autostart-phase=1</span><br></pre></td></tr></table></figure><p>而在 Arch 的 bbs 里，有人提到了一个似乎更专业的解决方案</p><div class="note info">            <p>change the line ‘TimeoutSec=5s’ to higher value</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">╰─&gt;$ bat /usr/lib/systemd/user/plasma-powerdevil.service</span><br><span class="line">─────┬──────────────────────────────────────────────</span><br><span class="line">   1 │ [Unit]</span><br><span class="line">   2 │ Description=Powerdevil</span><br><span class="line">   3 │ PartOf=graphical-session.target</span><br><span class="line">   4 │ After=plasma-core.target</span><br><span class="line">   5 │</span><br><span class="line">   6 │ [Service]</span><br><span class="line">   7 │ ExecStart=/usr/lib/org_kde_powerdevil</span><br><span class="line">   8 │ Type=dbus</span><br><span class="line">   9 │ BusName=org.kde.Solid.PowerManagement</span><br><span class="line">  10 │ TimeoutSec=9sec</span><br><span class="line">  11 │ Slice=background.slice</span><br><span class="line">  12 │ Restart=on-failure</span><br></pre></td></tr></table></figure>          </div><div class="note danger">            <h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://man.archlinux.org/man/dbus-launch.1.en">https://man.archlinux.org/man/dbus-launch.1.en</a></li><li><a href="https://www.freedesktop.org/wiki/Software/dbus/">https://www.freedesktop.org/wiki/Software/dbus/</a></li><li><a href="https://forum.manjaro.org/t/powerdevil-fails-energy-settings-unavailable/151081">https://forum.manjaro.org/t/powerdevil-fails-energy-settings-unavailable/151081</a></li><li><a href="https://forum.manjaro.org/t/frame-drops-below-vsync-every-coupel-of-secound-but-killall-org-kde-powerdevil-fixes-it/151260">https://forum.manjaro.org/t/frame-drops-below-vsync-every-coupel-of-secound-but-killall-org-kde-powerdevil-fixes-it/151260</a></li><li><a href="https://forum.endeavouros.com/t/power-devil-restart-loop-bug-after-updating-today/47271/21">https://forum.endeavouros.com/t/power-devil-restart-loop-bug-after-updating-today/47271/21</a></li><li><a href="https://bugs.kde.org/show_bug.cgi?id=476375">https://bugs.kde.org/show_bug.cgi?id=476375</a></li><li><a href="https://bbs.archlinux.org/viewtopic.php?id=289979">https://bbs.archlinux.org/viewtopic.php?id=289979</a></li></ul>          </div>          </div>]]></content>
    
    <summary type="html">
    
      KDE crashed again so I have to check KSystemlog&lt;br&gt;where I found a process Powerdevil restart about every five seconds
    
    </summary>
    
    
    
      <category term="ERROR" scheme="https://augists.top/tags/ERROR/"/>
    
      <category term="LINUX" scheme="https://augists.top/tags/LINUX/"/>
    
  </entry>
  
  <entry>
    <title>VeriFlow: Verifying Network-Wide Invariants in Real Time</title>
    <link href="https://augists.top/NOTES/PAPER/VeriFlow-Verifying-Network-Wide-Invariants-in-Real-Time/"/>
    <id>https://augists.top/NOTES/PAPER/VeriFlow-Verifying-Network-Wide-Invariants-in-Real-Time/</id>
    <published>2023-11-08T02:59:39.000Z</published>
    <updated>2025-05-22T08:50:20.308Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <div class="note info">            <ul><li><p>check network-wide invariants in real time, as the network state evolves</p></li><li><p>a layer between a software-defined networking controller and network devices that checks for network-wide invariant violations dynamically</p></li><li><p>incremental algorithms</p><ol><li>slice the network into a set of equivalence classes (ECs) of packets based on the new rule and the existing rules that overlap with the new rule</li><li>build individual forwarding graphs for each of these ECs using the current network state</li><li>traverse these graphs to query the status of one or more invariants</li></ol></li><li><p>reachability checks</p><ul><li>NP-Complete<ul><li>packet filters</li><li>arbitrary programs allowed</li><li>real-time checks</li></ul></li><li>solution<ol><li>monitor all the network update events in a live network</li><li>confine our verification activities to only those parts of the network whose actions may be influenced by a new update</li><li>a custom algorithm</li></ol></li></ul></li><li><p>jobs</p><ol><li>track every forwarding-state change event -&gt; intercept all these rules and verify them before they reach the network<ul><li>a shim layer between the controller and the network and monitors all communication in either direction</li></ul></li><li>verify the effect of the rule on the entire network at very high speeds<ol><li>slice the network into a set of equivalence classes of packets <ul><li>based on the new rule and the existing rules that overlap with the new rule</li><li>Packets belonging to an equivalence class experience the same forwarding actions throughout the network</li><li>data structure to quickly store new network rules and find overlapping rules &lt;- <em>prefix tree</em> or <em>trie</em> (an ordered tree data structure that is used to store an associative array)</li></ul></li><li>build individual forwarding graphs for every equivalence class using the current network state<ul><li>a node represents an equivalence class at a particular device</li><li>a directed edge from node A to node B if according to the forwarding table at node A, the next hop for the equivalence class is node B</li><li>For each equivalence class, we traverse the trie structure to find the devices and rules that match packets from that equivalence class, and build the graph using this information.</li></ul></li><li>run queries<ul><li>an algorithm, which takes as input an invariant to be checked, traverses the forwarding graphs of the affected equivalence classes, and outputs information about whether the invariant holds.</li><li>traverse every forwarding graph using depth-first search</li><li>encounter a node</li><li>twice -&gt; routing loop</li><li>not have any outgoing edge -&gt; black hole</li><li>if violated -&gt; execute an associated action that is pre-configured for each invariant by the network operator</li><li>drop the rule</li><li>install the rule but generating an alarm for the operator</li></ul></li></ol></li></ol></li><li><p>implementation</p><ul><li>intercept all network events in an OpenFlow network in a transparent manner<ul><li>as a proxy application</li><li>determine message boundaries within this stream of bytes and filter out rule insertion/deletion messages<ul><li>buffer and check whether a complete OpenFlow message or not</li><li>Flow Modification message -&gt; invokes rule verification module</li></ul></li></ul></li><li>use of trie structure<ul><li>consider each rule as a binary string and use individual bits to prepare the trie</li><li>each node has three branches<ol><li>if the corresponding rule bit is 0 -&gt; 0 and the don’t care branch</li><li>the bit is 1 -&gt; 1 and the don’t care branch</li><li>the bit is don’t care -&gt; explore all the branches of the current node</li></ol></li><li>the leaves store the actual rules that are represented by the path that leads to a particular leaf starting from the root of the trie.</li></ul></li><li>graph-cache based strategy to speed up<ul><li>maintain a cache of forwarding graphs indexed by their equivalence classes<ul><li>some equivalent classes will remain common across multiple rule insertions and their forwarding graphs can be reused by updating the graphs with the new rules.</li></ul></li></ul></li></ul></li></ul>          </div>          </div>]]></content>
    
    <summary type="html">
    
      paper note
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="NETWORK" scheme="https://augists.top/tags/NETWORK/"/>
    
      <category term="PAPER" scheme="https://augists.top/tags/PAPER/"/>
    
  </entry>
  
  <entry>
    <title>Header Space Analysis: Static Checking for Networks</title>
    <link href="https://augists.top/NOTES/PAPER/Header-Space-Analysis-Static-Checking-For-Networks/"/>
    <id>https://augists.top/NOTES/PAPER/Header-Space-Analysis-Static-Checking-For-Networks/</id>
    <published>2023-10-26T05:50:29.000Z</published>
    <updated>2025-05-22T08:50:20.308Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <div class="note danger">            <p><strong>Word &amp; Explanation</strong></p><ul><li>slicing: partition networks</li><li>secure slice: no packet from one slice can be controlled by or read by the other slice</li><li>take the notion of isolation further, and enable the static analysis of networks sliced in more general ways -&gt; each slice has own control plane</li><li>Ψ: network transfer functions<br><img src="https://i.imgur.com/MYuEuho.png" alt=""></li><li>Γ: topology transfer function<br><img src="https://i.imgur.com/R7XwhiP.png" alt=""></li><li>H: Header space</li><li>N: Network space</li><li>header: both packet headers (points in H) and wildcard expressions (hyper-cubes in H)</li></ul>          </div><div class="note info">            <p>Even when individual protocols function correctly, failures can arise from the complex interactions of their aggregate, requiring network administrators to be masters of detail.</p><hr><p>Header Space Analysis (HSA) statically check network specifications and configurations</p><ul><li>entire packet header as a concatenation of bits without any associated meaning -&gt; {0, 1}^L space</li><li>networking boxes transform packets from one point in the space to another point or set of points (multicast)</li></ul><p>Goal:</p><ul><li>help system administrators statically analyze production networks</li><li>make it easier for system administrators to guarantee isolation between sets of hosts, users or traffic</li></ul><p>Key:</p><ul><li>generalization of the geometric approach to packet classification</li></ul><ol><li>jettison the notion of pre-specified fields in favor of a header space of L bits where each packet is represented by a point in {0, 1}^L space, where L is the header length</li><li>model all router and middlebox processing as box transfer functions transforming subspaces of the L-dimensional space to other subspaces</li><li>model a network of boxes using a network transfer function, Ψ and a topology transfer function, Γ</li></ol><p>Model:<br>Φ(.) = Ψ(Γ(.)) -&gt; if a packet with header h enters a network on port p, the header after k hops will be Ψ(Γ(…(Ψ(Γ(h, p)…), or simply Φ^k (h, p)</p><p>Algebra:</p><ul><li>set operations<ul><li>intersection<ul><li>For two headers to have a non-empty intersection, both headers must have the same bit value at every position that is not a wildcard.</li><li>If two headers differ in bit bi, then the two headers will be in different hyper-planes defined by bi = 0 and bi = 1.<br><img src="https://i.imgur.com/Qr9ilqK.png" alt=""><br>z means the bitwise intersection is empty, if any bit returns z, the intersection of all bits is empty</li></ul></li><li>union<ul><li>cannot be simplified</li></ul></li><li>complementation<br><img src="https://i.imgur.com/ojn2Mi1.png" alt=""></li><li>difference(minus)<ul><li>A − B = A ∩ B′</li><li>The difference operation can be used to check if one header is a subset of another: A ⊆ B ⇐⇒ A − B = φ</li></ul></li></ul></li><li>transfer functions<ul><li>Domain<ul><li>the set of all possible (header, port) pairs that the transfer function accepts</li></ul></li><li>Range<ul><li>the set of all possible (header, port) pairs that the transfer function can output after applying all possible inputs on every port</li></ul></li><li>Range Inverse</li></ul></li></ul><p>Reachability Analysis:</p><p><img src="https://i.imgur.com/0yc3QrQ.png" alt=""></p><p><img src="https://i.imgur.com/7MNeWde.png" alt=""></p><ul><li><p>Complexity:</p><ul><li>Linear Fragmentation assumption: each of the input wildcard expressions will match only a few rules in the transfer function and generate at most cR(c &lt;&lt; R)</li><li>running time is O(dR^2) where d is the network diameter and R is the maximum number of forwarding rules in a router</li></ul></li><li><p>Loop Detection (breadth first search)</p><ul><li>generic loop<ul><li>inject an <strong>all-x</strong> test packet header from <strong>each port</strong> in the network and track the packet until:<ul><li>It leaves the network</li><li>It returns to a port already visited (Pret) -&gt; report twice</li><li>It returns to the port it was injected from (Pinj) -&gt; <strong>Loop</strong><br><img src="https://i.imgur.com/KyZyVXM.png" alt=""><br><img src="https://i.imgur.com/B6DFFI7.png" alt=""></li></ul></li><li>Complexity<ul><li>same algorithmic structure as reachability test -&gt; O(dPR^2), P is number of ports that need to inject</li></ul></li></ul></li><li>infinite loop<ul><li>Let hret denote the part of header space that returns to A1, then horig = Φ^−1(Φ^−1(Φ^−1(Φ^−1(hret, A1)))) is the original header space that produces hret</li><li>hret and horig relate in:<ul><li>hret ∩ horig = φ -&gt; finite</li><li>hret ⊆ horig -&gt; infinite</li><li>Neither -&gt; redefine hret := hret ∩ horig and calculate the new horig<blockquote><p>An example of a generic, but finite loop, is an IP packet that loops until the TTL decrements to zero</p></blockquote></li></ul></li></ul></li></ul></li><li><p>Slice Isolation</p><ul><li>create new slices isolated<ul><li>require identification of a region of network space that does not overlap with region belonging to existing slices -&gt; no header space in common on any common port</li></ul></li><li>detect when slices are leaking traffic<ul><li>Leakage occurs when a packet in slice a at any switch-port can be rewritten to fall into the network space of another slice</li><li>apply the network transfer function of slice a to its header space reservation -&gt; generate all possible packet headers (output header set)</li><li>If the output header space of slice a at any switch port, overlaps with any other slice, then there is the potential for leaks<br><img src="https://i.imgur.com/LU658ls.png" alt=""></li></ul></li><li>Complexity<ul><li>O(W^2 N ), where W is the maximum number of wildcard expressions used to describe any slice’s reservation and N is the total number of slices in the network</li></ul></li></ul></li></ul><p><img src="https://i.imgur.com/CE9sbqy.png" alt=""></p>          </div>          </div>]]></content>
    
    <summary type="html">
    
      Paper Note
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="NETWORK" scheme="https://augists.top/tags/NETWORK/"/>
    
      <category term="PAPER" scheme="https://augists.top/tags/PAPER/"/>
    
  </entry>
  
  <entry>
    <title>Full Duplex or Half in 3.5mm</title>
    <link href="https://augists.top/SELF/THINKING/full-duplex-or-half-in-3-5mm/"/>
    <id>https://augists.top/SELF/THINKING/full-duplex-or-half-in-3-5mm/</id>
    <published>2023-10-11T10:15:58.000Z</published>
    <updated>2025-05-22T08:50:20.327Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>这个疑问由来已久，经历了几次装机让我的质疑不减反增</p><blockquote><p>为什么机箱的 3.5mm 耳机接口有的要做成输入输出分开，并作为机箱的卖点之一呢</p></blockquote><p>我可以理解作为专业用户，需要使用单独的麦克风输入甚至接声卡进行更为复杂的音频管理。但是对于普通用户来说，目前市场上更多的是输入输出二合一的耳机。把机箱做成分离接口只会徒增烦恼。为了解决这个问题，我已经先后购买过多个二合一的音频转接线材了</p><p>与此同时的另一个背景是，大部分笔记本都使用的二合一音频口，即便强如 MacBook 被很多音乐人拿来作为主要音频处理设备，也只提供了一个 3.5mm 接口。这也让我对音频输入分离是为了专业的输入设备提出质疑</p><p>我理想的解决方案是，保留机箱上的两个 3.5mm 音频接口，其中一个仍然为输入端，另一个使用全双工的二合一接口，用来满足不同人群的需求。从已有产品上看，这似乎并没有什么难度。我不相信机箱厂商没有过这种解决方案</p><blockquote><p>这个问题在我的 reminder 里呆了一年多了 :(</p></blockquote>          </div>]]></content>
    
    <summary type="html">
    
      3.5mm耳机接口的全双工or半双工
    
    </summary>
    
    
    
      <category term="THINKING" scheme="https://augists.top/tags/THINKING/"/>
    
  </entry>
  
  <entry>
    <title>Blog on Multi-Platform</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/blog-on-multi-platform/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/blog-on-multi-platform/</id>
    <published>2023-09-21T07:54:16.000Z</published>
    <updated>2025-05-22T08:50:20.323Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>刚入学的时候还吐槽，交大的校园网限制只能登录3台设备，而我现在一共有4台电脑（去年年底组的电脑放在宿舍打游戏，工位配的电脑过于离谱，所以又组了一台5600G的基础配置放在工位用，再加上一个笔记本）1台Xbox，1台iPad，两部手机。所幸买了两个小路由器放在宿舍和工位，才躲开登录数量限制。</p><p>前两天有人催我说已经半年没更新博客了，正好今天在配置多平台的博客环境，就把遇到的坑记一下。其实在 reminder 里有好多想写和想做的东西，怪自己摆烂，总是找各种理由不干活。</p><p>多平台同步的博客环境我参考了<a href="https://www.jianshu.com/p/0b1fccce74e0">这篇文章</a>。他在原 <code>github.io</code> 仓库中创建了一个新的分支用来存放环境，并将它设置为默认用于每次同步，同时不修改 <code>master</code> 主分支，其用于hexo部署和 <code>github.io</code> 的静态网页渲染。但是我注意到我的 <code>config</code> 里有一个 <code>token</code> 出现在莫名其妙的位置，时间过于久远我也不记得为什么需要它，好在它可能只是第二层保障，并且只在这里用到了一下，所以就也无所谓了。</p><p>工位电脑装了一套 Arch Linux，这是在我去年的折腾里测试能顺利运行我需要看得项目的发行版，尽管可以说是迷信，但我还是选择了它，并且这次没有过多的在桌面环境上纠结，直接安装的KDE，毕竟工位电脑更多的是需要它流畅稳定的运行。如果这是自己平时玩的电脑，可能会继续尝试sway或者一些好玩的桌面环境。本身项目标明的是使用 Ubuntu，但是我一直不喜欢 gnome 嫌弃它怪以外，Ubuntu 官方一直在尝试从 <code>apt</code> 切换到 <code>snap</code>，让我感觉很陌生。宿舍里的那台游戏电脑之前在放弃双系统后我也被迫使用虚拟机安装了 Ubuntu，但体验一直谈不上好。</p><p>在 Arch 上配置 GitHub 密钥的过程中一直收到 <code>Connection closed by remote host</code> 的错误，我重新去搜索了官方的文档（会在后面列出），一开始以为是 <code>SHA</code> 被弃用的问题，但是在强制了 <code>RSA-SHA2-256</code> 和 <code>ed25519</code> 后仍然没有解决，于是到 NAOSI 里问。有同学提起应该考虑网络代理配置的问题</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/proxy%20bad%20github%20connection.png" alt=""></p><blockquote><p>这个终端大概率没走代理，如果是CFW设置http_proxy<br>from 金一</p></blockquote><p>突然点醒我。前几天在帮博士师兄配环境的时候也一直遇到网络问题，收到的是 <code>bad record MAC</code>，查询后结论为在 TLS 连接中被迫中断，也同样是由于代理。当时的电脑和我现在一样使用了 v2rayA 进行代理，在设置的时候按照官方文档中的配图将设置的代理模式选择为大陆白名单模式，此时猜测是配置了系统全局流量通过 v2rayA 的端口，使得我们在终端中所有的强制 proxy 都没有作用。最后修改为 GFWList 模式后解决。</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/GFW.png" alt=""></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://stackoverflow.com/questions/69394001/how-can-i-fix-kex-exchange-identification-read-connection-reset-by-peer">How can I fix “kex_exchange_identification: read: Connection reset by peer”?</a></li><li><a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account">新增 SSH 密钥到 GitHub 帐户</a></li><li><a href="https://www.freecodecamp.org/chinese/news/how-to-get-and-configure-git-and-github-ssh-keys/">如何获取和配置 Git 和 GitHub SSH 密钥</a></li><li><a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">生成新的 SSH 密钥并将其添加到 ssh-agent</a></li></ul>          </div>]]></content>
    
    <summary type="html">
    
      由于设备越来越丰富，我需要在多个平台上共享同步我的博客环境
    
    </summary>
    
    
    
      <category term="TERMINAL" scheme="https://augists.top/tags/TERMINAL/"/>
    
      <category term="HEXO" scheme="https://augists.top/tags/HEXO/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Lets Imagine a Magical World</title>
    <link href="https://augists.top/SELF/THINKING/lets-imagine-a-magical-world/"/>
    <id>https://augists.top/SELF/THINKING/lets-imagine-a-magical-world/</id>
    <published>2023-05-19T13:06:23.000Z</published>
    <updated>2025-05-22T08:50:20.327Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>首先，本文是作者在思考人生的过程中的一个小插曲，属于是临时走歪了想到的小 idea（可以看出笔者每天都在思考些什么东西</p><blockquote><p>另外，也鼓励大家记录生活中的奇思妙想，即便它可能被别人提出过，或是看起来天马行空不切实际。我现在会把我灵光一现想到的神奇的小玩意都记录下来，希望在以后能用上它吧</p></blockquote><p>明天就是 520 了，但是我也没什么恩爱可以秀，所以邀请各位和我一起畅想一个有点奇怪的世界</p><p>如果，我说如果？假如，我说假如？<br>这个世界上不再是以性别作为对人的区分，不再有性别这个概念，你的性别一栏不再是填写男女，而是写你是 S 还是 M（或者是任何一种可以用来区分人并且区分出来的类别可以在某些方面有契合的关系），在这样的世界会发生什么？</p><p>想到这个的一部分原因或许是网络上的性别对立越来越严重，让我觉得是否不再应该以性别男女作为对人类的一种重要划分了。男性中会有健壮的猛男，也会有可能看起来赢弱的文人；女性有娇小可人的小姑娘，也有能独当一面的女侠客。并且对于越来越多的人来说，男女不再是性取向或者一起生活的必须选择</p><p>那么，就应该找到一个更适合作为区分的标准，并且可以替代男女在人类基本延续上作用的性质。我国社会的基本矛盾已经从人民日益增长的物质文化需要同落后的社会生产之间的矛盾，转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾；同样，可能现代人已经不再满足于简单的人类火种和文明延续，开始追求更多个性化的需求了。所以，我非常不合适的想到了 SM，这是一种区分人在交友关系中主动与被动的区别的一种方式，它同样可以将人划分为两类，同样在人类“延续”上属于相互契合的关系。试想一下，你以后填写的信息表不再让你写男/女，而是S/M。你是M，看到别人的信息是S，你就恍然大悟：啊原来它就是我要找的那个真命天子！</p><p>同时，相比男女，SM更能体现出在友人关系上的双方地位、行为的区别和各自的优势，这当然也是随着时代发展和进步在不停变换的，曾经是男女，现在可能是SM，在未来或许会是人机，这必然都有可能。它是一个时代在交友上的需要的最直接反映，再也不会有人想要挑起性别对立，更不会有人出来说你们S就应该让着M，M人群需要 M help M了，因为大家都知道，xp是自由的。即便你是S，喜欢二次元纸片的M，也应当是合理的。</p><p>我把这个问题也同样抛给了 chatgpt（based GPT4 with web browsing），虽然我不知道我给人工智能教这种奇怪的东西是不是合理的，或许它违反 OpenAI CEO 的安全性要求，无所谓了。让我们来看看它是怎么说的：</p><div class="note danger">            <p>这是一个非常有趣的想象。在这个世界中，人们不再按照传统的男性和女性来区分，而是按照S（攻击性或统治性）和M（顺从性或被统治性）的性格特点来区分。在这种情况下，人们的社会地位、角色和期望可能会有很大的变化。</p><ol><li><p><strong>社会角色和职业分布</strong>：在这样的世界中，职业可能会更多地根据人的S或M特质来分配，而不是他们的生理性别。例如，一些更需要领导力或决断力的角色可能会更多地吸引具有S特质的人，而一些需要团队合作或者更多的耐心和细致的工作可能会吸引更多的M特质的人。</p></li><li><p><strong>社会期望和规范</strong>：社会对个人的期望可能会发生重大变化。在这个世界中，S和M的特质可能会成为评价个人的主要标准，而不再是他们的性别。这可能会改变我们对于个人能力和价值的看法。</p></li><li><p><strong>人际关系</strong>：在这个世界中，人们可能会根据他们的S或M特质来选择朋友和伴侣，而不是根据他们的性别。这可能会影响到人们的交际圈和恋爱关系。</p></li><li><p><strong>法律和权利</strong>：在这个世界中，法律可能会根据人的S或M特质来保护他们的权利，而不是他们的性别。例如，可能会有一些法律来保护M特质的人免受滥用，或者保证S特质的人在适当的环境中发挥他们的能力。</p></li></ol><p>这个世界可能会有很多的挑战和问题。例如，如何公正地评价一个人的S或M特质？如何保证每个人都能根据他们的特质找到满足他们需求的工作和社区？这是一个非常丰富的领域，值得进一步的探索。</p>          </div><div class="note info">            <p>甲评论：鉴于性癖的流动性比性向的流动性更大，我认为离异率会增加，但也不是坏事</p><p>笔者评论：忘了一件事情，可能会出现“被s1 s的s2在对s1来说也是m”或“某个m发现自己的s在外面当m而破防”，但这是未来的课题，但是非常感谢甲同学指出这种情况</p>          </div><p>在 520 临近之际，我倒是觉得这个问题非常有意思（但是希望不要被我不想让看到的人看到）</p><p>祝大家 520 快乐，都能找到自己心仪的对象！</p><blockquote><p>最近在写毕设论文，这博客写的像在写论文一样折磨</p></blockquote>          </div>]]></content>
    
    <summary type="html">
    
      如果，我说如果，这个世界上区分人的不是性别，而是S/M，或者是任何一种能用来区分并且有一定的契合关系的性质？
    
    </summary>
    
    
    
      <category term="THINKING" scheme="https://augists.top/tags/THINKING/"/>
    
  </entry>
  
  <entry>
    <title>Small Talk - 看到各路同学朋友收到的Offers</title>
    <link href="https://augists.top/SELF/THINKING/small-talk-in-spring-2023/"/>
    <id>https://augists.top/SELF/THINKING/small-talk-in-spring-2023/</id>
    <published>2023-03-31T14:07:09.000Z</published>
    <updated>2025-05-22T08:50:20.327Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>晚上偶然打开朋友圈看了看，我个人现在已经在尽量减少这种空间朋友圈的关心，只会有照片产出了发一发图</p><div class="note danger">            <p>有关信息摄入和社交形式等的讨论不放在这里，我也一直在尝试和改正自己的一些我觉得不合理的习惯。只能说目前很不满意</p>          </div><p>最近临近毕业季了，各种开花结果的分享也变得多了起来。找工作的朋友有的对秋招确定的offer不满意，又开始寻找待遇更高的去处；已经拿到秋招offer的朋友也收到了入职大礼包；下一届学弟春招的“金三”也到了尾声，手里握着我觉得还不错的实习；考研有人上岸，有人落榜，有人怀着忐忑拿到了最后的入场券，有人一年的努力化为泡影；出国的有人已经在国外，有人放弃了曾经的选择，拿到了更好的项目offer</p><p>选择太多，大家在每一个岔路口分别，又在下一条小路上碰到新的伴行者，没有人知道自己的终点在哪，也没有人知道自己走哪条路、走到哪里就到了终点。对于去年的我自己来说，同样有很多个选项摆在面前，每一个都看起来很诱人，我也不知道我选择哪个会更适合自己，在我有限的人生里，可能每一种都接触了一点点，但都只是冰山一角。我觉得我还没有能力选择，所以我尽量保留了每一个选项的可能性，让我能在以后看懂自己的时候再决定。但是对于有些人甚至是大部分人来说，没有那条能在下个路口仍然保留着几个方向的选择，就必须在这个路口选择其中一条可能充满迷雾的小路。</p><p>不管大家走在哪条小路上，都请抬头望向前方，这是我们自己选择的路，都值得尊敬。每一条小路都有自己的意义，无关对错，没有好坏。我羡慕每一个走在自己选择的小路上的人，每一条我都希望自己也能走一走看一看。正是因为不知道路的尽头在哪，会有什么美景在等待，每一次赌都值得期待。（有点像现在玩胶卷，每一次按快门都不知道自己拍下的照片洗完会变成什么样子，但是正是这份不确定的期待让每次拍摄都变得很有趣</p><div class="note danger">            <p>出于隐私考虑，不会把别人朋友圈发了什么放在这里，只能靠想象了，也说的比较隐晦</p><p>最近因为一些拍摄的隐私问题有一些争议，我有一些思考，写这篇播客的时候又想到这些争议，不在这里赘述了，以后有心情了再整理</p>          </div>          </div>]]></content>
    
    <summary type="html">
    
      晚上偶然逛了下朋友圈，几家欢喜几家愁。实习、考研、工作、出国的同学朋友也陆陆续续有了去向和offer
    
    </summary>
    
    
    
      <category term="THINKING" scheme="https://augists.top/tags/THINKING/"/>
    
      <category term="SMALL_TALK" scheme="https://augists.top/tags/SMALL-TALK/"/>
    
  </entry>
  
  <entry>
    <title>Benchmark on Different OS</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/benchmark-in-different-os/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/benchmark-in-different-os/</id>
    <published>2023-03-20T04:29:24.000Z</published>
    <updated>2025-05-22T08:50:20.323Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>去年双十一的时候自己选购和组装了一台新电脑，因为目前在用的 macbook 在一些情况下已经无法满足我的需要了<br>基本需求提升是对于 cpu 和内存，在我的使用过程中已经开始有很明显的卡顿和性能不足，经常能看到 swap 区占用超过了 10G<br>目前暂时可以确定的是，由于不需要做深度学习，我对 GPU 没有什么需求，所以就只需要核显能满足简单的游戏和日常的图形化渲染即可</p><p>最终的配置单放在这里，那段时间学习了非常多的硬件和电脑组装的知识，这是我根据自己学习的东西、自己的需求以及对钱包的掌控列出的最终配置单</p><div class="note danger">            <ul><li>CPU: AMD Ryzen 7600X</li><li>Motherboard: MSI B650M with WiFi</li><li>Memory: Kingston Fury 32G DDR5 5200 (16G x 2 with EXPO)</li><li>Radiator: Thermalright Magic EX 240 + TL C12C x 2</li><li>Hard Disk: Kioxia RC20 1T + ZhiTai TiPlus5000 1T</li><li>Battery: Antec NE650</li><li>Case: ASUS AP201</li></ul>          </div><p>组装调试好电脑之后，就想着要不要拿同一套配置在不同的操作系统上跑个 benchmark 看看，虽然并不严谨，甚至两个系统放在不同的 SSD 上，但是可以作为参考</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/1B2F0D1B18CC9501774C2A38DCA423D3.png" alt="arch"></p><p>这是在 Arch KDE 上用 Kitty 跑的</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/3A27AAAFD92CBCCECAA93316EBA5DE8F.png" alt="windows powershell"></p><p>在 Windows 上用 PowerShell</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/FCF5DE2C3156432019587C8BCFE8CB4D.png" alt="windows bash"></p><p>为了防止不同终端差异很大，又在 Windows 上的 Git Bash 跑了一下</p><p>从右下角的系统时间可以看到，这三张截图躺在我的硬盘里好几个月了</p><hr><p>可以看到在 Linux 上的共耗时约 35s，而在 Windows 上的两个都在大概 43s</p><p>当然，这是一个非常不严谨的测试，如果我没有记错的话，当时的 Windows 装在致钛盘，Linux 装在铠侠，并且由于系统不同，也没有条件使用相同的终端模拟器，Kitty 可能还会调用核显进行加速等等<br>跑这个 benchmark 也仅仅是为了娱乐，并不意味着相同的工作在 Windows 上的处理效率就一定比在 Linux 上要低</p><hr><p>测试的灵感和 benchmark 程序均来自于 <a href="https://www.youtube.com/watch?v=i_O8r1YQJVo&t=10s">youtube</a>，原作者对 m1 系列芯片和 intel i9 进行了对比，挺有意思的<br><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/mandelbrot-python3-7.html">benchmark</a></p><p>这里留一个 python 代码的备份好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The Computer Language Benchmarks Game</span></span><br><span class="line"><span class="comment"># https://salsa.debian.org/benchmarksgame-team/benchmarksgame/</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># contributed by Joerg Baumann</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> closing</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> cpu_count</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv, stdout</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pixels</span>(<span class="params">y, n, abs</span>):</span></span><br><span class="line">    range7 = bytearray(range(<span class="number">7</span>))</span><br><span class="line">    pixel_bits = bytearray(<span class="number">128</span> &gt;&gt; pos <span class="keyword">for</span> pos <span class="keyword">in</span> range(<span class="number">8</span>))</span><br><span class="line">    c1 = <span class="number">2.</span> / float(n)</span><br><span class="line">    c0 = <span class="number">-1.5</span> + <span class="number">1j</span> * y * c1 - <span class="number">1j</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        pixel = <span class="number">0</span></span><br><span class="line">        c = x * c1 + c0</span><br><span class="line">        <span class="keyword">for</span> pixel_bit <span class="keyword">in</span> pixel_bits:</span><br><span class="line">            z = c</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range7:</span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> range7:</span><br><span class="line">                    z = z * z + c</span><br><span class="line">                <span class="keyword">if</span> abs(z) &gt;= <span class="number">2.</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pixel += pixel_bit</span><br><span class="line">            c += c1</span><br><span class="line">        <span class="keyword">yield</span> pixel</span><br><span class="line">        x += <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_row</span>(<span class="params">p</span>):</span></span><br><span class="line">    y, n = p</span><br><span class="line"></span><br><span class="line">    result = bytearray(islice(pixels(y, n, abs), (n + <span class="number">7</span>) // <span class="number">8</span>))</span><br><span class="line">    result[<span class="number">-1</span>] &amp;= <span class="number">0xff</span> &lt;&lt; (<span class="number">8</span> - n % <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> y, result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ordered_rows</span>(<span class="params">rows, n</span>):</span></span><br><span class="line">    order = [<span class="literal">None</span>] * n</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = n</span><br><span class="line">    <span class="keyword">while</span> i &lt; len(order):</span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            row = next(rows)</span><br><span class="line">            order[row[<span class="number">0</span>]] = row</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> order[i]:</span><br><span class="line">            <span class="keyword">yield</span> order[i]</span><br><span class="line">            order[i] = <span class="literal">None</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_rows</span>(<span class="params">n, f</span>):</span></span><br><span class="line">    row_jobs = ((y, n) <span class="keyword">for</span> y <span class="keyword">in</span> range(n))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cpu_count() &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> map(f, row_jobs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line">        <span class="keyword">with</span> Pool() <span class="keyword">as</span> pool:</span><br><span class="line">            unordered_rows = pool.imap_unordered(f, row_jobs)</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> ordered_rows(unordered_rows, n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mandelbrot</span>(<span class="params">n</span>):</span></span><br><span class="line">    write = stdout.buffer.write</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> closing(compute_rows(n, compute_row)) <span class="keyword">as</span> rows:</span><br><span class="line">        write(<span class="string">&quot;P4\n&#123;0&#125; &#123;0&#125;\n&quot;</span>.format(n).encode())</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">            write(row[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mandelbrot(int(argv[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>          </div>]]></content>
    
    <summary type="html">
    
      run an open source benchmark program on Arch Linux and Windows&lt;br&gt;with the same hardware device&lt;br&gt;just an uncritical comparison
    
    </summary>
    
    
    
      <category term="DEVICE" scheme="https://augists.top/tags/DEVICE/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>UTF8MB X Emoji Encoding Error in MySQL</title>
    <link href="https://augists.top/SELF/ERROR/UTF8MB-x-Emoji-Encoding-Error-in-MySQL/"/>
    <id>https://augists.top/SELF/ERROR/UTF8MB-x-Emoji-Encoding-Error-in-MySQL/</id>
    <published>2023-02-09T03:32:40.000Z</published>
    <updated>2025-05-22T08:50:20.314Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <div class="note info">            <p>这是一篇基于编码踩坑博客引发的关于字符编码的讨论整理，你可以先行阅读初始博客</p><p><a href="http://forimoc.me/blog/36">utf8mb4之鏖战逆天emoji编码 —— 一文通透后端和数据库的编码</a> from 🐟神</p>          </div><h2 id="emoji编码"><a href="#emoji编码" class="headerlink" title="emoji编码"></a>emoji编码</h2><ul><li>emoji表情符号，是20世纪90年代由NTT Docomo栗田穣崇(Shigetaka Kurit)创建的，词义来自日语（えもじ，e-moji，moji在日语中的含义是字符）。emoji可以使数字通信做到让人如同面对面交流，避免错误传达信息。</li><li>在NTT DoCoMo的i-mode系统电话系统中，绘文字的尺寸是12x12 像素，在传送时，一个图形有2个字节。</li><li>自苹果公司发布的iOS 5输入法中加入了emoji后，这种表情符号开始席卷全球，目前emoji已被大多数现代计算机系统所兼容的Unicode编码采纳，普遍应用于各种手机短信和社交网络中。</li><li>所谓Emoji就是一种在Unicode位于\u1F601-\u1F64F区段的字符。这个显然超过了目前常用的UTF-8字符集的编码范围\u0000-\uFFFF。</li></ul><h2 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h2><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/AEEA064BB83CE89C9775A20C1D6A79CA.png" alt="utf-8 wikipedia"></p><div class="note danger">            <h3 id="UTF编码补充"><a href="#UTF编码补充" class="headerlink" title="UTF编码补充"></a>UTF编码补充</h3><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/1B7F7236282723A1D3505834BC930363.png" alt=""><br><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/9B9CB57BCC5FFF69B47995820EFDE376.png" alt=""></p>          </div><h2 id="UTF8MB4"><a href="#UTF8MB4" class="headerlink" title="UTF8MB4"></a>UTF8MB4</h2><ul><li>utf8mb4是utf8的超集并完全兼容utf8，能够用四个字节存储更多的字符，mb4就是most bytes 4的缩写，即至多四字节的意思</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>为什么emoji的编码范围U+1F601 ~ U+1F64F被覆盖在UTF-8规范限制后的范围U+0000 ~ U+10FFFF，但是UTF-8不兼容emoji，需要使用UTF8MB4</p><p>或者说，为什么我们日常说的（MySQL &lt; 8.0 默认的）UTF-8指的是UTF8MB3（范围U+0000 ~ U+FFFF），但是实际上UTF-8并非仅有这个范围</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>查了一下，utf8mb x这个是mysql特有的一个概念，这个问题也只会出现在旧版本的mysql里</p><p>官方文档reference</p><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/charset-unicode-utf8mb4.html">https://dev.mysql.com/doc/refman/8.0/en/charset-unicode-utf8mb4.html</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/charset-unicode-utf8mb3.html">https://dev.mysql.com/doc/refman/8.0/en/charset-unicode-utf8mb3.html</a></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://zh.wikipedia.org/wiki/UTF-8">UTF-8 wikipedia</a></li><li><a href="https://q.cnblogs.com/q/96864/">10FFFF不是只用3个字节吗？？？？翻遍了资料怎么都说是4个呢？？？</a></li><li><a href="https://stackoverflow.com/questions/30074492/what-is-the-difference-between-utf8mb4-and-utf8-charsets-in-mysql#30074553">What is the difference between utf8mb4 and utf8 charsets in MySQL?</a></li><li><a href="https://segmentfault.com/a/1190000039294107">一次彻底搞清unicode、utf8和utf8mb4</a></li></ul>          </div>]]></content>
    
    <summary type="html">
    
      If you use MySQL &lt; 8.0 to store an emoji, it will be symbolized as &quot;?&quot;&lt;br&gt;This is an archive during discussing utf encoding based on a blog&lt;br&gt;http://forimoc.me/blog/36
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="CODE" scheme="https://augists.top/tags/CODE/"/>
    
      <category term="ERROR" scheme="https://augists.top/tags/ERROR/"/>
    
  </entry>
  
  <entry>
    <title>2022-Review</title>
    <link href="https://augists.top/SELF/REVIEW/2022-Review/"/>
    <id>https://augists.top/SELF/REVIEW/2022-Review/</id>
    <published>2022-12-30T07:04:36.000Z</published>
    <updated>2025-05-22T08:50:20.316Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <blockquote><p>其实最开始不是很想写今年的review了，弹指一挥间，回忆起来没有留下很深印象的</p></blockquote><p>我对自己今年的总结就是，尝试了很多以前没有接触过的事务</p><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><p>从去年从朋友那玩了 PS5 和 Switch，对游戏就开始有点感兴趣了。因为高中就把游戏戒掉了，本身我对游戏（除了LOL）也都不会上瘾。今年寒假就花自己钱买了 Xbox，又被星浩忽悠入股了 Switch，前前后后在游戏上花了不少钱。我在游戏上的投资一直很小，花的最多的是大二玩的最上瘾的时候给原神氪金了800多（这游戏我号平均33发出金，稻妻城放出来肝了三天，幡然醒悟，把号送给朋友了<br>这个寒假在游戏上的开销：Xbox 欧版 2200r + Switch 红蓝续航增强二手 1500r + Switch Pro 手柄🎮 300多r（后来跟人换成了 Xbox One 手柄）+ 西瓜皮会员14个月 150r + Xbox 游戏几百 + 任天堂会员 + 任亏券<br>但是好在我游戏打得菜，一旦上瘾就会自动幡然醒悟（除了LOL），可以说玩游戏一直不会到上瘾的程度。再加上对3a大型的并不感冒，游戏对我来说更像是消遣和社交<br>我得承认我也爱玩，即便以前能断然戒掉所有游戏，当我有机会重新把时间投入进去的时候我也还是乐意的<br>在商业模式上，我很欣赏西瓜皮的订阅制，它让我能在开销很小的情况下上手尝试了很多有意思的游戏，库里一直更新的四百多个也让我很满足，对于我这种接触不多，并且很多游戏都仅限于尝试的程度的人来说非常友好<br>Switch对我来说就性质不大了。我原本把它定义为 party game 主机，但是也只有在工作室的时候大家好多人围在一起开马里奥赛车或是任天堂大乱斗的时候很开心，塞尔达这种需要自己独自探索的反而我打的三个存档都没有玩到最后</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/7985B954-933C-4916-A766-C33FDE80F4A0_1_105_c.jpeg" alt=""></p><h2 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h2><p>今年买了第一台属于自己的相机，在综合考虑了很多因素以及当时自己的钱包之后，决定购买了 Nikon FE2 胶片机。在之前用过从我妈单位里借的 Nikon 数码相机（忘了型号了），工作室里有几台 Canon 曾经的高端型号，再加上从别人那玩到的各种相机，也算是有一些经验了，但是胶片这种过于古老的形式一直没有了解过<br>由于相机和镜头都是四五十年前的东西了，肯定也都转过很多手。从闲鱼上的一个成都高校的学弟那 900r 买的 FE2 + 50 1.4 的头，又自己买了 135 3.5 的长焦。摄影对我来说一直是个爱好，拍的好不好看并没有那么重要，心态有点像摄影人拍的多了之后慢慢开始变得佛系。这个时候胶片摄影就很适合我了<br>胶片的好处在于，每一张都很贵，每按一次快门都要先停下来好好想想（手头宽裕的时候不会），并且拍完看不到自己拍的效果。我目前的口粮卷用的是柯达的几个电影卷，5203、5207、5219，大概每张照片的成本在三块钱（我也在寻找更便宜的购买和冲洗方式，这卷拍完就会购买成体系的有趣儿系列，可能每张照片的成本会降低到两块钱左右）。当然，💰是王八蛋，我每次出门都会带上我的相机拿给朋友教他们拍照试试。电影卷有一种特殊的魔力（还有诺兰buff），让我对它的色彩非常期待。拍完看不到回放也会让我不那么焦虑，之前用数码相机的时候，每拍完可能都会很想点开回放看看拍的怎么样，但是胶卷就拍完就拍完了，直到拿去冲洗之前绝不会直到效果怎么样。当收到商家冲洗扫描后的成片，就会有很大的惊喜<br>之前冲过一次，成片也让我很惊喜。在今年的最后一天把第二波的最后一卷也拍完了，准备把这次的四卷胶卷也寄去冲洗<br>胶卷照片保留在了 QQ 空间里，按照胶卷的型号做了区分，这里就随便找了几张作为样例<br>不止胶片，数码相机和无人机也拍了很多，今年完成了去年做了一半的<a href="https://www.bilibili.com/video/BV18B4y1976t/">《换个视角看软院》</a>个人项目，第一次尝试了达芬奇。在明年剩下的半年 SSDUT 时光里，可能也会尝试开一个新的团队项目或是帮助参与到新《光缘》项目的制作里</p><blockquote><p>今年在 b 站也发了一些不再是搬运或是素材的视频，<a href="https://www.bilibili.com/video/BV1Lg411Q7Xb/">HHKB 键盘音</a>的视频刚才看就有了 2.4w 的播放量，<a href="https://www.bilibili.com/video/BV1XG4y1d7vK/">图吧禁片 CPU</a>这种也有近万的播放，应该说对内容类型不是很满意吧，想要做的一个技术向的<a href="https://www.bilibili.com/video/BV1D14y1E7k9/">性能对比</a>也做了一小半就没有再继续了</p></blockquote><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/324E0BA2-FF45-4898-A05B-FED4F4F2FE46_1_105_c.jpeg" alt=""></p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/6EA42C25-A91D-4C1D-BE2F-EA4292104EF1_1_105_c.jpeg" alt=""><br><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/49C45B87-F5F7-47FC-80E0-EDF9B8967089_1_105_c.jpeg" alt=""><br><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/5021E8B9-4E67-4134-AA03-3561535694D3_1_105_c.jpeg" alt=""><br><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/87CD8C55-77F7-460C-ACCD-A42C3AB3AC3D_1_105_c.jpeg" alt=""></p><h2 id="F1"><a href="#F1" class="headerlink" title="F1"></a>F1</h2><p>今年在开始打游戏之后发现对开车的兴趣很高，地平线5玩了上百小时，也就慢慢接触到了 F1。作为赛车方向的顶级赛事，今年作为萌新入坑，看了大部分比赛的直播和视频，从入门到一定程度的了解就用了很短的时间。也自己上手开始玩 F1 的模拟器，F1 21 玩了很久，直到年底开始在地平线里改手动挡。开车和在 LOL 里打大乱斗一样，有一种很单纯的刺激，并且入门门槛可以很低。当有朋友来我家玩的时候，除了《双人成行》，我也会让他们尝试一下用手柄在地平线里开车遨游<br>短短不到一年的时间里，我被红色跃马所折服，不合时宜的成了一名铁佛寺，看着这一年法拉利高开低走，Lec 从争冠到保年度第二，小周的死里逃生为车队拿到最后一个积分，回顾过去几年的 F1 的经典赛事，跟随 Netflix 的纪录片，我成长为半个合格的车迷。从小到大，我一直没有对某一项运动着迷过，记得高中假期给自己定的计划里面曾经有过看几场 NBA 的比赛，我很难沉浸到足球、篮球甚至羽毛球的比赛里面，跟随镜头去专注的看完体育比赛，但是今年我可以为了能看到 F1 的直播熬夜，也算是一种进步了<br>因为迷上 F1，我也找 meow 老师订制了新的头像，我觉得很好看，把我当前最喜欢的东西都融在了一起，如果你也喜欢，欢迎找我和 meow 老师要原图</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/D5555B64-BF39-4521-821B-1AECC5C8F40B_1_105_c.jpeg" alt=""><br><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/7985B954-933C-4916-A766-C33FDE80F4A0_1_105_c.jpeg" alt=""><br><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/17F29280-C9F2-4126-A9D0-26EAD8413986_1_105_c.jpeg" alt=""></p><h2 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h2><p>在寒假期间，有幸能进入到海信子公司的研发中心实习，接触到了很多生产端的东西，也看到企业里的生产线与研发之间的合作。感觉能摆到台面上说的东西不多，每天早上8点多坐着公交车慢慢晃悠到单位，中午还能蹭到食堂好吃的饭。非常感激在部门里带我的姐姐和张工，还有重邮的以及坐在对面的哥哥每天不嫌弃我带我去食堂一起吃饭，帮我解决问题。前几天收拾房间还从角落里翻出来公司过年发的红包，记得当时还因为不好意思没有拿元宵，拍照的时候还钻进大玩偶里和大家一起拍照</p><h2 id="动漫"><a href="#动漫" class="headerlink" title="动漫"></a>动漫</h2><p>以前从来没想过自己会和二次元沾边。今年5月份一次偶然的点开了动漫，就变得一发不可收拾，短短的三个月看了几十部动漫，也接触到了一群非常有意思的人们。尽管看的方向可能和很多人不一样，以恋爱番为主，但是也让我对这样的一个以前从来没有接触过的群体有了很多了解。这半年左右的时间里，看了很多动漫，看了轻小说，赶上了烂尾的蒜吻之争，追更了两个“助眠”UP主。说实话，霓虹人的很多东西我还是无法理解，但是这也让我对旁边的这个小小岛国产生了浓厚的兴趣。后面可能不再会看动漫了，也不会继续看轻小说，会继续听叶初然讲《天使》《义妹》，听《实教》后续的发展。恰逢《三体》更新，虽然一直被喷，但是我也会继续等国漫的崛起，也许在十年之后下一部罗小黑院线上映的时候，我还是会抱着对动漫的热爱买票去看，但是平常的动漫可能就不会再看那么多了</p><h2 id="挣钱"><a href="#挣钱" class="headerlink" title="挣钱"></a>挣钱</h2><p>挣钱其实并不是今年的事情，但是是今年在回顾的，应该在前面的 review 里也有写过这个。到今年实习工资发放为止，不到一年的时间里，挣了 2w 多。回想起来也挺神奇的，从上一年接触到挖矿，玩了三个月；比赛奖金；奖学金；实习工资等，零零散散的有了一些不稳定的收入，也接机买了很多大件。这两年的模式一直都是，上半年花压岁钱，下半年花自己挣的钱。由于我自己本身开销小，这个模式也在我买了这么多大件的情况下维持正常运转。但是今年上半年实习之后就失去了收入来源了，也没有想着要主动去挣。这就导致到了六七月份，没钱了，只能在时隔一年半多后再次找爹妈要生活费。当时其实有点不是很适应，毕竟距离上一次主动开口要钱已经过去很久了。到了年底，尽管因为一些不愿提及的原因，错失了企业奖学金，但是我还是有了一点自己可以支配的钱，加上做勤工俭学，又有了一点额外的收入<br>本来想10月底去川藏玩，后来又机缘巧合准备一起去上海做一个项目顺便去玩玩，因为疫情和一些原因都没有去成，只希望明年能有机会几个人一起出去逛逛（很想去重庆和成都</p><h2 id="电脑"><a href="#电脑" class="headerlink" title="电脑"></a>电脑</h2><p>今年双十一组了台自己的电脑，我的第一台 PC。入学的时候打定主意要的 mac，虽然我很感激它让我早早就接触到了类 Unix，但是当我需要深入到方向里的时候，比如现在被迫开始使用大型 IDE，或是需要虚拟机、Docker 的时候，笔记本就逐渐显得不够用了。到了今年开的服务越来越重之后，有时候 mac 的 swap 甚至会占用 10G（物理内存 8G），于是就确定了自己的需求，开始着手组装自己的台式机。自己开始看各种的对比、测试视频，研究需求，看红绿蓝的发布会，学装机。最终踩着各种坑完成了第一台 PC 的组装。电脑很好看，我也装了 Win 和 Arch 的双系统。因为太久没有用过 Windows 了，反而刚上手的时候各种找人问问题，即便到现在，我也不能说我会用 Windows（但是我之前敢说自己一定程度上会用 mac 了）。双系统的 Arch 因为有时候会掉 wifi，甚至会导致 Windows 也一起掉，暂时还在 X11 和 Wayland 之间犹豫，Wayfire 没有调好，KDE 倒是确实开箱即用。但是对我来说，还是想要转到 twm</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/96C3CE09-3AEB-4A4D-B54D-A64D2F04D8F9_1_105_c.jpeg" alt=""><br><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/F45F693D-94C7-4033-A808-62986EDA92D2_1_105_c.jpeg" alt=""><br><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/1F003491-A312-4BDC-BD2F-F916182AB456_1_105_c.jpeg" alt=""></p><h2 id="桌搭"><a href="#桌搭" class="headerlink" title="桌搭"></a>桌搭</h2><p>今年的最后几天，把卧室重新做了一下布局，顺便换了新桌搭。买的新东西还没到，需要明年再更新下一次桌搭了。想换个桌子，但是没有被同意，只能用旧桌子慢慢改造了<br>这一 part 主要是秀自己的桌搭进化史<br>先放两张以前宿舍里的桌搭</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/F886EA31-8298-4608-9935-A86D4B0A208F_1_105_c.jpeg" alt=""><br><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/5EDCBA71-AAB6-4B17-8453-6CEDAFBF4A49_1_105_c.jpeg" alt=""></p><p>家里的由于现在的房子卧室都变得很小，倒是我施展的空间也很小，需要一些奇怪的办法来拓展空间，比如从床上挤一挤位置</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/0E27B518-5C06-4659-AEB3-A7DF58B376BA_1_105_c.jpeg" alt=""><br><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/50AE15E1-2CEE-4E3D-A49F-7D20F981EF7A_1_105_c.jpeg" alt=""></p><p>卧室整个布局花了一下午的时间换了一下之后，桌面的空间就可以更大一些了。我的设备也增多变成了：MacBook Pro + Xbox Series S + 台式机 + 键盘鼠标 + 显示器 + 两个手柄 + 耳机 + 台灯，Switch 这个假期借出去了，我也想把 Switch 卖掉，所以就不放在这里考虑了</p><p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/5F8D23F0-152B-4309-B273-E91CB8D8AB60_1_105_c.jpeg" alt=""></p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>大三接手了心协理事部的部长，前前后后也比较曲折。大三上因为疫情有很多活动没有得以办成，一直拖到大三下还是因为疫情办不了。部门策划了很多线下好玩的活动，也提出了新的 idea，但是很可惜，由于学校政策一直没有办法做。最终连关心杯也变成了线上，心动杯直接被迫取消。关心杯也充满了遗憾，甚至连线下验节目也取消，最终决赛改成了大家提交（或我们去拍）视频，我自己一个人用了两三天的时间全部修改合并好放在线上直播的形式，非常可惜最后一个活动也没有办法拉大家一起办。<br>我觉得我本科生活过的还挺丰富的，要说唯一缺的就可能是学校的工作了。于是在临近年底回学校后，我开始在党政办做助理工作。借此也做了很多以前没想过会做的事情，也接触到了校区、学院的老师，给学校布置会议会场，或是管理仓库等等，也是这一年里全新的体验</p><h2 id="社团"><a href="#社团" class="headerlink" title="社团"></a>社团</h2><p>在今年9月份，我接任了 <a href="https://github.com/NAOSI-DLUT">NAOSI</a> 网络与开源软件协会的会长。作为开发区校区唯一一个技术向的社团，我们显得有些格格不入。我们希望能帮助想要学习知识的同学指引方向，也帮助本科生和实验室之间搭建科研的桥梁。校区的氛围并不是很好，很多人对于课外但是必须的知识也没有足够的了解，本科生对于科研的接触非常少，很少有人知道可以加入实验室开始学习。我的愿望是大家能以进入 NAOSI 而自豪，NAOSI 也将成为大家简历上的一种标志<br>我们这一学期做了很多次线上的例会，也办了两次软院wo谈会，wo谈会因为和更多人关系很大，所以每次都有很多学弟学妹来参与，两次都有近 200 名同学参与我们的线上会议，而教学例会就非常不理想了。我们的例会文件和录屏都上传到了 <a href="https://github.com/NAOSI-DLUT/Online-Talk">GitHub 组织仓库</a>和 <a href="https://space.bilibili.com/1058346981">B站</a>，欢迎前去参观<br>至此我的本科阶段可能真的一点遗憾都没有了，不管是什么我都亲自做过、了解过了。很幸运能做到各种方向都亲自去接触一下，班委、级队委、团学、心协、社团、勤工助学等等。如果仅从结果上来看，可能我的本科生活要比所有其他人都要丰富了</p><h2 id="科研"><a href="#科研" class="headerlink" title="科研"></a>科研</h2><p>今年完成了去年就在参与的基于WiFi的人体动作识别模型，也在学姐的带领下投中了C类会议。由于前面大创参与形式不是很好，这是第一次较为深入的去接触到科研的工作。尽管我对工作的实际意义一直有疑问，并且对深度学习实在是提不起兴趣，但是也在工作中尽可能发挥了些自己的作用，和大家一起完成了从数据采集到部署实验，再到最后论文修改的工作<br>在早早确定好保研去向后，在7月份就已经开始了新的任务，到目前为止这一项一直只有我一个人在做，和导师沟通，尽管可能不是很大，但是还是希望自己能在这个全新的方向上好好地完成，学习到东西并得到最后的成果吧，不宜多说，就是这样</p><h2 id="疫情"><a href="#疫情" class="headerlink" title="疫情"></a>疫情</h2><p>从上大学开始，我们就一直被疫情的乌云笼罩着。今年上半年仍然保持着封校，禁止线下举办活动等规定，较为严重的时候学校就会暂停外卖，也经常借天气等为由暂停快递工作。但是，也要承认，学校在疫情的三年里会有进步。恰好我的位置对着三年没开过的生活区西门，我也有机会记录下了<a href="https://www.bilibili.com/video/BV14L4y1i7vG/">快递点等的变化</a><br>大四上我选择了赌，想回学校，但是赌学校能放开，很不幸，赌输了。也算是有机会去体验了一下疫情的隔离环境。回学校的第三天，崂山区变成低风险了，尽管和疫情八杆子打不着，我也被强行拉走住进了隔离酒店。在此期间精神心态一次次受到冲击，几近崩溃，我也把<a href="https://augists.top/SELF/SHARING/LIFE/Quarantine-Diary/">隔离日记</a>整理成了 Blog，点击就可以跳转参观。在年底回家的飞机上，我开始头疼发烧，也趁着年关将至阳过了<br>现在就期待着明年放开后，大家普遍杨康后能让生活回归正常。我目前的态度是，大家要多出门杨过之后，才能让生活回归正常，否则一直惧怕病毒，永远也不可能回到疫情前了</p><blockquote><p>终于赶在 31 号晚上写完了今年的 Review，和以前的形式不一样，可能对我自己以后的回顾会更有好一些<br>最后祝大家新年快乐啊，要相信明年会变好的！</p></blockquote>          </div>]]></content>
    
    <summary type="html">
    
      Written on Fri Dec 30, 2022
    
    </summary>
    
    
    
      <category term="REVIEW" scheme="https://augists.top/tags/REVIEW/"/>
    
  </entry>
  
  <entry>
    <title>Quarantine Diary</title>
    <link href="https://augists.top/SELF/SHARING/LIFE/Quarantine-Diary/"/>
    <id>https://augists.top/SELF/SHARING/LIFE/Quarantine-Diary/</id>
    <published>2022-11-21T14:44:45.000Z</published>
    <updated>2025-05-22T08:50:20.319Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <blockquote><p>这几天状态也不是很好，遇上各种不顺心的事情，又不知道该怎么才能调整过来了<br>很想出去喝酒🍺<br>想了想，那就花点时间把前段时间隔离的日记搬到博客上来吧，正好也可以做归档<br>注意：所有内容均为直接复制归档，言语可能过激，请自行分辨<br>一般来说，表达出来的只会是冰山一角，我当时也有一定程度上控制情绪宣泄，只是希望这一段记忆能一直警醒自己</p></blockquote><h2 id="11-05"><a href="#11-05" class="headerlink" title="11-05"></a>11-05</h2><p>从今天开始更新单独隔离的“日记”<br>已经从下到上挨个打电话骂过一遍了<br>坏运气来了挡都挡不住</p><blockquote><p>转隔离群<br>陋室新铭大陶·壬寅虎年十月初十新冠肆虐，望断天涯。天高路远，家是归途。有家难回，独居陋室。已然数次，波澜不惊。夜伴空调嗡嗡而眠，晨惊敲门阵阵而醒。终日无阳，了无生机。白墙生斑，貌似灰苔欲出。光线昏暗，犹如灯火阑珊。百六大洋，贵而不实，与民逐利；十五足平，方寸难尽，如陷囹圄。四十不惑，常为生计而奔波，天南海北，难得清闲。防不胜防，蒙冤新冠而隔离，修生养性，忆苦思甜。跳丸日月，三日将过，一事无成。飞鸿雪泥，人生苦短，业已躺平。天下大事纷争，与我无关，犹入桃园，不知魏晋。</p></blockquote><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/4A0C8584-7EE4-4EDE-B4F9-99C5E9FFFA19_1_102_o.jpeg"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/B4C0725A-7C2F-428A-AB68-7D7DB34057EA_1_102_o.jpeg"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/045A1D51-0AFF-41F1-9B43-CF54CAA5E4E5_1_102_o.jpeg"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/9DA50DD0-F5B4-4A7E-83F6-BB132A976964_1_102_o.jpeg"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/6C149756-6958-4270-AAAA-08A6ED0F91D6_1_102_o.jpeg"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/D0518E80-2A46-4C2B-946F-5F4BDECEE46F_1_102_o.jpeg"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/0EB0D8B7-4F2B-4D1F-AAF5-F5FA1AA9388B_1_102_o.jpeg"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/0E8D7A0B-E4C8-4BDE-9D49-E7DB278F39FF_1_102_o.jpeg"><h2 id="11-06"><a href="#11-06" class="headerlink" title="11-06"></a>11-06</h2><h3 id="早"><a href="#早" class="headerlink" title="早"></a>早</h3><p>更新今日隔离“日记”-早<br>没人问你要订什么饭，就想借机会直接送完收钱，一天饭钱80r（20-30-30）。酒店只有泡面，5r一桶（比前两天隔离的地方便宜1r），并且不愿意卖。群里说只有刚来的时候能买，后面再买就会说没有了。根据群里的经验，早饭除了粥都是凉的，晚饭有人没有收到。<br>大连要求7天的隔离要做5次核酸。酒店不认我前面已经做了三天三次核酸，要求我跟酒店再做5次，也就是每天都要做。每次核酸16r。从我来的时候跟我说疾控中心会给我打电话说明，到现在也没好收到过疾控中心的电话，只有早上酒店打来电话态度非常差要求我交钱并且在电话里对我大吼以及直接挂死电话<br>隔离所有费用（包括核酸）全部自费</p><p>补更昨天：给社区、金州区、大连市都打了电话，政策不合理没有人承担责任，只有死板落实（上面要求，我们就这么干）。就转运司机啥也不知道对着名单拉人，路上跟着我们一起骂</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/AC9D5D6B-1CF2-441D-885F-6CE88489EC41_1_102_o.jpeg"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/EC43DD51-B24C-42D2-8873-7AE551C0AD9D_1_102_o.jpeg"><h3 id="午"><a href="#午" class="headerlink" title="午"></a>午</h3><p>更新隔离“日记”-午<br>猕猴桃是昨晚晚饭里的，现在还是邦邦硬<br>泡面昨晚买了两桶，现在估计不愿意卖给我了<br>估计还要再负担两次的晚饭60r</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/68D90335-A8C9-443B-BAF4-606332C4AD22_1_105_c.jpeg"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/636E3C28-B4DE-4CF6-AF7D-C56817C4551E_1_105_c.jpeg"><h3 id="晚"><a href="#晚" class="headerlink" title="晚"></a>晚</h3><p>隔离日记-晚<br>酒店的床是不平的，背上会有很明显的凸起物顶着的感觉，而且不止一个地方，这两天睡的确实很差<br>把带来的配件组起来，用螺丝刀短接开机的，幸好这个1280*768的电视有个hdmi接口，接上进BIOS确定了一下没有损坏。没带键鼠，酒店也不给借，所以亮个机就完事了（顺便吐槽海韵居然把cpu供电按照8+4和8+8分了不同型号，就我所知的同瓦数其他商家都是直接给两条4+4的cpu供电，掉坑里了，幸好jd给的退货时间长，等隔离出来我再换一个电源<br>装机是我枯燥的隔离生活里面最快乐的一小段时光了</p><blockquote><p>以及酒店的网明显变差了</p></blockquote><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/3BBF14B8-7888-452B-893A-5B6B10051F42_1_105_c.jpeg"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/B74BE2B2-573F-4937-8259-AB4EBA7017B2_1_105_c.jpeg"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/87FB9062-9C1A-4F76-9E6D-195E36D2DDBF_1_105_c.jpeg"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/1172EDB2-FE64-434B-BC80-17051DCDB754_1_105_c.jpeg"><h2 id="11-07"><a href="#11-07" class="headerlink" title="11-07"></a>11-07</h2><h3 id="早-1"><a href="#早-1" class="headerlink" title="早"></a>早</h3><p>隔离日记-早<br>刚做完核酸，每天是从上往下做，所以比较幸运住在二楼，每次做到我都要7点多了。但是6点半就被群里说做核酸的声音叫起来了<br>昨天本来出去了好多，然后大半夜的又进来好几个，群里又50多个人了<br>按照每人每天200r的基本最低标准来计算，酒店每天的流水就超过1w了。我要是开酒店的我也搞成隔离酒店</p><blockquote><p>补：群里有人说问了很多人隔离的核酸都是免费的，就只有我们这里收钱</p></blockquote><h3 id="午-1"><a href="#午-1" class="headerlink" title="午"></a>午</h3><p>隔离日记-午<br>开窗之后进来只苍蝇🪰，昨天是蚊子[<br>每天睡醒之后就感觉和没睡一样.作为从不午睡的人，现在每天早上早早起来核酸之后继续睡，中午吃完饭再睡。不过睡觉能有效减少枯燥的隔离时间，并且减少体力消耗，让我少花晚饭的冤枉钱<br>昨天让前台再给两桶泡面，对我吼完应该是忘掉了，也不想再和前台有什么交流，就这样吧</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/691C9C90-DAEB-4ACC-AB16-D721F40E78BA_1_105_c.jpeg"><h2 id="11-08"><a href="#11-08" class="headerlink" title="11-08"></a>11-08</h2><h3 id="早-2"><a href="#早-2" class="headerlink" title="早"></a>早</h3><p>隔离日记-早<br>房间到现在进过至少两只蚊子🦟和一只🪰了，🦟打死一两只了，但是被咬了好几口，而且晚上睡前看视频它就会溜达过来，白天基本都在躲着<br>之前群里说只有刚来的时候能买泡面。我昨晚试了一下加订了一个晚饭和两桶泡面，果然要先给点好处，泡面就显得是附赠的了<br>做核酸有个很奇怪的地方，这两天都是这样。别的房间：捶门+“做核酸”，到了我这里就不喊了。别是上了什么刺头名单(^_^)a<br>“改过自新，重新做人，早日出狱”</p><h3 id="午-2"><a href="#午-2" class="headerlink" title="午"></a>午</h3><p>发现越来越多认识的人也在这个酒店隔离/doge还发现好像早饭才是它一天的饭里面最值的，可惜不吃早饭<br>之前群里一直说酒店的热水要放十分钟才能出来，但是我昨晚很快就有热水了（群友也反映昨晚突然热水来的很快），还比较幸运<br>当时抱过来的一大桶冰红茶昨天喝完，开了包带的椰子粉，但是l肚子，不知道是饭还是椰子粉。今天喝酒店之前某顿饭给的美年达, 控制变量看看<br>另外，今天太阳好大，记得晒晒太阳哇</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/98D4622B-EC8A-4C0F-A9C1-B5A8C44EE3EB_1_105_c.jpeg"><h3 id="晚-1"><a href="#晚-1" class="headerlink" title="晚"></a>晚</h3><p>隔离日记-晚<br>越来越习惯隔离生活了 倒计时还有一天半 本来以为我和我的快递们一块到学校，还是失算了<br>晚饭这明显比午饭要好得多，但是我来的第一天给的那个猕猴桃现在还是邦邦硬 看来要变成回学校之后的加餐了<br>每天就只有晚上能精神一会，现在7点多又困起来了<br>P2 朋友那的小学二年级有个孩子是密接，发来张小孩穿防护服排队去隔离的照片</p><blockquote><p>btw 正经人谁写日记啊，习惯之后真的就已经懒得吐槽了。明日一更<br>继续祈祷别出幺蛾子，让我返校吧</p></blockquote><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/50ACA286-AD4A-4283-8CA2-F6F376854ECE_1_105_c.jpeg"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/783BDC49-BAE1-4F9E-A3D7-640717B01198.jpeg"><h2 id="11-09"><a href="#11-09" class="headerlink" title="11-09"></a>11-09</h2><h3 id="早-3"><a href="#早-3" class="headerlink" title="早"></a>早</h3><p>隔离日记-早<br>当时看哥谭的时候觉得butch被精神改造挺不可思议的 昨晚这一觉每过一个小时都会被幻听的核酸捶门声音惊醒，3点多、4点多、5点多，然后就再没睡了。/哈欠就是有那么两个人，你也看不清长相，全身都被包裹起来，每天早上很早就把你叫起来捅你，你不被允许提问，即便问了也只是冷漠的敷衍几句，然后就会催你关门把自己继续关在笼子里面。精神改造的重要一环不就是在他快要睡着的时候强行打断嘛<br>现在很想睡觉，眼睛都睁不开，但是又知道自己睡不着<br>sandman还是🐮的，被叫错了人，法器全被偷走，全裸被囚禁了几十年。换我我也不信那个孩子</p><h3 id="午-3"><a href="#午-3" class="headerlink" title="午"></a>午</h3><p>隔离日记-午<br>只要一躺下就感觉在发抖，一睡觉就冒冷汗。上午睡的一会又惊醒了，脖子 枕头床单被子全是湿的/<br>给晚上准备了两桶泡面，还有这几天攒下来能吃的不能吃的水果。来的时候酒店给放的两排冰露已经快喝完了 大黑山西边比东边还要干，已经好几次鼻腔里面有血<br>某奖学金要求必须大型工业软件特色班才能报，19级也没有这东西，通知的就是都可以 为啥初筛不给直接筛掉呢，来浪费时间</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/CD3923A3-7CF3-4BCE-92E3-DC08F05B5724_1_105_c.jpeg"><h2 id="11-10"><a href="#11-10" class="headerlink" title="11-10"></a>11-10</h2><p>我要回去了哈哈哈哈哈我没疯我要回去了我要回去了我要回去了我要回去了我要回去了我要回去了我要回去了我要回去了我要回去了</p><p>刑满释放 我一定好好做人</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/IMG_7685.jpeg"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/1F42A78F-5F99-4F6D-A7FD-B603DA1C6BD2_1_105_c.jpeg"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/139D6531-7CA6-4257-9631-1D741D17DA98_1_105_c.jpeg">          </div>]]></content>
    
    <summary type="html">
    
      Diary updated during life in quarantine
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Open Case Design</title>
    <link href="https://augists.top/SELF/SHARING/LIFE/open-case-design/"/>
    <id>https://augists.top/SELF/SHARING/LIFE/open-case-design/</id>
    <published>2022-11-01T08:12:28.000Z</published>
    <updated>2025-05-22T08:50:20.320Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h1 id="开放式机箱设计方案"><a href="#开放式机箱设计方案" class="headerlink" title="开放式机箱设计方案"></a>开放式机箱设计方案</h1><div class="note danger">            <p>项目已经放在<a href="https://github.com/Augists/openCase">GitHub 仓库</a></p>          </div><p>由于市面上的机箱设计方案便宜的普遍不好看，好看又优秀的设计又导致机箱特别贵。正好我也在计划着装一台自己的电脑，所以就想能不能自己设计一套符合自己审美，又能拿出来看的机箱</p><p>在最开始我曾非常坚定的想要做壁挂主机，把所有的电脑配件都挂到洞洞板上立起来，也可以钉到墙上。后来在看了很多视频后，决定做成桌面的开放式机箱。壁挂机箱的最大缺点就是，硕大的电源也需要挂上去，成为整个壁挂主机最不和谐的地方</p><p>所以我就想，能不能把这个方块的电源藏起来，甚至让它作为机箱的一部分起到某种作用呢？</p><p><img src="https://github.com/Augists/openCase/raw/main/img/sample.JPG" alt="sample"></p><p>上图是我在浏览购物平台时发现的一套分体水的开放式机箱，店家也是专做水冷的，名字叫 bykski。感兴趣可以去搜索一下这个机箱 B-CE-X 的效果，这也是我这次设计的模仿</p><p>这套机箱为了能实现分体水冷和显卡的支撑，将 atx 主板旋转了 90 度摆放。作为一台开放式主机，风冷散热器可能并不合适直接放置在外面，所以尽管没有能力做分体水，我也选择了一体水作为我的开放式机箱的散热支持</p><img alt="手绘" src="https://github.com/Augists/openCase/raw/main/img/手绘设计图 ver. 2.PNG"><p>在第一次的构想里，我把水冷放在了机箱背板的顶部。整个结构想要通过背板和电源以及支架来倾斜放置，然后将水冷放在较为中心的位置以平衡整个机箱结构的重心。由于我目前手边并没有台式机，只能依靠之前触碰的印象进行猜测。电源应该是在不考虑显卡的情况下电脑配件里最笨重的一个了，将它倾斜作为支点，同时分担平衡主板的重量，感觉还是挺合理的</p><p>另外有一点，我特意将主板正放，不同于 B-CE-X，以便我可以在没有前置 IO 的情况下能方便的使用主板的 IO 接口</p><img alt="ver 1" src="https://github.com/Augists/openCase/raw/main/img/ver. 1/main pad.PNG"><p>于是我就开始用 Sharp3D 着手进行设计，并参考了网上的 m-atx 主板的尺寸以及螺丝孔位，为主板和CPU供电预留了两个应该够大的走线孔。右下角的圆形开孔是我从淘宝找到的主板开机键跳线和按钮，商家提供了 12/16/22mm 等直径的开机按键，我在这里只是以最小的 12mm 直径为例</p><p>通过简单的组合可以预估到装机后的情况，由于第一版设计需要分开部件单独制作并组装，在水冷架上就发现一开始的构想存在问题</p><img alt="com" src="https://github.com/Augists/openCase/raw/main/img/ver. 1/主视图.PNG"><p>m-atx 主板的大小是 244x244mm，这也意味着在不太突出水冷的情况下，不能选择 360 大小的水冷，最大可能就只能通过延长机箱背板让它支持 240 规格的水冷。在询问了利民 240 冰封幻境的规格后我才发现，水冷排的尺寸并非简单的两把 120 风扇拼接，而是 277x120x27，也就意味着我的背板需要至少 280 的长度才可以，并且再加上 25mm 高的风扇，整个水冷的厚度已经到了 52mm，放在机箱里可能没有什么感觉，但是在我的这种结构里，如此厚重的水冷无疑是灾难</p><blockquote><p>这块机箱背板我找了一家铝板定制，报价为 85r，如果加厚到 5mm，预估会在 100r 出头</p></blockquote><p>所以在第二版的设计里，我将水冷转移到了背板的侧面，让它改为立式的放置方式，同时由于 52mm 的厚度，我觉得不应该将整个背板再继续延长来支撑它，而是将散热器架到水冷架的外侧进行固定</p><img src="https://github.com/Augists/openCase/raw/main/img/ver. 2/底部视角.PNG"><p>我也在背板的底部添加了两个小的开孔，想让主板下面的例如开机跳线、sata线等穿过这个孔洞来进行整理。整个机箱的装饰风格也从第一版的模仿 B-CE-X 改为这种房子🏠形状的开孔和凹槽</p><p>不过我在给朋友看这套设计的时候，他提到如果我用的是铝材料做机箱，它在强度和刚性上可能会不足，所以我就在第三版里将水冷架延伸到桌面进行支撑，并且加厚了背部的电源支架和机箱脚</p><img src="https://github.com/Augists/openCase/raw/main/img/ver. 3/前视角.PNG"><img src="https://github.com/Augists/openCase/raw/main/img/ver. 3/斜视角.PNG"><img src="https://github.com/Augists/openCase/raw/main/img/ver. 3/底部视角.PNG"><p>不过很可惜，这个开放式机箱的项目流产了（PS 最近流产的项目有点多，感觉自己很浮躁），因为我找到的商家无法直接 cnc 这么大的三维结构，而改用其他材料又会出现很多限制，而我又急于得到一个可以使用的机箱</p><p>我的模型文件 ver.1 对应 <code>case1.step</code>，ver.3 对应 <code>case2.step</code></p><p>希望能等到一个有缘人，看到我的这个不是很成熟的开放式机箱设计方案，记得和我说一声给我看看装机的图片让我也开心一下</p>          </div>]]></content>
    
    <summary type="html">
    
      A open case structure designed by myself
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
      <category term="DESIGN" scheme="https://augists.top/tags/DESIGN/"/>
    
  </entry>
  
  <entry>
    <title>DLUT-EDA Network List Has Been Rewritten Using Beego</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/DLUT-EDA-Network-List-Has-Been-Rewritten-Using-Beego/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/DLUT-EDA-Network-List-Has-Been-Rewritten-Using-Beego/</id>
    <published>2022-10-09T16:28:56.000Z</published>
    <updated>2025-05-22T08:50:20.322Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>前几天重新拾起来 <a href="https://github.com/beego/beego">Beego</a> （重新学习），把之前的一个想法💡用 beego 的 MVC 重新实现出来了一个 baseline</p><p><a href="https://github.com/Augists/DLUT-EDA-NetworkList">项目地址</a></p><p>我得承认这个项目是我的愿景，有些不够切合实际</p><p>我的想法💡是，大家都有自己的熟人小圈子：</p><ul><li>每个人每个月对校园网的需求都是波动的</li><li>上个月用了 20 G，下个月我可能又会需要用 120 G</li><li>5 个人的小圈子，可能总共只会用 3 个人的量</li></ul><p>所以我就想，通过这种方式，让大家均摊校园网的成本，同时也能让你在超量使用的情况下收到来自小圈子里别人的“援手”</p><p>它可能有点乌托邦了，但是我相信这能帮助一些人在一定程度上解决校园网的窘境</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> 将 shell 脚本转化为 golang，不再依赖 <a href="https://github.com/bboymega/dlut-eda-shell-login">mega 的 DLUT-EDA-Login</a> 项目</li><li><input disabled="" type="checkbox"> 随机选择账户登陆失败后，继续随机下一个</li><li><input disabled="" type="checkbox"> 打包为 Release 发布，多平台</li></ul>          </div>]]></content>
    
    <summary type="html">
    
      This is a simple but interesting idea💡 for campus network&lt;br&gt;And I have accomplished a baseline using beego framework
    
    </summary>
    
    
    
      <category term="GOLANG" scheme="https://augists.top/tags/GOLANG/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
</feed>

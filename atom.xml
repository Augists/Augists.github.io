<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Augists-ZDCZ</title>
  
  <subtitle>LESS is MORE</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://augists.top/"/>
  <updated>2021-11-12T05:15:00.196Z</updated>
  <id>https://augists.top/</id>
  
  <author>
    <name>Augists</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Bit Operation: Average of Two Integer</title>
    <link href="https://augists.top/NOTES/CODE_LANGUAGE/bit-operation-average-of-two-integer/"/>
    <id>https://augists.top/NOTES/CODE_LANGUAGE/bit-operation-average-of-two-integer/</id>
    <published>2021-11-12T04:59:34.000Z</published>
    <updated>2021-11-12T05:15:00.196Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>如何求两个整数的平均值？</p><p>问题看起来简单，如果用代码实现起来却有很多值得研究的地方。</p><p>下面我们使用Java代码来实现。</p><h2 id="普通实现1"><a href="#普通实现1" class="headerlink" title="普通实现1"></a>普通实现1</h2><p>求两个整数的平均值，最简单的实现方法就是两个数相加再除以二。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mean</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x + y) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是, 如果传入的是两个整数都是<code>Integer.MAX_VALUE</code>， 下面的断言就过不了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertEquals(Integer.MAX_VALUE, </span><br><span class="line">    mean(Integer.MAX_VALUE, Integer.MAX_VALUE));</span><br></pre></td></tr></table></figure><p>我们期望的结果是<code>Integer.MAX_VALUE</code>，但是实际上返回的结果却是-1。因为 <code>Integer.MAX_VALUE + Integer.MAX_VALUE = -2</code>， 结果已经溢出了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.AssertionError</span>: </span><br><span class="line"><span class="selector-tag">Expected</span> <span class="selector-pseudo">:2147483647</span></span><br><span class="line"><span class="selector-tag">Actual</span>   <span class="selector-pseudo">:-1</span></span><br></pre></td></tr></table></figure><h2 id="普通实现2"><a href="#普通实现2" class="headerlink" title="普通实现2"></a>普通实现2</h2><p>如果我们使用无符号的右移运算符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mean1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x + y) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样虽然可以得到我们想要的结果<code>Integer.MAX_VALUE</code>, 但是却是不支持负数。</p><p>比如我们求-9和-3的平均值,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertEquals(-<span class="number">6</span>, mean1(-<span class="number">9</span>, -<span class="number">34</span>));</span><br></pre></td></tr></table></figure><p>期望返回的结果是-6,但是实际上却返回了2147483642</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.AssertionError: </span><br><span class="line">Expected :-<span class="number">6</span></span><br><span class="line">Actual   :<span class="number">2147483642</span></span><br></pre></td></tr></table></figure><h2 id="普通实现3"><a href="#普通实现3" class="headerlink" title="普通实现3"></a>普通实现3</h2><p>那么如果我们不把两个整数直接相加, 而是分别除以2再相加, 是不是就不会溢出了呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mean3</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &gt;&gt; <span class="number">1</span>) + (y &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现的话, 确实是不会溢出了，但是精度也丢失了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.AssertionError: </span><br><span class="line">Expected :<span class="number">2147483647</span></span><br><span class="line">Actual   :<span class="number">2147483646</span></span><br></pre></td></tr></table></figure><p>那么有没有一种实现方式, 既不会溢出,又可以同时支持正负整数呢?</p><p>答案是不止一种!</p><h2 id="位运算实现1"><a href="#位运算实现1" class="headerlink" title="位运算实现1"></a>位运算实现1</h2><p>我们来看看Google的guava工具类是怎么实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IntMath#mean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@link</span> https://github.com/google/guava/blob/master/guava/src/com/google/common/math/IntMath.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 小数 向下取整</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">meanRoundDown</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &amp; y) + ((x ^ y) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过集合来理解上面的代码。</p><p>比如我们求整数9和3的平均值。</p><p>9的二进制是1001, 3的二进制是0011,</p><p>那么这两个数的交集就是<code>9&amp;3=0001</code>,</p><p>差集就是1010。<code>0001+(1010&gt;&gt;1)</code>结果就是6。</p><p>我们都知道二进制数字都是一串0和1，那么可以把整数x和y都看作是一个有很多不同的0和1组成的集合。</p><p>那么<code>x &amp; y</code>就表示两个集合的交集, 因为<code>1&amp;1=1</code>；</p><p><code>x ^ y</code>得到的就是两个集合的差集, 因为<code>1^1=0</code>,<code>1^0=1</code>；</p><p>交集加上差集的一半, 就得到了两个数的二进制平均值。</p><h2 id="位运算实现2"><a href="#位运算实现2" class="headerlink" title="位运算实现2"></a>位运算实现2</h2><p>下面我们来看看用位运算的第二种实现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小数 向上取整</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">meanRoundUp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x | y) - ((x ^ y) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码怎么理解呢？</p><p><code>x | y</code> 得到的就是两个集合的去重并集。</p><p>并集减去差集的一半，就得到了两个数的二进制平均值。</p><h2 id="两种方式的区别"><a href="#两种方式的区别" class="headerlink" title="两种方式的区别"></a>两种方式的区别</h2><p>如果两个整数的平均值是小数时，</p><p>第一种方式是向下取整；</p><p>第二种方式是向上取整。</p><p>比如我们求整数9和4的平均值，这两个数的平均值应该是6.5，向上取整就是7，向下取值就是6。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertEquals(<span class="number">6</span>, meanRoundDown(<span class="number">9</span>, <span class="number">4</span>)); <span class="comment">// 6</span></span><br><span class="line">Assert.assertEquals(<span class="number">7</span>, meanRoundUp(<span class="number">9</span>, <span class="number">4</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>上面探讨的只是求两个整数的平均值, 那么求多个整数的平均值又有哪些值得参考的实现方式呢?</p><p>同样我们来看看Google的guava工具类是怎么实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Stats#meanOf</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@link</span> https://github.com/google/guava/blob/master/guava/src/com/google/common/math/Stats.java</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * Returns the &lt;a href=&quot;http://en.wikipedia.org/wiki/Arithmetic_mean&quot;&gt;arithmetic mean&lt;/a&gt; of the</span></span><br><span class="line"><span class="comment">   * values. The count must be non-zero.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;The definition of the mean is the same as &#123;<span class="doctag">@link</span> Stats#mean&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> values a series of values</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalArgumentException if the dataset is empty</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">meanOf</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">  checkArgument(values.length &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">double</span> mean = values[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">1</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    <span class="keyword">double</span> value = values[index];</span><br><span class="line">    <span class="keyword">if</span> (isFinite(value) &amp;&amp; isFinite(mean)) &#123;</span><br><span class="line">      <span class="comment">// Art of Computer Programming vol. 2, Knuth, 4.2.2, (15)</span></span><br><span class="line">      mean += (value - mean) / (index + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mean = calculateNewMeanNonFinite(mean, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意这句注释:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Art of Computer Programming vol. <span class="number">2</span>, Knuth, <span class="number">4.2</span>.<span class="number">2</span>, (<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p>Guava的实现是参考了高德纳老爷子的经典之作《计算机编程的艺术》, 这套书规划有 7 卷, 目前已经出版了 4 卷。</p><p>比尔盖茨给出的评价是：“如果你能读完此书，你绝对得给我发份简历。”</p><blockquote><p>速记卡</p><p>求两个整数的平均值<br><code>(x &amp; y) + ((x ^ y) &gt;&gt; 1)</code>向下取整；<br><code>(x | y) - ((x ^ y) &gt;&gt; 1)</code>向上取整；</p></blockquote>          </div>]]></content>
    
    <summary type="html">
    
      Network Protocol Stack Notes
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="C/C++" scheme="https://augists.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Why Su &amp; Why Sudo</title>
    <link href="https://augists.top/NOTES/TERMINAL/Why-su-Why-sudo/"/>
    <id>https://augists.top/NOTES/TERMINAL/Why-su-Why-sudo/</id>
    <published>2021-11-10T04:13:15.000Z</published>
    <updated>2021-11-10T04:21:09.809Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <div class="note info">            <p>作者 | Jun Tao<br>来源 | <a href="https://tanjuntao.github.io/">https://tanjuntao.github.io/</a><br>转自 | <a href="https://mp.weixin.qq.com/s/iMF-3NXgWk5yEfLlQp1MqQ">https://mp.weixin.qq.com/s/iMF-3NXgWk5yEfLlQp1MqQ</a></p>          </div><p>之前一直对 su 和 sudo 这两个命令犯迷糊，最近专门搜了这方面的资料，总算是把两者的关系以及用法搞清楚了，这篇文章来系统总结一下。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>因为本篇博客中涉及到用户切换，所以我需要提前准备好几个测试用户，方便后续切换。</p><p>Linux 中新建用户的命令是 useradd ，一般系统中这个命令对应的路径都在 PATH 环境变量里，如果直接输入 useradd 不管用的话，就用绝对路径名的方式：/usr/sbin/useradd 。</p><p>useradd 新建用户命令只有 root 用户才能执行，我们先从普通用户 ubuntu 切换到 root 用户（如何切换后文会介绍）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ su -</span><br><span class="line">Password:                                         <span class="comment"># 输入 root 用户登录密码</span></span><br><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># useradd -m test_user       # 带上 -m 参数</span></span><br><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># ls /home</span></span><br><span class="line">test_user  ubuntu                                 <span class="comment"># 可以看到 /home 目录下面有两个用户了</span></span><br></pre></td></tr></table></figure><p>因为还没有给新建的用户 test_user 设置登录密码，这就导致我们无法从普通用户 ubuntu 切换到 test_user，所以接下来，我们需要用 root 来设置 test_user 的登录密码。需要用到 passwd 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># passwd test_user</span></span><br><span class="line">Enter new UNIX password:                          <span class="comment"># 输出 test_user 的密码</span></span><br><span class="line">Retype new UNIX password:       </span><br><span class="line">passwd: password updated successfully</span><br><span class="line">root@VM-0-14-ubuntu:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>接着我们输入 exit 退出 root 用户到 普通用户 ubuntu：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">logout</span></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$</span><br></pre></td></tr></table></figure><p>可以看到，命令提示符前面已经由 root 变成 ubuntu，说明我们现在的身份是 ubuntu 用户。</p><h2 id="su-命令介绍及主要用法"><a href="#su-命令介绍及主要用法" class="headerlink" title="su 命令介绍及主要用法"></a>su 命令介绍及主要用法</h2><p>首先需要解释下 su 代表什么意思。</p><p>之前一直以为 su 是 super user，查阅资料之后才知道原来表示 switch user。</p><p>知道 su 是由什么缩写来的之后，那么它提供的功能就显而易见了，就是切换用户。</p><h3 id="参数"><a href="#参数" class="headerlink" title="- 参数"></a><code>-</code> 参数</h3><p>su 的一般使用方法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su  &lt;user_name&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - &lt;user_name&gt;</span><br></pre></td></tr></table></figure><p>两种方法只差了一个字符 -，会有比较大的差异：</p><p>如果加入了 - 参数，那么是一种 login-shell 的方式，意思是说切换到另一个用户 <user_name> 之后，当前的 shell 会加载 <user_name> 对应的环境变量和各种设置；<br>如果没有加入 - 参数，那么是一种 non-login-shell 的方式，意思是说我现在切换到了 <user_name>，但是当前的 shell 还是加载切换之前的那个用户的环境变量以及各种设置。<br>光解释会比较抽象，我们看一个例子就比较容易理解了。</p><p>我们首先从 ubuntu 用户以 non-login-shell 的方式切换到 root 用户，比较两种用户状态下环境变量中 PWD 的值（su 命令不跟任何 <user_name> ，默认切换到 root 用户）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ env | grep ubuntu</span><br><span class="line">USER=ubuntu</span><br><span class="line">PWD=/home/ubuntu                                         <span class="comment"># 是 /home/ubuntu</span></span><br><span class="line">HOME=/home/ubuntu</span><br><span class="line"><span class="comment"># 省略......</span></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$ su                              <span class="comment"># non-login-shell 方式</span></span><br><span class="line">Password:                                                <span class="comment"># 输入 root 用户登录密码</span></span><br><span class="line">root@VM-0-14-ubuntu:/home/ubuntu<span class="comment"># env | grep ubuntu</span></span><br><span class="line">PWD=/home/ubuntu                                         <span class="comment"># 可以发现还是 /home/ubuntu</span></span><br><span class="line">root@VM-0-14-ubuntu:/home/ubuntu<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>我们的确是切换到 root 用户了，但是 shell 环境中的变量并没有改变，还是用之前 ubuntu 用户的环境变量。</p><p>接着我们从 ubuntu 用户以 login-shell 的方式切换到 root 用户，同样比较两种用户转台下环境变量中 PWD 的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ env | grep ubuntu</span><br><span class="line">USER=ubuntu</span><br><span class="line">PWD=/home/ubuntu                               <span class="comment"># 是 /home/ubuntu</span></span><br><span class="line">HOME=/home/ubuntu</span><br><span class="line"><span class="comment"># 省略.......</span></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$ su -                  <span class="comment"># 是 login-shell 方式</span></span><br><span class="line">Password:</span><br><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># env | grep root</span></span><br><span class="line">USER=root</span><br><span class="line">PWD=/root                                      <span class="comment"># 已经变成 /root 了</span></span><br><span class="line">HOME=/root</span><br><span class="line">MAIL=/var/mail/root</span><br><span class="line">LOGNAME=root</span><br><span class="line">root@VM-0-14-ubuntu:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>可以看到用 login-shell 的方式切换用户的话，shell 中的环境变量也跟着改变了。</p><p>总结：具体使用哪种方式切换用户看个人需求：</p><p>如果不想因为切换到另一个用户导致自己在当前用户下的设置不可用，那么用 non-login-shell 的方式；<br>如果切换用户后，需要用到该用户的各种环境变量（不同用户的环境变量设置一般是不同的），那么使用 login-shell 的方式。</p><h3 id="切换到指定用户"><a href="#切换到指定用户" class="headerlink" title="切换到指定用户"></a>切换到指定用户</h3><p>前面已经介绍了，如果 su 命令后面不跟任何 <user_name>，那么默认是切换到 root 用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ su -</span><br><span class="line">Password:                                       <span class="comment"># root 用户的密码</span></span><br><span class="line">root@VM-0-14-ubuntu:/home/ubuntu<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>因为我们在 1. 准备工作 部分已经新建了一个 test_user 用户，并且我们也知道 test_user 用户的登录密码（root 用户设置的），我们就能从 ubuntu 用户切换到 test_user 用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ su - test_user</span><br><span class="line">Password:                                       <span class="comment"># test_user 用户的密码</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="c-参数"><a href="#c-参数" class="headerlink" title="-c 参数"></a>-c 参数</h3><p>前面的方法中，我们都是先切换到另一个用户（root 或者 test_user），在哪个用户的状态下执行命令，最后输入 exit 返回当前 ubuntu 用户。</p><p>还有一种方式是：不需要先切换用户再执行命令，可以直接在当前用户下，以另一个用户的方式执行命令，执行结束后就返回当前用户。这就得用到 -c 参数。</p><p>具体使用方法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - -c <span class="string">&quot;指令串&quot;</span>                                  <span class="comment"># 以 root 的方式执行 &quot;指令串&quot;</span></span><br></pre></td></tr></table></figure><p>我么看个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ cat /etc/shadow</span><br><span class="line">cat: /etc/shadow: Permission denied                <span class="comment"># ubuntu 用户不能直接查看 /etc/shadow 文件内容</span></span><br><span class="line"></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$ su - -c <span class="string">&quot;tail -n 4 /etc/shadow&quot;</span></span><br><span class="line">Password:                                          <span class="comment"># 输入 root 用户密码</span></span><br><span class="line">ubuntu:<span class="variable">$1</span><span class="variable">$fZKcWEDI</span><span class="variable">$uwZ64uFvVbwpHTbCSgim0</span>/:18352:0:99999:7:::</span><br><span class="line">ntp:*:17752:0:99999:7:::</span><br><span class="line">mysql:!:18376:0:99999:7:::</span><br><span class="line">test_user:<span class="variable">$6</span>$.ZY1lj4m<span class="variable">$ii0x9CG8h</span>.JHlh6zKbfBXRuolJmIDBHAd5eqhvW7lbUQXTRS//89jcuTzRilKqRkP8YbYW4VPxmTVHWRLYNGS/:18406:0:99999:7:::</span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$                            <span class="comment"># 执行完马上返回 ubuntu 用户而不是 root 用户</span></span><br></pre></td></tr></table></figure><p>这种执行方式和后面要介绍的 sudo 很像，都是临时申请一下 root 用户的权限。但还是有差异，我们接着往后看。</p><h2 id="sudo-命令介绍及主要用法"><a href="#sudo-命令介绍及主要用法" class="headerlink" title="sudo 命令介绍及主要用法"></a>sudo 命令介绍及主要用法</h2><p>首先还是解释下 sudo 命令是什么意思。</p><p>sudo 的英文全称是 super user do，即以超级用户（root 用户）的方式执行命令。这里的 sudo 和之前 su 表示的 switch user 是不同的，这点需要注意，很容易搞混。</p><p>我们先介绍 sudo 命令能做什么事情，然后说明为何能做到这些，以及如何做到这些。</p><p>我们开始。</p><h3 id="主要用法"><a href="#主要用法" class="headerlink" title="主要用法"></a>主要用法</h3><p>我们在 Linux 中经常会碰到 Permission denied 这种情况，比如以 ubuntu 用户的身份查看 /etc/shadow 的内容。因为这个文件的内容是只有 root 用户能查看的。</p><p>那如果我们想要查看怎么办呢？这时候就可以使用 sudo :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ tail -n 3 /etc/shadow</span><br><span class="line">tail: cannot open <span class="string">&#x27;/etc/shadow&#x27;</span> <span class="keyword">for</span> reading: Permission denied      <span class="comment"># 没有权限</span></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$ sudo !!                                    <span class="comment"># 跟两个惊叹号</span></span><br><span class="line">sudo tail -n 3 /etc/shadow</span><br><span class="line">ntp:*:17752:0:99999:7:::</span><br><span class="line">mysql:!:18376:0:99999:7:::</span><br><span class="line">test_user:<span class="variable">$6</span>$.ZY1lj4m<span class="variable">$ii0x9CG8h</span>.JHlh6zKbfBXRuolJmIDBHAd5eqhvW7lbUQXTRS//89jcuTzRilKqRkP8YbYW4VPxmTVHWRLYNGS/:18406:0:99999:7:::</span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$</span><br></pre></td></tr></table></figure><p>实例中，我们使用了 sudo !! 这个小技巧，表示重复上面输入的命令，只不过在命令最前面加上 sudo 。</p><p>因为我已经设置了 sudo 命令不需要输入密码，所以这里 sudo !! 就能直接输出内容。如果没有设置的话，需要输入当前这个用户的密码，例如本例中，我就应该输入 ubuntu 用户的登录密码。</p><p>两次相邻的 sudo 操作，如果间隔在 5min 之内，第二次输入 sudo 不需要重新输入密码；如果超过 5min，那么再输入 sudo 时，又需要输入密码。所以一个比较省事的方法是设置 sudo 操作不需要密码。后面介绍如何设置。</p><p>sudo 除了以 root 用户的权限执行命令外，还有其它几个用法，这里做简单介绍。</p><p>切换到 root 用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su -</span><br></pre></td></tr></table></figure><p>这种方式也能以 login-shell 的方式切换到 root 用户，但是它和 su - 方法是由区别的：</p><p>前者输入 sudo su - 后，需要提供当前用户的登录密码，也就是 ubuntu 用户的密码；<br>后者输入 su - 后，需要提供 root 用户的登录密码。<br>还有一个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -i</span><br></pre></td></tr></table></figure><p>这个命令和 sudo su - 效果一致，也是切换到 root 用户，也是需要提供当前用户（ubuntu 用户）的登录密码。</p><p>我们现在切换到 test_user 用户，尝试显示 /etc/shadow 文件的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ su - test_user</span><br><span class="line">Password:                                       <span class="comment"># test_user 的密码</span></span><br><span class="line">$ sudo cat /etc/shadow</span><br><span class="line">[sudo] password <span class="keyword">for</span> test_user:                  <span class="comment"># test_user 的密码</span></span><br><span class="line">test_user is not <span class="keyword">in</span> the sudoers file.  This incident will be reported.</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>我们会看到倒数第二行中的错误提示信息，我们无法查看 /etc/shadow 的内容，这是为什么？为什么 ubuntu 可以使用 sudo 但是 test_user 不行呢？</p><p>这就涉及到 sudo 的工作原理了。</p><h3 id="sudo-工作原理"><a href="#sudo-工作原理" class="headerlink" title="sudo 工作原理"></a>sudo 工作原理</h3><p>一个用户能否使用 sudo 命令，取决于 /etc/sudoers 文件的设置。</p><p>从 3.1 节中我们已经看到，ubuntu 用户可以正常使用 sudo ，但是 test_user 用户却无法使用，这是因为 /etc/sudoers 文件里没有配置 test_user。</p><p>/etc/sudoers 也是一个文本文件，但是因其有特定的语法，我们不要直接用 vim 或者 vi 来编辑它，需要用 visudo 这个命令。输入这个命令之后就能直接编辑 /etc/sudoers 这个文件了。</p><p>需要说明的是，只有 root 用户有权限使用 visudo 命令。</p><p>我们先来看下输入 visudo 命令后显示的内容。</p><p>输入（root 用户）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># visudo</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># User privilege specification</span></span><br><span class="line">root    ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment"># Members of the admin group may gain root privileges</span></span><br><span class="line">%admin ALL=(ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment"># Allow members of group sudo to execute any command</span></span><br><span class="line">%sudo   ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment"># See sudoers(5) for more information on &quot;#include&quot; directives:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#includedir /etc/sudoers.d</span></span><br><span class="line">ubuntu  ALL=(ALL:ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure><p>解释下每一行的格式：</p><p>第一个表示用户名，如 root 、ubuntu 等；<br>接下来等号左边的 ALL 表示允许从任何主机登录当前的用户账户；<br>等号右边的 ALL 表示：这一行行首对一个的用户可以切换到系统中任何一个其它用户；<br>行尾的 ALL 表示：当前行首的用户，能以 root 用户的身份下达什么命令，ALL 表示可以下达任何命令。<br>我们还注意到 ubuntu 对应的那一行有个 NOPASSWD 关键字，这就是表明 ubuntu 这个用户在请求 sudo 时不需要输入密码，到这里就解释了前面的问题。</p><p>同时我们注意到，这个文件里并没有 test_user 对应的行，这也就解释了为什么 test_user 无法使用 sudo 命令。</p><p>接下来，我们尝试将 test_user 添加到 /etc/sudoers 文件中，使 test_user 也能使用 sudo 命令。我们在最后一行添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">test_user  ALL=(ALL:ALL)  ALL       <span class="comment"># test_user 使用 sudo 需要提供 test_user 的密码</span></span><br><span class="line">接下来我们再在 test_user 账户下执行 sudo ：</span><br><span class="line"></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$ su - test_user</span><br><span class="line">Password:</span><br><span class="line">$ tail -n 3 /etc/shadow</span><br><span class="line">tail: cannot open <span class="string">&#x27;/etc/shadow&#x27;</span> <span class="keyword">for</span> reading: Permission denied</span><br><span class="line">$ sudo tail -n 3 /etc/shadow                   <span class="comment"># 加上 sudo</span></span><br><span class="line">ntp:*:17752:0:99999:7:::</span><br><span class="line">mysql:!:18376:0:99999:7:::</span><br><span class="line">test_user:<span class="variable">$6</span>$.ZY1lj4m<span class="variable">$ii0x9CG8h</span>.JHlh6zKbfBXRuolJmIDBHAd5eqhvW7lbUQXTRS//89jcuTzRilKqRkP8YbYW4VPxmTVHWRLYNGS/:18406:0:99999:7:::</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>可以看到，现在已经可以使用 sudo 了。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>我们已经看到了，如果一个用户在 /etc/sudoers 文件中，那么它就具有 sudo 权限，就能通过 sudo su - 或者 sudo -i 等命令切换到 root 用户了，那这时这个用户就变成 root 用户了，那这不对系统造成很大的威胁吗？</p><p>实际上的确是这样的。所以如果在编辑 /etc/sudoers 文件赋予某种用户 sudo 权限时，必须要确定该用户是可信任的，不会对系统造成恶意破坏，否则将所有 root 权限都赋予该用户将会有非常大的危险。</p><p>当然，root 用户也可以编辑 /etc/sudoers 使用户只具备一部分权限，即只能执行一小部分命令。有兴趣的读者可以参考 Reference 部分第二条，这篇文章不再赘述。</p><h2 id="二者的差异对比"><a href="#二者的差异对比" class="headerlink" title="二者的差异对比"></a>二者的差异对比</h2><p>我们已经看到：</p><p>使用 su - ，提供 root 账户的密码，可以切换到 root 用户；<br>使用 sudo su - ，提供当前用户的密码，也可以切换到 root 用户<br>两种方式的差异也显而易见：如果我们的 Linux 系统有很多用户需要使用的话，前者要求所有用户都知道 root 用户的密码，这显然是非常危险的；后者是不需要暴露 root 账户密码的，用户只需要输入自己的账户密码就可以，而且哪些用户可以切换到 root，这完全是受 root 控制的（root 通过设置 /etc/sudoers 实现的），这样系统就安全很多了。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.rootusers.com/the-difference-between-su-and-sudo-commands-in-linux/">https://www.rootusers.com/the-difference-between-su-and-sudo-commands-in-linux/</a></li><li>《鸟哥的 Linux 私房菜》13.4 节：使用者身份切换</li><li><a href="https://github.com/ustclug/Linux101-docs/blob/master/docs/Ch05/index.md">https://github.com/ustclug/Linux101-docs/blob/master/docs/Ch05/index.md</a></li><li><a href="https://www.maketecheasier.com/differences-between-su-sudo-su-sudo-s-sudo-i/">https://www.maketecheasier.com/differences-between-su-sudo-su-sudo-s-sudo-i/</a></li><li><a href="https://stackoverflow.com/questions/35999671/whats-the-difference-between-sudo-i-and-sudo-su?r=SearchResults">https://stackoverflow.com/questions/35999671/whats-the-difference-between-sudo-i-and-sudo-su?r=SearchResults</a></li><li><a href="https://www.zhihu.com/question/51746286">https://www.zhihu.com/question/51746286</a></li><li><a href="https://www.linuxidc.com/Linux/2017-06/144916.htm">https://www.linuxidc.com/Linux/2017-06/144916.htm</a></li></ul>          </div>]]></content>
    
    <summary type="html">
    
      Copyright@Jun Tao&lt;br&gt;From https://tanjuntao.github.io
    
    </summary>
    
    
    
      <category term="TERMINAL" scheme="https://augists.top/tags/TERMINAL/"/>
    
  </entry>
  
  <entry>
    <title>Squid Game</title>
    <link href="https://augists.top/SELF/THINKING/Squid-Game/"/>
    <id>https://augists.top/SELF/THINKING/Squid-Game/</id>
    <published>2021-11-08T15:04:40.000Z</published>
    <updated>2021-11-09T15:34:02.614Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>最近鱿鱼游戏属实是挺火，不管是国内还是国外，到处都在说鱿鱼游戏，这一个 Netflix 原生 ip 直接给东家带来了成吨的新用户，是目前 Netflix 热度最高的 ip</p><p>本身这个电视剧拍的是挺好的，并且韩国在近几年产出的电影质量都在上乘，所以电影能在国外火起来并不让人意外。但是偏偏国内也非常火爆，这就很奇怪了。本身国内能有能力访问外网的就不多，基本上可以排除非计算机行业的人员；有能力访问 Netflix 的就更少了，尤其是在 Netflix 对访问 ip 限制一直在加大的情况下；有买 Netflix 会员的那简直是少之又少。所以，初步又一个小结论是，很多人是通过第三方网站（即盗版网站）观看的，或是很大一部分人仅仅是跟风，并不了解电视剧的内容</p><p>实际上，在我的观看体验中，对为什么 Squid Game 能火起来一直抱有疑惑。本身电视剧所探讨的主题是在极端情况下对人性的探讨，这种题材的电影电视剧其实已经非常多了，比如《蝇王》等，都是在探讨将一群人放入一个无领导空间下，所暴露出来的人性问题，只不过这一次把目标换成了钱，“更俗气了”</p><p>简单介绍一下剧情，可能涉及剧透，谨慎观看</p><div class="note info">            <p>男主是双门洞的成奇勋，生活穷困潦倒，靠年迈的母亲卖菜挣钱养活，自己平日喜欢去赌赛马，手气不佳经常赌输，也在外面欠了高利贷。和妻子已经离婚多年，有一个7岁的小女儿。男主虽然各方面都不太行，但是确实是打心里喜欢自己女儿。但是由于自己太穷，赌赛马赢得钱也被别人偷走，十分对不起女儿。恰好此时，有人找上来，问他想不想玩游戏，赢了就有钱拿。男主最终没有经得住诱惑选择加入，这个组织也就是故事的主线——鱿鱼游戏（Squid Game）</p><p>游戏一共有七关，每一关都是在年幼时会玩的游戏，如：一二三木头人，弹球，以及第七关鱿鱼游戏。在这个密闭的空间内，所有人通过其他竞争对手的死亡累计奖池里的奖金，每个人相当于 1 亿韩元。只有通过最后一关的一个人可以拿到奖池里的奖金。在整个游戏过程中，不限制每位竞争者的获胜手段，即便是直接杀死别的竞争者也是被默许的</p>          </div><p>可以说，“Squid Game” 只是最后一关，但它同时也象征着不择手段、甚至通过暴力的方式来获取胜利。这本身是在现在社会看来非常荒谬的，所以电视剧把游戏的组织方的位置摆的很荒谬，让它处处充满荒谬之处。主办方的动机很荒谬，富人们取乐的方式很荒谬，参加者同意参加的方式很荒谬，工作人员的穿着和行为很荒谬，比赛场地的布置很荒谬等等。</p><p>电视剧中还有一个值得注意的点是，15 年最终的获胜者，也就是警察的哥哥，在多年后成为了主办方的黑衣人。而最后，成奇勋也没有登上去往美国的飞机，转头拿起了新一轮的鱿鱼游戏名片。他是否会成为下一个黑衣人，还是继承警察的遗志继续探查下去。显然老人的死并没有组织 Squid Game 的继续举办，剧中富豪意指是谁，谁又会成为新一轮的观看者</p><p>有一个事情剧里一直没有交代，即工作人员的动机。这里不展开叙述，如果你也看了《Squid Game》，那你可能也会对这个登记森严的群体产生兴趣</p><p>尽管黑衣人一直在阐述 Squid Game 的目的是让他们能有最后一次机会翻盘，在这其中每个人都是平等的，但是这个平等与我们常规理解中的平等并不完全相等。他是抛弃了先天条件下的平等，仅仅是对于肉体上的平等，而不是对每个人综合（大致为我们平时在日常生活中的平等观）情况下的平等。当然，这也是让整部剧显得荒谬的一点</p><p>非常高兴的能看到在最后与老人的实验中，人性与爱战胜了老人的冷漠世界观，但是他可能并没有看到就离开了。最后，成奇勋心中的正义和人性，也让他做出了在我们角度更为合理的选择。</p><p>总结来看，《Squid Game》是一部中上游的电视剧，它以荒诞的形式作为表层，核心一直围绕在人性与金钱的探讨。因为本身在对于这个话题的探讨上有非常多的优秀作品，其中也有很大一部分是出自韩国，所以本身电视剧是有一个非常优秀的基调的。再加上它用荒诞不经、博人眼球的方式呈现出来，也让它成为 2021 年下爆品级的存在。这部电视剧在最早放出预告片的时候我就有在乌鸦上关注到，它一经推出也常常占据 Netflix 的首页推荐位，但是我一直没有打开它看，即便在它热度最高的时候，我也依然不认为它会是一部好作品。直到自己看完，我能理解它为什么能成为这样火爆全球的存在，但是我并不能承认它可以超过前辈们对这个话题的探讨，它的火爆很大程度上归咎于外表更适应这个时代的节奏罢了。如果 Netflix 成功制作出了第二部，我依然不会立刻就看，但不能否认，它是一部优秀的电视剧，它也配得上让 Netflix 这一季度新用户数据达到新高。</p>          </div>]]></content>
    
    <summary type="html">
    
      Squid Game is Hot&lt;br&gt;But why?
    
    </summary>
    
    
    
      <category term="THINKING" scheme="https://augists.top/tags/THINKING/"/>
    
      <category term="NETFLIX" scheme="https://augists.top/tags/NETFLIX/"/>
    
  </entry>
  
  <entry>
    <title>Record an Experience of Computer Fixing</title>
    <link href="https://augists.top/SELF/THINKING/Record-an-experience-of-computer-fixing/"/>
    <id>https://augists.top/SELF/THINKING/Record-an-experience-of-computer-fixing/</id>
    <published>2021-10-25T12:28:05.000Z</published>
    <updated>2021-11-08T15:07:08.286Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>昨天朋友的 windows 在更新系统的时候，突然蓝屏了，叫我过去帮忙。</p><p>蓝屏代码 0xc0000001，网上查询其错误原因特别乱，最终确定可能是因为系统引导故障。</p><p>电脑是 ROG 的笔记本，每次开机时间都超级长。出现蓝屏问题后，无法正常进入系统。F8通过安全模式启动，无论是否带命令行的安全模式（我应该没记错，也可能叫恢复模式）还是是否禁用一些启动设置再启动系统，都无法进入系统。尝试了自带的修复工具、恢复到还原点（3个）、UEFI固件设置等所有可以尝试的操作（除了直接重置系统），都没有任何反应。</p><p>其实修电脑并不是我想说的，最终的修复方法是用其他电脑做了一个windows的启动盘然后将系统装在D盘，并且成功进入了新做好的系统，并将C盘里需要的文件拷贝回来。我是在想。。。</p><p>当你使用一套别人制作好并且闭源的系统，当它出现这种故障时，你只能使用开发者提供的修复工具尝试进行修复，而无法了解为什么出现这个问题，如何复现，怎么才能避免出现这种状况。我一直提倡的理念是，简约、但将其他复杂的功能作为备选项提供给用户，让它的决定权还给用户自己。我可以不用，但你不能没有。以手机系统为例，我可以将屏幕刷新率默认设置到一个用户能接受并且对系统影响不大的数值，比如系统默认设置为60Hz的刷新率，同时提供90Hz、120Hz甚至ProMotion这种可变刷新率的选项。依照它的实用程度、用户的使用频率甚至说计算出的用户使用的可能性，将它放在一定的系统设置的层级深度。比如刚才提到的屏幕刷新率设置放在 设置-显示-屏幕刷新率 层级里，或是 设置-显示-屏幕-刷新率，因为屏幕刷新率是用户有可能与默认设置意见不同而进行修改的选项。如果提供了如ProMotion这种动态可变刷新率的设置，当用户将刷新率修改为ProMotion后，屏幕刷新率的选项设置层级会进行下移，将它放入 设置-其他-屏幕（显示）-屏幕刷新率 这种角落里。本身系统提供了最基础最大众最优化（甚至可以说是让用户感知的结果最好）的方案，将方案的修改细节同样提供给用户可以进行任意的修改。</p><p>说完我自己的想法，那就可以来说说现在市场上的产品了。windows作为一个完全闭源，基本软件也闭源的操作系统，可以说是和我相去甚远的。当我遇到这种情况，仅仅使用它提供的工具和手段无法方便快捷的解决问题时，我会非常无能为力。macOS只能说达标了一部分。本身系统也闭源，但是它很好的提供了对开源的Linux的兼容性，同时开放的去接受了大量开源软件和开源思想。所以当你在macOS上遇到了问题，如果你有能力，是可以一定程度上自己尝试解决的。但是在开放系统本身上，它做的只是提供了一套非常优秀的配置方案，而并没有给用户开放更多的权限了。在Linux的众多发行版里，arch就比较极端，ubuntu系中规中矩。arch（甚至gentoo）将所有都开放给了用户， 甚至可以说连最基本的都完全交给用户自己定义。ubuntu系本身提供了一套还不错的路子，但是似乎在可自定义性上稍微会差一点。介于中间的像Manjaro同时兼具了提供配套服务、提供用户最大化的选择权，同时拥有类arch的自定义性，所以我一直把Manjaro当作我心目中最佳的选择了。</p>          </div>]]></content>
    
    <summary type="html">
    
      Export My Thought
    
    </summary>
    
    
    
      <category term="THINKING" scheme="https://augists.top/tags/THINKING/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu Server on Raspberry Pi</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/Ubuntu-Server-on-Raspberry-Pi/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/Ubuntu-Server-on-Raspberry-Pi/</id>
    <published>2021-10-05T14:51:08.000Z</published>
    <updated>2021-11-08T15:10:24.736Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>又在树莓派上折腾了一顿，简单整理一下一开始遇到的问题</p><hr><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p>现在拿到 ubuntu 每次第一件事就要先去网上找镜像源。比较习惯用清华源和中科大源<br>按照惯例写了几个镜像源，一更新发现坏了，根本不行<br>之前一直是在服务器上做配置，树莓派最大的区别在于改用了 arm 架构<br>镜像源对 arm 架构要使用 ports 源</p><p><img src="https://mirrors.ustc.edu.cn/help/ubuntu-ports.html" alt="UTSC ubuntu ports"><br><img src="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" alt="TUNA ubuntu ports"></p><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>换完源之后更新，还是不行，报错大概是这个</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update failed because certificate verification failed because handshake failed on nodesource</span><br></pre></td></tr></table></figure><p>一开始是用 ca 证书解决的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ca-certificates</span><br></pre></td></tr></table></figure><p>但是想了想，应该不是这个问题。<code>date -R</code> 查看系统时间，时区默认被设置成了格林尼治</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tzselect</span><br></pre></td></tr></table></figure><p>不知道这有啥用，它加在 <code>.profile</code> 文件里 <code>TZ=</code>，不是很优雅</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><p>大概用软链接更合理</p><h2 id="静态ip"><a href="#静态ip" class="headerlink" title="静态ip"></a>静态ip</h2><p>ubuntu server 配置静态 ip 和之前树莓派自己的 raspbianOS 上不太一样，要复杂一些<br>因为本身我们是为了搭建 ss 服务器，并且有一些特殊需求，就没有配好</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/netplan/00-installer-config.yaml</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">network:</span><br><span class="line">  ethernets:</span><br><span class="line">    ens160:     #配置的网卡的名称</span><br><span class="line">      addresses: [192.168.0.105/24]    #配置的静态ip地址和掩码</span><br><span class="line">      dhcp4: no    #关闭DHCP，如果需要打开DHCP则写yes</span><br><span class="line">      optional: true</span><br><span class="line">      gateway4: 192.168.0.1    #网关地址</span><br><span class="line">      nameservers:</span><br><span class="line">         addresses: [114.114.114.114,180.76.76.76]    #DNS服务器地址，多个DNS服务器地址需要用英文逗号分隔开</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: networkd    #指定后端采用systemd-networkd或者Network Manager，可不填写则默认使用systemd-workd</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>          </div>]]></content>
    
    <summary type="html">
    
      There is not much executable and helpful manual page for Ubuntu Server on a Raspberry Pi
    
    </summary>
    
    
    
      <category term="DEVICE" scheme="https://augists.top/tags/DEVICE/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>MAC With External Display</title>
    <link href="https://augists.top/APPLE/MAC-with-external-display/"/>
    <id>https://augists.top/APPLE/MAC-with-external-display/</id>
    <published>2021-09-13T15:12:29.000Z</published>
    <updated>2021-09-13T15:37:44.965Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <p>刚开学的时候买了台显示器，确实是我看到过的最便宜的给 mac 用的显示器了</p>          </div><div class="note warning">            <p>给 mac 配显示器，稍微有点要求的话，大概这些是必须的吧</p><ul><li>3.5k 以上的分辨率</li><li>支持 HiDPI</li><li>反向充电 65W 以上的 C 口</li><li>色域达标为支持 P3 色域</li></ul><p>这只是一个非常笼统的配置要求，例如 P3 色域在实际显示的时候也会有非常多的讲究<br>可以在先看评测的对 4k 以下显示器的横评中看到非常多的评价标准，同时即便是相同的标准也可能有一些消费者无法感知的差异</p><p>我购买的是 WE （小厂）的显示器，据说采用的是京东方的面板<br>最终花费 1.5k 的价格就拿下这款显示器了<br>但是毕竟价钱摆在这里，色域上只能达到 99-100% sRGB<br>但是其实实际观感不会差什么，整体色调相比与 mac build-in 显示器会偏暖的比较多，目前也没有改调色方案</p><hr><p>前面说的感觉真的挺好的，但是有一点是我自己遇到的问题<br>mac 自带的电源线是没有视频传输能力的<br>这一点，不得不承认，有道理，但是用的时候很烦人<br>确实，不是所有人都有把 mac 接到外置显示器的需求<br>但是像我这种一开始不知道的人，买了显示器之后发现原装的线不能用，被迫只能使用 HDMI</p><p>买了根便宜的雷电 3 数据线，便宜的我有点不是很能相信<br>常规的雷电 3 数据线价格一般在 2-3 百上下<br>现在只能等便宜的这根到了试试好不好用了<br>希望到时候能让桌面更清爽一点，只使用一根雷电数据线接出来</p>          </div>]]></content>
    
    <summary type="html">
    
      Here comes an external display I bought&lt;br&gt;An 27 inches 4k display with full functional type c&lt;br&gt;BUT!!! only 1.5k RMB
    
    </summary>
    
    
    
      <category term="APPLE" scheme="https://augists.top/tags/APPLE/"/>
    
      <category term="MAC" scheme="https://augists.top/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>Backspace Does Not Work on VPS?</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/Backspace-does-not-work-on-VPS/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/Backspace-does-not-work-on-VPS/</id>
    <published>2021-08-27T08:36:56.000Z</published>
    <updated>2021-11-08T15:09:39.614Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>在我用我的新终端 kitty 登陆 VPS 的时候发现，很多快捷键都失效了。比如退格键就会变成空格，<code>&lt;C-u&gt;</code> 会没有反应，<code>clear</code> 会提示我的终端模拟器不支持等</p><p><img src="https://i.loli.net/2021/08/27/7DTkwj6LFPIdxRq.png" alt=""></p><p>我们也可以通过 <code>echo $TERM</code> 查看到终端的情况</p><p><img src="https://i.loli.net/2021/08/27/oFkeaPMsTdhQJXy.png" alt=""></p><p>大概就可以看到，应该是当前的 VPS 不支持 xterm-kitty</p><p>可以通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stty -a</span><br></pre></td></tr></table></figure><p>进行查看服务器支持的终端通信参数</p><p>我们尝试使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stty sane</span><br></pre></td></tr></table></figure><p>命令 sane 最常出现在大多数终端的 stty 选项的集合中。它并不改变通信信道的速率，但当终端发生混乱时，通常能够产生有益的效果。</p><p>不过很可惜，没啥效果</p><p>最终经过尝试，使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TERM=linux</span><br></pre></td></tr></table></figure><p>有效</p><div class="note info">            <p>TERM 环境变量用于终端处理。它允许 DB-Access（及其他基于字符的应用程序）识别您正在使用的终端并与其通信。</p>          </div><p>可以推测，我们将终端类型设置成 VPS 自己，从而使对于 VPS 本身是正常的</p><p>后来查到</p><div class="note info">            <ul><li><code>putty</code>，<code>konsole</code>，<code>Eterm</code>，<code>rxvt</code>，<code>gnome</code>等, 如果你正在运行的 XTerm 模拟器和一些功能键，退格键，删除，Home 和 End 不能正常工作</li><li><code>linux</code> 通过 Linux 控制台登录时</li><li><code>dumb</code> 当其他都不能用时</li></ul>          </div><p>可以通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toe /usr/share/terminfo</span><br></pre></td></tr></table></figure><p>查看可选信息</p><p><img src="https://i.loli.net/2021/08/27/QEJsUv8z72SGrbn.png" alt=""></p><p><img src="https://i.loli.net/2021/08/27/zW5tGqPfeVyj3i6.png" alt=""></p>          </div>]]></content>
    
    <summary type="html">
    
      This is the first time that I use my VPS on kitty&lt;br&gt;It goes wrong with my expect&lt;br&gt;Plenty of shortcuts fail such as *Backspace*, *clear*, and so on
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Applications &amp; Command Line Tools</title>
    <link href="https://augists.top/APPLE/Applications-and-Command-Line-Tools/"/>
    <id>https://augists.top/APPLE/Applications-and-Command-Line-Tools/</id>
    <published>2021-08-20T08:27:19.000Z</published>
    <updated>2021-08-20T10:20:07.659Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>There is the overview of my recommends. 不全，但是是我在重装系统之后经过重新考虑之后保留下来的推荐</p><div class="note info">            <center><b>System</b></center><ul><li>Caffeinated: 保持系统常量不休眠的小工具</li><li>AppCleaner: 软件清理</li><li>Hidden Bar: Menu Bar 隐藏</li><li>IINA: 视频播放器</li><li>Karabiner: 修改键盘映射</li><li>OnlyX: 系统垃圾清理</li><li>Paste: 剪贴板历史</li><li>The Unarchiver: 解压</li><li>uPic: 图片上传图床</li><li>Vimari: safari 的 vim-like 快捷键</li><li>V2rayU: VPN</li><li>rectangle: 窗口管理器</li><li>yabai: 窗口管理器</li><li>shkd: 快捷键工具</li><li>spacebar: Menu Bar 定制</li><li>htop: 活动监视器</li></ul><center><b>Code</b></center><ul><li>Dash: 查看文档</li><li>Kitty: 终端模拟器</li><li>Typora: markdown</li><li>Docker: 虚拟容器</li><li>homebrew: 包管理器</li><li>tmux: 终端复用</li><li>neovim: 编辑器</li><li>fzf: fuzzy file finder</li><li>nnn: 文件管理器</li><li>autojump: 快速跳转</li><li>zsh<ul><li>oh-my-zsh: 终端美化</li><li>zsh-autosuggestions: 终端补全</li><li>zsh-syntax-highlighting: 终端高亮</li></ul></li><li>clang-format: c language formatter</li></ul>          </div><p>简单说明是啥之后，就可以挑主要的说了</p><h2 id="Caffeinated"><a href="#Caffeinated" class="headerlink" title="Caffeinated"></a>Caffeinated</h2><p>这是一个比较简单，图标也好看一点的禁止休眠工具，直接显示在 Menu Bar 上<br>比其他同类软件更简单，不提供一些有的没的工具，与终端指令 Caffeinate 相同效果</p><h2 id="AppCleaner-amp-OnlyX-amp-fzf"><a href="#AppCleaner-amp-OnlyX-amp-fzf" class="headerlink" title="AppCleaner &amp; OnlyX &amp; fzf"></a>AppCleaner &amp; OnlyX &amp; fzf</h2><p>卸载软件其实一直都是一件很头疼的事情，即便有了这两个工具<br>首先，一定不推荐任何打着清理名头的软件，如 CleanMyMacX、腾讯柠檬清理等<br>AppCleaner 在卸载软件时查找它在系统中存储的一些配置信息文件，但是并不是所有都能找到<br>它主要检索 <code>$HOME/Library</code> 下的文件，但是即便是这样，也并不是能发现全部可以删除的垃圾文件<br>而 OnlyX 是更为深度的清理系统缓存等垃圾，需要对一些名词有一定了解<br>众所周知，macOS 采用了沙盒机制<br>我第一次对沙盒机制感慨是在看了飞蚊话的<a href="https://www.bilibili.com/video/BV1WA411V7r8">分析视频</a><br>即便有这样优秀的思想，也不能防止软件忽悠你获取权限然后把文件放在不该放的地方<br>所以我一般会在删除完软件或者我想要清理系统垃圾的时候手动去两个 Library 里看看<br>心情好就去根目录用 fzf 开个全盘扫描，经常会发现几个漏网之鱼<br>举个例子，前几天下载了 Parallel Desktop 试用了几下，一看空间，好家伙，占了我 50G 的空间<br>在 AppCleaner 找完一部分，手动去 Library 里删了一些之后，我又去根目录用 fzf 扫了一下，果然发现在 <code>/etc</code> 和 <code>/var</code> 下都还有配置文件</p><h2 id="Karabiner"><a href="#Karabiner" class="headerlink" title="Karabiner"></a>Karabiner</h2><p>这个是在键盘与系统之间虚拟出一层来，对键盘的键位映射进行修改<br>由于我现在开始用 HHKB，一些键位我就需要重新改一下（最主要还是因为 QQ<br>我的 Karabiner 配置文件已经放在 GitHub 上的 dotfiles 里了<br>通过 json 文件简单修改就可以用了</p><h2 id="uPic"><a href="#uPic" class="headerlink" title="uPic"></a>uPic</h2><p>uPic 的作者挺好玩的，之前加了 tg 群，正好碰到他说要上架 app store了<br>app store 里的版本是收费的，同时因为软件开源，免费版可以直接从 GitHub 上下载</p><h2 id="yabai-amp-shkd-amp-spacebar"><a href="#yabai-amp-shkd-amp-spacebar" class="headerlink" title="yabai &amp; shkd &amp; spacebar"></a>yabai &amp; shkd &amp; spacebar</h2><p>最近新换的窗口管理器，配置也比较简单，实现效果就和 Linux 下的如 dwm、i3 等类似<br>经过一番操作，我的 mac 它更像 Linux 了<br>但是 yabai 需要关闭 SIP<br>不推荐了解不够深入的关闭 SIP</p><h2 id="Kitty"><a href="#Kitty" class="headerlink" title="Kitty"></a>Kitty</h2><p>Kitty 是一个更符合 Unix 哲学的终端模拟器，基于 GPU，更快速<br>我用 Kitty 替换了 iTerm2，主要是 iTerm2 太过于庞杂，提供的功能基本都用不上<br>而 Kitty 只需要修改它的配置文件就可以啦 <code>~/.config/kitty/kitty.conf</code><br>在换用 Kitty 之后，我把我的配置文件重新整理了一遍，按照模块进行加载</p><h2 id="nnn"><a href="#nnn" class="headerlink" title="nnn"></a>nnn</h2><p>nnn 我用来替换了 ranger<br>其实论实用，ranger 更好用一点，但是在我电脑上，一旦开启了一些功能就会变卡<br>如果打开了 git，直接就卡到怀疑人生<br>我之前的 ranger 经常在预览上卡住。一开始我以为是预览大文件会卡，后来发现啥都可能卡<br>ranger 的好处是它可以直接调用 iTerm2 在终端显示图片预览<br>而 nnn 虽然也采用 vim-like 快捷键，但是它没有了三栏的设计，操作也都尽可能的用一个键完成<br>总的来说，应该算是 ranger 的下位替代吧<br>另外有一点，如果想让 nnn 显示图标，需要自己手动编译，修改编译参数，这在无形中提高了门槛</p><h2 id="neovim"><a href="#neovim" class="headerlink" title="neovim"></a>neovim</h2><p>vim 作为我一直在使用的编辑器，一直就仅限于想要的那一部分就再没往下探索新的东西了<br>重装系统之前改用 neovim 重新进行了配置，新的 neovim 配置基于 coc，并且终于我开始用提示了<br>LSP 让它的配置变得非常好用<br>最近也在想改用 lua 重写配置，放弃 coc，直接转用新配置<br>目前只是学会了 lua，还没有换新 <em>init.lua</em> 的动力</p><h2 id="autojump"><a href="#autojump" class="headerlink" title="autojump"></a>autojump</h2><p>autojump 算是比较推荐的一个终端工具，它可以记住我的 <code>cd</code> 路径，并在后面直接 <code>j</code> 过去<br>在从 ranger 改用 nnn 之后我把 autojump 卸载了，但是最近又重新安装回来了<br>我一直把它作为文件管理器的辅助，比如要写博客的时候 <code>j augists</code> 就会跳到博客目录</p><hr><div class="note info">            <p>最近的最后一次大改是因为在学习 python<br>在 macOS 里，系统自带了 python2.7<br>如果你使用 <code>xcode-select --install</code> 安装了 Command Line Tools<br>它就会给你安装上 python3（目前是 python3.8)<br>但是因为路径和权限的原因经常会出现一些问题<br>所以我现在电脑上同时存在了 3 个 python</p><ul><li>系统自带的 python2</li><li>Command Line Tools 安装的 python3.8</li><li>homebrew 安装的 python3.9</li></ul><p>2 为系统提供服务<br>3.8 为 neovim 服务，在 <code>$PATH</code> 中存放在后面<br>3.9 是我平常用的，因为 homebrew 很鸡贼的让安装的路径是环境变量的第一个</p>          </div>          </div>]]></content>
    
    <summary type="html">
    
      !!!NOW!!! These applications and command line tools are on my mac&lt;br&gt;which I strongly recommend
    
    </summary>
    
    
    
      <category term="APPLE" scheme="https://augists.top/tags/APPLE/"/>
    
      <category term="MAC" scheme="https://augists.top/tags/MAC/"/>
    
      <category term="TERMINAL" scheme="https://augists.top/tags/TERMINAL/"/>
    
  </entry>
  
  <entry>
    <title>Reinstall macOS</title>
    <link href="https://augists.top/APPLE/Reinstall-macOS/"/>
    <id>https://augists.top/APPLE/Reinstall-macOS/</id>
    <published>2021-08-13T04:25:54.000Z</published>
    <updated>2021-08-14T10:46:09.596Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>花了一天多的时间，把 mac 抹盘重装了，收获了一个全新的 mac</p><p>之前使用的是 macOS 12 public beta 4。本身使用并没有什么问题，问题出在了软件的兼容性上。很多软件如 <em>OnlyX</em> 都无法在新系统里正常打开运行（这里还是再点一下 <em>OnlyX</em>，每个系统版本出一个软件版本，导致兼容性非常差。但是也不是说这样做不好，只是我觉得应该又一个更鲜明的提示，当检测为更新的系统版本时提示一下）</p><p>导致我重装系统的直接原因是下载了 <em>CrossOver</em>，我不记得它有要我的系统权限，但是它直接修改了系统默认显示 <code>.exe</code> 文件的图标，而我比较菜（lan）。权衡了一下啊，干脆直接抹盘重装一次系统</p><hr><p>在这次重装过程中也发现了很多好玩的事情，也对很多东西有了新的理解。比如：</p><ul><li>切换输入法的快捷键应该设置给 <em>select the previous input source*，而不是 *select next input source</em></li><li><em>screen saver</em> 文件一般为 <code>.saver</code> 文件，而 <em>fliqlo</em> 是 <code>dmg</code> 安装器</li><li>由于更换了 <code>neovim</code>，很多东西都和以前不太一样，同时 <code>vim</code> 作为被我抛弃掉的被替代品，没有再使用任何插件，当作一个单纯的编辑器来使用了</li><li>对电脑的容量非常诧异。本来以为会清理出非常多的东西，能让 256G 的容量剩出很多，但是现在看其实和之前差别不大，只是少装了很多软件，大概节省了 20G 的空间，甚至 <em>Chrome</em> 我都还没有安装（也是在尝试一个单 <em>Safari</em> 能否承担重任，尤其是在下个版本中将要加回 <em>Group Tab</em>，这个在测试版中我爱不释手的功能</li><li>在抹盘之后，可以将 Data 和 数据 两个盘直接删掉，只保留 <em>Macintosh HD</em> 就可以，之前被这个奇怪的保护机制烦了很久</li><li>mac 启动器下载完成之后打开就会报错，但是事实上是正常的，这一点在网上查阅的时候都没有指出来。使用官方的制作启动器的指令之后报错了一次，有点莫名其妙，第二次就好了</li><li>mac 在使用制作好的外置磁盘启动器进行安装时，仍然需要关闭一些安全性设置（由于 T2 芯片的缘故）。我目前没有把这些安全性设置修改回来，但是我现在也不是很想折腾 <em>yabai</em></li></ul>          </div>]]></content>
    
    <summary type="html">
    
      Spend A day for reinstalling my macOS&lt;br&gt;Downgrade the system from the beta version to official version Big Sur
    
    </summary>
    
    
    
      <category term="APPLE" scheme="https://augists.top/tags/APPLE/"/>
    
      <category term="MAC" scheme="https://augists.top/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>A Comfortable Way for Coding</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/A-better-way-for-coding/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/A-better-way-for-coding/</id>
    <published>2021-08-08T01:44:25.000Z</published>
    <updated>2021-11-08T15:09:16.093Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>这几天一直在尝试从头重新配置一个更适合我使用的 coding platform，用这篇博客简单记录一下我的配置过程<br>是探索，也是从上一个舒适区里走出来，划定一个更大范围的舒适区</p><div class="note info">            <p>我一直使用终端作为我的 coding platform，所以我也将基本围绕终端展开</p>          </div><hr><h2 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h2><p>既然是要走出舒适区，那肯定就要大胆尝试一下新东西。<a href="https://iterm2.com">iTerm2</a> 一直是我不知道需不需要尝试的一个新玩意。一直以来看所有的 mac 装机推荐文章或视频里很多都会告诉你，当你拿到一个新 mac 的时候，要先下载 iTerm2，然后安装 <code>oh-my-zsh</code>。这就和让装 Alfred 一样，完全不知道它好在哪，但是就是所有人都推荐装</p><p>目前就在使用 iTerm2。尽管在换用 iTerm2 之后我仍然没有很明显的感知它有多少特别的功能并提升了我的终端使用体验，但是通过设置让它变得比原生 Terminal<br>更好看了是真的。我取消了顶部的 title bar，并且添加了彩虹 🌈 色小组件，这就是我现在改用 iTerm2 的主要原因了</p><p><img src="https://i.loli.net/2021/08/08/6ngbcAlLQBmtUrx.png" alt="iTerm2"></p><p>当然，每个东西肯定有好有不好。iTerm2 最让我无法忍受的是每次粘贴都会刷新屏幕，就一个非常明显的闪屏。虽然可以理解，但是对它的好感度大打折扣。除此之外，之前说的打开 vim 再退出时终端会自动变到最后一行的问题在改用终端模拟器之后并没有解决，反而是换成 neovim 之后解决掉了</p><h2 id="neovim"><a href="#neovim" class="headerlink" title="neovim"></a>neovim</h2><p>相比 iTerm2，<a href="https://neovim.io">neovim</a> 带给我的体验提升就非常大了，甚至可以说是飞跃。Neovim 相比于 vim，进行了非常多体验上的优化，比如便捷的添加如 python 支持，通过命令直接查看 provider 的状态等等。同时 neovim 下也提供了一些插件的支持，提供了新的 api。现在我甚至可以不用分屏就能打开终端或者 fzf 了</p><p><img src="https://i.loli.net/2021/08/08/wYOWZb7krNFag5q.png" alt="fzf"></p><h2 id="coc-nvim"><a href="#coc-nvim" class="headerlink" title="coc.nvim"></a>coc.nvim</h2><p>更换了 neovim 之后，我也对我的 <a href="https://github.com/Augists/ZDCZ-vimrc">vimrc</a> 进行了重写。新的 <code>init.vim</code> 改为基于赵启明大佬的 <a href="https://github.com/neoclide/coc.nvim">coc.nvim</a> 进行配置，尽可能多的使用 LSP 插件体系</p><p>在以前我认为，刚学习敲代码，就应该去掉代码提示，像在记事本写代码一样减少机器辅助。现在我已经到了日常需要查文档才能写代码的时候了（其实就是不会写了），尽管装了 Dash 但是从来不用……Code Completion &amp; Document 显得非常重要了。我屈服了</p><h2 id="glow"><a href="#glow" class="headerlink" title="glow"></a>glow</h2><p><code>glow</code> 是一个似乎不是很轻量的 markdown 终端渲染程序<br>很明显我并不会去使用它，我已经有太多的 markdown 渲染了，但是这不妨碍我把它放在推荐列表，因为确实很好看</p><h2 id="brew-rmtree"><a href="#brew-rmtree" class="headerlink" title="brew rmtree"></a>brew rmtree</h2><p><code>homebrew</code> 的 <code>formula &amp; cask</code> 的卸载一直是一个大问题，因为它没有像 <code>apt</code> 那样的 <code>autoremove</code> 来自动清理不需要的依赖。后果就是我在以前使用的时候每次安装软件都会把终端的内容打印到一个文件里进行存储，然后在卸载的时候对照着一个一个删掉</p><p><code>retree</code> 是一个辅助清理不需要的依赖的工具，但是在我的使用中它似乎对新系统的兼容性有待提升，就像我每次使用 <code>homebrew</code> 都会收到一个新系统的警告一样烦人</p><blockquote><p>我在尝试 <code>pip-autoremove</code> 的过程中遇到了更加恶心的问题。简单来说就是 mac 系统中的 python 太多太乱导致的，这导致我直接放弃了对 <code>pip-autoremove</code> 的研究</p></blockquote>          </div>]]></content>
    
    <summary type="html">
    
      After &lt;i&gt;remake&lt;/i&gt; my coding tools, I find my comfortable zone
    
    </summary>
    
    
    
      <category term="CODE" scheme="https://augists.top/tags/CODE/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Command Ps | Grep Then Find Itself</title>
    <link href="https://augists.top/SELF/ERROR/Command-ps-grep-then-find-itself/"/>
    <id>https://augists.top/SELF/ERROR/Command-ps-grep-then-find-itself/</id>
    <published>2021-07-24T16:50:07.000Z</published>
    <updated>2021-11-08T15:11:39.231Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>分享今日份蠢事</p><p>事情要从下载学校的 VPN 客户端开始说起 …</p><hr><p>学校的 VPN 客户端使用的是 GlobalProtect，应该是一个提供成熟的 VPN 服务的软件，可以自己根据需求定制。这个软件有一个很奇怪的地方，它自动设置为开机自启动，而且进程不允许关闭<br>要知道，当你打开它之后，你会发现它连个 quit 都没有<br>我也尝试过在任务管理器里终止，或是直接 <code>kill</code> 掉它，但都会发现每次它都会立刻重启并开始尝试连接。总之让人看的非常想卸载<br>除此之外，它一直在不断的弹窗让我同意它监控我的所有网络活动…当时我就来气。我看的东西是你不花钱能跟着看的？<br>所以，在发现它并不能帮助我登录 IEEE 之后，我毅然决然的准备卸载掉它 😒</p><p><img src="https://i.loli.net/2021/07/25/GCTESI5Fo4NAPat.jpg" alt=""></p><hr><p>在我使用它提供的 pkg 里卸载时，它就莫名其妙的卡住了。于是我直接强制关闭了 installer（对，它的卸载是在安装器里的），然后准备重新卸载</p><p><img src="https://i.loli.net/2021/07/25/RdigjZxuhy1I4An.jpg" alt=""></p><p>这时候就发现，第二个 installer 会等待第一个运行完，而第一个尽管被我强制退出了，不过很明显它并没有“实质性”的退出 installer<br>它就这么莫名其妙的锁住了！！！<br>当时我就有点懵，尽管这可能是 macOS 系统限制，但是它的卸载强行卡死，导致我连关机都不能执行<br>在我长按关机执行强制重启后，它在启动界面再一次卡死了…</p><p><img src="https://i.loli.net/2021/07/25/tBzuefaORyUcgb9.jpg" alt=""></p><p>最后，上网查到这个软件会在 <code>Contents/Resources</code> 里面放一个卸载 shell 脚本，终于算是卸载掉了</p><hr><p>但是还是很慌，毕竟它能干出要监控我这种事情。我就怀疑他是不是背地里还有卸载残留<br>于是我一通 <code>ps -ef | grep GlobalProtect</code>，好家伙！还真有<br>当场又懵了，这啥进程啊怎么卸载完了还在运行，而且居然每次查看 pid 都不一样<br>又是一通骚操作，甚至已经入魔了，开始每次把获取到的 pid 提出来扔给 <code>kill</code>，然后就发现这个“病毒”非常的顽固呀，每秒都会换一个进程 id，还变成小强了</p><p><img src="https://i.loli.net/2021/07/25/1UQyAg2D5BrWfJ8.png" alt=""></p><p>过了很久才反应过来，这不就是我 <code>grep</code> 进程嘛…<br>也就是说，<code>grep GlobalProtect</code> 就是一个 <code>grep</code> 查找进程，然后它每次都会查找到自己…害得我在这折腾一晚上</p>          </div>]]></content>
    
    <summary type="html">
    
      While running command ps -ef | grep xxx, I came up with a stupid circle
    
    </summary>
    
    
    
      <category term="ERROR" scheme="https://augists.top/tags/ERROR/"/>
    
  </entry>
  
  <entry>
    <title>Merge Tab Bar in Safari</title>
    <link href="https://augists.top/APPLE/Merge-Tab-Bar-in-Safari/"/>
    <id>https://augists.top/APPLE/Merge-Tab-Bar-in-Safari/</id>
    <published>2021-07-17T15:22:50.000Z</published>
    <updated>2021-07-31T02:56:09.582Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>英文表述明白这意思太麻烦了<br>简单来说，就是我的 mac 更新了新的公测版本之后发现，safari 在上个版本添加的新功能：把 tab bar 合并到上面行程一栏，可以节省 title bar 的空间。这个功能不见了<br>😭 我那个急啊，这么好的功能，苹果官方怎么就想不开了<br>把偏好设置翻了个遍都没找到有关于这个的设置，最后在上面找到了<br>截两张图，省的下次再犯傻</p><p><img src="https://i.loli.net/2021/07/17/EC4JfaoDshVkvGO.png" alt=""></p><p><img src="https://i.loli.net/2021/07/17/Zwx1OfkuidEtXgC.png" alt=""></p><p><img src="https://i.loli.net/2021/07/17/eEzm4GfRNicL2jZ.png" alt=""></p><hr><p>更新到 public beta 4 之后，safari 的偏好设置中改用更为明显的方式进行修改了</p><p><img src="https://i.loli.net/2021/07/31/eOpZgKhmSGUE2nI.png" alt=""></p>          </div>]]></content>
    
    <summary type="html">
    
      You may find surprisingly that there will be a separate tab bar in Safari after updating to macOS Monterey beta 12.0&lt;br&gt;I like what it looks like in the last beta version&lt;br&gt;Then...How to roll back Safari
    
    </summary>
    
    
    
      <category term="APPLE" scheme="https://augists.top/tags/APPLE/"/>
    
      <category term="MAC" scheme="https://augists.top/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>Pac Proxy for Github</title>
    <link href="https://augists.top/NOTES/GIT/Pac-Proxy-for-Github/"/>
    <id>https://augists.top/NOTES/GIT/Pac-Proxy-for-Github/</id>
    <published>2021-06-14T02:34:15.000Z</published>
    <updated>2021-06-14T02:47:20.007Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>为了能好好上 GitHub，真是招数用尽<br>之前转了一篇通过添加 Hosts 的方式正常使用 GitHub 并让图片正常加载的，没过多久就不好用了。当时也有提到，需要通过查询 hosts 的网站经常更新才可以。俗话说，懒是第一生产力，所以还是通过 pac 规则添加才是正道</p><p>如何自定义 PAC 列表规则</p><p>规则大概描述如下</p><p>通配符支持，如 <code>*.example.com/</code> 实际书写时可省略如 <code>.example.com/</code> 意即 <code>*.example.com/*</code><br>正则表达式支持，以 <code>\</code> 开始和结束，如 <code>[\w]+://example.com\</code><br>例外规则 <code>@@</code>，如 <code>@@_.example.com/_</code> 满足 <code>@@</code> 后规则的地址不使用代理<br>匹配地址开始和结尾<code>|</code>，如<code>|http://example.com</code>, <code>example.com|</code> 分别表示以 <code>http://example.com</code> 开始和以 <code>example.com</code> 结束的地址<br><code>||</code> 标记，如 <code>||example.com</code> 则 <code>http://example.com</code>，<code>https://example.com</code>，<code>FTP：//example.com</code> 等地址均满足条件，只用于匹配地址开头<br>注释 <code>!</code><br>分隔符 <code>^</code>，表示除了字母，数字或者<code>_ - 。％</code>之外的任何字符。如 <code>http://example.com^</code>，则 <code>http://example.com/</code>, <code>http://example.com:8000/:</code> 均满足条件，而 <code>http://example.com.ar/</code> 不满足条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">! Put user rules line by line in this file.</span><br><span class="line">! See https:&#x2F;&#x2F;adblockplus.org&#x2F;en&#x2F;filter-cheatsheet</span><br><span class="line">||amazonaws.com</span><br><span class="line">||atom.io</span><br><span class="line">||github.com^</span><br></pre></td></tr></table></figure>          </div>]]></content>
    
    <summary type="html">
    
      How to write your pac configuration for surfing on GitHub
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="GIT" scheme="https://augists.top/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title>Way of HarmonyOS</title>
    <link href="https://augists.top/NOTES/DEVICE/way-of-HarmonyOS/"/>
    <id>https://augists.top/NOTES/DEVICE/way-of-HarmonyOS/</id>
    <published>2021-06-06T15:55:28.000Z</published>
    <updated>2021-06-06T16:05:18.178Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <blockquote><p>Copyright@Linux中国<br><a href="https://linux.cn/article-13457-1.html">link</a></p></blockquote><p><img src="https://img.linux.net.cn/data/attachment/album/202106/04/224803x7fppnqf77yyjfzb.jpg" alt=""><br>6 月 2 日晚上八点，鸿蒙召开了 2.0 的发布会，发布了鸿蒙 OS，以及一大批的新品。这两天想必大家也都看到了不少。这篇文章不想讨论鸿蒙系统本身的体验层面的变化，而是将会将精力更多的投放在鸿蒙的生态发展中。</p><h2 id="鸿蒙想要的是什么？"><a href="#鸿蒙想要的是什么？" class="headerlink" title="鸿蒙想要的是什么？"></a>鸿蒙想要的是什么？</h2><p>从 2019<br>年鸿蒙发布，有几个关键词就是核心，分布式、全场景、自主研发，其中自主研发比较好理解，而分布式、全场景一直是我无法理解的，直到看了发布会，我才意识到鸿蒙真正想要的是什么。由于我近几年来，使用的都是苹果的生态，使用<br>Macbook Pro 办公，使用 Homepod 听歌，出门会使用 Airpods Pro 来降噪。所以，在看鸿蒙发布会的时候，我时常有一个想法：这个功能苹果生态里已经有了啊？<br>或者是这个功能的 UI 交互确实是新的，但核心的体验我在苹果生态中也已经体验了啊？<br>也正是这一刻，我悟了，鸿蒙想要的分布式、全场景，其实就是过去我在苹果生态一直体验的那些东西，不同的是，鸿蒙的分布式、全场景，是超出了苹果生态所给予我的东西。</p><p><img src="https://img.linux.net.cn/data/attachment/album/202106/04/224147uqxu94xvvlf19482.png" alt=""></p><p>鸿蒙的产品架构是 1+8+N，1 指的是手机，8 指的是 PC、平板、智慧屏、手表、智能音箱、车机、耳机、AR/VR，N 则是更多的生态。对比着我们来看苹果的生态，1 指的是 iPhone，8 指的是 Macbook Pro、iPad、Apple TV、Apple Watch、Homepod、Apple Car、AirPods 以及不知道有没有的 VR/AR 产品。到这一步，鸿蒙和苹果看起来都很像，那为什么我又说华为超越了苹果生态？原因在于 8 加的 N。在蒙的描述中，N 是指更多的 IoT 设备，他们可以通过鸿蒙系统借助 4G/5G/HiLink 等方式，和核心的 8 个产品进行连接，沟通，从而提升产品的智能性，让用户真正感受到产品的智能特性。而在苹果生态中，苹果是不做 IoT 设备的操作系统的。鸿蒙既做了手机、核心设备的操作系统，还做了嵌入式的操作系统，确实可以让 IoT 设备的操作体验，如同 8 个核心设备的体验，这一点是只制定标准，不下场做事的苹果所无法达到的。可以说，鸿蒙生态假设真的铺设起来了，体验、易用性，可能都要超过苹果生态目前能够提供给我们的。</p><h2 id="鸿蒙生态之乱象"><a href="#鸿蒙生态之乱象" class="headerlink" title="鸿蒙生态之乱象"></a>鸿蒙生态之乱象</h2><p>鸿蒙作为一个看起来还不错的产品，为何近几年来饱受争议？我觉得主要是在宣传策略上的混乱。</p><p><img src="https://img.linux.net.cn/data/attachment/album/202106/04/224305nao3xua1o2jg3xa9.png" alt=""></p><p>提起鸿蒙，数码圈的人往往说的是鸿蒙 OS；而互联网/科技圈的人说的往往是 OpenHarmony 操作系统。二者在宣传的过程中，往往都是被人称作是鸿蒙系统。但实际上，鸿 OS 是真正的鸿蒙 OS，OpenHarmony 仅仅是鸿蒙生态的一个基座，如果你将之与 Android 对比，便是 Android 与 AOSP 的区别。</p><p><img src="https://img.linux.net.cn/data/attachment/album/202106/04/224336t72gddgygyq1jeg3.png" alt=""></p><p>我们真正在使用的鸿蒙系统，是一个完整的、加入了各项系统设定的操作系统，而我们所看到的源码的部分，只是一个操作系统的基座，你真正在使用的过程中，还需要做大量的修改和剪裁的版本。不过，这样的区分是一件好事。Android 当年之所以能够盛行，AOSP 功不可没。OpenHarmony 同样承载了鸿蒙系统发扬光大的路线。不过，OpenHarmony 本身也在宣传上有硬伤。一直以来，OpenHarmony 都被称之为 Android 套壳，在我看来，是不完全准确的。OpenHarmony 在手机/平板/智慧屏部分，使用的是兼容 Android 的机制，而且兼容 Android 的路线也是没有问题的；但在覆盖面更广的嵌入式设备中，产生的价值的是 2012 年就开发的 LiteOS；对于一些特定的场景下，OpenHarmony 可能会使用 Linux Kernel 来完成自己的工作。OpenHarmony 不是 Android 套壳，而是基于 Android/LiteOS/Linux Kernel 的土壤所诞生出的操作系统。操作系统的研发一直以来都不是技术问题而是生态问题，用户不太会裸用操作系统提供的基础功能，能够留下用户的，必然是操作系统之上的应用生态，对于 OpenHarmony 这样的一个后来者，一个最为简单高效获得生态的方式，就是与原有生态的兼容，所以 OpenHarmony 兼容 Android 生态是在我意料之中的事情，倘若鸿蒙真的将整个系统完全重写，那我反而不看好 OpenHarmony。相比于è¯´ OpenHarmony 套壳 Android，我更倾向于 OpenHarmony 编写了一个抽象层，磨平了 LiteOS 和 Android 的系统 API，从而使得一些功能特性可以更加容易的在两种系统之上来实现。而这些，也正是鸿蒙所宣传的 1 + 8 + N战略下的核心体验的由来。但不得不说，在宣传上，OpenHarmony 做的很一般，至可能没有起到好的作用，而是一个坏的作用。</p><h2 id="鸿蒙生态的未来"><a href="#鸿蒙生态的未来" class="headerlink" title="鸿蒙生态的未来"></a>鸿蒙生态的未来</h2><p>说完了鸿蒙想要的东西和鸿蒙生态的乱象，最后，我想聊一聊关于鸿蒙的未来。鸿蒙生态看起来非常的不错，但，能否达到所预想的水平，又是另外一个问题，对于鸿蒙来说，前路依然坎坷。在国内方面，鸿蒙如果希进行推广，就必须要考虑合作伙伴的问题，鸿蒙生态的建设不仅仅是华为的事情，华为可以完成 1+8 的建设，可后面的 N，是需要无数的中小 IoT 设备生产厂商共同建设而来的。但，国内的厂商可能要面临的问题就是，面对曾经的对手，是否还要继续合作？如果合作了，未来是否会被华为卡脖子？华为又是否会在 OpenHarmony 中为自家系统添加单独的优化？这些问题都会让国内的厂商在面临选择时产生困惑。此外，国内的厂商在完成了接入后， 鸿蒙想要扩大生态范围，就必然需要进行出海，出海时就要正面与 Android、iOS 所构建的生态进行竞争，在海外生态不足的情况下，如何取得竞争的胜利，也是一个需要研究和探讨的话题。不过，说了这么多困难，我还是想说，鸿蒙看起来真的很好，或许，有朝一日我会面临这样的选择“花 15000 元，获得完整的苹果生态体验；花 10000 元，获得完整的鸿蒙生态体验，可以实现苹果生态 80% 甚至是 120% 的体验”，你会怎么选？<br>鸿蒙之路，道阻且长。</p>          </div>]]></content>
    
    <summary type="html">
    
      鸿蒙之路，道阻且长&lt;br&gt;Copyright@Linux中国
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Login in 163 in Mail App on Apple Device</title>
    <link href="https://augists.top/APPLE/Login-in-163-in-Mail-app-on-apple-device/"/>
    <id>https://augists.top/APPLE/Login-in-163-in-Mail-app-on-apple-device/</id>
    <published>2021-06-03T10:39:59.000Z</published>
    <updated>2021-06-05T02:39:04.288Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>一直以来，我都很嫌弃苹果设备自带的邮箱。附件稍微大一点就无法正常发送，而且感觉使用逻辑也不是很清晰，一些我需要的小功能也没有提供<br>尝试了 Spark，网易邮箱大师。Spark 的配置上似乎不支持网易邮箱，但网易邮箱又在我的使用中占了大头，所以忍痛割爱，选择了网易邮箱大师<br>但这只是电脑端啊，我还有 pad 和手机端的邮箱需要使用。碰到问题，就要解决问题 😏<br>首先，分析自己的需求：</p><ol><li>发送较大附件 📎 仅在电脑上进行，通常为传输视频或软件一些有较高存储占用的</li><li>移动端主要为接收验证码和一些通知类邮件使用，几乎没有重度使用的要求。但是要求稳定、便捷</li><li>常用邮箱为网易 163 邮箱，并且对 outlook 和 edu 邮箱有一定的使用需求，Gmail 几乎不打开</li></ol><p>根据我自己的要求分析</p><ul><li>电脑端使用网易自己的邮箱软件进行接收更合适，并且似乎不要求必须开启 imap/smtp 功能</li><li>电脑端同时登陆 163, outlook, edu 及一些特殊邮箱，提供必要时的接收和较大附件的发送。有自动签名、自动回复和一些别的功能</li><li>移动端登陆 iCloud、outlook、163 邮箱，仅作为查看邮件的使用和一些小文件的发送</li></ul><hr><p>在配置苹果上的 163 邮箱的时候遇到了无法验证账号和密码的情况，下面是解决方法（或者说配置 163 邮箱的正确步骤）</p><ol><li>网页上登陆 163 邮箱，进入邮箱的设置界面<br><img src="https://i.loli.net/2021/06/05/mvDK4FfhSQtyA2n.png" alt=""></li><li>选择 <code>POP3/SMTP/IMAP</code>，开启 <code>IMAP/SMTP</code> 服务（也可以选择 <code>POP3/SMTP</code> 服务，自行配置 <img src="https://i.loli.net/2021/06/05/oeUDQmVlWhtITMO.png" alt=""></li><li>记录弹出的授权码，授权码是用于登陆第三方设备的专用密码</li><li>在要登陆的位置填写好邮箱的信息，密码使用刚才得到的授权码，不要写自己邮箱的密码</li></ol>          </div>]]></content>
    
    <summary type="html">
    
      The mailbox in system event was suddenly invalid&lt;br&gt;Cannot login and receive emails as normal
    
    </summary>
    
    
    
      <category term="APPLE" scheme="https://augists.top/tags/APPLE/"/>
    
  </entry>
  
  <entry>
    <title>Git Not Ignore Under Directory</title>
    <link href="https://augists.top/NOTES/GIT/Git-not-ignore-under-directory/"/>
    <id>https://augists.top/NOTES/GIT/Git-not-ignore-under-directory/</id>
    <published>2021-06-01T13:25:07.000Z</published>
    <updated>2021-06-03T11:18:59.942Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>先来看我的情景吧</p><div class="note info">            <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dotfiles</span></span><br><span class="line">/*</span><br><span class="line">!.gitignore</span><br><span class="line">!.gitconfig</span><br><span class="line">!.zshrc</span><br></pre></td></tr></table></figure>之前是忽略目录下所有文件及文件夹，只追踪* `.gitignore`* `.gitconfig`* `.zshrc`<p>现在想要添加对 <code>.config</code> 文件夹下的一些文件或文件夹的支持</p>          </div><p>一开始想的比较简单，就直接添加呗，于是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dotfiles</span></span><br><span class="line">/*</span><br><span class="line">!.gitignore</span><br><span class="line">!.gitconfig</span><br><span class="line">!.zshrc</span><br><span class="line">!.config/</span><br></pre></td></tr></table></figure><p>如果你也尝试一下，就会发现，git 始终无法添加上对 <em>config</em> 文件夹下内容的追踪<br>查了好久都没找到应该怎么写，最后看到了 <em>git-doc</em> 才明白<br>官方给的例子是这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line"><span class="comment"># exclude everything except directory foo/bar</span></span><br><span class="line">/*</span><br><span class="line">!/foo</span><br><span class="line">/foo/*</span><br><span class="line">!/foo/bar</span><br></pre></td></tr></table></figure><p>也就是说，想要想让 <em>git</em> 追踪文件夹里的某些内容，需要先追踪全文件夹，然后在忽略文件夹下的所有内容，再添加对单个文件的追踪</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dotfiles</span></span><br><span class="line">/*</span><br><span class="line">!.gitignore</span><br><span class="line">!.gitconfig</span><br><span class="line">!.zshrc</span><br><span class="line">!/.config</span><br><span class="line">/.config/*</span><br><span class="line">!.config/htop</span><br><span class="line">!.config/ranger</span><br><span class="line">!.config/.zsh_history_bak</span><br><span class="line">!.config/.tmux</span><br></pre></td></tr></table></figure><blockquote><p>tmux 下 vim 似乎不是很好用</p></blockquote>          </div>]]></content>
    
    <summary type="html">
    
      How to write gitignore file&lt;br&gt;Ignore all except specific files under directory
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="GIT" scheme="https://augists.top/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title>Tmux Shortcut Record</title>
    <link href="https://augists.top/NOTES/TERMINAL/Tmux-Shortcut-Record/"/>
    <id>https://augists.top/NOTES/TERMINAL/Tmux-Shortcut-Record/</id>
    <published>2021-06-01T01:17:50.000Z</published>
    <updated>2021-06-05T02:45:01.127Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>三个概念 由大到小</p><ul><li>session</li><li>window</li><li>pane 窗格</li></ul><p><img src=";https://i.loli.net/2021/06/01/1vlPqRhLKN3Siob.png" alt=""></p><p>Shortcut</p><ul><li><code>tmux new -s session_name</code> 新建 session 并自动新建 window</li><li><code>ctrl b + ?</code> 调出命令面板 help</li><li><code>ctrl b + %</code> 左右分屏</li><li><code>ctrl b + &quot;</code> 上下分屏</li><li><code>ctrl b + o</code> 切换 focus 的 pane</li><li><code>ctrl b + d</code> detach 分离会话（退出但不关闭）</li><li><code>tmux ls</code> 查看正在运行的会话</li><li><code>tmux att -t session_name</code> attach 恢复会话（自动根据前缀匹配）</li><li><code>ctrl b + c</code> 新建 window</li><li><code>ctrl b + n</code> next window</li><li><code>ctrl b + p</code> previous window</li><li><code>ctrl b + ,</code> rename window</li><li><code>ctrl b + w</code> list windows and jump</li><li><code>ctrl b + s</code> list sessions and jump</li></ul><div class="note info">            <p>开启 tmux 并且分离会话后，再使用 <code>ps -a</code> 查看进程的时候，会发现非常乱，因为它包含了 tmux 下会话仍然在运行的进程<br>现在不知道 tmux 保存会话到底意义大不大了，占用系统资源保留进程，我现在可能并不需要为了一点便利而浪费性能和电量 🔋，也是因为我还没到那个层次吧</p>          </div>          </div>]]></content>
    
    <summary type="html">
    
      Take down the shortcut for better using tmux
    
    </summary>
    
    
    
      <category term="TERMINAL" scheme="https://augists.top/tags/TERMINAL/"/>
    
      <category term="TMUX" scheme="https://augists.top/tags/TMUX/"/>
    
  </entry>
  
  <entry>
    <title>Code Server on ECS</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/Code-Server-on-ECS/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/Code-Server-on-ECS/</id>
    <published>2021-05-29T05:31:02.000Z</published>
    <updated>2021-11-08T15:09:50.580Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h2 id="什么是-Code-Server"><a href="#什么是-Code-Server" class="headerlink" title="什么是 Code Server"></a>什么是 Code Server</h2><p><img src="https://i.loli.net/2021/05/29/Ft9MfxHQZ8TCdEK.png" alt="Screen Shot 2021-05-29 at 11.31.44 AM"></p><p>Code Server 是一个可以搭建在服务器上的网页版 VS Code，它允许你随时随地连接你服务器的 Code Server 并提供近似于本地 VS Code的服务，只需要你有一台能接入互联网的设备即可</p><blockquote><h2 id="Highlights"><a href="#Highlights" class="headerlink" title="Highlights"></a>Highlights</h2><ul><li>Code on any device with a consistent development environment</li><li>Use cloud servers to speed up tests, compilations, downloads, and more</li><li>Preserve battery life when you’re on the go; all intensive tasks run on your server</li></ul></blockquote><p>项目<a href="https://github.com/cdr/code-server">链接</a></p><p>以在苹果 iPad 为例，通过浏览器访问后 PWA，就可以获得一个 iPad 端的 VS Code</p><h2 id="搭建-Code-Server"><a href="#搭建-Code-Server" class="headerlink" title="搭建 Code Server"></a>搭建 Code Server</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>首先吧，你要有台服务器，服务器你要能自己开放特定的端口，要不让啥都免谈了。其次吧，你要能跟服务器进行一些交互，比如 SSH 登陆上去</p><p>下面就开始正式搭建啦，期间会遇到非常多的问题，有的经过我自己的摸索已经解决，也有的仍然没有找到合适的方法。如若你有什么想法，欢迎通过各种方式联系我啊</p><hr><p>在官方的 GitHub 仓库里提到，可以通过脚本一键安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://code-server.dev/install.sh | sh -s -- --dry-run</span><br></pre></td></tr></table></figure><p>其中 <code>-s -- --dry-run</code> 参数是作为输出中间过程的，如果删掉参数只是不会接收到一些过程信息。在 <code>install.sh</code> 文件中，我们可以看到注释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--dry-run</span><br><span class="line">    Echo the commands <span class="keyword">for</span> the install process without running them</span><br></pre></td></tr></table></figure><p>如果你也是使用的国内的服务器，没有办法让它能更便利的接近到外网时，就需要先在本机上下载 <code>install.sh</code> 脚本，然后通过 FTP 上传到服务器上了</p><p>运行 <code>install.sh</code> 脚本后会发现，它在尝试下载一个 deb 包。很明显，这个包又在国外</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fetch <span class="string">&quot;https://github.com/cdr/code-server/releases/download/v<span class="variable">$VERSION</span>/code-server_<span class="variable">$&#123;VERSION&#125;</span>_<span class="variable">$ARCH</span>.deb&quot;</span> \</span><br><span class="line">    <span class="string">&quot;<span class="variable">$CACHE_DIR</span>/code-server_<span class="variable">$&#123;VERSION&#125;</span>_<span class="variable">$ARCH</span>.deb&quot;</span></span><br></pre></td></tr></table></figure><p>于是，又要在本机下载这个 deb 包进行手动上传</p><p>那么上传之后，怎么才能让 <code>install.sh</code> 脚本继续工作呢？</p><p>查看刚才的 <code>fetch</code> 我们可以发现，脚本会把 deb 包下载到 <code>$CACHE_DIR/code-server_${VERSION}_$ARCH.deb</code> 这个路径下，所以我们也可以把包放在自己的 <code>~/.cache/</code> 下，并且按照脚本的命名方式进行更名，然后将 <code>fetch</code> 删掉，直接进入到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo_sh_c dpkg -i <span class="string">&quot;<span class="variable">$CACHE_DIR</span>/code-server_<span class="variable">$&#123;VERSION&#125;</span>_<span class="variable">$ARCH</span>.deb&quot;</span></span><br></pre></td></tr></table></figure><p>这里的 <code>sudo_sh_c</code> 是函数。需要注意的是，我们需要修改对应自己系统的 <code>install</code> 函数，比如我在 ubuntu 上安装，所以我需要修改的是 <code>install_deb()</code> 函数</p><p><img src="https://i.loli.net/2021/05/27/SbPQAme3tcv4poM.png" alt=""></p><p>修改到这里，就可以使用官方提供的脚本进行一键安装了。比较不好的一点是，官方的 GitHub Wiki 对安装及安装之后的步骤并没有详细的说明，而只是说</p><blockquote><p>When done, the install script prints out instructions for running and starting code-server.</p></blockquote><p>甚至给出的 in-depth setup and configuration 里也是这句话</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>安装完成后，直接输入 <code>code-server</code> 回车就会启动服务啦，但是在此之前，我们还需要进行一点简单的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi .config/code-server/config.yaml</span><br><span class="line"></span><br><span class="line"><span class="built_in">bind</span>-addr: 127.0.0.1:8080</span><br><span class="line">auth: password</span><br><span class="line">password: xxxxxx</span><br><span class="line">cert: <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li><code>bind-addr</code> 为监听地址，这里我作为服务器，修改为 <code>0.0.0.0:12345</code>，即本地加上一个自己可以设定的端口号。默认的 8080 端口通常也会有其他应用使用，容易产生冲突，这里推荐改为自己喜欢的一个端口</li><li><code>password</code> 为登陆 Code Server 需要使用的密码，可以改为一个简单好记但是不容易被爆破的密码，在我的使用中我感觉 Code Server 会使服务器的安全等级急剧降低，通过 Code Server 可以直接编辑服务器的一些文件，有很大的安全风险</li><li><code>cert</code> 应该是 SSL 证书，如果没有的话直接 false 即可。对于普通人来说，http 带来的安全性问题应该影响不大，但是每次登陆 Code Server 之后都会提醒一遍听烦人的</li></ul><p>在设定了给 Code Server 分配的端口号之后，我们需要在服务器的安全组里添加设定的特殊端口的开放。而想要让 Code Server 开机自启就要用到系统提供的 <code>systemctl</code> 了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> code-server@</span><br></pre></td></tr></table></figure><p>最好再 tab 一下</p><p>经过配置和启动之后，我们就可以通过服务器的公网 ip 和端口号登陆 Code Server 了</p><h2 id="进入-Code-Server-后遇到的问题"><a href="#进入-Code-Server-后遇到的问题" class="headerlink" title="进入 Code Server 后遇到的问题"></a>进入 Code Server 后遇到的问题</h2><h3 id="ms-vscode-cpptools"><a href="#ms-vscode-cpptools" class="headerlink" title="ms-vscode.cpptools"></a>ms-vscode.cpptools</h3><p>如果你在插件商城中尝试安装了 C/C++，你会发现它提示的报错 VS Code 未能安装 ms-vscode.cpptools</p><p>同样也可以在本机下载之后上传到服务器上，然后在 Code Server 中扩展，三个点，从 VSIX 安装，然后选择下载的 <code>cpptools-linux.vsix</code> 文件。如有需要，可以随时重启 Code Server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart code-server@</span><br></pre></td></tr></table></figure><h3 id="open-folder"><a href="#open-folder" class="headerlink" title="open folder"></a>open folder</h3><p>一开始可能会出现无法打开文件夹的情况。可以通过在 welcome 界面中选择打开文件夹解决。左侧的几个按钮在我的测试中都出现了失灵的情况</p><h3 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h3><p>我也尝试在服务器中安装了 PostgreSQL 并且通过 Code Server 直接在前台进行连接。也可能是由于 PostgreSQL 的配置问题，我在前端的 Code Server 一直没有成功连接上后台的数据库。我已经尝试了</p><ul><li>修改 postgres 用户密码</li><li>修改用户配置文件</li><li>修改监听地址</li><li>修改连接时的 ip 地址</li></ul><p>但是不确定具体问题出在哪里，提示的报错信息也只是验证失败。由于我已经有四个数据库和一个线上练习测试了，就不继续折腾这个</p><blockquote><p>后来，我一个干事告诉我他买了 30 块钱的 Code，使用上来说可能更加适合作为 iPad 上的敲代码的平台。这个软件以前在白嫖的时候也安装过，后来需要更新的时候以为是免费安装的，卸载之后就再也没找回来了。</p><p>本次实验搭建 Code Server 使用的平台是由华为云提供。本身是数据库课程于华为公司合作，统一申请的 300 元抵用券，在课程结束后的 8 月份就过期了。于是我就想怎么才能把用不到的钱利用起来，就在华为云上购买了一台最低配置的 ECS 服务器作为实验平台。</p><p>Code Server 是在很早以前就接触到的一个项目，一直很想自己动手实践搭建一下，但是当时看到的时候正好自己购买的阿里云学生机过期了，于是一直搁浅没有尝试。这次也很感谢华为云计算的平台，能自己搭建一个可以娱乐的平台，让我自己动手练习实践，体会到了很多。</p><p>目前已经在 ECS 上搭建过的项目：</p><ul><li>临时的 FTP Server</li><li>NextCloud</li><li>MC 私人服务器（最终失败了）</li><li>Code Server</li></ul><p>还想再尝试或继续的项目：</p><ul><li>个人下载站</li><li>VPN</li><li>挂载网盘</li><li>shell 脚本实战</li><li>python for beginners</li></ul><p>仍需要继续学习的工具：</p><ul><li>tmux</li><li>FTP Transmit</li><li>docker</li></ul></blockquote>          </div>]]></content>
    
    <summary type="html">
    
      Those troubles during the process of building an Code Server on my ECS&lt;br&gt;Solved or Solving
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Shortcut Screen Saver</title>
    <link href="https://augists.top/APPLE/Shortcut-Screen-Saver/"/>
    <id>https://augists.top/APPLE/Shortcut-Screen-Saver/</id>
    <published>2021-05-26T09:29:19.000Z</published>
    <updated>2021-05-26T09:46:49.719Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>If asked how to start your screen saver on your mac, what is your answer? Some of you may respond with <em>Hot Corners</em>. But it may be the second choice on mine</p><h2 id="Hot-Coners"><a href="#Hot-Coners" class="headerlink" title="Hot Coners"></a>Hot Coners</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Preference -&gt; Desktop &amp;<span class="built_in"> Screen </span>Saver -&gt; Hot Corners</span><br></pre></td></tr></table></figure><p>Choice one of the four corners and <code>Start Screen Saver</code></p><h2 id="Automator"><a href="#Automator" class="headerlink" title="Automator"></a>Automator</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Automator -&gt; New Document -&gt; Quick Action -&gt; Start<span class="built_in"> Screen </span>Saver -&gt; Workflow receives: <span class="literal">no</span> input -&gt; save</span><br></pre></td></tr></table></figure><p>then give your workflow a shortcut</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P<span class="function"><span class="title">reference</span> -&gt;</span> K<span class="function"><span class="title">eyboard</span> -&gt;</span> S<span class="function"><span class="title">hortcuts</span> -&gt;</span> Services</span><br></pre></td></tr></table></figure><p>I record <code>control + option + command + s</code> for screen saver, which is also known as <code>hybrid + s</code></p><div class="note info">            <p>Recommend:<br>Fliqlo – a clock screen saver<br>4K video – downloaded from apple TV screen saver</p>          </div>          </div>]]></content>
    
    <summary type="html">
    
      How to start screen saver on your mac in a split second?&lt;br&gt;Hot corner? NO&lt;br&gt;Automator is the best choice
    
    </summary>
    
    
    
      <category term="APPLE" scheme="https://augists.top/tags/APPLE/"/>
    
      <category term="MAC" scheme="https://augists.top/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>Linux Fork</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/linux-fork/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/linux-fork/</id>
    <published>2021-05-20T13:22:39.000Z</published>
    <updated>2021-11-08T15:10:30.047Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2-1程序一"><a href="#2-1程序一" class="headerlink" title="2.1程序一"></a>2.1程序一</h3><h4 id="2-1-1实验代码"><a href="#2-1-1实验代码" class="headerlink" title="2.1.1实验代码"></a>2.1.1实验代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value=<span class="number">5</span>;     <span class="comment">//where?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;     <span class="comment">//where?</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;    <span class="comment">// How many new processes and printfs？</span></span><br><span class="line">        pid=fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">            value += <span class="number">15</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child: value = %d\n&quot;</span>,value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;PARNET: value = %d\n&quot;</span>,value);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);   <span class="comment">//Notice：What will happen with or without this line?</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2代码理解"><a href="#2-1-2代码理解" class="headerlink" title="2.1.2代码理解"></a>2.1.2代码理解</h4><ol><li><code>fork()</code> 函数会在运行时创建一个与自己完全相同的子进程，即父进程在进入第一次 <code>for</code> 循环后进行第一次 <code>fork</code> 创建。此时父进程 <code>pid &gt; 0</code> 而子进程 <code>pid == 0</code></li><li>父进程继续执行，并进行 <code>wait(NULL)</code>。<code>wait</code> 意为：立即阻塞父进程，并进行判断：<ol><li>是否有当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，<code>wait</code> 就会收集这个子进程的信息，并把它彻底销毁后返回</li><li>如果没有找到这样一个子进程，<code>wait</code> 就会一直阻塞在这里，直到有一个出现为止（此时没有僵尸子进程，所以父进程阻塞等待）</li></ol></li><li>子进程并行执行，输出 <code>Child: value = 20</code> 并进入下一个 <code>for</code> 循环</li><li>进入第二个 <code>for</code> 循环后，原子进程变为新父进程，并创建与当前状态（<code>i = 1</code>）相同的子进程。子进程执行输出 <code>Child: value = 35</code> 并向下继续；新父进程进入 <code>wait</code> 阻塞</li><li>子进程运行结束，变为僵尸进程；新父进程结束阻塞，输出 <code>PARNET: value = 20</code> 并向下运行，<code>exit</code> 后运行结束；原父进程结束阻塞，输出 <code>PARNET: value = 5</code> 并 <code>exit</code>，结束运行</li></ol><blockquote><p>考虑 <code>value</code> 的生存期问题，在程序中作为全局变量，生存期一直到程序结束。对于每一个进程来说，<code>value</code> 的值在进程创建时为自己进程固定，不再受到其他进程影响</p></blockquote><blockquote><p><code>fork</code> 函数用于创建子进程，同时返回 0 用于父进程与子进程的区分判断。</p><p><code>fork</code> 可能有三种不同的返回值：<br>  1）在父进程中，fork返回新创建子进程的进程ID；<br>  2）在子进程中，fork返回0；<br>  3）如果出现错误，fork返回一个负值；</p><p>所以在子进程创建自己的子进程时，它存储的 <code>pid</code> 变量值已经变为新子进程的 <code>pid</code>，不为 0，即为新父进程</p></blockquote><blockquote><p>若父进程没有 <code>exit(0)</code> 则父进程会再次进入 <code>for</code> 循环，并创建子进程</p></blockquote><h4 id="2-1-3程序截图"><a href="#2-1-3程序截图" class="headerlink" title="2.1.3程序截图"></a>2.1.3程序截图</h4><ol><li>fork 程序</li></ol><p><img src="https://i.loli.net/2021/05/20/BIq3ceboUPxzKig.png" alt="Screen Shot 2021-05-20 at 7.50.53 PM"></p><ol start="2"><li>验证 fork 函数程序</li></ol><p><img src="https://i.loli.net/2021/05/20/3wGpUvTz1KosJBg.png" alt="Screen Shot 2021-05-20 at 7.52.04 PM"></p>]]></content>
    
    <summary type="html">
    
      What is behind fork() in Linux?&lt;br&gt;Share by an example for Operating System Course
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
      <category term="UNIX" scheme="https://augists.top/tags/UNIX/"/>
    
  </entry>
  
</feed>

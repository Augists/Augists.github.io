<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Augists-ZDCZ</title>
  
  <subtitle>LESS is MORE</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://augists.top/"/>
  <updated>2022-07-17T12:42:00.807Z</updated>
  <id>https://augists.top/</id>
  
  <author>
    <name>Augists</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Crazy for Tools</title>
    <link href="https://augists.top/SELF/THINKING/Crazy-for-Tools/"/>
    <id>https://augists.top/SELF/THINKING/Crazy-for-Tools/</id>
    <published>2022-07-17T11:24:12.000Z</published>
    <updated>2022-07-17T12:42:00.807Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>最近开始有一些反思，自己对于一些工具性质的东西是否执着的太过了</p><p>就比如对 vim 来说，我一直非常坚定的认为，它通过三种模式让手可以不离开键盘中心区域就能完成大部分甚至全部工作。确实，这对我个人的效率而言，我觉得有很大帮助。但是，这可能并非是一个值得被发散到每一个人身上的东西。对于大部分 coder 来说，手不离开键盘这件事并不重要</p><p>最近认识一个在做 Linux 推广的学弟，能看得出他对于 Linux 的狂热，他希望能将 Linux 推广到每一个人。如果你问我，愿不愿意把 Linux 推广到每个普通用户，放在以前我可能会做。我把家里电脑换成 Manjaro，换成 Deepin，让我家人开始尝试用 Linux 发行版。但是放到现在，我反而对这件事情持保留态度</p><p>并非是因为年纪大了，没那么有热情了。恰恰相反，就我自己来说，接触 coding 这些东西也是在上大学之后，一些思想观念由于接触的时间短，容易发生变化，甚至整个推翻</p><div class="note danger">            <p>工具是给人用的，不同工具就意味着有不同的面向人群（市场）。对于一个比较完善的工具来说，可能并不存在好坏之分。他们的区别只有对你自己来说是否更适用，解决更多痛点，实现更多你需要的功能。</p>          </div><p>我觉得谁也不能评判 vim 和 emacs 就好于现在的 IDEs。没有人能说 markdown 和 org-mode 孰优孰劣，他们又比 word 甚至 LaTeX 强什么。同样，我们不能说 Linux 就比 Windows 适用于更多人，我并不认为已经到了 Linux 的易用性替代 Windows 的时候，并且从最初的想法来看，Linux 可能永远都没有办法替代</p><p>今天看到一篇文章，<a href="https://sspai.com/post/61029">对工具狂热的反思</a>。作者以笔记软件为切入点聊了对于双链等过于狂热大环境下的一些思考，正巧我今天也在和一个学弟说有关笔记软件的选择。作者举了一个例子还挺有意思的</p><blockquote><p>之后我也陷入了知识管理的军备竞赛中，频繁查看各种讨论群及论坛。老实说，这没什么好奇怪的，回想起我们第一次接触 Markdown 及 RSS 等工具时，也是一样的狂热，恨不得将所有用法、技巧收入囊中，如用 Markdown 做 PPT，写结构复杂的论文，用 RSS 浏览社交媒体、YouTube 等等，但最后，我们发现当 Markdown 如同 Word 一般融入生活，当使用 RSS 如同刷朋友圈一样习惯时，我们只需要最基本的功能就能极大的地提升效率。</p></blockquote><p>前两天给老师讲完论文，老师最后问了我一个问题。我为什么要用这种 markdown 形式的 PPT 工具。其实一开始决定用 <a href="https://github.com/maaslalani/slides">slides</a> 做这次的汇报，就是单纯想试试这个工具玩。我并不能下“markdown 转 ppt 比直接做 ppt 更高效”的结论，事实上，同样的一个 slide，我用目前用的 keynote 做的更快。（<a href="https://github.com/slidevjs/slidev">slidev</a> 对我来说更像是一个一边做 ppt，一边学学前端的工具</p><p>在对于一些需要图片甚至动画来辅助理解的事情上，用 keynote （或者 powerpoint）做演示文稿更高效、更有用，同时，它门槛低，上手简单。这是否意味着，有时候我过于为了追求小众而把路走的太极端了。它们只是工具，对我们这些使用者来说，区别应该是在于哪个更好用更听话，而不是哪个用的人少、功能更新奇</p><p>其实对于工具狂热并不是不好，就像我在一开始接触 mac 的半年多，疯狂的寻找、试用各种软件，然后自己比较，确定出最适合自己的那一个。在这之后，我就很少关注那些所谓的软件推荐了，因为我很明确的知道我已经找到了最适合我的工具，我对它们之间的区别和优劣已经很清楚了</p><p>回过头来，对于推广 Linux 这件事，除非涉及到政治因素，否则我想我不会为了能让更多人了解 Linux 而把它强推给别人了</p><hr><p>另外，我博客上线了 About 页面。目前的想法是在里面放一点我个人的一点点小信仰。现在里面应该写了我对于 <code>Less is more</code> 和 <code>Geek</code> 的解释，仅代表个人观点</p>          </div>]]></content>
    
    <summary type="html">
    
      Discussion about extremely crazy utility of tools on computer
    
    </summary>
    
    
    
      <category term="THINKING" scheme="https://augists.top/tags/THINKING/"/>
    
  </entry>
  
  <entry>
    <title>&lt;Paper Reading&gt; Fast BGP Simulation of Large Datacenters</title>
    <link href="https://augists.top/NOTES/PAPER/Fast%20BGP%20Simulation%20of%20Large%20Datacenters/"/>
    <id>https://augists.top/NOTES/PAPER/Fast%20BGP%20Simulation%20of%20Large%20Datacenters/</id>
    <published>2022-07-12T15:44:46.000Z</published>
    <updated>2022-07-20T16:03:06.823Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h1 id="Fast-BGP-Simulation-of-Large-Datacenters"><a href="#Fast-BGP-Simulation-of-Large-Datacenters" class="headerlink" title="Fast BGP Simulation of Large Datacenters"></a>Fast BGP Simulation of Large Datacenters</h1><blockquote><p>VMCAI 2019 (CCF B)</p><p>Nuno P. Lopes and Andrey Rybalchenko</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@inproceedings&#123;lopes2019fast,</span><br><span class="line">  title&#x3D;&#123;Fast BGP simulation of large datacenters&#125;,</span><br><span class="line">  author&#x3D;&#123;Lopes, Nuno P and Rybalchenko, Andrey&#125;,</span><br><span class="line">  booktitle&#x3D;&#123;International Conference on Verification, Model Checking, and Abstract Interpretation&#125;,</span><br><span class="line">  pages&#x3D;&#123;386--408&#125;,</span><br><span class="line">  year&#x3D;&#123;2019&#125;,</span><br><span class="line">  organization&#x3D;&#123;Springer&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[toc]</p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>outage 运行中断</p><p>misconfigurations, maintenance, upgrades, hardware and firmware failures -&gt; production datacenters outage</p><table><thead><tr><th>RIP</th><th>OSPF</th></tr></thead><tbody><tr><td>DV</td><td>LS</td></tr><tr><td>Floyd</td><td>Dijkstra</td></tr></tbody></table><table><thead><tr><th>OSPF</th><th>BGP</th></tr></thead><tbody><tr><td>IGP</td><td>EGP</td></tr><tr><td>easily configured</td><td>complex</td></tr><tr><td>Dijkstra</td><td>Best path selection</td></tr><tr><td>Speed first</td><td>Best</td></tr></tbody></table><ul><li><p>LS</p><ul><li>链路状态路由算法</li><li>每个节点都周期性的向网络上所有其它节点广播自己到邻居节点的距离。每个节点都具有完整的网络信息，即知道网络上每条边的距离。于是，每个节点都可以彼此独立的使用Dijkstra最短路径算法来计算到网络上其它节点的最短路径。</li></ul></li><li><p>边界网关协议 BGP (Border Gateway Protocol)</p><ul><li>一种实现自治系统AS（Autonomous System）之间的路由可达，并选择最佳路由的距离矢量路由协议</li><li>外部网关协议 EGP (Exterior Gateway Protocol): 在 AS 之间动态交换路由信息，只发布网络可达，不优选，不考虑环路避免等问题</li><li>路由优选、避免路由环路、更高效率的传递路由和维护大量的路由信息<ul><li>采用认证和GTSM的方式，保证了<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A7890/pages/DZE0811M/09/DZE0811M/09/resources/dc/dc_feature_bgp_0006.html">网络的安全性</a></li><li>提供了丰富的路由策略，能够灵活的进行<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A7890/pages/DZE0811M/09/DZE0811M/09/resources/dc/dc_feature_bgp_0007.html">路由选路</a></li><li>提供了<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A7890/pages/DZE0811M/09/DZE0811M/09/resources/dc/dc_feature_bgp_0010.html">路由聚合</a>和<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A7890/pages/DZE0811M/09/DZE0811M/09/resources/dc/dc_feature_bgp_0011.html">路由衰减</a>功能用于防止路由振荡，有效提高了网络的稳定性</li><li>用TCP作为其传输层协议（端口号为179），并支持<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A7890/pages/DZE0811M/09/DZE0811M/09/resources/dc/dc_feature_bgp_0012.html">BGP与BFD联动</a>、<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A7890/pages/DZE0811M/09/DZE0811M/09/resources/dc/dc_feature_bgp_0013.html">BGP Tracking</a>和<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A7890/pages/DZE0811M/09/DZE0811M/09/resources/dc/dc_feature_bgp_0020.html">BGP GR</a>，提高了网络的可靠性</li></ul></li><li>角色<ul><li>Speaker: 接收或产生新的报文信息，并发布（Advertise）给其它BGP Speaker</li><li>Peer: 相互交换报文的Speaker之间互称对等体（Peer）。若干相关的对等体可以构成对等体组（Peer Group）</li></ul></li><li>报文<ul><li>Open报文：用于建立BGP对等体连接</li><li>Update报文：用于在对等体之间交换路由信息</li><li>Notification报文：用于中断BGP连接</li><li>Keepalive报文：用于保持BGP连接，周期性发送</li><li>Route-refresh报文：用于在改变路由策略后请求对等体重新发送路由信息。只有支持路由刷新（Route-refresh）能力的BGP设备会发送和响应此报文</li></ul></li></ul></li></ul><p><img src="https://pic1.zhimg.com/80/v2-a60f360061dd3d41d12ca88a5ee8f0dc_1440w.jpg" alt=""></p><ul><li>RIB (route information base)<ul><li>维护每种协议的网络拓扑和路由表。这将包括许多到达相同目的地前缀的路由。</li></ul></li><li>FIB (forwarding information base)<ul><li>是从下推的RIB中可能的许多协议到快速转发查找内存的最佳路径的最佳路由。</li></ul></li></ul><p>FASTPLANE - based on Dijkstra</p><ul><li>is two orders of magnitude faster than the state-of-the-art on small and medium datacenters (快两个数量级)</li><li>goes beyond the state-of-the-art by scaling to large datacenters</li></ul><p>静态检查无法处理一些路由器固件层面上的bug，因此需要用动态的模拟来寻找问题</p><p>总结：提出了一种快速可拓展的BGP系统模拟算法，它需要数据中心路由策略有单调性，用路由报文而非权重计算出单源最短路。</p><h2 id="Datacenters-and-BGP"><a href="#Datacenters-and-BGP" class="headerlink" title="Datacenters and BGP"></a>Datacenters and BGP</h2><p>ASN (autonomous system number)</p><p>路径属性的词典顺序(这里用的是ASN) 替代 跳数</p><p>RIB根据配置初始化，根据新收到的前缀和unreachable更新</p><h2 id="Illustration"><a href="#Illustration" class="headerlink" title="Illustration"></a>Illustration</h2><h3 id="Prefix-Interaction"><a href="#Prefix-Interaction" class="headerlink" title="Prefix Interaction"></a>Prefix Interaction</h3><p><code>(router,prefix,AS path)</code> 代表要到达 router，下一跳 prefix，中转路径 AS path</p><p>WL 中不止一个时，选择优先级最高的 (we need to visit a most preferred advertisement first)</p><p>优先级由 BGP 最优路径选择算法得出，即更短的 AS path 优先级更高。但并不总是可以比较的</p><ul><li>算法被用于单路由？而FASTPLANE被用于处理属于不同路由的报文</li><li>AS path length 可能相等</li></ul><p>最终优先级<strong>先判断路径长度，在长度相同时选择 ASN 小的 (an auxiliary lexicographic order on names of routers)</strong></p><p>路由根据自己是否已经在 AS path 中来决定是否要 reject 收到的报文</p><p>R2 此时 RIB 中不空且 <code>24 &gt; 16</code>，进行 aggregation，生成新的 <code>a&#39;&#39; = (R2, 10.0.0.0/16, &lt;&gt;)</code> 作为种子 </p><p>最后将 RIB 中每个前缀的最优报文交给 FIB</p><h3 id="Globally-vs-Locally-Preferred-Advertisements"><a href="#Globally-vs-Locally-Preferred-Advertisements" class="headerlink" title="Globally vs. Locally Preferred Advertisements"></a>Globally vs. Locally Preferred Advertisements</h3><p>当同一路由出现两个甚至多个竞争的报文时，选取并替换 WL</p><p>为什么 R4 就会等 R1 发的包呢？(by propagating only globally optimal advertisements)</p><h3 id="Necessity-of-Monotonic-Increase-of-Preference"><a href="#Necessity-of-Monotonic-Increase-of-Preference" class="headerlink" title="Necessity of Monotonic Increase of Preference"></a>Necessity of Monotonic Increase of Preference</h3><p>FASTPLANE 需要路由节点的优先级越来越低 (the preference of a route advertisement at the destination router cannot be higher than the preference of the originating advertisement at the source router)，但是又要求单调增？？？(ensure monotonic increase of preference)</p><p>最终优先级的判断修改为<strong>先判断配置中的优先级 local pref，再判断路径长度，最后在路径长度相同时选择 ASN 较小的一个</strong> (the adver- tisement with the highest local preference is preferred. If advertisements have an equal value of the local preference attribute, then the advertisement with the shortest AS path is preferred)</p><p><code>(router,prefix,local pref,AS path)</code></p><h2 id="Future-Work"><a href="#Future-Work" class="headerlink" title="Future Work"></a>Future Work</h2><p>本文提出了一种计算路由表的算法，该算法仅适用于使用BGP的特定特征子集。需要进一步重新搜索，以拓宽和准确描述哪些特征集合（或多组）可以一起使用，并且仍然与拟议的算法（或类似的单调推理方法）兼容。</p><p>双重而言，需要进一步研究来描述要避免的协议功能，以支持高效的验证。此外，对是否/如何用单调特征取代非单调特征知之甚少。这不仅可以提高网络验证的效率，还可以加快生产网络的融合时间，因为撤回的广告会更少。</p><p>另一个途径是研究控制平面上的非确定性。有时不是总顺序，这意味着网络中可能存在不同的稳定状态。这有缺点，例如使故障排除变得更加困难。我们目前的原型故意以一致、确定性的方式计算单个稳定状态，以便结果可以重现。然而，这种稳定状态可能与真实网络稳定的状态不同。</p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><ul><li><p>第一个例子中RIB初始化后，如果R1和R3都为<code>10.0.0.0/24</code>，R2应该怎么办</p><ul><li>对于相同的前缀长度，incomparable -&gt; pick either of them arbitrarily</li><li>挨个运行？</li></ul></li><li><p>遍历种子列表、prefix 选择等过程像是由主节点选择</p><ul><li>猜测报文在每一步都返回到单源路由，由单源路由计算后再发出下一步？</li></ul></li><li><p>计算单源最优路径，计算过程是由路由计算异步传播还是有中心计算并将结果给路由节点</p><ul><li>节点自行计算<ul><li>By running BGP each datacenter router participates in a distributed best path computation, where information about the best paths is ex- changed between direct neighbors</li><li>transBGP函数的OutRouteMap返回值和InRouteMap</li></ul></li></ul></li><li><p>三个示例中修改使得非最优路径会提前发送</p><ul><li>在后文中看到好像是会撤回后续节点RIB中的非最优路径，保留出现最优路径歧义节点RIB中的存储</li></ul></li><li><p>only deal with transBGP that is monotonically increasing，增 or 减？</p><ul><li>In a network, monotonicity implies that the weight of a walk does not decrease when it is extended by a new link (Paper: <em>An Algebraic Theory of Dynamic Network Routing</em>)</li></ul></li><li><p>初始状态多个路由器的配置有冲突，且交叉点有距离</p><ul><li>4.4</li></ul></li></ul><h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.youtube.com/watch?v=_Z29ZzKeZHc">BGP Overview</a></p><p><a href="https://www.techtarget.com/searchnetworking/definition/BGP-Border-Gateway-Protocol">BGP</a></p><p><a href="https://www.cisco.com/c/zh_cn/support/docs/ip/border-gateway-protocol-bgp/5441-aggregation.pdf">了解 BGP 中的路由聚合</a></p><p><a href="https://www.cisco.com/c/zh_cn/support/docs/ip/border-gateway-protocol-bgp/13753-25.pdf">BGP 最佳路径选择算法</a></p><h3 id="Slide"><a href="#Slide" class="headerlink" title="Slide"></a>Slide</h3><hr><h1 id="Batfish"><a href="#Batfish" class="headerlink" title="Batfish"></a>Batfish</h1><h2 id="ACLs-and-firewalls"><a href="#ACLs-and-firewalls" class="headerlink" title="ACLs and firewalls"></a>ACLs and firewalls</h2><p>Analysis Access Control Lists (ACLs) and Firewall Rules are permitting and denying traffic as intended.</p><ul><li>manually checking these rules</li><li>loading them onto a lab device in order to test behaviors on example packets of interest</li></ul><p>-&gt;</p><ul><li>time consuming</li><li>error-prone</li></ul><p>Batfish</p><ul><li>testfilters<ul><li>find how a given flow is treated</li></ul></li><li>searchfilters<ul><li>get guarantees for large spaces of flows</li></ul></li><li>filterLineReachability<ul><li>find unreachable lines</li></ul></li></ul><h2 id="Provably-Safe-ACL-and-Firewall-Changes"><a href="#Provably-Safe-ACL-and-Firewall-Changes" class="headerlink" title="Provably Safe ACL and Firewall Changes"></a>Provably Safe ACL and Firewall Changes</h2><ul><li>block access to critical services</li><li>expose sensitive resources</li></ul><p>Batfish</p><ol><li>Ensure that the intended traffic is not already permitted<ul><li>searchfilters: permit or deny</li></ul></li><li>Ensure that the intended traffic is permitted in the candidate change</li><li>Ensure that no collateral damage has occurred<ul><li>nothing but the intended traffic is impacted by the candidate change</li></ul></li><li>Step 2 again</li><li>Step 3 again</li></ol><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>![](<a href="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Screen">https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Screen</a> Shot 2022-07-20 at 21.28.52.png)</p><p>With Batfish and Pandas you can easily retrieve the exact information you are looking for from the routing tables on ANY or ALL network devices for ANY or ALL VRFs.<br>This concludes the notebook. To recap, in this notebook we covered the foundational tasks for route analysis:</p><ol><li>How to get routes at all nodes in the network or only at a subset of them</li><li>How to retrieve routing entries that match a specific protocol or metric</li><li>How to find which nodes have an entry for a prefix or which ones do not</li></ol><hr><h1 id="Deep-Thinking"><a href="#Deep-Thinking" class="headerlink" title="Deep Thinking"></a>Deep Thinking</h1><p>在一个较大型的数据中心里，应该不会大量使用优先级来过多的影响报文的传播顺序。在本文这样的对于优先级数值单调性非常敏感的情况，可能在实际使用中只会在较为边缘的地方出现优先级不单调的节点配置。这样的话，示例3中的由于节点优先级变为200导致需要撤回已经发送的数据报文的情况就会少且影响范围不大。并且，通过作者举的三个例子可以看到，（如果我们将数据中心网络看作树形），FastPlane的运行流程可以视为一种BFS。由源路由节点作为根，在没有优先级变化的情况下相当于向外逐层拓展，层中根据字典序遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DEFAULT_PREF <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    ASN        <span class="keyword">int</span></span><br><span class="line">    local_pref <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFS</span><span class="params">(n []Node)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(n) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(n, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="comment">// preference check</span></span><br><span class="line">        <span class="comment">// 1. local_pref</span></span><br><span class="line">        <span class="comment">// 2. AS path length (inside BFS)</span></span><br><span class="line">        <span class="comment">// 3. auxiliary lexicographic order</span></span><br><span class="line">        <span class="keyword">if</span> n[i].local_pref == n[j].local_pref &#123;</span><br><span class="line">            <span class="keyword">return</span> n[i].ASN &lt; n[j].ASN</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n[i].local_pref &lt; n[j].local_pref</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// if local preference of node is more than default preference</span></span><br><span class="line">    <span class="comment">// it will be the new root of BFS and run prior BFS on it</span></span><br><span class="line">    <span class="keyword">if</span> n[<span class="number">0</span>].local_pref &gt; DEFAULT_PREF &#123;</span><br><span class="line">        BFS(findNeighbor(n[<span class="number">0</span>]))</span><br><span class="line">        <span class="comment">// remove n[0] from queue for its local_pref</span></span><br><span class="line">        n = n[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// next BFS layer</span></span><br><span class="line">    queue := []Node&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, node := <span class="keyword">range</span> n &#123;</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, findNeighbor(node)...)</span><br><span class="line">    &#125;</span><br><span class="line">    BFS(queue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNeighbor</span><span class="params">(n Node)</span> []<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="comment">// return neighbors of n</span></span><br><span class="line">    <span class="keyword">return</span> []Node&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    source := Node&#123;ASN: <span class="number">1</span>&#125;</span><br><span class="line">    queue := []Node&#123;source&#125;</span><br><span class="line">    BFS(queue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用Go简单表述一下意思。当出现优先级大于默认值100的报文（在这里以节点代替）时，就会出现此节点的抢占情况。由此节点作为根开始抢占运行新的BFS，原优先级的BFS将会在新BFS运行结束后继续运行。</p><p>由于是BFS，且出现非默认优先级通常处于较为边缘的位置，就会出现三种情况：</p><ul><li>整个系统运行后期，出现高优先级报文<ul><li>由于影响较小，仅需要撤回很少的错误报文，造成的额外开销也很小</li></ul></li><li>整个系统运行初期，出现高优先级报文<ul><li>直接以高优先级报文作为新的根开始BFS，从源节点到高优先级报文的节点路径不需要修改，其他节点路径由新的BFS决定</li></ul></li><li>整个系统运行中期，在辐射网中间的边缘位置出现高优先级报文<ul><li>影响较大</li></ul></li></ul><p>从刚才的表述中可以看到，如果说在系统运行前先找出非默认优先级的配置节点，先做由源节点到非默认节点的路径，然后再从此节点开始运行系统就可以。</p><p>仍需要考虑：系统中可能出现100、150、200等多个不同的优先级配置。尽管配置优先级时可以人为控制此因素，但是仍需要考虑100-150-200的初始路径，以及多个200的情况。</p>          </div>]]></content>
    
    <summary type="html">
    
      Note taken down during reading process
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="PAPER" scheme="https://augists.top/tags/PAPER/"/>
    
  </entry>
  
  <entry>
    <title>How to Choose a Suitable Laptop for Freshmen Majoring in Software Engineering</title>
    <link href="https://augists.top/SELF/SHARING/LIFE/how-to-choose-laptop/"/>
    <id>https://augists.top/SELF/SHARING/LIFE/how-to-choose-laptop/</id>
    <published>2022-07-10T11:57:55.000Z</published>
    <updated>2022-07-10T16:00:55.764Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <blockquote><p>这是一篇给远古时代装机猿的<a href="https://www.bilibili.com/video/BV1kZ4y1i7Le?spm_id_from=333.999.0.0&vd_source=970c58530383d2118b4d7ea7b310c0ca">活动</a>的投稿<br>整理了对于 DUT （尤其）软件学院及相似专业的同学对电脑的需求，希望能对相关专业的学生提供参考<br>装机猿的<a href="https://www.bilibili.com/video/BV1Ga411Q78p?spm_id_from=333.999.0.0&vd_source=970c58530383d2118b4d7ea7b310c0ca">活动整理</a><br>（希望我能如愿得到装机猿 T 恤</p></blockquote><hr><blockquote><p>整理了我和周围同学以及工作室里使用的情况</p><p>每个人情况不一样，需求也不同。主要包括三个方面：代码开发、图片视频制作、游戏</p><p>我本人用19款mbp13 次丐版+xbox+switch+云服务器，外接27寸4k60Hz显示器（带65W反向充电c口）（代表低端mac用户）</p><p>同学A用mbp14 次顶配+win 2019款Y7000P+ps5，外接27寸2k75Hz显示器（代表高端mac用户）</p><p>同学B用win游戏本ROG gl504gx（代表win用户）</p><p>同学C用win轻薄本联想Yoga14s（代表win用户）</p><p>同学D用win台式机+win轻薄本（代表普通台式机用户）</p><p>工作室里组的win台式机+NAS+树莓派等（有额外需求的台式机用户）</p><p><strong>需要提的是，计算机专业意味着肯定不会只用一个系统。不管是双系统还是虚拟机等方式，win需要装Linux，mac需要win或主机来打游戏</strong></p></blockquote><h2 id="你在哪所学校和专业"><a href="#你在哪所学校和专业" class="headerlink" title="你在哪所学校和专业"></a>你在哪所学校和专业</h2><p>所有人都来自 大连理工大学 软件学院</p><p>工作室为软件学院DV工作室，负责校区的海报、视频等工作</p><h2 id="平时会用到什么软件"><a href="#平时会用到什么软件" class="headerlink" title="平时会用到什么软件"></a>平时会用到什么软件</h2><ul><li><p>自己（轻度开发，web后端方向，科研）</p><ul><li>终端：Kitty+Terminal（大部分东西例如敲代码、文件管理啥的都转移到终端里了，非GUI）</li><li>浏览器：Safari+Chrome</li><li>聊天工具：QQ、微信、Telegram、腾讯会议等</li><li>敲代码的：终端、VScode、少量使用IDE（如PyCharm）（大型IDE吃配置）</li><li>窗口管理器：yabai+rectangle+amethyst</li><li>数据库：Navicat Premium</li><li>代码辅助：Dash等（不吃性能）</li><li>显示器辅助：smcFanControl（用于风扇超频，电脑接4k输出压力比较大）</li><li>虚拟化：Docker（较吃内存）</li><li>直播：OBS（吃cpu，但是电脑足够用）（用来推流xbox做直播和其他工作室直播）</li><li><strong>在使用Proteus和Altum Designer这种电路设计软件时，用的是别人的win电脑。不过本身专业对这个需求很小，且可以用机房电脑</strong></li><li><strong>matlab使用的是别人的win电脑，mac可以用但是不想让自己的mac受罪。专业对matlab有需求，但是方向上只要不做数模的特定位置就可以避开。我不觉得这个有影响</strong></li></ul></li><li><p>同学A（嵌入式开发转Java开发方向、视频制作、大型游戏）</p><ul><li>主用大型IDE，如IDEA，PyCharm等</li><li>PS、PR、AE、达芬奇等，win本剪辑性能已经不够用，只能满足轻度的视频工作</li><li>3A大作电脑已经不太能带动了，飞行模拟类也跑的很慢，最近刚转到ps5主机</li><li>嵌入式方向会用到例如keil等，需要用串口调试，需要各种接口齐全</li><li>软件学院嵌入式方向人数比较少，很少有人需要考虑这个</li></ul></li><li><p>同学B（轻度开发、产品策划方向、大型游戏）</p><ul><li>玩各种游戏，各种类型都玩。今年的游戏只能跑到1080p的40-50fps</li><li>大型IDE，Visual Studio、PyCharm、Android Studio等</li></ul></li><li><p>同学C（轻度开发、轻度科研、轻度游戏）</p><ul><li>打游戏能明显感觉到显卡带不起来，虽然有一块高清的屏幕但是打游戏还是只能1080p60</li><li>要这2k90只能看视频</li><li>简单开发足够，但是需要多注意一下，例如断电后除了轻度文档工作，基本不太能干啥了</li><li>整理的专业软件清单<ul><li>大一：Dev C++/Codeblock</li><li>大二：Visual Studio/Visual Studio Code</li><li>大三：Pycharm、IntelliJ IDEA/Eclipse</li><li>其他应用：Android Studio、VMWare、Proteus、MATLAB、AD</li></ul></li></ul></li><li><p>同学D（科研，后端开发）</p><ul><li>大型IDE，以Visual Studio、Visual Studio Code、PyCharm为主</li><li>跑深度学习，3060Ti不够用，比较慢，只能跑较简单的模型</li></ul></li><li><p>工作室（视频制作、大型游戏）</p><ul><li>轻度开发，偶尔使用大型IDE</li><li>以PS、PR、AE、达芬奇、LR等为主，在应付学校的海报、视频等设计工作时，正常工作勉强够用。有一次ps工程开大了，临时文件150G多，是搬到我自己的mbp上做的。基本上在达到<code>.psb</code>级别或者中度视频剪辑任务（4k60少轨道或1080p60多轨道）的时候，渲染开1/4就比较勉强。如果是个人的小活还是可以的</li></ul></li></ul><h2 id="需要什么配置"><a href="#需要什么配置" class="headerlink" title="需要什么配置"></a>需要什么配置</h2><ul><li>自己<ul><li>unix系的系统（mac或Linux）</li><li>16G+的内存，目前的内存影响较大，SWAP区有时候可以用到10G以上</li><li>显卡带的动外接4k显示器，雷电或USB4</li><li>CPU上没有遇到明显的瓶颈，编译速度慢这一点影响不大</li><li>存储比较小，自己还用到1T机械盘+500G固态盘（另外还有1T机械盘+1T专用固态拓展盘给xbox装游戏）</li></ul></li></ul><h2 id="装的啥配置"><a href="#装的啥配置" class="headerlink" title="装的啥配置"></a>装的啥配置</h2><ul><li><p>自己</p><ul><li>19款macbook pro 13<ul><li>8代i5 1.4GHz 四核</li><li>8G LPDDR3 2133MHz</li><li>Intel Iris Plus Graphics 645</li></ul></li></ul></li><li><p>同学A</p><ul><li><p>14寸macbook pro</p><ul><li>m1pro，10核中央处理器，14核图形处理器，16核神经网络引擎</li><li>32G统一内存</li><li>1T SSD</li></ul></li><li><p>19款联想Y9000P</p><ul><li>i7-9750H</li><li>8G</li><li>1T SSD</li><li>GTX 1660Ti</li><li>15.6英寸 1080p144Hz</li></ul></li></ul></li><li><p>同学B</p><ul><li>ROG gl504gx 19款</li></ul></li><li><p>同学C</p><ul><li><p>联想Yoga14s</p><ul><li>i5-11300H</li><li>MX450</li><li>2880p</li><li>他觉得是当时5k档最好的笔记本</li></ul></li><li><p>大学头两年有一个微星游戏本</p><ul><li>9代i7</li><li>1660Ti</li><li>南桥有问题修不好</li><li>嫌弃太沉，换了轻薄本</li></ul></li></ul></li><li><p>同学D</p><ul><li><p>台式机</p><ul><li>cpu i7 10700k 加九州风神360水冷</li><li>主板华硕TUFB56QQM-PWA</li><li>显卡 铭瑄电竞之心3060ti</li><li>内存海盗船16G*3200l两条</li><li>WD固态硬盘 1T 海盗船VS650</li></ul></li><li><p>轻薄本为19款华为matebook pro x</p><ul><li>散热大问题，CPU和主板也有问题，一般做轻度ppt、word等任务</li><li>触控屏很舒服，3000*2000分辨率</li></ul></li></ul></li><li><p>工作室</p><ul><li><p>台式机</p><ul><li>i5 6500</li><li>双1070，STI，偶尔接三1080p屏组 nvidia surround</li><li>4*8G内存条DDR4</li><li>其他配置已无法查证，电脑比较老，学校资产</li><li>这台电脑一直我在用</li><li>接群晖DS1511+，2T*5，用于工作室素材存储和工程备份</li></ul></li><li><p>树莓派4B</p><ul><li>4G内存，专门用做网络代理和简单Linux服务器</li><li>放在这里主要为了说<strong>专业内设备多而杂，入学买的电脑不代表固定死，需求的解决方案可以有很多</strong></li></ul></li></ul></li></ul><h2 id="如何进行优化"><a href="#如何进行优化" class="headerlink" title="如何进行优化"></a>如何进行优化</h2><ul><li><p>mac</p><ul><li>14寸macbook pro，m1pro+32G内存<ul><li>性能已经足够完美，同学A的这款学生优惠后2w，没有遇到过任何性能瓶颈（除了不能打游戏），开虚拟机也没有什么影响</li><li>唯一差的一点在于如果要走例如计算机视觉方向，对GPU需求会提高。一般可以用到实验室的服务器或者使用colab的免费显卡</li></ul></li><li>13寸新macbook air，m2<ul><li>对于刚入学的同学来说，不管哪一款mac的性能都已经足够了。可能内存需要加一下，尽量上16G内存或者更高（目前不清楚m2还会不会有刷内存的情况）</li></ul></li></ul></li><li><p>win</p><ul><li>买mac<ul><li>有非常多当时买了win，对打游戏需求没有特别大的同学都后悔没有买mac，并且大三出现了大面积换14寸或16寸mbp的情况</li><li>软件工程专业，基本可以无脑选mac，即便是后面想做AI方向，也可以通过其他方式补足</li></ul></li><li>游戏本<ul><li><strong>如果有游戏需求，按照游戏需求选就可以了</strong>。专业软件性能需求基本都可以满足，深度学习性能需求没有上限。所以根据游戏需求来就行</li><li>如果想要做硬件相关的，例如嵌入式方向，就需要找一个接口齐全的win本。通常被迫购买游戏本，还经常需要到处搬（很惨</li></ul></li><li>台式机<ul><li>台式机的同学说再给他一次机会，他一定买mac</li><li>深度学习的性能需求没有上限，而且对于大多数情况，都可以使用实验室的服务器来跑</li></ul></li></ul></li></ul>          </div>]]></content>
    
    <summary type="html">
    
      This is an analysis of the computer needs of software engineering students, and it encompasses most of the different computer needs around me.&lt;br&gt;Hopefully it will help you!
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Yan DP Analysis</title>
    <link href="https://augists.top/NOTES/CODE_LANGUAGE/Yan-DP-Analysis/"/>
    <id>https://augists.top/NOTES/CODE_LANGUAGE/Yan-DP-Analysis/</id>
    <published>2022-06-21T02:28:16.000Z</published>
    <updated>2022-06-21T03:29:37.454Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h1 id="闫氏DP分析法"><a href="#闫氏DP分析法" class="headerlink" title="闫氏DP分析法"></a>闫氏DP分析法</h1><p><img src="https://cdn.acwing.com/media/article/image/2020/03/23/27426_73d9c53a6c-2.png" alt=""></p><p><a href="https://www.acwing.com/activity/content/code/content/246257/">示例</a></p><h2 id="dp问题的下标"><a href="#dp问题的下标" class="headerlink" title="dp问题的下标"></a>dp问题的下标</h2><ol><li>若状态转移方程中有<code>dp[i - 1]</code>这种状态, 下标(状态转移那部分代码)尽量从1开始</li><li>否则就最好从0开始</li></ol><h2 id="dp问题的时间复杂度"><a href="#dp问题的时间复杂度" class="headerlink" title="dp问题的时间复杂度"></a>dp问题的时间复杂度</h2><p>状态数量(n^几个约束维度) * 转移状态的时间复杂(状态转移代码的时间复杂度)</p><h2 id="dp的集合划分依据-gt-寻找最后一个不同操作"><a href="#dp的集合划分依据-gt-寻找最后一个不同操作" class="headerlink" title="dp的集合划分依据 -&gt; 寻找最后一个不同操作"></a>dp的集合划分依据 -&gt; 寻找最后一个不同操作</h2><p>eg. 加不加这个背包, 数字三角形最后一步是由左边还是右边走过来的呀(根据操作的不同来对集合进行划分)<br>使得划分之后的小集合可以递推求出当前集合, 且最小集合已知</p><p>集合划分要不漏，但是不一定不重。当dp数组维护的特性是集合的max或min时，集合划分可以有重复（最长公共子序列）</p><ol><li><code>dp[i][j]</code>维护的是a字符串的前i个字符组成的字符串和b字符串前j个字符组成的字符串的公共子序列的最大长度，应该按照端点划分为：含不含a的第i个字符和含不含b的第j个字符，共分为四个部分。<code>dp[i][j-1]+dp[i-1][j]+dp[i-1][j-1]+1+dp[i-1][j-1]</code>大于<code>dp[i][j]</code></li><li>如果是求max或min的话，A和B集合有重合部分，同样只需要单独求后再取一次最值就可以</li></ol><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/406072/">链接</a></p>          </div>]]></content>
    
    <summary type="html">
    
      How to analyse DP problem?
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
  </entry>
  
  <entry>
    <title>Read and Write Mutex in Operating System</title>
    <link href="https://augists.top/NOTES/CODE_LANGUAGE/GOLANG/Read-and-Write-Mutex-in-Operating-System/"/>
    <id>https://augists.top/NOTES/CODE_LANGUAGE/GOLANG/Read-and-Write-Mutex-in-Operating-System/</id>
    <published>2022-05-15T10:51:38.000Z</published>
    <updated>2022-05-16T08:00:01.012Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在操作系统的进程管理中，会遇到有关同步和互斥的问题，其中读写就是一种非常经典的同步问题</p><p>通常我们在对数据访问权限进行限制时，会要求：</p><ul><li>写时不可读</li><li>写时不可写</li><li>读时不可写</li><li>读时可以读</li></ul><p>也就是说，为了防止不一致的情况出现，只会允许同时的读数据，而禁止其他的操作同时发生</p><h2 id="常规实现"><a href="#常规实现" class="headerlink" title="常规实现"></a>常规实现</h2><p>这里使用一个 <code>count</code> 记录正在进行读操作的进程数量，一个互斥量 <code>count_mutex</code> 用于对 <code>count</code> 加锁，一个互斥量 <code>data_mutex</code> 用于对读写操作的数据加锁<br>可以写出第一种进程读写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        read();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当有 reader 读（第一个 reader 进入后），会给 data 上锁，从而使得 writer 无法对数据进行修改。只有当所有 reader 都读完后，才会释放 <code>data_mutex</code> 锁。这就会导致当一直有读进程时，writer 无法拿到 <code>data_mutex</code> 锁，造成写饥饿<br>换种思路来理解，当 writer 因为没有拿到 <code>data_mutex</code> 锁而在排队等待时，reader 可以通过不拿锁进行插队</p><h2 id="读写公平"><a href="#读写公平" class="headerlink" title="读写公平"></a>读写公平</h2><p>那么，如何才能拒绝 reader 的插队，实现读写公平</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore balance = <span class="number">1</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;balance)</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        up(&amp;balance)</span><br><span class="line">        read();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;balance)</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">        up(&amp;balance)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过增加互斥量 <code>balance</code> 让 writer 在进入时先抢占 <code>balance</code> 锁，从而使后续到达的 reader 因为无法抢占到 <code>balance</code> 锁而排在 writer 后面无法插队，实现了读写的公平<br>这样，writer 到达后会等待前面的 reader 读完，将 <code>data_mutex</code> 释放后修改数据，即读写操作下的 FIFO</p><h2 id="深入和案例思考"><a href="#深入和案例思考" class="headerlink" title="深入和案例思考"></a>深入和案例思考</h2><p>但是，我觉得以上的讨论都没有把读写的频率和读写的消耗考虑进去。例如，在算法题中，如果对数据只进行少量修改，更多的需要读取时，我们会使用空间来换取时间，维护一个方便读的结构来提高效率<br>通常来说，读可能更重要，更普遍，而且更快，或者说需要它更快<br>举个<a href="https://www.bilibili.com/video/BV1kA4y1Q7tD?spm_id_from=333.337.search-card.all.click">之前看到的实例</a>。如果让你去构建一个 Twitter 后端，你如何设计后台的数据存储方式。你需要考虑，当用户量很大时，对于同一条推文的阅读会以数量级增多。<br>那么，可能会让推文的读提前拿出来交给所有的 followers，让他们能更快速的读，而不是去每个 following 看看是否有新的推文。这时，读就显得尤其重要，值得用空间来换取时间。这种情况下，读写锁就不再需要考虑公平，因为是一对一的读写<br>但是，如果这个人是个 follower 很大的用户，显然就无法将新推文维护到所有 followers 里。此时，就只能让每个 follower 都去他的 following 里读数据。这种情况下，读写锁就是一写N读。你需要考虑读带来的损耗，是否值得让所有读都去等待写进程的完成，写是否需要等待所有读都将锁释放掉再开始<br>分布式的存储是否可以将读写进行分离，从而不再需要读写锁，只进行分布式系统之间的同步<br>除此之外，脏读也是需要考虑的一环。如果读写的平衡是读可以无视写，仅读取旧数据，那是不是就会有不同的 follower 同时读到新旧不同的推文</p><h2 id="Copy-on-Write-机制"><a href="#Copy-on-Write-机制" class="headerlink" title="Copy-on-Write 机制"></a>Copy-on-Write 机制</h2><p>还有一种 Copy-on-Write 的方式来实现对于读写的分离，达到类似的效果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mutex_;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;data&gt; <span class="title">G_data</span><span class="params">(<span class="keyword">new</span> data())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;data&gt; Temp;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        Temp = G_data;</span><br><span class="line">    &#125;</span><br><span class="line">    Temp-&gt;read_something();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!G_data.unique())&#123;</span><br><span class="line">        G_data.reset(<span class="keyword">new</span> data(*G_data));</span><br><span class="line">    &#125;</span><br><span class="line">    G_data-&gt;write_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们现在有一个 ThreadA 为读线程，有一个 ThreadB 为写线程，ThreadA 去执行 <code>read()</code>, 其中首先把构造防止锁外, 减小锁的粒度以及保证异常安全, 在得到锁后进行赋值。<br>此时 <code>G_data</code> 引用计数为 2, 现在 ThreadA 执行至 <code>read_something()</code> 之前, guard 作用域之后<br>ThreadB 此时得到锁，进行 <code>unique()</code>, 因为 ThreadA 执行了拷贝, 所以 <code>unique()</code> 返回 false, 进入 if 中,这就是关键所在<br>进行拷贝, 并对 <code>G_data</code> 进行 <code>reset</code>, 此时两个线程持有的是不同的 <code>shared_ptr</code>, ThreadA 对旧数据进行读取, 而 ThreadB 对新数据进行修改, 这时显然其它再有的读线程无法持有锁, 其持有锁时 ThreadB 已经修改完毕，这样就做到了避免写锁中的饥饿问题<br>有些人看到后可能会觉得眼熟, 这其实类似于 linux 内核中的 RCU(read-copy-update) 锁, RCU 的核心理念其实就是读线程访问时，写线程可以去更新保护数据的副本，但写线程需要等待所有读线程完成读取后，才可以删除老对象</p><p>其实去年我的病毒学大作业中有一个就是 DirtyCOW 漏洞，通过 linux 中的 Copy-on-Write 机制的漏洞来实现提权，只是一直对 Copy-on-Write 机制不是很了解</p><h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p>在 Java8 中引入了一种新的机制，StampedLock 类，是对读写锁 ReentrantReadWriteLock 的增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = sl.writeLock();    <span class="comment">//涉及对共享资源的修改，使用写锁-独占操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sl.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用乐观读锁访问共享资源</span></span><br><span class="line"><span class="comment">     * 注意：乐观读锁在保证数据一致性上需要拷贝一份要操作的变量到方法栈，并且在操作数据时候可能其他写线程已经修改了数据，</span></span><br><span class="line"><span class="comment">     * 而我们操作的是方法栈里面的数据，也就是一个快照，所以最多返回的不是最新的数据，但是一致性还是得到保障的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = sl.tryOptimisticRead();    <span class="comment">// 使用乐观读锁</span></span><br><span class="line">        <span class="keyword">double</span> currentX = x, currentY = y;      <span class="comment">// 拷贝共享资源到本地方法栈中</span></span><br><span class="line">        <span class="keyword">if</span> (!sl.validate(stamp)) &#123;              <span class="comment">// 如果有写锁被占用，可能造成数据不一致，所以要切换到普通读锁模式</span></span><br><span class="line">            stamp = sl.readLock();             </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123; <span class="comment">// upgrade</span></span><br><span class="line">        <span class="comment">// Could instead start with optimistic, not read mode</span></span><br><span class="line">        <span class="keyword">long</span> stamp = sl.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp);  <span class="comment">//读锁转换为写锁</span></span><br><span class="line">                <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123;</span><br><span class="line">                    stamp = ws;</span><br><span class="line">                    x = newX;</span><br><span class="line">                    y = newY;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                    stamp = sl.writeLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sl.unlock(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try 系列获取锁的函数，当获取锁失败后会返回为 0 的 stamp 值。当调用释放锁和转换锁的方法时候需要传入获取锁时候返回的 stamp 值。<br>StampedLockd 的内部实现是基于 CLH 锁的，CLH 锁原理：锁维护着一个等待线程队列，所有申请锁且失败的线程都记录在队列。一个节点代表一个线程，保存着一个标记位 locked, 用以判断当前线程是否已经释放锁。当一个线程试图获取锁时，从队列尾节点作为前序节点，循环判断所有的前序节点是否已经成功释放锁。</p><p>可以看到，这里使用了乐观锁的概念。乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p><ul><li>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</li><li>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</li></ul><p>可以看到，示例中的 <code>distanceFromOrigin</code> 方法使用饿了乐观读锁，使得读写可以并发执行。乐观读也是在实现 Copy-on-Write 机制，它遵循以下模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.tryOptimisticRead();  <span class="comment">// 非阻塞获取版本信息</span></span><br><span class="line">copyVaraibale2ThreadMemory();           <span class="comment">// 拷贝变量到线程本地堆栈</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;              <span class="comment">// 校验</span></span><br><span class="line">    <span class="keyword">long</span> stamp = lock.readLock();       <span class="comment">// 获取读锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        copyVaraibale2ThreadMemory();   <span class="comment">// 拷贝变量到线程本地堆栈</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock(stamp);              <span class="comment">// 释放悲观锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">useThreadMemoryVarables();              <span class="comment">// 使用线程本地堆栈里面的数据进行操作</span></span><br></pre></td></tr></table></figure><h2 id="Golang-源码"><a href="#Golang-源码" class="headerlink" title="Golang 源码"></a>Golang 源码</h2><p>可以在 <code>/usr/local/go/src/sync</code> 中查看 rwmutex.go 的源码</p><blockquote><p>A RWMutex is a reader/writer mutual exclusion lock.<br>The lock can be held by an arbitrary number of readers or a single writer.<br>The zero value for a RWMutex is an unlocked mutex.</p></blockquote><p>可以在 Golang 的注释里看到，它采用的是读写公平的加锁方式</p><blockquote><p>If a goroutine holds a RWMutex for reading and another goroutine might<br>call Lock, no goroutine should expect to be able to acquire a read lock<br>until the initial read lock is released. In particular, this prohibits<br>recursive read locking. This is to ensure that the lock eventually becomes<br>available; a blocked Lock call excludes new readers from acquiring the<br>lock.</p></blockquote><p>其中对于 RWMutex 的定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w           Mutex  <span class="comment">// held if there are pending writers</span></span><br><span class="line">    writerSem   <span class="keyword">uint32</span> <span class="comment">// semaphore for writers to wait for completing readers</span></span><br><span class="line">    readerSem   <span class="keyword">uint32</span> <span class="comment">// semaphore for readers to wait for completing writers</span></span><br><span class="line">    readerCount <span class="keyword">int32</span>  <span class="comment">// number of pending readers</span></span><br><span class="line">    readerWait  <span class="keyword">int32</span>  <span class="comment">// number of departing readers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reader 的最大数量被定义为 <code>1 &lt;&lt; 30</code><br>而 happens-before 关系可以表示为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Unlock  -&gt; Lock:  readerSem</span><br><span class="line">Unlock  -&gt; RLock: readerSem</span><br><span class="line">RUnlock -&gt; Lock:  writerSem</span><br></pre></td></tr></table></figure><p>当读者进入后，会调用 <code>rw.w.Lock()</code>，使后续不再有读者可以读取数据，并通过</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line"><span class="comment">// Wait for active readers.</span></span><br><span class="line"><span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">    runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来等待当前的读进程的结束，而写进程完成后 <code>Unlock()</code> 将所有在等待中的 reader 唤醒</p><p>读进程 <code>RLock()</code> 在 <code>rw.w.state</code> 后，进行 <code>atomic.AddInt32(&amp;rw.readerCount, 1) &lt; 0</code> 的判断，如果有写进程正在执行，就会通过 runtime 把自己加入到读的等待队列中去</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#_2-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98">CS NOTE</a><br><a href="https://blog.csdn.net/wuli_xin/article/details/103794404">PV经典问题之读写者问题</a><br><a href="https://blog.csdn.net/weixin_43705457/article/details/104150455">读写锁中的饥饿问题</a><br><a href="https://cloud.tencent.com/developer/article/1470988">一篇文章搞定——JDK8中新增的StampedLock</a><br><a href="https://www.bilibili.com/video/BV1kA4y1Q7tD?spm_id_from=333.337.search-card.all.click">马斯克都要把twitter买了，要不来学一下twitter的架构？</a></p>          </div>]]></content>
    
    <summary type="html">
    
      How to write an optimized PV operation for reading and writing
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="OS" scheme="https://augists.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Pass Value or Reference in Golang</title>
    <link href="https://augists.top/NOTES/CODE_LANGUAGE/GOLANG/pass-value-or-reference-in-Golang/"/>
    <id>https://augists.top/NOTES/CODE_LANGUAGE/GOLANG/pass-value-or-reference-in-Golang/</id>
    <published>2022-04-19T05:35:35.000Z</published>
    <updated>2022-04-19T07:13:24.581Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>昨天在写 LeetCode 39 的时候，遇到了一个奇怪的问题，会自动让我的 <code>res</code> 在返回的时候发生变化<br>按照意思简单复原一下部分代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> r []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    res = [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    r = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    solve(<span class="number">5</span>)</span><br><span class="line">    fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solve</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    r = <span class="built_in">append</span>(r, i)</span><br><span class="line">    r[<span class="number">0</span>] = i</span><br><span class="line">    res = <span class="built_in">append</span>(res, r)</span><br><span class="line">    solve(i - <span class="number">1</span>)</span><br><span class="line">    r = r[:<span class="built_in">len</span>(r)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，最终输出的 <code>res</code> 里变量非常奇怪<br>这个情况主要由于 Golang 中的切片以及在函数参数传递的过程中发生的浅拷贝</p><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>我们可以把切片理解为一个结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice <span class="keyword">struct</span> &#123;</span><br><span class="line">  data  <span class="keyword">uintptr</span></span><br><span class="line">  <span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">  <span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片的浅拷贝是指，当它在赋值时，相当于创建了新的副本，结构体中的三个变量的值进行了复制。也就是说，虽然指向的是同一个 data 地址，并且 len 和 cap 都相同，但是从二级指针的角度来看，是一个新的变量了<br>而 append 虽然它直接被写成了汇编，但是它的实现是在切片存储的数据小于 1024 时进行 cap 翻倍，在大于时扩容到 1.25 倍。如果发生了切片的扩容，就会返回一个新开辟的内存空间用来存放数据；否则就会返回原地址</p><h2 id="Pass"><a href="#Pass" class="headerlink" title="Pass"></a>Pass</h2><p>对于 Golang 的函数传参是传值还是传引用一直都有争议。有人把变量分成了值类型和引用类型。但是实际上，通过上面对于 Slice 的拷贝可以看到，Golang 对于函数传参一直都是传值。但是值得注意的是，虽然在不发生扩容的情况下在函数中修改切片的内容会反馈到原切片（由于 data 指针），但是切片的 len 和 cap 都是在函数中创建了新的拷贝<br>也就是说，如果有如下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAppend</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  nums := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">  myAppend(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，尽管在 <code>myAppend</code> 中对于 nums 添加 1 成功反馈给了 <code>main</code> 中的 nums，但是由于 <code>main</code> 中 nums 的 len 仍为 3，所以如果这时输出 nums，会发现似乎对它并没有任何反馈的影响</p><hr><p>回到开头的例子。由于 res 可以看作二级指针，而 r 可以看作一级指针，这就导致对 r 仍然在 len 中的元素的修改会影响到最终的 res 的结果，而若由于 append 发生了扩容，后续就会使用新的切片地址，就不会对原切片产生影响</p>          </div>]]></content>
    
    <summary type="html">
    
      A discussion about passing to function in Golang origin from `res = append(res, r)`
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="GOLANG" scheme="https://augists.top/tags/GOLANG/"/>
    
  </entry>
  
  <entry>
    <title>Nil Pointer Error in Golang During webChat Development on Database</title>
    <link href="https://augists.top/SELF/ERROR/nil-pointer-error-in-golang-during-webChat-development-on-database/"/>
    <id>https://augists.top/SELF/ERROR/nil-pointer-error-in-golang-during-webChat-development-on-database/</id>
    <published>2022-03-26T03:19:08.000Z</published>
    <updated>2022-03-30T02:36:13.747Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>前几天在进行 <a href="https://github.com/Augists/webChat">webChat</a> 的 Server 端的数据库部分代码调试的时候，一直被一个奇怪的错误缠着。</p><p>我在前面全局变量里声明了数据库引擎的指针</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  DBdriver = <span class="string">&quot;mysql&quot;</span></span><br><span class="line">  DBinfo   = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">  DBengine *xorm.Engine</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后在数据库初始化时</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DBengine, err := xorm.NewEngine(DBdriver, DBinfo)</span><br></pre></td></tr></table></figure><p>因为 golang 在一定程度上对变量类型进行了弱化，添加了类似于 C++ 中的 auto 对类型进行自动判断，所以为了区分新变量，Go 中使用 <code>:=</code> 运算符作为新变量开辟并初始化的标志<br>例如这里，将 <code>xorm.NewEngine</code> 函数的返回值赋给新变量。由于 Go 中函数可以进行多返回值，当左值中存在新变量时，就需要使用 <code>:=</code><br>在这里就产生了歧义。err 是新的局部变量，同时 DBengine 也被编译器认为是新本地变量，这就使得这行代码并没有给全局的 DBengine 进行赋值<br>所以即使进行了初始化，全局变量中的 DBengine 依旧为 nil</p><p>解决的方法其实也不难，在这之前将 err 创建好就可以消除误解了</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">DBengine, err = xorm.NewEngine(DBdriver, DBinfo)</span><br></pre></td></tr></table></figure><p>这算一个比较隐性的 bug，不是很容易被发现。我感觉，这是由于 Go 对于语法及特性妥协导致的，这种情况必定会导致歧义，如果让编译器将这种情况处理为先去寻找是否有更高层级已经声明的变量 DBengine 并优先赋值，将会使得这种情况只能通过修改变量命名来解决局部与全局的冲突，亦或局部声明 <code>var DBengine *xorm.Engine</code><br>我感觉后一种逻辑更容易理解吧，想尝试在 Go 社区中提 issue 询问一下</p><p>解释：<br>当同一包名下存在多个文件时，如果 complier 在检索完局部变量后再去检索全局变量，并优先对全局变量赋值而不是创建新变量，那么如果在同名包的别的文件里对变量进行了定义，就会对 coder 造成很大的问题</p><p>详细内容可见<a href="https://forum.golangbridge.org/t/some-thought-about-while-creating-a-new-variable/26874/4">Go Forum</a></p>          </div>]]></content>
    
    <summary type="html">
    
      During the developing process of Database Engine of webChat, an undiscoverable error occured&lt;br&gt;and I blamed it on golang itself
    
    </summary>
    
    
    
      <category term="CODE" scheme="https://augists.top/tags/CODE/"/>
    
      <category term="ERROR" scheme="https://augists.top/tags/ERROR/"/>
    
      <category term="GOLANG" scheme="https://augists.top/tags/GOLANG/"/>
    
  </entry>
  
  <entry>
    <title>Watch Later or Store in History List</title>
    <link href="https://augists.top/SELF/SHARING/LIFE/watch-later-or-store-in-history-list/"/>
    <id>https://augists.top/SELF/SHARING/LIFE/watch-later-or-store-in-history-list/</id>
    <published>2022-02-03T15:57:55.000Z</published>
    <updated>2022-02-04T04:39:35.402Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>今天在 xbox 上看游戏的时候，突然有注意到一个“稍后再玩”的 list。同样在 b 站上，也有一个“稍后再看”的 list<br>其实 我早先的习惯是使用历史记录来做存储。如果看到一个想要保留的视频内容以后在看，我都是点进去看几秒确认一下就退出来，这样它就会自动被添加到历史记录里了。再加上有整理历史记录的习惯，偶尔进去把没用的删掉，提醒自己看完想看的视频<br>我的很多会员账号是与别人一起使用的，例如 Netflix，Apple Music 等等，定期清理历史记录对我而言既麻烦又有必要，所以这个习惯坚持了挺长时间的<br>它有一点问题，历史记录通常都不是无限长的，过于久远的历史记录会被清理掉，并且早期 b 站手机端是不能看到专栏的历史记录的，这也使得能够存储的条目莫名其妙的变少<br>现在开始使用“稍后再看”，但是里面只能存放 100 个，目前我一直是在 80 个左右“稍后再看”的视频<br>比较难受的一点是，如果想要把视频添加到“稍后再看”，需要点进视频，在没有最大化视频的情况下，点击右上角的三个点，选择添加到“稍后再看”，步骤非常繁琐<br>并且如果有空闲时间可以去看看自己之前存储过的视频时，在网页端，需要在收藏的最下面才能找到“稍后再看”列表。删除列表中刚刚看完的视频也需要从视频中退出来<br>我感觉，watch or play later 这个功能并没有像它名字那样美好，入口和常用功能都比较繁琐</p>          </div>]]></content>
    
    <summary type="html">
    
      When I have something to watch later, I should throw it into watch-later or store in history list&lt;br&gt; Compare these two
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Google RE2 Syntax</title>
    <link href="https://augists.top/NOTES/CODE_LANGUAGE/RE2Syntax/"/>
    <id>https://augists.top/NOTES/CODE_LANGUAGE/RE2Syntax/</id>
    <published>2022-01-20T06:37:37.000Z</published>
    <updated>2022-01-20T06:45:06.524Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>Regular expressions are a notation fordescribing sets of character strings.When a particular string is in the setdescribed by a regular expression,we often say that the regular expression<i>matches</i>the string.</p><p>The simplest regular expression is a single literal character.Except for the metacharacters like<code>*+?()|</code>,characters match themselves.To match a metacharacter, escape it witha backslash:<code>\+</code>matches a literal plus character.</p><p>Two regular expressions can be alternated or concatenated to form a newregular expression:if <i>e</i><sub>1</sub> matches<i>s</i>and <i>e</i><sub>2</sub> matches<i>t</i>,then <i>e</i><sub>1</sub><code>|</code><i>e</i><sub>2</sub> matches<i>s</i>or<i>t</i>,and<i>e</i><sub>1</sub><i>e</i><sub>2</sub>matches<i>st</i>.</p><p>The metacharacters<code>*</code>,<code>+</code>,and<code>?</code>are repetition operators:<i>e</i><sub>1</sub><code>*</code>matches a sequence of zero or more (possibly different)strings, each of which match <i>e</i><sub>1</sub>;<i>e</i><sub>1</sub><code>+</code>matches one or more;<i>e</i><sub>1</sub><code>?</code>matches zero or one.</p><p>The operator precedence, from weakest to strongest binding, isfirst alternation, then concatenation, and finally therepetition operators.Explicit parentheses can be used to force different meanings,just as in arithmetic expressions.Some examples:<code>ab|cd</code>is equivalent to<code>(ab)|(cd)</code>;<code>ab*</code>is equivalent to<code>a(b*)</code>.</p><p>The syntax described so far is most of the traditional Unix<i>egrep</i>regular expression syntax.This subset suffices to describe all regularlanguages: loosely speaking, a regular language is a setof strings that can be matched in a single pass throughthe text using only a fixed amount of memory.Newer regular expression facilities (notably Perl andthose that have copied it) have addedmany new operators and escape sequences, which make the regularexpressions more concise, and sometimes more cryptic, but usuallynot more powerful.</p><p>This page lists the regular expression syntax accepted by RE2.<p>It also lists some syntax accepted by PCRE, PERL, and VIM.<table><tr><th>kinds of single-character expressions</th><th>examples</th></tr><tr><td>any character, possibly including newline (s=true)</td><td><code>.</code></td></tr><tr><td>character class</td><td><code>[xyz]</code></td></tr><tr><td>negated character class</td><td><code>[^xyz]</code></td></tr><tr><td>Perl character class <a href="#perl">(link)</a></td><td><code>\d</code></td></tr><tr><td>negated Perl character class</td><td><code>\D</code></td></tr><tr><td>ASCII character class <a href="#ascii">(link)</a></td><td><code>[[:alpha:]]</code></td></tr><tr><td>negated ASCII character class</td><td><code>[[:^alpha:]]</code></td></tr><tr><td>Unicode character class (one-letter name)</td><td><code>\pN</code></td></tr><tr><td>Unicode character class</td><td><code>\p&#123;Greek&#125;</code></td></tr><tr><td>negated Unicode character class (one-letter name)</td><td><code>\PN</code></td></tr><tr><td>negated Unicode character class</td><td><code>\P&#123;Greek&#125;</code></td></tr></table><table><tr><th></th><th>Composites</th></tr><tr><td><code>xy</code></td><td><code>x</code> followed by <code>y</code></td></tr><tr><td><code>x|y</code></td><td><code>x</code> or <code>y</code> (prefer <code>x</code>)</td></tr></table><table><tr><th></th><th>Repetitions</th></tr><tr><td><code>x*</code></td><td>zero or more <code>x</code>, prefer more</td></tr><tr><td><code>x+</code></td><td>one or more <code>x</code>, prefer more</td></tr><tr><td><code>x?</code></td><td>zero or one <code>x</code>, prefer one</td></tr><tr><td><code>x&#123;n,m&#125;</code></td><td><code>n</code> or <code>n</code>+1 or ... or <code>m</code> <code>x</code>, prefer more</td></tr><tr><td><code>x&#123;n,&#125;</code></td><td><code>n</code> or more <code>x</code>, prefer more</td></tr><tr><td><code>x&#123;n&#125;</code></td><td>exactly <code>n</code> <code>x</code></td></tr><tr><td><code>x*?</code></td><td>zero or more <code>x</code>, prefer fewer</td></tr><tr><td><code>x+?</code></td><td>one or more <code>x</code>, prefer fewer</td></tr><tr><td><code>x??</code></td><td>zero or one <code>x</code>, prefer zero</td></tr><tr><td><code>x&#123;n,m&#125;?</code></td><td><code>n</code> or <code>n</code>+1 or ... or <code>m</code> <code>x</code>, prefer fewer</td></tr><tr><td><code>x&#123;n,&#125;?</code></td><td><code>n</code> or more <code>x</code>, prefer fewer</td></tr><tr><td><code>x&#123;n&#125;?</code></td><td>exactly <code>n</code> <code>x</code></td></tr><tr><td><font color='#808080'><code>x&#123;&#125;</code></font></td><td>(≡ <code>x*</code>) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>x&#123;-&#125;</code></font></td><td>(≡ <code>x*?</code>) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>x&#123;-n&#125;</code></font></td><td>(≡ <code>x&#123;n&#125;?</code>) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>x=</code></font></td><td>(≡ <code>x?</code>) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr></table><p>Implementation restriction: The counting forms <code>x&#123;n,m&#125;</code>, <code>x&#123;n,&#125;</code>, and <code>x&#123;n&#125;</code> reject forms that create a minimum or maximum repetition count above 1000. Unlimited repetitions are not subject to this restriction.<table><tr><th></th><th>Possessive repetitions</th></tr><tr><td><font color='#808080'><code>x*+</code></font></td><td>zero or more <code>x</code>, possessive <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>x++</code></font></td><td>one or more <code>x</code>, possessive <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>x?+</code></font></td><td>zero or one <code>x</code>, possessive <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>x&#123;n,m&#125;+</code></font></td><td><code>n</code> or ... or <code>m</code> <code>x</code>, possessive <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>x&#123;n,&#125;+</code></font></td><td><code>n</code> or more <code>x</code>, possessive <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>x&#123;n&#125;+</code></font></td><td>exactly <code>n</code> <code>x</code>, possessive <small>(NOT SUPPORTED)</small></td></tr></table><table><tr><th></th><th>Grouping</th></tr><tr><td><code>(re)</code></td><td>numbered capturing group (submatch)</td></tr><tr><td><code>(?P&lt;name&gt;re)</code></td><td>named & numbered capturing group (submatch)</td></tr><tr><td><font color='#808080'><code>(?&lt;name&gt;re)</code></font></td><td>named & numbered capturing group (submatch) <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?'name're)</code></font></td><td>named & numbered capturing group (submatch) <small>(NOT SUPPORTED)</small></td></tr><tr><td><code>(?:re)</code></td><td>non-capturing group</td></tr><tr><td><code>(?flags)</code></td><td>set flags within current group; non-capturing</td></tr><tr><td><code>(?flags:re)</code></td><td>set flags during re; non-capturing</td></tr><tr><td><font color='#808080'><code>(?#text)</code></font></td><td>comment <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?|x|y|z)</code></font></td><td>branch numbering reset <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?&gt;re)</code></font></td><td>possessive match of <code>re</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>re@&gt;</code></font></td><td>possessive match of <code>re</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>%(re)</code></font></td><td>non-capturing group <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr></table><p><a name="flags"></a></p><table><tr><th></th><th>Flags</th></tr><tr><td><code>i</code></td><td>case-insensitive (default false)</td></tr><tr><td><code>m</code></td><td>multi-line mode: <code>^</code> and <code>$</code> match begin/end line in addition to begin/end text (default false)</td></tr><tr><td><code>s</code></td><td>let <code>.</code> match <code>\n</code> (default false)</td></tr><tr><td><code>U</code></td><td>ungreedy: swap meaning of <code>x*</code> and <code>x*?</code>, <code>x+</code> and <code>x+?</code>, etc (default false)</td></tr></table><p>Flag syntax is <code>xyz</code> (set) or <code>-xyz</code> (clear) or <code>xy-z</code> (set <code>xy</code>, clear <code>z</code>).<table><tr><th></th><th>Empty strings</th></tr><tr><td><code>^</code></td><td>at beginning of text or line (<code>m</code>=true)</td></tr><tr><td><code>$</code></td><td>at end of text (like <code>\z</code> not <code>\Z</code>) or line (<code>m</code>=true)</td></tr><tr><td><code>\A</code></td><td>at beginning of text</td></tr><tr><td><code>\b</code></td><td>at ASCII word boundary (<code>\w</code> on one side and <code>\W</code>, <code>\A</code>, or <code>\z</code> on the other)</td></tr><tr><td><code>\B</code></td><td>not at ASCII word boundary</td></tr><tr><td><font color='#808080'><code>\g</code></font></td><td>at beginning of subtext being searched <small>(NOT SUPPORTED)</small> <small>PCRE</small></td></tr><tr><td><font color='#808080'><code>\G</code></font></td><td>at end of last match <small>(NOT SUPPORTED)</small> <small>PERL</small></td></tr><tr><td><font color='#808080'><code>\Z</code></font></td><td>at end of text, or before newline at end of text <small>(NOT SUPPORTED)</small></td></tr><tr><td><code>\z</code></td><td>at end of text</td></tr><tr><td><font color='#808080'><code>(?=re)</code></font></td><td>before text matching <code>re</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?!re)</code></font></td><td>before text not matching <code>re</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?&lt;=re)</code></font></td><td>after text matching <code>re</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?&lt;!re)</code></font></td><td>after text not matching <code>re</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>re&amp;</code></font></td><td>before text matching <code>re</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>re@=</code></font></td><td>before text matching <code>re</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>re@!</code></font></td><td>before text not matching <code>re</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>re@&lt;=</code></font></td><td>after text matching <code>re</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>re@&lt;!</code></font></td><td>after text not matching <code>re</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\zs</code></font></td><td>sets start of match (= \K) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\ze</code></font></td><td>sets end of match <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%^</code></font></td><td>beginning of file <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%$</code></font></td><td>end of file <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%V</code></font></td><td>on screen <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%#</code></font></td><td>cursor position <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%'m</code></font></td><td>mark <code>m</code> position <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%23l</code></font></td><td>in line 23 <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%23c</code></font></td><td>in column 23 <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%23v</code></font></td><td>in virtual column 23 <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr></table><table><tr><th></th><th>Escape sequences</th></tr><tr><td><code>\a</code></td><td>bell (≡ <code>\007</code>)</td></tr><tr><td><code>\f</code></td><td>form feed (≡ <code>\014</code>)</td></tr><tr><td><code>\t</code></td><td>horizontal tab (≡ <code>\011</code>)</td></tr><tr><td><code>\n</code></td><td>newline (≡ <code>\012</code>)</td></tr><tr><td><code>\r</code></td><td>carriage return (≡ <code>\015</code>)</td></tr><tr><td><code>\v</code></td><td>vertical tab character (≡ <code>\013</code>)</td></tr><tr><td><code>\*</code></td><td>literal <code>*</code>, for any punctuation character <code>*</code></td></tr><tr><td><code>\123</code></td><td>octal character code (up to three digits)</td></tr><tr><td><code>\x7F</code></td><td>hex character code (exactly two digits)</td></tr><tr><td><code>\x&#123;10FFFF&#125;</code></td><td>hex character code</td></tr><tr><td><code>\C</code></td><td>match a single byte even in UTF-8 mode</td></tr><tr><td><code>\Q...\E</code></td><td>literal text <code>...</code> even if <code>...</code> has punctuation</td></tr><tr><td><font color='#808080'><code>\1</code></font></td><td>backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\b</code></font></td><td>backspace <small>(NOT SUPPORTED)</small> (use <code>\010</code>)</td></tr><tr><td><font color='#808080'><code>\cK</code></font></td><td>control char ^K <small>(NOT SUPPORTED)</small> (use <code>\001</code> etc)</td></tr><tr><td><font color='#808080'><code>\e</code></font></td><td>escape <small>(NOT SUPPORTED)</small> (use <code>\033</code>)</td></tr><tr><td><font color='#808080'><code>\g1</code></font></td><td>backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\g&#123;1&#125;</code></font></td><td>backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\g&#123;+1&#125;</code></font></td><td>backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\g&#123;-1&#125;</code></font></td><td>backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\g&#123;name&#125;</code></font></td><td>named backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\g&lt;name&gt;</code></font></td><td>subroutine call <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\g'name'</code></font></td><td>subroutine call <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\k&lt;name&gt;</code></font></td><td>named backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\k'name'</code></font></td><td>named backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\lX</code></font></td><td>lowercase <code>X</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\ux</code></font></td><td>uppercase <code>x</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\L...\E</code></font></td><td>lowercase text <code>...</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\K</code></font></td><td>reset beginning of <code>$0</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\N&#123;name&#125;</code></font></td><td>named Unicode character <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\R</code></font></td><td>line break <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\U...\E</code></font></td><td>upper case text <code>...</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\X</code></font></td><td>extended Unicode sequence <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\%d123</code></font></td><td>decimal character 123 <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%xFF</code></font></td><td>hex character FF <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%o123</code></font></td><td>octal character 123 <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%u1234</code></font></td><td>Unicode character 0x1234 <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%U12345678</code></font></td><td>Unicode character 0x12345678 <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr></table><table><tr><th></th><th>Character class elements</th></tr><tr><td><code>x</code></td><td>single character</td></tr><tr><td><code>A-Z</code></td><td>character range (inclusive)</td></tr><tr><td><code>\d</code></td><td>Perl character class</td></tr><tr><td><code>[:foo:]</code></td><td>ASCII character class <code>foo</code></td></tr><tr><td><code>\p&#123;Foo&#125;</code></td><td>Unicode character class <code>Foo</code></td></tr><tr><td><code>\pF</code></td><td>Unicode character class <code>F</code> (one-letter name)</td></tr></table><table><tr><th></th><th>Named character classes as character class elements</th></tr><tr><td><code>[\d]</code></td><td>digits (≡ <code>\d</code>)</td></tr><tr><td><code>[^\d]</code></td><td>not digits (≡ <code>\D</code>)</td></tr><tr><td><code>[\D]</code></td><td>not digits (≡ <code>\D</code>)</td></tr><tr><td><code>[^\D]</code></td><td>not not digits (≡ <code>\d</code>)</td></tr><tr><td><code>[[:name:]]</code></td><td>named ASCII class inside character class (≡ <code>[:name:]</code>)</td></tr><tr><td><code>[^[:name:]]</code></td><td>named ASCII class inside negated character class (≡ <code>[:^name:]</code>)</td></tr><tr><td><code>[\p&#123;Name&#125;]</code></td><td>named Unicode property inside character class (≡ <code>\p&#123;Name&#125;</code>)</td></tr><tr><td><code>[^\p&#123;Name&#125;]</code></td><td>named Unicode property inside negated character class (≡ <code>\P&#123;Name&#125;</code>)</td></tr></table><p><a name="perl"></a></p><table><tr><th></th><th>Perl character classes (all ASCII-only)</th></tr><tr><td><code>\d</code></td><td>digits (≡ <code>[0-9]</code>)</td></tr><tr><td><code>\D</code></td><td>not digits (≡ <code>[^0-9]</code>)</td></tr><tr><td><code>\s</code></td><td>whitespace (≡ <code>[\t\n\f\r ]</code>)</td></tr><tr><td><code>\S</code></td><td>not whitespace (≡ <code>[^\t\n\f\r ]</code>)</td></tr><tr><td><code>\w</code></td><td>word characters (≡ <code>[0-9A-Za-z_]</code>)</td></tr><tr><td><code>\W</code></td><td>not word characters (≡ <code>[^0-9A-Za-z_]</code>)</td></tr><tr><td><font color='#808080'><code>\h</code></font></td><td>horizontal space <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\H</code></font></td><td>not horizontal space <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\v</code></font></td><td>vertical space <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\V</code></font></td><td>not vertical space <small>(NOT SUPPORTED)</small></td></tr></table><p><a name="ascii"></a></p><table><tr><th></th><th>ASCII character classes</th></tr><tr><td><code>[[:alnum:]]</code></td><td>alphanumeric (≡ <code>[0-9A-Za-z]</code>)</td></tr><tr><td><code>[[:alpha:]]</code></td><td>alphabetic (≡ <code>[A-Za-z]</code>)</td></tr><tr><td><code>[[:ascii:]]</code></td><td>ASCII (≡ <code>[\x00-\x7F]</code>)</td></tr><tr><td><code>[[:blank:]]</code></td><td>blank (≡ <code>[\t ]</code>)</td></tr><tr><td><code>[[:cntrl:]]</code></td><td>control (≡ <code>[\x00-\x1F\x7F]</code>)</td></tr><tr><td><code>[[:digit:]]</code></td><td>digits (≡ <code>[0-9]</code>)</td></tr><tr><td><code>[[:graph:]]</code></td><td>graphical (≡ <code>[!-~]</code> ≡ <code>[A-Za-z0-9!"#$%&amp;'()*+,\-./:;&lt;=&gt;?@[\\\]^_</code><code>`</code><code>&#123;|&#125;~]</code>)</td></tr><tr><td><code>[[:lower:]]</code></td><td>lower case (≡ <code>[a-z]</code>)</td></tr><tr><td><code>[[:print:]]</code></td><td>printable (≡ <code>[ -~]</code> ≡ <code>[ [:graph:]]</code>)</td></tr><tr><td><code>[[:punct:]]</code></td><td>punctuation (≡ <code>[!-/:-@[-</code><code>`</code><code>&#123;-~]</code>)</td></tr><tr><td><code>[[:space:]]</code></td><td>whitespace (≡ <code>[\t\n\v\f\r ]</code>)</td></tr><tr><td><code>[[:upper:]]</code></td><td>upper case (≡ <code>[A-Z]</code>)</td></tr><tr><td><code>[[:word:]]</code></td><td>word characters (≡ <code>[0-9A-Za-z_]</code>)</td></tr><tr><td><code>[[:xdigit:]]</code></td><td>hex digit (≡ <code>[0-9A-Fa-f]</code>)</td></tr></table><table><tr><th></th><th>Unicode character class names--general category</th></tr><tr><td><code>C</code></td><td>other</td></tr><tr><td><code>Cc</code></td><td>control</td></tr><tr><td><code>Cf</code></td><td>format</td></tr><tr><td><font color='#808080'><code>Cn</code></font></td><td>unassigned code points <small>(NOT SUPPORTED)</small></td></tr><tr><td><code>Co</code></td><td>private use</td></tr><tr><td><code>Cs</code></td><td>surrogate</td></tr><tr><td><code>L</code></td><td>letter</td></tr><tr><td><font color='#808080'><code>LC</code></font></td><td>cased letter <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>L&amp;</code></font></td><td>cased letter <small>(NOT SUPPORTED)</small></td></tr><tr><td><code>Ll</code></td><td>lowercase letter</td></tr><tr><td><code>Lm</code></td><td>modifier letter</td></tr><tr><td><code>Lo</code></td><td>other letter</td></tr><tr><td><code>Lt</code></td><td>titlecase letter</td></tr><tr><td><code>Lu</code></td><td>uppercase letter</td></tr><tr><td><code>M</code></td><td>mark</td></tr><tr><td><code>Mc</code></td><td>spacing mark</td></tr><tr><td><code>Me</code></td><td>enclosing mark</td></tr><tr><td><code>Mn</code></td><td>non-spacing mark</td></tr><tr><td><code>N</code></td><td>number</td></tr><tr><td><code>Nd</code></td><td>decimal number</td></tr><tr><td><code>Nl</code></td><td>letter number</td></tr><tr><td><code>No</code></td><td>other number</td></tr><tr><td><code>P</code></td><td>punctuation</td></tr><tr><td><code>Pc</code></td><td>connector punctuation</td></tr><tr><td><code>Pd</code></td><td>dash punctuation</td></tr><tr><td><code>Pe</code></td><td>close punctuation</td></tr><tr><td><code>Pf</code></td><td>final punctuation</td></tr><tr><td><code>Pi</code></td><td>initial punctuation</td></tr><tr><td><code>Po</code></td><td>other punctuation</td></tr><tr><td><code>Ps</code></td><td>open punctuation</td></tr><tr><td><code>S</code></td><td>symbol</td></tr><tr><td><code>Sc</code></td><td>currency symbol</td></tr><tr><td><code>Sk</code></td><td>modifier symbol</td></tr><tr><td><code>Sm</code></td><td>math symbol</td></tr><tr><td><code>So</code></td><td>other symbol</td></tr><tr><td><code>Z</code></td><td>separator</td></tr><tr><td><code>Zl</code></td><td>line separator</td></tr><tr><td><code>Zp</code></td><td>paragraph separator</td></tr><tr><td><code>Zs</code></td><td>space separator</td></tr></table><table><tr><th>Unicode character class names--scripts</th></tr><tr><td><code>Adlam</code></td></tr><tr><td><code>Ahom</code></td></tr><tr><td><code>Anatolian_Hieroglyphs</code></td></tr><tr><td><code>Arabic</code></td></tr><tr><td><code>Armenian</code></td></tr><tr><td><code>Avestan</code></td></tr><tr><td><code>Balinese</code></td></tr><tr><td><code>Bamum</code></td></tr><tr><td><code>Bassa_Vah</code></td></tr><tr><td><code>Batak</code></td></tr><tr><td><code>Bengali</code></td></tr><tr><td><code>Bhaiksuki</code></td></tr><tr><td><code>Bopomofo</code></td></tr><tr><td><code>Brahmi</code></td></tr><tr><td><code>Braille</code></td></tr><tr><td><code>Buginese</code></td></tr><tr><td><code>Buhid</code></td></tr><tr><td><code>Canadian_Aboriginal</code></td></tr><tr><td><code>Carian</code></td></tr><tr><td><code>Caucasian_Albanian</code></td></tr><tr><td><code>Chakma</code></td></tr><tr><td><code>Cham</code></td></tr><tr><td><code>Cherokee</code></td></tr><tr><td><code>Chorasmian</code></td></tr><tr><td><code>Common</code></td></tr><tr><td><code>Coptic</code></td></tr><tr><td><code>Cuneiform</code></td></tr><tr><td><code>Cypriot</code></td></tr><tr><td><code>Cypro_Minoan</code></td></tr><tr><td><code>Cyrillic</code></td></tr><tr><td><code>Deseret</code></td></tr><tr><td><code>Devanagari</code></td></tr><tr><td><code>Dives_Akuru</code></td></tr><tr><td><code>Dogra</code></td></tr><tr><td><code>Duployan</code></td></tr><tr><td><code>Egyptian_Hieroglyphs</code></td></tr><tr><td><code>Elbasan</code></td></tr><tr><td><code>Elymaic</code></td></tr><tr><td><code>Ethiopic</code></td></tr><tr><td><code>Georgian</code></td></tr><tr><td><code>Glagolitic</code></td></tr><tr><td><code>Gothic</code></td></tr><tr><td><code>Grantha</code></td></tr><tr><td><code>Greek</code></td></tr><tr><td><code>Gujarati</code></td></tr><tr><td><code>Gunjala_Gondi</code></td></tr><tr><td><code>Gurmukhi</code></td></tr><tr><td><code>Han</code></td></tr><tr><td><code>Hangul</code></td></tr><tr><td><code>Hanifi_Rohingya</code></td></tr><tr><td><code>Hanunoo</code></td></tr><tr><td><code>Hatran</code></td></tr><tr><td><code>Hebrew</code></td></tr><tr><td><code>Hiragana</code></td></tr><tr><td><code>Imperial_Aramaic</code></td></tr><tr><td><code>Inherited</code></td></tr><tr><td><code>Inscriptional_Pahlavi</code></td></tr><tr><td><code>Inscriptional_Parthian</code></td></tr><tr><td><code>Javanese</code></td></tr><tr><td><code>Kaithi</code></td></tr><tr><td><code>Kannada</code></td></tr><tr><td><code>Katakana</code></td></tr><tr><td><code>Kayah_Li</code></td></tr><tr><td><code>Kharoshthi</code></td></tr><tr><td><code>Khitan_Small_Script</code></td></tr><tr><td><code>Khmer</code></td></tr><tr><td><code>Khojki</code></td></tr><tr><td><code>Khudawadi</code></td></tr><tr><td><code>Lao</code></td></tr><tr><td><code>Latin</code></td></tr><tr><td><code>Lepcha</code></td></tr><tr><td><code>Limbu</code></td></tr><tr><td><code>Linear_A</code></td></tr><tr><td><code>Linear_B</code></td></tr><tr><td><code>Lisu</code></td></tr><tr><td><code>Lycian</code></td></tr><tr><td><code>Lydian</code></td></tr><tr><td><code>Mahajani</code></td></tr><tr><td><code>Makasar</code></td></tr><tr><td><code>Malayalam</code></td></tr><tr><td><code>Mandaic</code></td></tr><tr><td><code>Manichaean</code></td></tr><tr><td><code>Marchen</code></td></tr><tr><td><code>Masaram_Gondi</code></td></tr><tr><td><code>Medefaidrin</code></td></tr><tr><td><code>Meetei_Mayek</code></td></tr><tr><td><code>Mende_Kikakui</code></td></tr><tr><td><code>Meroitic_Cursive</code></td></tr><tr><td><code>Meroitic_Hieroglyphs</code></td></tr><tr><td><code>Miao</code></td></tr><tr><td><code>Modi</code></td></tr><tr><td><code>Mongolian</code></td></tr><tr><td><code>Mro</code></td></tr><tr><td><code>Multani</code></td></tr><tr><td><code>Myanmar</code></td></tr><tr><td><code>Nabataean</code></td></tr><tr><td><code>Nandinagari</code></td></tr><tr><td><code>New_Tai_Lue</code></td></tr><tr><td><code>Newa</code></td></tr><tr><td><code>Nko</code></td></tr><tr><td><code>Nushu</code></td></tr><tr><td><code>Nyiakeng_Puachue_Hmong</code></td></tr><tr><td><code>Ogham</code></td></tr><tr><td><code>Ol_Chiki</code></td></tr><tr><td><code>Old_Hungarian</code></td></tr><tr><td><code>Old_Italic</code></td></tr><tr><td><code>Old_North_Arabian</code></td></tr><tr><td><code>Old_Permic</code></td></tr><tr><td><code>Old_Persian</code></td></tr><tr><td><code>Old_Sogdian</code></td></tr><tr><td><code>Old_South_Arabian</code></td></tr><tr><td><code>Old_Turkic</code></td></tr><tr><td><code>Old_Uyghur</code></td></tr><tr><td><code>Oriya</code></td></tr><tr><td><code>Osage</code></td></tr><tr><td><code>Osmanya</code></td></tr><tr><td><code>Pahawh_Hmong</code></td></tr><tr><td><code>Palmyrene</code></td></tr><tr><td><code>Pau_Cin_Hau</code></td></tr><tr><td><code>Phags_Pa</code></td></tr><tr><td><code>Phoenician</code></td></tr><tr><td><code>Psalter_Pahlavi</code></td></tr><tr><td><code>Rejang</code></td></tr><tr><td><code>Runic</code></td></tr><tr><td><code>Samaritan</code></td></tr><tr><td><code>Saurashtra</code></td></tr><tr><td><code>Sharada</code></td></tr><tr><td><code>Shavian</code></td></tr><tr><td><code>Siddham</code></td></tr><tr><td><code>SignWriting</code></td></tr><tr><td><code>Sinhala</code></td></tr><tr><td><code>Sogdian</code></td></tr><tr><td><code>Sora_Sompeng</code></td></tr><tr><td><code>Soyombo</code></td></tr><tr><td><code>Sundanese</code></td></tr><tr><td><code>Syloti_Nagri</code></td></tr><tr><td><code>Syriac</code></td></tr><tr><td><code>Tagalog</code></td></tr><tr><td><code>Tagbanwa</code></td></tr><tr><td><code>Tai_Le</code></td></tr><tr><td><code>Tai_Tham</code></td></tr><tr><td><code>Tai_Viet</code></td></tr><tr><td><code>Takri</code></td></tr><tr><td><code>Tamil</code></td></tr><tr><td><code>Tangsa</code></td></tr><tr><td><code>Tangut</code></td></tr><tr><td><code>Telugu</code></td></tr><tr><td><code>Thaana</code></td></tr><tr><td><code>Thai</code></td></tr><tr><td><code>Tibetan</code></td></tr><tr><td><code>Tifinagh</code></td></tr><tr><td><code>Tirhuta</code></td></tr><tr><td><code>Toto</code></td></tr><tr><td><code>Ugaritic</code></td></tr><tr><td><code>Vai</code></td></tr><tr><td><code>Vithkuqi</code></td></tr><tr><td><code>Wancho</code></td></tr><tr><td><code>Warang_Citi</code></td></tr><tr><td><code>Yezidi</code></td></tr><tr><td><code>Yi</code></td></tr><tr><td><code>Zanabazar_Square</code></td></tr></table><table><tr><th></th><th>Vim character classes</th></tr><tr><td><font color='#808080'><code>\i</code></font></td><td>identifier character <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\I</code></font></td><td><code>\i</code> except digits <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\k</code></font></td><td>keyword character <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\K</code></font></td><td><code>\k</code> except digits <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\f</code></font></td><td>file name character <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\F</code></font></td><td><code>\f</code> except digits <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\p</code></font></td><td>printable character <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\P</code></font></td><td><code>\p</code> except digits <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\s</code></font></td><td>whitespace character (≡ <code>[ \t]</code>) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\S</code></font></td><td>non-white space character (≡ <code>[^ \t]</code>) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><code>\d</code></td><td>digits (≡ <code>[0-9]</code>) <small>VIM</small></td></tr><tr><td><code>\D</code></td><td>not <code>\d</code> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\x</code></font></td><td>hex digits (≡ <code>[0-9A-Fa-f]</code>) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\X</code></font></td><td>not <code>\x</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\o</code></font></td><td>octal digits (≡ <code>[0-7]</code>) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\O</code></font></td><td>not <code>\o</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><code>\w</code></td><td>word character <small>VIM</small></td></tr><tr><td><code>\W</code></td><td>not <code>\w</code> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\h</code></font></td><td>head of word character <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\H</code></font></td><td>not <code>\h</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\a</code></font></td><td>alphabetic <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\A</code></font></td><td>not <code>\a</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\l</code></font></td><td>lowercase <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\L</code></font></td><td>not lowercase <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\u</code></font></td><td>uppercase <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\U</code></font></td><td>not uppercase <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\_x</code></font></td><td><code>\x</code> plus newline, for any <code>x</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\c</code></font></td><td>ignore case <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\C</code></font></td><td>match case <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\m</code></font></td><td>magic <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\M</code></font></td><td>nomagic <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\v</code></font></td><td>verymagic <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\V</code></font></td><td>verynomagic <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\Z</code></font></td><td>ignore differences in Unicode combining characters <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr></table><table><tr><th></th><th>Magic</th></tr><tr><td><font color='#808080'><code>(?&#123;code&#125;)</code></font></td><td>arbitrary Perl code <small>(NOT SUPPORTED)</small> <small>PERL</small></td></tr><tr><td><font color='#808080'><code>(??&#123;code&#125;)</code></font></td><td>postponed arbitrary Perl code <small>(NOT SUPPORTED)</small> <small>PERL</small></td></tr><tr><td><font color='#808080'><code>(?n)</code></font></td><td>recursive call to regexp capturing group <code>n</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?+n)</code></font></td><td>recursive call to relative group <code>+n</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?-n)</code></font></td><td>recursive call to relative group <code>-n</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?C)</code></font></td><td>PCRE callout <small>(NOT SUPPORTED)</small> <small>PCRE</small></td></tr><tr><td><font color='#808080'><code>(?R)</code></font></td><td>recursive call to entire regexp (≡ <code>(?0)</code>) <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?&amp;name)</code></font></td><td>recursive call to named group <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?P=name)</code></font></td><td>named backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?P&gt;name)</code></font></td><td>recursive call to named group <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?(cond)true|false)</code></font></td><td>conditional branch <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?(cond)true)</code></font></td><td>conditional branch <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*ACCEPT)</code></font></td><td>make regexps more like Prolog <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*COMMIT)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*F)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*FAIL)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*MARK)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*PRUNE)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*SKIP)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*THEN)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*ANY)</code></font></td><td>set newline convention <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*ANYCRLF)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*CR)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*CRLF)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*LF)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*BSR_ANYCRLF)</code></font></td><td>set \R convention <small>(NOT SUPPORTED)</small> <small>PCRE</small></td></tr><tr><td><font color='#808080'><code>(*BSR_UNICODE)</code></font></td><td><small>(NOT SUPPORTED)</small> <small>PCRE</small></td></tr></table>          </div>]]></content>
    
    <summary type="html">
    
      Google RE2 Syntax&lt;br&gt;RE2 is a fast, safe, thread-friendly alternative to backtracking regular expression engines
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="REGEX" scheme="https://augists.top/tags/REGEX/"/>
    
  </entry>
  
  <entry>
    <title>Why My Devices Cannot Automatically Connect to Mbp</title>
    <link href="https://augists.top/SELF/SHARING/LIFE/Why-my-devices-cannot-automatically-connect-to-mbp/"/>
    <id>https://augists.top/SELF/SHARING/LIFE/Why-my-devices-cannot-automatically-connect-to-mbp/</id>
    <published>2022-01-10T12:27:43.000Z</published>
    <updated>2022-01-10T13:00:39.981Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>早先的无线设备大多使用的是 2.4G 无线接收器来进行传输，例如之前使用的罗技 M370 和 ikbc poker，并且耳机也一直用着 3.5mm 的音频线，可以说对蓝牙真无线一直没有接触很多<br>自从去年换用了 HHKB，经常需要使用蓝牙来进行连接。前几天又买了罗技的 mx master 2s 作为在家里使用的过渡品，耳机也改为了无线蓝牙来进行传输，蓝牙自动连接的问题就一直在困扰着我</p><div class="note danger">            <p>为什么我在唤醒电脑之后，只有耳机自动连接了电脑，另外两个都无法连接</p>          </div><p>我们知道，在点击系统 menu bar 上的蓝牙小图标时，如果按住 <code>option</code> 再点，会显示详细信息；旧版本的系统在按住 <code>shift + option</code> 点击时，可以重置蓝牙模块（现在好像没有了<br>恰巧我再查看的时候，注意到我的电脑蓝牙开关下有一行小字写着 <code>Discoverable: off</code><br>我就感觉不是很对劲</p><p>根据 ssh 心跳包的理解，我们可以猜测，耳机由于没有关机并且是音频设备，可能会一直用心跳包来维持蓝牙的连接<br>而键盘和鼠标都有长时间不用自动断电的功能<br>由于 mac 的蓝牙被设定为不可以被发现，所以当电脑不是主动去发现并连接设备时，设备的主动尝试连接失效</p><p>解决方案是：可以在 <code>系统偏好设置 - Sharing - Bluetooth Sharing</code> 将其勾选打开，这样电脑就允许被其他设备通过蓝牙进行扫描发现了</p>          </div>]]></content>
    
    <summary type="html">
    
      After getting more wireless connectivity devices, I have unfortunately found that my Bluetooth devices have a high probability of not connecting every time I wake up my Macbook Pro.&lt;br&gt; At first I thought it was the fault of HHKB, but now I am temporarily a fan of bluetooth wireless&lt;br&gt; I bought a Logi master 2s as my new mouse to cope with the use of scenarios at home&lt;br&gt; Also my Audio-Technica headphones also changed to wireless mode&lt;br&gt; Just now I wake up my mac and only headphones connected&lt;br&gt; It really bothered me for a long time
    
    </summary>
    
    
    
      <category term="MAC" scheme="https://augists.top/tags/MAC/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>AODV Analysis</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/AODV-Source-Code-Analysis/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/AODV-Source-Code-Analysis/</id>
    <published>2022-01-03T15:26:34.000Z</published>
    <updated>2022-01-03T15:31:07.219Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h1 id="AODV-协议基本原理及工作流程"><a href="#AODV-协议基本原理及工作流程" class="headerlink" title="AODV 协议基本原理及工作流程"></a>AODV 协议基本原理及工作流程</h1><h2 id="AODV-简介"><a href="#AODV-简介" class="headerlink" title="AODV 简介"></a>AODV 简介</h2><blockquote><p>The Ad hoc On-Demand Distance Vector (AODV) algorithm enables<br>dynamic, self-starting, multihop routing between participating mobile<br>nodes wishing to establish and maintain an ad hoc network.  AODV<br>allows mobile nodes to obtain routes quickly for new destinations,<br>and does not require nodes to maintain routes to destinations that<br>are not in active communication.  AODV allows mobile nodes to respond<br>to link breakages and changes in network topology in a timely manner.<br>The operation of AODV is loop-free, and by avoiding the Bellman-Ford<br>“counting to infinity” problem offers quick convergence when the ad<br>hoc network topology changes (typically, when a node moves in the<br>network).  When links break, AODV causes the affected set of nodes to<br>be notified so that they are able to invalidate the routes using the<br>lost link.</p></blockquote><p>One distinguishing feature of AODV is its use of a destination<br>sequence number for each route entry.  The destination sequence<br>number is created by the destination to be included along with any<br>route information it sends to requesting nodes.  Using destination<br>sequence numbers ensures loop freedom and is simple to program.<br>Given the choice between two routes to a destination, a requesting<br>node is required to select the one with the greatest sequence number.</p><p>AODV uses the following fields with each route table entry:</p><ul><li>Destination IP Address</li><li>Destination Sequence Number</li><li>Valid Destination Sequence Number flag</li><li>Other state and routing flags (e.g., valid, invalid, repairable, being repaired)</li><li>Network Interface</li><li>Hop Count (number of hops needed to reach destination)</li><li>Next Hop</li><li>List of Precursors (described in Section 6.2)</li><li>Lifetime (expiration or deletion time of the route)</li></ul><hr><h2 id="AODV-特点"><a href="#AODV-特点" class="headerlink" title="AODV 特点"></a>AODV 特点</h2><ul><li>接入速度快</li><li>计算量小</li><li>内存占用低</li><li>网络负载轻</li></ul><p>疑问🤔️：AODV 协议通过管理 sequence number 来在有多个有效路由的情况下进行决策，每使用过一次 sequence number+1，并以此来表示节点的新鲜程度，选择 sequence number 较大的有效路由。这样难道不会导致积压、增大负载吗？感觉并不是一个合理的方案</p><hr><h2 id="AODV-Message-Type"><a href="#AODV-Message-Type" class="headerlink" title="AODV Message Type"></a>AODV Message Type</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* AODV Message types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_HELLO 0 <span class="comment">/* Really never used as a separate type... */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_RREQ 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_RREP 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_RERR 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_RREP_ACK 4</span></span><br></pre></td></tr></table></figure><hr><h2 id="AODV-文件树分析"><a href="#AODV-文件树分析" class="headerlink" title="AODV 文件树分析"></a>AODV 文件树分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── ChangeLog</span><br><span class="line">├── GPL</span><br><span class="line">├── Makefile</span><br><span class="line">├── README</span><br><span class="line">├── README.ns</span><br><span class="line">├── TODO</span><br><span class="line">├── aodv_hello.c</span><br><span class="line">├── aodv_hello.h</span><br><span class="line">├── aodv_neighbor.c</span><br><span class="line">├── aodv_neighbor.h</span><br><span class="line">├── aodv_rerr.c</span><br><span class="line">├── aodv_rerr.h</span><br><span class="line">├── aodv_rrep.c</span><br><span class="line">├── aodv_rrep.h</span><br><span class="line">├── aodv_rreq.c</span><br><span class="line">├── aodv_rreq.h</span><br><span class="line">├── aodv_socket.c</span><br><span class="line">├── aodv_socket.h</span><br><span class="line">├── aodv_timeout.c</span><br><span class="line">├── aodv_timeout.h</span><br><span class="line">├── debug.c</span><br><span class="line">├── debug.h</span><br><span class="line">├── defs.h</span><br><span class="line">├── endian.c</span><br><span class="line">├── list.c</span><br><span class="line">├── list.h</span><br><span class="line">├── llf.c</span><br><span class="line">├── llf.h</span><br><span class="line">├── lnx</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── TAGS</span><br><span class="line">│   ├── kaodv-debug.c</span><br><span class="line">│   ├── kaodv-debug.h</span><br><span class="line">│   ├── kaodv-expl.c</span><br><span class="line">│   ├── kaodv-expl.h</span><br><span class="line">│   ├── kaodv-ipenc.c</span><br><span class="line">│   ├── kaodv-ipenc.h</span><br><span class="line">│   ├── kaodv-mod.c</span><br><span class="line">│   ├── kaodv-mod.h</span><br><span class="line">│   ├── kaodv-netlink.c</span><br><span class="line">│   ├── kaodv-netlink.h</span><br><span class="line">│   ├── kaodv-queue.c</span><br><span class="line">│   ├── kaodv-queue.h</span><br><span class="line">│   └── kaodv.h</span><br><span class="line">├── locality.c</span><br><span class="line">├── locality.h</span><br><span class="line">├── main.c</span><br><span class="line">├── nl.c</span><br><span class="line">├── nl.h</span><br><span class="line">├── params.h</span><br><span class="line">├── patches</span><br><span class="line">│   ├── ns-2.26-aodv-uu-0.8.patch</span><br><span class="line">│   ├── ns-2.27-aodv-uu-0.8.patch</span><br><span class="line">│   ├── ns-2.27-aodv-uu-0.9.1.patch</span><br><span class="line">│   ├── ns-2.27-aodv-uu-0.9.patch</span><br><span class="line">│   ├── ns-2.28-aodv-uu-0.9.1.patch</span><br><span class="line">│   ├── ns-2.29-aodv-uu-0.9.1-dsr-uu-0.2-oolsr-0.99.15.patch</span><br><span class="line">│   ├── ns-2.29.3-aodv-uu-0.9.2.patch</span><br><span class="line">│   └── ns-2.32-aodv-uu.patch</span><br><span class="line">├── rfc3561.txt</span><br><span class="line">├── routing_table.c</span><br><span class="line">├── routing_table.h</span><br><span class="line">├── seek_list.c</span><br><span class="line">├── seek_list.h</span><br><span class="line">├── tags</span><br><span class="line">├── timer_queue.c</span><br><span class="line">└── timer_queue.h</span><br><span class="line"></span><br><span class="line">2 directories, 65 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过在 AODV 项目根目录下运行 <code>tree</code> 可以得到如上面代码块中的结果。项目中共有65个文件，其中通过分析 Makefile 文件中的编译链接方式我们可以看到，AODV 项目共提供了两大方向，分别为 ns-2 模拟器运行和实际运行服务。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SRC =  main.c list.c debug.c timer_queue.c aodv_socket.c aodv_hello.c \</span><br><span class="line">  aodv_neighbor.c aodv_timeout.c routing_table.c seek_list.c \</span><br><span class="line">  aodv_rreq.c aodv_rrep.c aodv_rerr.c nl.c</span><br><span class="line"></span><br><span class="line">SRC_NS =   debug.c list.c timer_queue.c aodv_socket.c aodv_hello.c \</span><br><span class="line">    aodv_neighbor.c aodv_timeout.c routing_table.c seek_list.c \</span><br><span class="line">    aodv_rreq.c aodv_rrep.c aodv_rerr.c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里，SRC 是为实际运行使用的 c 文件，而 SRC_NS 是在 NS 模拟器中编译需要使用的文件。在这次对 AODV 源代码分析的过程中，我们只关注于它运用在实践中的代码部分。所以不仅是 SRC_NS 的文件，在 SRC 的文件中如果遇到例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NS_PORT</span></span><br><span class="line"><span class="comment">/* code */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>我们都可以将其化简。</p><p>这样，我们将所有需要查看的源代码文件根据我们定下的阅读顺序进行了分类，如下表所示：</p><ul><li>Preparation<ul><li>params.h: AODV 运行时的参数定义</li><li>defs.h: 包含了 AODV 代码中的主要宏定义，例如 <code>MINTTL</code>、AODV message type 等全局宏定义，以及对主机和网卡设备的信息结构体 <code>host_info</code> 和<code>dev_info</code></li><li>list.{c|h}: 对循环双链表结构 <code>list_t</code> 的定义及操作</li><li>timer_queue.{c|h}: 定时器 <code>timer</code> 的定义及操作，依托于 <code>list_t</code> 循环双链表进行串联</li><li>routing_table.{c|h}: 路由表的定义及操作</li><li>endian.c: 对于硬件和操作系统的大小端的定义，被应用于 aodv 结构体内变量顺序</li></ul></li><li>AODV Message<ul><li>aodv_hello.{c|h}: </li><li>aodv_neighbor.{c|h}:</li><li>aodv_rreq.{c|h}:</li><li>aodv_rrep.{c|h}:</li><li>aodv_rerr.{c|h}:</li><li>aodv_socket.{c|h}:</li><li>aodv_timeout.{c|h}:</li></ul></li><li>Main<ul><li>llf.{c|h}: 链路层反馈</li><li>locality.{c|h}: 寻找目的地的方位</li><li>nl.{c|h}: AODV 协议专用套接字</li><li>seek_list.{c|h}: RREQ寻找的目的地链表</li><li>main.c: 协议初始化和运行</li></ul></li></ul><hr><h2 id="define-do-while-0"><a href="#define-do-while-0" class="headerlink" title="#define do while (0)"></a><code>#define do while (0)</code></h2><p><a href="https://www.linuxidc.com/Linux/2014-10/108520.htm">C语言宏定语执行多条语句一般都会用 do { … } while (0)</a></p><hr><h2 id="list-c"><a href="#list-c" class="headerlink" title="list.c"></a><code>list.c</code></h2><ul><li><code>list.c</code> 文件是所有<strong>循环双链表</strong> 操作，有一个空的头节点 head<ul><li><code>listelm_detach</code>: 把两个参数的节点连接起来</li><li><code>listelm_add</code>: 第一个参数的节点添加到后两个节点中间</li><li><code>list_add</code>: 插入头节点之后的那个位置</li><li><code>list_add_tail</code>: 相当于插入tail位置</li><li><code>list_detach</code>: 把参数中的节点删除</li></ul></li></ul><blockquote><p>所有 <code>list_t *le</code> 都全名是 list element</p></blockquote><hr><h2 id="Log-Path"><a href="#Log-Path" class="headerlink" title="Log Path"></a>Log Path</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_LOG_PATH <span class="meta-string">&quot;/var/log/aodvd.log&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_RT_LOG_PATH <span class="meta-string">&quot;/var/log/aodvd.rtlog&quot;</span></span></span><br></pre></td></tr></table></figure><hr><h2 id="defs-h"><a href="#defs-h" class="headerlink" title="defs.h"></a><code>defs.h</code></h2><ul><li><p><code>defs.h</code></p><ul><li><p>host 主机, dev 网卡</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Data for a network device */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> enabled; <span class="comment">/* 1 if struct is used, else 0 */</span></span><br><span class="line">    <span class="keyword">int</span> sock;    <span class="comment">/* AODV socket associated with this device */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GATEWAY</span></span><br><span class="line">    <span class="keyword">int</span> psock; <span class="comment">/* Socket to send buffered data packets. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ifindex;</span><br><span class="line">    <span class="keyword">char</span> ifname[IFNAMSIZ];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ipaddr</span>;</span>  <span class="comment">/* The local IP address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">netmask</span>;</span> <span class="comment">/* The netmask we use */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">broadcast</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">host_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> seqno;           <span class="comment">/* Sequence number */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">bcast_time</span>;</span> <span class="comment">/* The time of the last broadcast msg sent */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">fwd_time</span>;</span>   <span class="comment">/* The time a data packet was last forwarded */</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> rreq_id;         <span class="comment">/* RREQ id */</span></span><br><span class="line">    <span class="keyword">int</span> nif;                   <span class="comment">/* Number of interfaces to broadcast on */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_info</span></span></span><br><span class="line"><span class="class">        <span class="title">devs</span>[<span class="title">MAX_NR_INTERFACES</span> +</span></span><br><span class="line"><span class="class">             1];</span> <span class="comment">/* Add +1 for returning as &quot;error&quot; in ifindex2devindex. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>host_info</code> 中存储 <code>def_info</code> 数组，多开了一个位置 <code>(MAX_NR_INTERFACES+1)</code>，让函数返回错误时使用，来代表 error</p></li><li><p><code>ifindex</code> 全称是 network interface index</p></li><li><p>对 <code>AODV_msg</code> 结构体进行简化后为</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">u_int8_t</span> type;</span><br><span class="line">&#125; AODV_msg;</span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* An generic AODV extensions header */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> type;</span><br><span class="line">    <span class="keyword">u_int8_t</span> length;</span><br><span class="line">    <span class="comment">/* Type specific data follows here */</span></span><br><span class="line">&#125; AODV_ext;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="对-list-t-和-timer-嵌套结构体的理解"><a href="#对-list-t-和-timer-嵌套结构体的理解" class="headerlink" title="对 list_t 和 timer 嵌套结构体的理解"></a>对 <code>list_t</code> 和 <code>timer</code> 嵌套结构体的理解</h2><p><img src="https://s2.loli.net/2021/12/12/ZitwIevknBAWyQ6.jpg" alt="timer通过list_t实现循环双链表"></p><hr><h2 id="timeval-结构体在不同系统中的不同定义"><a href="#timeval-结构体在不同系统中的不同定义" class="headerlink" title="timeval 结构体在不同系统中的不同定义"></a><code>timeval</code> 结构体在不同系统中的不同定义</h2><ul><li><p>在 Linux 中<code>time.h</code>库文件内</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">__time_t</span> tv_sec;        <span class="comment">/* Seconds. */</span></span><br><span class="line"><span class="keyword">__suseconds_t</span> tv_usec;  <span class="comment">/* Microseconds. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在 macOS 中</p><ul><li><p>util_ldap.h</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> timeval l_timeval</span></span><br></pre></td></tr></table></figure></li><li><p>time.h</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure used as a parameter by getitimer(2) and setitimer(2) system</span></span><br><span class="line"><span class="comment"> * calls.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">itimerval</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span>  <span class="title">timeval</span> <span class="title">it_interval</span>;</span>    <span class="comment">/* timer interval */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span>  <span class="title">timeval</span> <span class="title">it_value</span>;</span>       <span class="comment">/* current value */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>clock_types.h</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Normal time specification used by the kernel clock facility.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_timespec</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>    tv_sec;                 <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="keyword">clock_res_t</span>             tv_nsec;                <span class="comment">/* nanoseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_timespec</span>    <span class="title">mach_timespec_t</span>;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="timer-queue-c"><a href="#timer-queue-c" class="headerlink" title="timer_queue.c"></a><code>timer_queue.c</code></h2><ul><li><p><code>timer_queue.c</code></p><ul><li><p><code>timer_timeout</code> 函数</p><ul><li>对 <code>list_t</code> 串联起来的 <code>timer</code> 循环双链表 <code>TQ</code></li><li>循环判断其时间是否为当前时间，将 <code>timeout</code> 的 <code>timer</code> 放入 <code>expTQ</code> 中<ul><li>若是，则从 <code>TQ</code> 中移除，并加入到 <code>expTQ</code></li><li>若否，则终止循环判断</li></ul></li><li>循环执行并删除 <code>expTQ</code> 中 <code>timer</code> 的 handler function</li></ul></li><li><p><code>timer_remove</code></p><ul><li><code>t-&gt;used</code> 置 0</li></ul></li><li><p><code>timer_add</code></p><ul><li><p><code>t-&gt;used</code> 置 1</p></li><li><p>判断 <code>TQ</code> 是否为空</p><ul><li>若空，则直接添加</li><li>若非空，则遍历 <code>TQ</code>，将 t 按照时间顺序添加到 <code>TQ</code> 中</li></ul></li><li><p><code>timer_timeout_now</code></p><ul><li><p>判断 <code>timer</code> 是否在 <code>TQ</code> 中</p><ul><li>若是，则执行 <code>handler</code>，并 <code>t-&gt;used</code> 置 0，<code>timer</code> 依旧在 <code>TQ</code> 中等待执行</li><li>若否，则返回-1</li></ul></li><li><p><code>timer_set_timeout</code></p><ul><li><p><code>t-&gt;used</code> 置 0</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;timeout.tv_usec += msec * <span class="number">1000</span>;</span><br><span class="line">t-&gt;timeout.tv_sec += t-&gt;timeout.tv_usec / <span class="number">1000000</span>;</span><br><span class="line">t-&gt;timeout.tv_usec = t-&gt;timeout.tv_usec % <span class="number">1000000</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>timer_add(t)</code></p></li></ul></li></ul></li></ul></li></ul></li></ul><hr><h2 id="AODV-Socket"><a href="#AODV-Socket" class="headerlink" title="AODV Socket"></a>AODV Socket</h2><p>在对于 <code>aodv_socket.{c|h}</code> 文件的分析中，我们发现它大量依赖于系统 C 语言源代码中的 <code>struct cmsghdr</code>，于是我们查看了系统源代码 C 语言文件中的 <code>socket.h</code> 文件，并从中找到了对于 <code>msghdr</code> 和 <code>cmsghdr</code> 结构体的定义。</p><ul><li><p><code>msghdr</code>：用于调用 recvmsg 和 sendmsg 的消息头。在 recvmsg 中使用值与结果相对应，而在 sendmsg 中仅使用值。</p><ul><li>套接口地址成员 <code>msg_name</code> 与 <code>msg_namelen</code>，分别指向我们要发送或是接收信息的套接口地址及这个套接口地址的长度<ul><li>当调用 recvmsg 时，msg_name 会指向一个将要接收的地址的接收区域</li><li>当调用 sendmsg 时，它会指向一个数据报将要发送到的目的地址</li></ul></li><li>I/O 向量引用 <code>msg_iov</code> 与 <code>msg_iovlen</code></li><li>附属数据缓冲区成员 <code>msg_control</code> 与 <code>msg_controllen</code></li><li>接收信息标记位 <code>msg_flags</code>，其可以接收的标记如下</li></ul><table><thead><tr><th>标记位</th><th>描述</th></tr></thead><tbody><tr><td>MSG_EOR</td><td>当接收到记录结尾时会设置这一位。这通常对于SOCK_SEQPACKET套接口类型十分有用</td></tr><tr><td>MSG_TRUNC</td><td>这个标记位表明数据的结尾被截短，因为接收缓冲区太小不足以接收全部的数据</td></tr><tr><td>MSG_CTRUNC</td><td>这个标记位表明某些控制数据(附属数据)被截短，因为缓冲区太小</td></tr><tr><td>MSG_OOB</td><td>这个标记位表明接收了带外数据</td></tr><tr><td>MSG_ERRQUEUE</td><td>这个标记位表明没有接收到数据，但是返回一个扩展错误</td></tr></tbody></table></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>            *msg_name;      <span class="comment">/* [XSI] optional address */</span></span><br><span class="line">    <span class="keyword">socklen_t</span>       msg_namelen;    <span class="comment">/* [XSI] size of address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>          <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span> <span class="comment">/* [XSI] scatter/gather array */</span></span><br><span class="line">    <span class="keyword">int</span>             msg_iovlen;     <span class="comment">/* [XSI] # elements in msg_iov */</span></span><br><span class="line">    <span class="keyword">void</span>            *msg_control;   <span class="comment">/* [XSI] ancillary data, see below */</span></span><br><span class="line">    <span class="keyword">socklen_t</span>       msg_controllen; <span class="comment">/* [XSI] ancillary data buffer len */</span></span><br><span class="line">    <span class="keyword">int</span>             msg_flags;      <span class="comment">/* [XSI] flags on received message */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>cmsghdr</code>：msg_control 缓冲区中辅助数据对象的头。用于提供数据报的额外信息的附加信息。 格式是一串以 cmsghdr 结构为首的信息元素的序列。<ul><li><code>cmsg_len</code>:  附属数据的字节计数，这包含结构头的尺寸。这个值是由 <code>CMSG_LEN()</code> 宏计算的</li><li><code>cmsg_level</code>:  这个值表明了原始的协议级别(例如，<code>SOL_SOCKET</code>)</li><li><code>cmsg_type</code>:  这个值表明了控制信息类型(例如，<code>SCM_RIGHTS</code>)</li><li><code>cmsg_data</code>:  这个成员并不实际存在。他用来指明实际的额外附属数据所在的位置</li></ul></li></ul><p>对 <code>msg_level</code> 的描述如下：</p><table><thead><tr><th>cmsg_level</th><th>描述</th></tr></thead><tbody><tr><td>SCM_RIGHTS</td><td>附属数据对象是一个文件描述符</td></tr><tr><td>SCM_CREDENTIALS</td><td>附属数据对象是一个包含证书信息的结构</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">socklen_t</span>       cmsg_len;       <span class="comment">/* [XSI] data byte count, including hdr */</span></span><br><span class="line">    <span class="keyword">int</span>             cmsg_level;     <span class="comment">/* [XSI] originating protocol */</span></span><br><span class="line">    <span class="keyword">int</span>             cmsg_type;      <span class="comment">/* [XSI] protocol-specific type */</span></span><br><span class="line"><span class="comment">/* followed by    unsigned char  cmsg_data[]; */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AODV 协议认为系统提供的源代码的关于 routine 部分存在 bug，所以通过 <code>msghdr</code> 和 <code>cmsghdr</code> 结构并重写部分函数来解决这个问题。</p><ul><li><code>__cmsg_nxthdr_fix</code> </li><li><code>cmsg_nxthdr_fix</code></li></ul><p>其中 <code>cmsg_nxthdr_fix</code> 函数调用 <code>__cmsg_nxthdr_fix</code> 来完成</p><ul><li><code>aodv_socket.c</code><ul><li><code>aodv_socket_init</code><ul><li></li></ul></li></ul></li></ul><p>我们在处理 AODV 协议源代码中的 <code>socket</code> 函数时发现了对于 <code>PF_INET</code> 量，于我们在高级 C 语言课程中学习的 <code>AF_INET</code> 不同。经过在网上的查阅我们可以看到，对于 Windows 系统来说，它在 <code>Winsock2.h</code> 中将 <code>PF_INET</code> 与 <code>IF_INET</code> 等价</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INET 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_INET AF_INET</span></span><br></pre></td></tr></table></figure><p>而在 Unix/Linux 系统中，对于 BSD 是 AF，对于 POSIX 是 PF。在 《Unix 网络编程 卷1: 套接字联网 API》书中，我们找到了这一段解释</p><blockquote><p><code>AF_XXX</code> Versus <code>PF_XXX</code></p><p>The “<code>AF_</code>“ prefix stands for “address family” and the “<code>PF_</code>“ prefix stands for “protocol family”. Historically, the intent was that a single protocol family might support multiple address families and that the <code>PF_</code> value was used to create the socket and the <code>AF_</code> value was used in socket address structures. But in actuality, a protocol family supporting multiple address families has never been supported and the <code>&lt;sys/socket.h&gt;</code> header defines the <code>PF_</code> value for a given protocol to be equal to the <code>AF_</code> value for that protocol. While there is no guarantee that this equality between the two will always be true, should anyone change this for existing protocols, lots of existing code would break. To conform to existing coding practice, we use only the <code>AF_</code> constants in this text, although you may encounter the <code>PF_</code> value, mainly in calls to socket.</p></blockquote><ul><li><p><code>aodv_socket_init</code></p><ul><li><p>在函数中第一次使用了 ifreq 结构体，跳转得到其化简后的部分定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">ifreq</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>    ifr_name[IFNAMSIZ];             <span class="comment">/* if name, e.g. &quot;en0&quot; */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">sockaddr</span> <span class="title">ifru_addr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">sockaddr</span> <span class="title">ifru_dstaddr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">sockaddr</span> <span class="title">ifru_broadaddr</span>;</span></span><br><span class="line">        <span class="keyword">short</span>   ifru_flags;</span><br><span class="line">        <span class="keyword">int</span>     ifru_metric;</span><br><span class="line">        <span class="keyword">int</span>     ifru_mtu;</span><br><span class="line">        <span class="keyword">int</span>     ifru_phys;</span><br><span class="line">        <span class="keyword">int</span>     ifru_media;</span><br><span class="line">        <span class="keyword">int</span>     ifru_intval;</span><br><span class="line">        <span class="keyword">caddr_t</span> ifru_data;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">ifdevmtu</span> <span class="title">ifru_devmtu</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">ifkpi</span>   <span class="title">ifru_kpi</span>;</span></span><br><span class="line">        <span class="keyword">u_int32_t</span> ifru_wake_flags;</span><br><span class="line">        <span class="keyword">u_int32_t</span> ifru_route_refcnt;</span><br><span class="line">        <span class="keyword">int</span>     ifru_cap[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">u_int32_t</span> ifru_functional_type;</span><br><span class="line">    &#125; ifr_ifru;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体中包含了两部分，包括接口 interface 的名称和一个 union 类型的定义。ifreq 为接口请求结构，用于套接字 ioctl 的接口请求结构。 所有的接口 IOctl 必须有参数定义，该定义以 ifr_name 开头。 其余的其余的可以是特定的接口。</p></li><li><p>socket 初始化 udp 数据包时，会查看 <code>this_host.nif</code> 即 number of interface to boardcast on。若为 0 则异常退出。</p></li><li><p>在 socket 部分有非常多的内容在高级 C 语言课程 Unix 网络编程中学到过，如 <code>socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)</code> 来创建 UDP 包，但在 aodv 协议中，均使用了 <code>PF_INET</code> 来替换原始的 <code>AF_INET</code></p></li><li><p>在 Unix Network Programming 中，作者提到他建议使用 <code>bzero</code> 来替换 <code>memset(&amp;aodv_addr, 0, sizeof(aodv_addr))</code>，我们组成员也查阅了这两种在内存层面上对其赋值为 0 的区别。<code>bcopy</code>、<code>bzero</code> 和 <code>bcmp</code> 是传统 BSD 的函数，属于 POSIX 标准；<code>mem*</code> 是 C90 (以及 C99)标准的 C 函数。区别在于，如果你打算把程序弄到一个符合 C90/C99，但是不符合 POSIX 标准的平台时，后者会更有优势。但是 <code>memset</code> 函数的第二和第三个参数需要单独记忆</p><blockquote><p>C has memset(), the Berkeley UNIX C library has <strong>bzero</strong>(). They are not<br>identical, and <strong>bzero</strong>() pre dates memset() but is not widely available (since<br>it’s not part of standard C</p></blockquote></li><li><p>函数中通过 <code>setsockopt</code> 给 socket 设置了以下的字段选项：</p><ul><li><code>SOL_SOCKET</code> - <code>SO_BROADCAST</code>：允许发送广播数据包</li><li><code>SOL_SOCKET</code> - <code>SO_BINDTODEVICE</code>：将套接字绑定到指定接口</li><li><code>SOL_SOCKET</code> - <code>SO_PRIORITY</code>：设置在套接字发送的所有包的协议定义优先权</li><li><code>SOL_SOCKET</code> - <code>SO_RCVBUF</code>：接受缓冲区大小</li><li><code>SOL_IP</code> - <code>IP_RECVTTL</code>：传送一条带有用一个字节表示的接收包生存时间字段的 IP_RECVTTL 控制信息</li><li><code>SOL_IP</code> - <code>IP_PKTINFO</code>：获取接收报文的相关信息，也可在发送报文时指定报文的相关控制信息</li></ul></li><li><p>aodv 将 receive buffer size 设定为了 1024 并且不允许修改（没有通过 <code>#define</code> 或其他形式提供便于修改的方法）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (setsockopt(DEV_NR(i).sock, SOL_SOCKET, SO_RCVBUF,</span><br><span class="line">               (<span class="keyword">char</span> *)&amp;bufsize, optlen) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    alog(LOG_NOTICE, <span class="number">0</span>, __FUNCTION__,</span><br><span class="line">         <span class="string">&quot;Receive buffer size set to %d&quot;</span>, bufsize);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bufsize &lt; RECV_BUF_SIZE)</span><br><span class="line">&#123;</span><br><span class="line">    alog(LOG_ERR, <span class="number">0</span>, __FUNCTION__,</span><br><span class="line">         <span class="string">&quot;Could not set receive buffer size&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>aodv_socket_process_packet</code></p><ul><li>确保邻居节点已经被添加或更新</li><li>判断消息报文类型<ul><li>通过 <code>type == RREP &amp; ttl == 1 &amp; dst.s_addr == AODV_BROADCAST</code> 判断是否为 Hello 包，并调用 hello_process 来对 Hello 包进行处理</li><li><code>AODV_RREQ</code>: <code>rreq_process((RREQ *)aodv_msg, len, src, dst, ttl, ifindex)</code></li><li><code>AODV_RREP</code>: <code>rrep_process((RREP *)aodv_msg, len, src, dst, ttl, ifindex)</code></li><li><code>AODV_RERR</code>: <code>rerr_process((RERR *)aodv_msg, len, src, dst)</code></li><li><code>AODV_RREP_ACK</code>: <code>rrep_ack_process((RREP_ack *)aodv_msg, len, src, dst)</code></li></ul></li></ul></li><li><p><code>aodv_socket_read</code></p><ul><li>本函数负责读取并调用 <code>aodv_socket_process_packet</code> 处理 AODV socket 包，在 NS-2 系统中，函数为 <code>recvAODVUUPacket</code></li><li>通过 <code>recvmsg(fd, &amp;msgh, 0)</code>  读取 socket，并从控制信息中获取 ttl 和目标地址。通过判断 <code>cmsg-&gt;cmsg_type</code><ul><li><code>IP_TTL</code>: <code>ttl = *(CMSG_DATA(cmsg));</code></li><li><code>IP_PKTINFO</code>: <code>struct in_pktinfo *pi = (struct in_pktinfo *)CMSG_DATA(cmsg); dst.s_addr = pi-&gt;ipi_addr.s_addr;</code></li></ul></li><li>若 TTL 为负值，则异常，并进行空返回</li><li>通过 <code>devfromsock</code> 尝试将 <code>sockf</code> 转换为 <code>dev_info</code>，对转换错误即空指针的返回同样按照异常处理并进行空返回</li></ul></li><li><p><code>aodv_socket_send</code></p><ul><li><p>本函数负责发送 AODV socket 数据包</p></li><li><p>不处理 AODV_RREP 数据包，并且当 <code>wait_on_reboot</code> 被设置为真时也不再发送数据包</p></li><li><p>设置 socket 的 TTL 值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(dev-&gt;sock, SOL_IP, IP_TTL, &amp;ttl, <span class="keyword">sizeof</span>(ttl))</span><br></pre></td></tr></table></figure></li><li><p>如果速率限制被启用，检查我们是否正在发送一个 RREQ 或 RERR。在这种情况下，丢弃传出的控制数据包。如果距离上次发送该类型的数据包的时间少于或小于允许的 RATE LIMIT 时间</p></li></ul></li><li><p><code>aodv_socket_new_msg</code></p><ul><li>为新产生的数据包发送缓冲空间</li></ul></li><li><p><code>aodv_socket_queue_msg</code></p><ul><li>把一个AODV消息存储在发送缓冲区中</li></ul></li><li><p><code>aodv_socket_clean</code></p><ul><li>清空套接字信息并关闭</li></ul></li></ul><p>对部分 Socket 函数的详细解释将放在内容中</p><hr><h2 id="RREQ"><a href="#RREQ" class="headerlink" title="RREQ"></a><code>RREQ</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |J|R|G|D|U|      Reserved       |   Hop Count   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                            RREQ ID                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Destination IP Address                     |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                  Destination Sequence Number                  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Originator IP Address                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                  Originator Sequence Number                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>疑问🤔️：代码实际没有 U 标志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> type;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__LITTLE_ENDIAN)</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> res1:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">u_int8_t</span> d:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int8_t</span> g:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int8_t</span> r:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int8_t</span> j:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__BIG_ENDIAN)</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> j:<span class="number">1</span>;    <span class="comment">/* Join flag (multicast) */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> r:<span class="number">1</span>;    <span class="comment">/* Repair flag */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> g:<span class="number">1</span>;    <span class="comment">/* Gratuitous RREP flag */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> d:<span class="number">1</span>;    <span class="comment">/* Destination only respond */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> res1:<span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">&quot;Adjust your &lt;bits/endian.h&gt; defines&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">u_int8_t</span> res2;</span><br><span class="line">    <span class="keyword">u_int8_t</span> hcnt;</span><br><span class="line">    <span class="keyword">u_int32_t</span> rreq_id;</span><br><span class="line">    <span class="keyword">u_int32_t</span> dest_addr;</span><br><span class="line">    <span class="keyword">u_int32_t</span> dest_seqno;</span><br><span class="line">    <span class="keyword">u_int32_t</span> orig_addr;</span><br><span class="line">    <span class="keyword">u_int32_t</span> orig_seqno;</span><br><span class="line">&#125; RREQ;</span><br></pre></td></tr></table></figure><ul><li><p><code>aodv_rreq.c</code></p><ul><li><p><code>rare_create</code></p><ul><li><p>创建 <code>RREQ</code> 并初始化</p></li><li><p>seq number increase（0 仍为 0，最大值时变为 1，其他正常 +1）</p><ul><li>当某一节点要产生 RREQ 洪泛，必须先增大自身序列号</li></ul></li><li><p><code>flag</code> 匹配并给对应的值赋 1</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* RREQ Flags: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RREQ_JOIN          0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RREQ_REPAIR        0x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RREQ_GRATUITOUS    0x4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RREQ_DEST_ONLY     0x8</span></span><br></pre></td></tr></table></figure><ul><li><p>疑问🤔️：为什么不直接用数组记录，或直接使用 <code>flag</code> 记录？目前用于匹配的代码如下</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags &amp; RREQ_JOIN)</span><br><span class="line">    rreq-&gt;j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; RREQ_REPAIR)</span><br><span class="line">    rreq-&gt;r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; RREQ_GRATUITOUS)</span><br><span class="line">    rreq-&gt;g = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; RREQ_DEST_ONLY)</span><br><span class="line">    rreq-&gt;d = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>解释：可以同时有多个 <code>flag</code></li></ul></li><li><p><code>rreq_add_ext</code></p><ul><li><p>用于对 RREQ 进行补充</p></li><li><p>存放于 <code>(AODV_ext *)((char *)rreq + offset)</code></p><ul><li><code>offset</code> 应大于或等于 <code>RREQ_SIZE</code></li></ul></li><li><p><code>AODV_ext</code> 存储信息</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* An generic AODV extensions header */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> type;</span><br><span class="line">    <span class="keyword">u_int8_t</span> length;</span><br><span class="line">    <span class="comment">/* Type specific data follows here */</span></span><br><span class="line">&#125; AODV_ext;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>type</code></li><li><code>length</code></li></ul></li><li><p>将 data 复制到 <code>((char *)((char *)ext + sizeof(AODV_ext))</code></p></li></ul></li><li><p><code>rreq_send</code></p><ul><li><p><code>struct in_addr</code></p></li><li><p><code>apr_uint32_t</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">apr_uint32_t</span>  s_addr; <span class="comment">/**&lt; storage to hold the IP# */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>unsigned int</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dest.s_addr = AODV_BROADCAST;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Broadcast on all interfaces */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_NR_INTERFACES; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!DEV_NR(i).enabled)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    rreq = rreq_create(flags, dest_addr, dest_seqno, DEV_NR(i).ipaddr);</span><br><span class="line">    aodv_socket_send((AODV_msg *)rreq, dest, RREQ_SIZE, ttl, &amp;DEV_NR(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>广播 <code>dest.s_addr = AODV_BROADCAST;</code></p></li><li><p>创建 RREQ 并发送报文</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rreq = rreq_create(flags, dest_addr, dest_seqno, DEV_NR(i).ipaddr);</span><br><span class="line">aodv_socket_send((AODV_msg *)rreq, dest, RREQ_SIZE, ttl, &amp;DEV_NR(i));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>rreq_forward</code></p><ul><li><p>记录目的和源</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dest.s_addr = AODV_BROADCAST;</span><br><span class="line">orig.s_addr = rreq-&gt;orig_addr;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>若 TTL 仍然大于 0 时继续转发</p></li><li><p>报文进入队列 <code>send_buf</code>，等待发送</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rreq = (RREQ *)aodv_socket_queue_msg((AODV_msg *)rreq, size);</span><br></pre></td></tr></table></figure></li><li><p>增加跳数 hcnt <code>rreq-&gt;hcnt++;</code></p></li><li><p>转发发送缓冲区 <code>send_buf</code> 中的报文</p></li><li><p>疑问🤔️：转发时 TTL-1 操作没有找到</p><ul><li><p>回答：forward 中只转发，在 process 中找到如下的对 TTL 的处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ip_ttl &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Update the sequence number in case the maintained one is</span></span><br><span class="line"><span class="comment">     * larger */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd_rt &amp;&amp; !(fwd_rt-&gt;flags &amp; RT_INET_DEST) &amp;&amp;</span><br><span class="line">        (<span class="keyword">int32_t</span>)fwd_rt-&gt;dest_seqno &gt; (<span class="keyword">int32_t</span>)rreq_dest_seqno)</span><br><span class="line">        rreq-&gt;dest_seqno = htonl(fwd_rt-&gt;dest_seqno);</span><br><span class="line">                                                                </span><br><span class="line">    rreq_forward(rreq, rreqlen, --ip_ttl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    DEBUG(LOG_DEBUG, <span class="number">0</span>, <span class="string">&quot;RREQ not forwarded - ttl=0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>当 TTL 大于 1 时，判断并转发 <code>—-ip_ttl</code> 的包</p></li></ul></li><li><p><code>rreq_process</code></p><ul><li><p>目的和源的初始化</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rreq_dest.s_addr = rreq-&gt;dest_addr;</span><br><span class="line">rreq_orig.s_addr = rreq-&gt;orig_addr;</span><br><span class="line">rreq_id = ntohl(rreq-&gt;rreq_id);</span><br><span class="line">rreq_dest_seqno = ntohl(rreq-&gt;dest_seqno);</span><br><span class="line">rreq_orig_seqno = ntohl(rreq-&gt;orig_seqno);</span><br><span class="line">rreq_new_hcnt = rreq-&gt;hcnt + <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>忽略由本节点开始发送的包</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rreq_orig.s_addr == DEV_IFINDEX(ifindex).ipaddr.s_addr)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>检查接收到的 RREQ 包的上一跳是否在黑名单中，若在则忽略该包</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rreq_blacklist_find(ip_src))</span><br><span class="line">&#123;</span><br><span class="line">    DEBUG(LOG_DEBUG, <span class="number">0</span>, <span class="string">&quot;prev hop of RREQ blacklisted, ignoring!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>忽略已经处理过的 RREQ 包，防止发生网络风暴</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rreq_record_find(rreq_orig, rreq_id))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>疑问🤔️：是否可以通过将检查操作前置到函数内初始化之前，小幅度提升运算速度</p></li><li><p>缓存接收到的 RREQ 包，下次接收到相同包时可以忽略不进行处理</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rreq_record_insert(rreq_orig, rreq_id);</span><br></pre></td></tr></table></figure></li><li><p>通过 rreqlen 和 extlen 处理分割 RREQ 包</p></li><li><p>路由发现 <code>rt_table_find</code></p><ul><li><p>若路由表中没有存储过目的节点，则添加到路由表中 <code>rt_table_insert</code></p></li><li><p>若发现已经存储过的记录，则尝试计算出开销最小的路径并更新</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">life = PATH_DISCOVERY_TIME - <span class="number">2</span> * rreq_new_hcnt * NODE_TRAVERSAL_TIME;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rev_rt-&gt;dest_seqno == <span class="number">0</span> ||</span><br><span class="line">    (<span class="keyword">int32_t</span>)rreq_orig_seqno &gt; (<span class="keyword">int32_t</span>)rev_rt-&gt;dest_seqno ||</span><br><span class="line">    (rreq_orig_seqno == rev_rt-&gt;dest_seqno &amp;&amp;</span><br><span class="line">     (rev_rt-&gt;state == INVALID || rreq_new_hcnt &lt; rev_rt-&gt;hcnt)))</span><br><span class="line">&#123;</span><br><span class="line">    rev_rt =</span><br><span class="line">        rt_table_update(rev_rt, ip_src, rreq_new_hcnt, rreq_orig_seqno,</span><br><span class="line">                        life, VALID, rev_rt-&gt;flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>判断自己是否为目的节点</p><ul><li><p>若是目的节点，终止 RREQ，开始 RREQ 过程，更新最大序列号</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rreq_dest.s_addr == DEV_IFINDEX(ifindex).ipaddr.s_addr)</span><br><span class="line">&#123;</span><br><span class="line">                                                                           </span><br><span class="line">    <span class="comment">/* WE are the RREQ DESTINATION. Update the node&#x27;s own</span></span><br><span class="line"><span class="comment">       sequence number to the maximum of the current seqno and the</span></span><br><span class="line"><span class="comment">       one in the RREQ. */</span></span><br><span class="line">    <span class="keyword">if</span> (rreq_dest_seqno != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int32_t</span>)this_host.seqno &lt; (<span class="keyword">int32_t</span>)rreq_dest_seqno)</span><br><span class="line">            this_host.seqno = rreq_dest_seqno;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (this_host.seqno == rreq_dest_seqno)</span><br><span class="line">            seqno_incr(this_host.seqno);</span><br><span class="line">    &#125;</span><br><span class="line">    rrep =</span><br><span class="line">        rrep_create(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, DEV_IFINDEX(rev_rt-&gt;ifindex).ipaddr,</span><br><span class="line">                    this_host.seqno, rev_rt-&gt;dest_addr, MY_ROUTE_TIMEOUT);</span><br><span class="line">                                                                           </span><br><span class="line">    rrep_send(rrep, rev_rt, <span class="literal">NULL</span>, RREP_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>若不是目的节点，则查看是否包含目的节点的路由信息</p><ul><li>若有则回复 RREP</li><li>若没有则继续广播 RREQ<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* We are an INTERMEDIATE node. - check if we have an active</span></span><br><span class="line"><span class="comment">     * route entry */</span></span><br><span class="line">                                                                          </span><br><span class="line">    fwd_rt = rt_table_find(rreq_dest);</span><br><span class="line">                                                                          </span><br><span class="line">    <span class="keyword">if</span> (fwd_rt &amp;&amp; fwd_rt-&gt;state == VALID &amp;&amp; !rreq-&gt;d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">        <span class="keyword">u_int32_t</span> lifetime;</span><br><span class="line">                                                                          </span><br><span class="line">        <span class="comment">/* GENERATE RREP, i.e we have an ACTIVE route entry that is fresh</span></span><br><span class="line"><span class="comment">           enough (our destination sequence number for that route is</span></span><br><span class="line"><span class="comment">           larger than the one in the RREQ). */</span></span><br><span class="line">                                                                          </span><br><span class="line">        gettimeofday(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">                                                                          </span><br><span class="line">        <span class="comment">/* Respond only if the sequence number is fresh enough... */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd_rt-&gt;dest_seqno != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (<span class="keyword">int32_t</span>)fwd_rt-&gt;dest_seqno &gt;= (<span class="keyword">int32_t</span>)rreq_dest_seqno)</span><br><span class="line">        &#123;</span><br><span class="line">            lifetime = timeval_diff(&amp;fwd_rt-&gt;rt_timer.timeout, &amp;now);</span><br><span class="line">            rrep = rrep_create(<span class="number">0</span>, <span class="number">0</span>, fwd_rt-&gt;hcnt, fwd_rt-&gt;dest_addr,</span><br><span class="line">                               fwd_rt-&gt;dest_seqno, rev_rt-&gt;dest_addr,</span><br><span class="line">                               lifetime);</span><br><span class="line">            rrep_send(rrep, rev_rt, fwd_rt, rrep_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* If the GRATUITOUS flag is set, we must also unicast a</span></span><br><span class="line"><span class="comment">           gratuitous RREP to the destination. */</span></span><br><span class="line">        <span class="keyword">if</span> (rreq-&gt;g)</span><br><span class="line">        &#123;</span><br><span class="line">            rrep = rrep_create(<span class="number">0</span>, <span class="number">0</span>, rev_rt-&gt;hcnt, rev_rt-&gt;dest_addr,</span><br><span class="line">                               rev_rt-&gt;dest_seqno, fwd_rt-&gt;dest_addr,</span><br><span class="line">                               lifetime);</span><br><span class="line">                                                                          </span><br><span class="line">            rrep_send(rrep, fwd_rt, rev_rt, RREP_SIZE);</span><br><span class="line">                                                                          </span><br><span class="line">            DEBUG(LOG_INFO, <span class="number">0</span>, <span class="string">&quot;Sending G-RREP to %s with rte to %s&quot;</span>,</span><br><span class="line">                  ip_to_str(rreq_dest), ip_to_str(rreq_orig));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">forward:</span><br><span class="line">    <span class="keyword">if</span> (ip_ttl &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Update the sequence number in case the maintained one is</span></span><br><span class="line"><span class="comment">         * larger */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd_rt &amp;&amp; !(fwd_rt-&gt;flags &amp; RT_INET_DEST) &amp;&amp;</span><br><span class="line">            (<span class="keyword">int32_t</span>)fwd_rt-&gt;dest_seqno &gt; (<span class="keyword">int32_t</span>)rreq_dest_seqno)</span><br><span class="line">            rreq-&gt;dest_seqno = htonl(fwd_rt-&gt;dest_seqno);</span><br><span class="line">                                                                          </span><br><span class="line">        rreq_forward(rreq, rreqlen, --ip_ttl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        DEBUG(LOG_DEBUG, <span class="number">0</span>, <span class="string">&quot;RREQ not forwarded - ttl=0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><hr><h2 id="RREP"><a href="#RREP" class="headerlink" title="RREP"></a><code>RREP</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |R|A|    Reserved     |Prefix Sz|   Hop Count   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                     Destination IP address                    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                  Destination Sequence Number                  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Originator IP address                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           Lifetime                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><ul><li><p><code>rrep_create</code></p><ul><li><p>通过 <code>aodv_socket_new_msg</code> 创建 socket message，并进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rrep-&gt;type = AODV_RREP;</span><br><span class="line">rrep-&gt;res1 = <span class="number">0</span>;</span><br><span class="line">rrep-&gt;res2 = <span class="number">0</span>;</span><br><span class="line">rrep-&gt;prefix = prefix;</span><br><span class="line">rrep-&gt;hcnt = hcnt;</span><br><span class="line">rrep-&gt;dest_addr = dest_addr.s_addr;</span><br><span class="line">rrep-&gt;dest_seqno = htonl(dest_seqno);</span><br><span class="line">rrep-&gt;orig_addr = orig_addr.s_addr;</span><br><span class="line">rrep-&gt;lifetime = htonl(life);</span><br></pre></td></tr></table></figure></li><li><p>对 flag 进行位判断，并将对应在 message 中的位置 1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags &amp; RREP_REPAIR)</span><br><span class="line">    rrep-&gt;r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; RREP_ACK)</span><br><span class="line">    rrep-&gt;a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>rrep_ack_create</code></p><ul><li><p>创建 socket message，初始化仅需要将其类型设置为 ACK 包</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rrep_ack-&gt;type = AODV_RREP_ACK;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>rrep_ack_process</code></p><ul><li><p>处理 ACK 包时，先在路由表中查找其源 ip，然后删除这个 RREP_ACK 包还未到期的计时器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_remove(&amp;rt-&gt;ack_timer);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>rrep_add_ext</code></p><ul><li>通 RREQ 时的处理，在 <code>(AODV_ext *)((char *)rrep + offset)</code> 位置添加 extension 信息。存储类型和长度信息</li></ul></li><li><p><code>rrep_send</code></p><ul><li><p>检查我们是否应该请求 <code>RREP_ACK</code>。如果收到 RREQ 的节点是邻居，则可能面临单向链路，最好请求一个<code>RREP_ACK</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (neighbor &amp;&amp; neighbor-&gt;state == VALID &amp;&amp; !neighbor-&gt;ack_timer.used)</span><br><span class="line">&#123;</span><br><span class="line">    rrep_flags |= RREP_ACK;</span><br><span class="line">    neighbor-&gt;flags |= RT_UNIDIR;</span><br><span class="line">                                                                       </span><br><span class="line">    <span class="comment">/* Must remove any pending hello timeouts when we set the</span></span><br><span class="line"><span class="comment">       RT_UNIDIR flag, else the route may expire after we begin to</span></span><br><span class="line"><span class="comment">       ignore hellos... */</span></span><br><span class="line">    timer_remove(&amp;neighbor-&gt;hello_timer);</span><br><span class="line">    neighbor_link_break(neighbor);</span><br><span class="line">                                                                       </span><br><span class="line">    DEBUG(LOG_DEBUG, <span class="number">0</span>, <span class="string">&quot;Link to %s is unidirectional!&quot;</span>,</span><br><span class="line">          ip_to_str(neighbor-&gt;dest_addr));</span><br><span class="line">                                                                       </span><br><span class="line">    timer_set_timeout(&amp;neighbor-&gt;ack_timer, NEXT_HOP_WAIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置 <code>RT_UNIDIR</code> 标志时，必须删除所有待处理的 Hello 超时，否则路由可能会在开始忽略 Hello 之后终止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fwd_rt)</span><br><span class="line">&#123;</span><br><span class="line">    precursor_add(fwd_rt, rev_rt-&gt;next_hop);</span><br><span class="line">    precursor_add(rev_rt, fwd_rt-&gt;next_hop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>rrep_forward</code></p><ul><li><p>检查是否应该请求 <code>RREP_ACK</code>，如果RREP的来源不是一个邻居，我们必须找到邻居条目，它是通往 RREP 源的下一跳。如果我们接收到 RREQ 的节点是邻居，则我们可能正面临单向链路，最好请求一个 <code>RREP_ACK</code></p></li><li><p>疑问🤔️：AODV 源码的作者在这里也没有弄明白，他们认为这里存在一个单向的连接，于是作者暂且使用了 <code>if(0)</code> 让这段代码仅仅存在于程序中但是不会被执行</p><blockquote><p>we suspect a unidirectional link</p></blockquote></li></ul></li><li><p><code>rrep_process</code></p><ul><li><p>在 RREP 的处理中，将 RREP 包中的地址信息提取出来放入四元组中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rrep_dest.s_addr = rrep-&gt;dest_addr;</span><br><span class="line">rrep_orig.s_addr = rrep-&gt;orig_addr;</span><br><span class="line">rrep_seqno = ntohl(rrep-&gt;dest_seqno);</span><br><span class="line">rrep_lifetime = ntohl(rrep-&gt;lifetime);</span><br></pre></td></tr></table></figure></li><li><p>考虑到中间节点的情况，增加RREP跳数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rrep_new_hcnt = rrep-&gt;hcnt + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>在 RREQ 的处理时，会忽略那些旨在建立一条通往自我的路线的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rrep_dest.s_addr == DEV_IFINDEX(ifindex).ipaddr.s_addr)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></li><li><p>对 RREQ 包是否还有 extension 进行判断，并将其放入 ext 变量中</p></li><li><p>检查是否应该进行前进的路线。若没有现有条目，则插入一个新条目。若有，则更新条目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">fwd_rt = rt_table_find(rrep_dest);</span><br><span class="line">rev_rt = rt_table_find(rrep_orig);</span><br><span class="line">                                                                           </span><br><span class="line"><span class="keyword">if</span> (!fwd_rt)</span><br><span class="line">&#123;</span><br><span class="line">    fwd_rt = rt_table_insert(rrep_dest, ip_src, rrep_new_hcnt, rrep_seqno,</span><br><span class="line">                             rrep_lifetime, VALID, rt_flags, ifindex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fwd_rt-&gt;dest_seqno == <span class="number">0</span> ||</span><br><span class="line">         (<span class="keyword">int32_t</span>)rrep_seqno &gt; (<span class="keyword">int32_t</span>)fwd_rt-&gt;dest_seqno ||</span><br><span class="line">         (rrep_seqno == fwd_rt-&gt;dest_seqno &amp;&amp;</span><br><span class="line">          (fwd_rt-&gt;state == INVALID || fwd_rt-&gt;flags &amp; RT_UNIDIR ||</span><br><span class="line">           rrep_new_hcnt &lt; fwd_rt-&gt;hcnt)))</span><br><span class="line">&#123;</span><br><span class="line">    pre_repair_hcnt = fwd_rt-&gt;hcnt;</span><br><span class="line">    pre_repair_flags = fwd_rt-&gt;flags;</span><br><span class="line">                                                                           </span><br><span class="line">    fwd_rt =</span><br><span class="line">        rt_table_update(fwd_rt, ip_src, rrep_new_hcnt, rrep_seqno,</span><br><span class="line">                        rrep_lifetime, VALID, rt_flags | fwd_rt-&gt;flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fwd_rt-&gt;hcnt &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DEBUG(LOG_DEBUG, <span class="number">0</span>,</span><br><span class="line">              <span class="string">&quot;Dropping RREP, fwd_rt-&gt;hcnt=%d fwd_rt-&gt;seqno=%ld&quot;</span>,</span><br><span class="line">              fwd_rt-&gt;hcnt, fwd_rt-&gt;dest_seqno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果设置了 <code>RREP_ACK</code> 标志，将 RREP 确认发送到所答复的目的地，并移除 <code>RREP_ACK</code> 标志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rrep-&gt;a)</span><br><span class="line">&#123;</span><br><span class="line">    RREP_ack *rrep_ack;</span><br><span class="line">                                                                            </span><br><span class="line">    rrep_ack = rrep_ack_create();</span><br><span class="line">    aodv_socket_send((AODV_msg *)rrep_ack, fwd_rt-&gt;next_hop, NEXT_HOP_WAIT,</span><br><span class="line">                     MAXTTL, &amp;DEV_IFINDEX(fwd_rt-&gt;ifindex));</span><br><span class="line">    <span class="comment">/* Remove RREP_ACK flag... */</span></span><br><span class="line">    rrep-&gt;a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果路由以前处于修复状态，应该向路由源发送 <code>NO DELETE RERR</code>，这样它就可以选择为目的地重新启动路由发现。通过这样的方式可以修正一个导致修复标志未被设置和 <code>RERR</code> 从未被发送的错误。</p></li></ul></li></ul><hr><h2 id="RERR"><a href="#RERR" class="headerlink" title="RERR"></a><code>RERR</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |N|          Reserved           |   DestCount   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|            Unreachable Destination IP Address (1)             |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|         Unreachable Destination Sequence Number (1)           |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|</span><br><span class="line">|  Additional Unreachable Destination IP Addresses (if needed)  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Additional Unreachable Destination Sequence Numbers (if needed)|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><ul><li><code>rerr_create</code><ul><li>RERR 的创建和初始化与 RREQ 和 RREP 类似，故这里不再赘述</li></ul></li><li><code>rerr_add_udest</code><ul><li>添加 RERR 信息，与 RREQ 和 RREP 中的 ext 类似，均为在内存中结构体后面添加附加信息</li></ul></li><li><code>rerr_process</code><ul><li>在处理 RERR 消息时，会检查哪些目的节点时不可达的。根据作者的描述，这些内容仍然只是草案</li><li>使用数据包中的目标序列号更新相应的目标序列号。检查前驱列表是否为空。如果不为空，则将该目标作为 RERR 中的不可访问目标。确定是否有新的前驱使它成为非单播 RERR 并删除所有无法到达的目的地的先驱列表</li><li>如果创建了 RERR 消息，则立即发送，同样需要经过路由发现等过程。仅在具有中断路由的先驱节点的那些接口上发送 RERR</li></ul></li></ul><hr><h2 id="HELLO"><a href="#HELLO" class="headerlink" title="HELLO"></a><code>HELLO</code></h2><ul><li><p><code>hello_start</code></p><ul><li><p>若计时器 used 则消息已经发送</p></li><li><p>设定计时器，与 Hello 进行绑定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timer_init(&amp;hello_timer, &amp;NS_CLASS hello_send, <span class="literal">NULL</span>);</span><br><span class="line">hello_send(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>hello_stop</code></p><ul><li><p>移除计时器即为停止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_remove(&amp;hello_timer);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>hello_send</code></p><ul><li>检测发送 Hello 消息是否有必要，通过判断 <code>time_diff &gt;= HELLO_INTERVAL</code> 以防我们已经在HELLO_INTERVAL内发送了其他广播信息</li></ul></li><li><p><code>hello_process</code></p><ul><li><p>处理 Hello 消息时，仅需要存储目的节点的信息，不需要完整的四元组。同样经过路由发现过程，并检测是否有补充信息</p></li><li><p>邻居节点应该只在收到3个连续的 Hello 消息后才有效</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (receive_n_hellos)</span><br><span class="line">    state = INVALID;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    state = VALID;</span><br></pre></td></tr></table></figure></li><li><p>在对时间的判断上，Hello 消息的处理为允许的时延与发送包的数量相乘后加入路由的时延</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout = ALLOWED_HELLO_LOSS * hello_interval + ROUTE_TIMEOUT_SLACK;</span><br></pre></td></tr></table></figure></li><li><p>最后通过 <code>hello_update_timeout</code> 更新 timeout 信息，而 <code>hello_update_timeout</code> 函数调用计时器的更新方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_set_timeout(&amp;rt-&gt;hello_timer, time + HELLO_DELAY);</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="RREP-ACK"><a href="#RREP-ACK" class="headerlink" title="RREP_ACK"></a><code>RREP_ACK</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |   Reserved    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><hr><h2 id="关于-t后缀"><a href="#关于-t后缀" class="headerlink" title="关于_t后缀"></a>关于<code>_t</code>后缀</h2><blockquote><p>but most often you will use &lt;inttypes.h&gt; which (unusually for standard C headers) includes &lt;stdint.h&gt;. It (&lt;inttypes.h&gt;) also defines macros for use with the printf() and scanf().</p><p>As Matt Curtis noted, there is no significance to the compiler in the suffix; it is a human-oriented convention.</p><p>However, you should also note that POSIX defines a lot of extra type names ending in ‘_t’, and reserves the suffix for the implementation. That means that if you are working on POSIX-related systems, defining your own type names with the convention is ill-advised. The system I work on has done it (for more than 20 years); we regularly get tripped up by systems defining types with the same name as we define.</p><p>CesarB:</p><p>I use _type instead of _t on my typedefs precisely to avoid that.</p><p><a href="https://stackoverflow.com/questions/231760/what-does-a-type-followed-by-t-underscore-t-represent">Reference</a></p></blockquote><p>推测 AODV 作者意为对本身 <code>struct struct_name</code> 的替换，使得所有 <code>struct_name_t</code> 都为对应 <code>struct struct_name</code> 的 <code>typedef</code>，但是根据网上所查阅的资料，除非对系统内核等有深入了解，对于非内核级别代码并不推荐这样命名，可能会与 POSIX 相关的代码起冲突</p><hr>          </div>]]></content>
    
    <summary type="html">
    
      Analysis of AODV protocol based on its source code
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>How to Choose Your Own Courses in SSDUT</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/How-to-choose-your-own-courses-in-SSDUT/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/How-to-choose-your-own-courses-in-SSDUT/</id>
    <published>2022-01-03T06:25:24.000Z</published>
    <updated>2022-01-12T02:12:54.937Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h1 id="究极无敌选课攻略"><a href="#究极无敌选课攻略" class="headerlink" title="究极无敌选课攻略"></a>究极无敌选课攻略</h1><blockquote><p>鉴于教务对于培养方案的各种模糊，在这里写一个面向于大一新生以及其他对于选课的操作有疑问的同学。希望大家都能抢到自己心仪的课程</p></blockquote><div class="note danger">            <ul><li>首先最重要的一点是，找到自己学院自己这一届的培养方案，拿出来好好看看。注意不要太相信教务写的文字解释，一定要以表格中写明的为准</li></ul><p>比如在软件学院会在大二上快结束的时候进行专业划分，分为软件工程和网络工程。所以在还没有分专业的时候两个都需要看看。当然，在没分专业之前两边的课程理应没有任何差别</p>          </div><ul><li>开发区的培养方案是从主校区的方案基础上进行修改的，所以会看到有很多课其实开发区不安排。例如：通识课程中的艺术类</li></ul><p><img src="https://s2.loli.net/2022/01/03/4HlezmgIncwr1NQ.jpg" alt=""></p><p>虽然看起来有这么多课可以选择，但是实际上开发区一般只会开设《艺术与审美》课程和《音乐鉴赏》课程，而《艺术与审美》课程同时是作为核心课程和艺术类课程的</p><ul><li>每学期的开设课程（推荐课表）可以提前从 <code>教务系统 - 我的班级课表 - 选择对应的学年和学期</code> 看到需要上的课程，如果这里没有显示可以通过点 <code>学期全部课程</code> 看到文字说明版本的课程</li></ul><p>需要注意，这里的课程并不意味着你必须按照这样来进行选择。对于选修课来说，他一般是教务给你安排错开所有选修课的最大集，你可以按照培养方案中的学分要求自己进行选择<br>同时，这也不意味着你只能选择这个老师或这个时间段。在选课系统中只会进行时间冲突限制，也就是说如果课程 A 与课程 B 时间发生冲突，而你已经选了课程 A，那么课程 B 的选课按钮将变为灰色<br>通常的建议是可以拿别的班级相同专业的同学的推荐课表进行比较，你可以完全按照别的班的推荐课表来进行选课，只要你能保证你的学分修满培养方案的要求并且本学期没有冲突即可</p><blockquote><p>若课程有冲突且必须这么选，可以通过 <code>冲突选课申请</code> 或直接联系你们年纪的教务老师。通常建议直接去办公室等线下联系方式，也可以通过电话、QQ 等方式。教务的上班时间大致为工作日的上午 9 点到下午 5 点，中午可能有两个小时的休息。如果教务不在或在非教务工作时间，请尝试别的方法或多尝试几次</p></blockquote><ul><li>2020 年选课方案进行了修改，预选课阶段只能选择自己推荐课表中的课程和老师（也可能开放选择别的年级的课程，正常情况下不要管他），通过意愿值分配并抽签的方式进行预选课。每个人每学期选课有 100 的意愿值，选课时可以分配 0 - 100 意愿值。教务系统在确定预选结果时通常会先按照意愿值进行排序，并从高到低选择。如果课容量满时的允许的意愿值有多位学生相同，则由这些同学进行随机安排</li></ul><p>对于意愿值分配，通常来说如果课程可选的人员固定，例如推荐课表中已经分配好的英语课程，可以考虑意愿值是否给 0，因为按照现在的选课方案，只有同样推荐课表分到了这个课序号的同学和重修或提前修的同学可以选择这门课程，掉课的可能性不大（不过最好也忽悠你同学跟你一起给 0，一起赌）<br>对于知道大家都给多少的课，比如以前的社会学，一般人都会给整十或者整五，比如别人都给 10，你就给 11 就行<br>其实也就只有一些热门的老师需要在意愿值上多考虑一下，因为预选课的限制，意愿值其实作用不大了现在</p><p>另外，不要对意愿值抱有太大的期待，因为 2021 年小学期出现过网络的课程所有网安专业的同学全部掉课的情况。</p><div class="note danger">            <p>从 2022 年春季选课的预选课结果统计上来看，意愿值系统进行了很大的修改，不再完全按照意愿值进行排序选取，但是大体上仍然是这样的<br>音乐鉴赏给到 84 及以上的基本都选上了，也出现偶尔有给 50 多或给 70 选上的情况</p>          </div><ul><li><p>一般你去问学长学姐的时候，都更多的是会告诉你需要避开哪些老师，而不是哪些老师一定一定要抢到。一般课程要水的时候大家一起水，偶尔会有那种人美心善的可以多注意一下。并且开发区不限制同学们蹭课。例如软件学院的计算机网络，一般除了孙wf大师，其他老师都会在第一次上课时告诉你，上谁的课都可以。并且这门课以自学为主，我的推荐是选一个例如万良田之类的老师，然后去蹭孙wf大师的课，因为他的课只讲拓展，不推荐直接选择</p></li><li><p>选课的时候要从校园门户或者从网站上直接登陆进行选课，不要使用 webvpn。选课系统没有 ip 限制，不必使用校园网。现在教务系统好像可以直接登陆了，之前有过一段时间没导入数据</p></li><li><p>一般来讲，预选课先选和后选是没有区别的，排名只会按照给出的意愿值，所以预选课可以不用着急，着重看自己想要上哪门课</p></li><li><p>正选课就是抢课，根据你的网络情况等会出现各种问题。系统开放时间每次都不一定，可能提前半小时也可能延后一小时，建议是直接 brunch，然后乖乖等好。正选课中退课释放的课容量不会立刻更新，而是会放到第二天，一般为中午的某一时间集中释放退掉的课容量，如果有想抢的课程请每天关注课容量的释放情况，因为你选不上课教务会怪你为什么正选的后面几天不看释放的课容量</p></li><li><p>正选的时候每天下午都有一个时间段是不开放选课的，请关注教务发放的选课通知</p></li><li><p>当前自己的课程选择情况可以在选课系统中点 <code>我的课表</code> 进行查看（也可以直接在校园门户页面的课表里看）。抢课时间很紧张，建议提前规划好课程，不要到时候再点开看自己是不是还有什么时间可以选，系统很慢，很浪费时间</p></li><li><p>遇到选课系统无法进入或出现各种故障请不要惊慌，是每次必有的常规操作，请告知学委，让学委来问教务，不要所有人都一窝蜂的找教务。会让教务不耐烦，也会让有价值的信息被淹没掉</p></li><li><p>建议学委在正选课开始之后制作一个班级没有选上课的同学的信息单，以班级或级队为单位找教务进行处理而尽量不要单独每个人都去找教务处理。虽然我每次都对教务很生气，但是选课这几天他们确实会很忙来不及一个一个回复。希望各位班级和级队学委能干一点活发挥一下自己的作用，也是为你自己好</p></li><li><p>选课期间的课程情况可以在 <code>教务系统 - 全校开课查询</code> 中找到你所想要查看的课。通常可以查看到的信息是课容量和当前已经选择的人数。一般在预选课和正选每一天过了中午选课高峰期之后进行，查看你想要选择的课程是否还有空余的名额留给你抢</p></li><li><p>预选课结束后，正选开始之前，可以通过 <code>我的课表</code> 来查看自己预选的课程是否已经被选中了</p></li><li><p><code>培养方案完成情况</code> 里会有一部分学分因为与当前大四的培养方案不同而被放入计划外完成情况。这部分的学分会在你上大四的时候由教务添加进系统</p></li><li><p>查看成绩的时候，需要先评教才能查看成绩，可以通过培养方案完成情况来避开</p></li><li><p>关于重修刷分后成绩单的显示情况目前仍然没有定论，希望能有一个官方的说法。目前有听说出国用的英文成绩单在主校区的校史馆打印时可以选择将思修类课程去掉，但是所有这方面的消息都为传言，如有需要请自行询问教务</p></li><li><p>退课最晚大概是在补退选的时间，学期中间非身体原因教务不会给你退课的一般</p></li><li><p>大一的体育都是体能课，大二开始教技能，但是教的很浅</p></li></ul>          </div>]]></content>
    
    <summary type="html">
    
      Help you select your favorite courses in SSDUT&lt;br&gt;For freshman
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>2021 Review</title>
    <link href="https://augists.top/SELF/REVIEW/2021-Review/"/>
    <id>https://augists.top/SELF/REVIEW/2021-Review/</id>
    <published>2021-12-31T02:32:44.000Z</published>
    <updated>2021-12-31T15:50:12.031Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>由于疫情的影响，大三上学期的课时和考试都压缩了近三个周的时间。我也被迫没有像前两年一样能早一点写完自己的年终总结。站在这个时间点上，大学四年的必修课已经全部结束，只剩下学期的6门选修课程。这可能也意味着我的大学生活即将画上句号，紧接着的是需要考虑更为现实的一些问题。回顾整个2021年，完全可以用“魔幻”来形容。今年我打算换个方式，把这段经历讲给每一个看到的人听。</p><div class="note info">            <p>曾经有一个学长，人做的非常耿直，思维方式和很多人相差甚远，总是能做出一些很奇怪的事情。在他心里事物的重要程度很多人也无法理解，例如他一直认为在打扮自己这件事情上花费时间是世界上最蠢的了。进入大二后，他选择了留在dv工作室，做一个上要负责学院和校区活动的苦力，下要教好大一新干事的老师。所以，在dv为数不多的例会中，他有四次站在了讲台上，并且在寒假组织了dv大作业的例会，并首次做了b站的直播。在工作上，他可以放弃任何一门课程，来保证随时可以完成学院校区的大大小小的任务。这一学年，很多课他都没怎么去过，大多数时间工作室的副部也只有他守在那里，即便是期末考试前的一个周他每天晚上留在dv做图导出到两点他也没什么所谓。俗话说，干一行爱一行。既然选择了，那便去做。但是，他不能忍受的是别人的不理解。他不能忍受别人把他的工作定义为偷偷出去卷，他不能忍受在期末前的几天带着十个干事熬夜做了上百张图之后被当作没有活干，他不能忍受一年几百个小时的付出要和别的部门划等号甚至小于号，他最不能忍受的是作为工作室负责的老师居然不能理解大家的辛苦。他看着同事心疼，因为他无法想象几个原本应该在认真学着敲代码的本科生需要把无数的时间拿出来学习制作海报、制作视频，居然还会被要求再做的更好一点。要知道这种任务的报价完全不输于被公认为工资第一梯队的程序员的小项目报价，他们却几乎没什么回报。这一年，工作室添购了桌子椅子，新买了机箱等一众零零散散的配件，而直到2021年的最后一天都没能收到那少得可怜的工资奖励。</p><p>最终，他放弃了。5月份，在通过别人作为媒介传达无效后，他在会议上与负责老师针锋相对。留任面试中，他在ppt中用每一页用黑底白字协商在过去一年承担的任务，他走了ppt都没有播放完。他可以不在乎自己获得什么，可以无所谓后面的评选，他只想让人们能知道能理解他在dv工作室这一年的辛苦。在2021年的最后一天，他终于释然了。</p><div class="note danger">            <p>仰天大笑出门去，我辈岂是蓬蒿人</p>          </div>          </div><p>对于2021年前半部分的总结，大体上每天的记忆只剩下dv的工作、玩玩游戏就没了。寒假因为同学都在玩，把原神又拾起来，然后把自己的账号肝成天花板，还第一次在游戏里氪金。前后一共花了800多，账号平均33发出金。收手了，账号送给朋友，从此再也不碰。</p><p>这学期开始做校区心协的理事部部长，手下突然变成了二十多个人。本来在dv就全都是我崽崽，现在又多出来二十多个崽崽。是开心，也是责任。是教大家怎么才是干活，是看着副部能承担起大梁的欣慰，是每一次搞活动都逼着大家能随口说出来旁边人的名字，是解答每一个问问题的崽崽。很开心，可以又认识到这么多可爱的人。和之前的两年一样，没有人是为了什么社会工作奖学金在阿谀奉承，跟大家在一起，只有开心</p><p>幸运的是，4月底开始参与到嘉禾连理论坛的项目中，并且在五一正式上线开放测试。论坛一开始搭建在我的树莓派上，加挂了一个硬盘就作为测试版上线了。被网信中心找上来之后，论坛逐渐开始正规化，尝试并转向了各种云服务商，并使用着最为便宜的方案……认识了各种大佬，见识到很多以前没有接触过的东西。论坛这个项目被作为创新创业项目陪伴我们拿到了校、省奖，尽管由于学校的时间安排问题让我们被迫止步于辽宁省，但是非常开心我们的项目能收到来自华为的各位大佬的青睐。</p><p>更幸运的是，7月份能有机会和学长们一起去沈阳的宝马工厂拼3天2夜。从刚到的懵逼到通宵准备答辩。我们是全场最为年轻的队伍，也是唯一一个全由本科生组成的队伍，在一众来自美国、清北浙的研究生甚至博士生队伍中杀出重围，得到了来自宝马德国总部的工程师的赏识，非常侥幸拿到全国冠军🏆。3天，3个赛道，长了不止3斤。谢谢宝马工厂的热情款待，让我们不仅能开心的参与活动，拿到额外的活动小礼品，还拿到了最佳人气奖🏆</p><p>8月是今年最黑暗的一段时间。对现在的担忧、对未来的焦虑，我无法很好的调节自己的情绪，让我找不到方向，让我不得不放下了很多东西。谢谢从8月份一直理解、帮助我的每一个人。我知道，心态的转变肯定不是一朝一夕就能做到的，有些东西对于我这个不太擅长表达自己的人来说有些困难，所以很多是需要自己一点一点来慢慢化解开，过程痛苦有漫长</p><p>谢谢hzm的ps5和switch，让我这个游戏白痴踏上新大陆。在坚定我需要整一个来party game的想法同时让我在选择哪一个上纠结死；感谢老胡的3070，让我获得了一点科研体验顺便能在寝室联机</p><p>想了想，今年挣了不少钱。奖金、奖学金、挖矿（合法时）、以及看不见的工资。今年也没少花钱。买了心心念念的HHKB，把之前的poker借出去；给家里添了把心水的人体工学椅，就是我日常都不在家；在寝室放了台新显示器，是满足我需求的最低价格的显示器了；买了二手的架子，把寝室布置换了个底朝天；买了好一点的台灯，终于不用忍受之前台灯的电流声……</p><p>其实回过头来，看看大学已经经过的两年半，必修已经全部学完了的我们，也应该对自己的大学做个总结了。作为入学时站在起跑线的我们，比已经提前出发的人多跑了多远，又与同样从起跑线出发的人有什么区别……</p><p>2021，注定不平凡；2022，我们拭目以待</p>          </div>]]></content>
    
    <summary type="html">
    
      Written on December 31st 2021
    
    </summary>
    
    
    
      <category term="REVIEW" scheme="https://augists.top/tags/REVIEW/"/>
    
  </entry>
  
  <entry>
    <title>Software Engineering Review 2</title>
    <link href="https://augists.top/NOTES/COURSES/Software_Engineering/Software-Engineering-Review-2/"/>
    <id>https://augists.top/NOTES/COURSES/Software_Engineering/Software-Engineering-Review-2/</id>
    <published>2021-12-22T15:55:11.000Z</published>
    <updated>2021-12-24T11:23:02.717Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h2 id="软件工程学概述"><a href="#软件工程学概述" class="headerlink" title="软件工程学概述"></a>软件工程学概述</h2><h3 id="何谓软件危机"><a href="#何谓软件危机" class="headerlink" title="何谓软件危机"></a>何谓软件危机</h3><p>软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题</p><h3 id="产生软件危机的原因及解决途径"><a href="#产生软件危机的原因及解决途径" class="headerlink" title="产生软件危机的原因及解决途径"></a>产生软件危机的原因及解决途径</h3><ul><li><p>技术原因</p><ul><li>软件规模越来越大</li><li>软件复杂度越来越高</li></ul></li><li><p>管理原因</p><ul><li>软件开发缺乏正确的理论指导，过分依靠个人技巧和创造性</li><li>对用户需求没有完整准确的认识</li></ul></li><li><p>解决途径：软件工程</p><ul><li>对计算机软件正确认识</li><li>推广使用开发软件成功的技术和方法，研究探索更好更有效的技术和方法，消除错误概念和做法</li><li>开发和使用更好的软件工具</li><li>对于时间、人员、资源等需要引入更加合理的管理措施</li></ul></li></ul><h3 id="软件工程定义及基本原理"><a href="#软件工程定义及基本原理" class="headerlink" title="软件工程定义及基本原理"></a>软件工程定义及基本原理</h3><ul><li>软件工程<ul><li>将系统化、规范化、可量化的工程原则和方法，应用于软件的开发、运行和维护</li><li>对其中方法的理论研究</li></ul></li><li>主要目标<ul><li>高效开发高质量软件，降低开发成本</li></ul></li><li>基本原理<ul><li>用分阶段的生命周期计划严格管理</li><li>坚持进行阶段评审</li><li>实行严格的产品控制</li><li>采用现代程序设计技术</li><li>结果应能清楚的审查</li><li>开发小组的人员应该少而精</li><li>承认不断改进软件工程实践的必要性</li></ul></li></ul><h3 id="软件工程方法学包含哪三个要素"><a href="#软件工程方法学包含哪三个要素" class="headerlink" title="软件工程方法学包含哪三个要素"></a>软件工程方法学包含哪三个要素</h3><ul><li>方法</li><li>工具</li><li>过程</li></ul><h3 id="软件生命周期阶段划分及各阶段的任务"><a href="#软件生命周期阶段划分及各阶段的任务" class="headerlink" title="软件生命周期阶段划分及各阶段的任务"></a>软件生命周期阶段划分及各阶段的任务</h3><ul><li>可行性分析与开发计划<ul><li>约束和限制</li><li>简要需求分析，建立逻辑模型</li><li>对可供选择的解决方法进行研究<ul><li>技术可行性</li><li>经济可行性</li><li>社会可行性</li></ul></li></ul></li><li>需求分析<ul><li>功能需求</li><li>非功能性需求</li></ul></li><li>软件设计<ul><li>概要设计</li><li>详细设计</li></ul></li><li>程序编码</li><li>软件测试<ul><li>单元测试</li><li>集成测试</li><li>系统测试</li></ul></li><li>软件维护<ul><li>改正性维护</li><li>适应性维护</li><li>完善性维护</li><li>预防性维护</li></ul></li></ul><h3 id="各种生命周期模型的概念和特点"><a href="#各种生命周期模型的概念和特点" class="headerlink" title="各种生命周期模型的概念和特点"></a>各种生命周期模型的概念和特点</h3><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><ul><li>阶段间具有顺序性和依赖性，文档驱动</li><li>推迟实现，不急于编写代码<ul><li>尽可能的理解和掌握系统需求</li><li>清楚区分逻辑设计与物理设计，尽可能推迟程序的物理实现</li></ul></li><li>质量保证的观点<ul><li>每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务</li><li>每个阶段结束前都要对所完成的文档进行评审，以便尽早发现问题，改正错误</li></ul></li></ul><p>问题</p><ul><li>不希望有变化</li><li>变化来的越晚，付出的代价越高</li><li>设计阶段过多的假设，导致理想化、一厢情愿的东西过多（用户只参与需求）</li><li>文档驱动，静态</li></ul><p>适合规模较大的系统或分布式开发模式</p><h4 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h4><ul><li>对系统进行简单和快速的分析，快速构造一个软件原型</li><li>用户和开发者在试用或演示过程中加强沟通和反馈，获取到用户真正的需求</li></ul><p>问题</p><ul><li>所选用的开发技术和工具不一定是实际项目的需要</li><li>快速建立起来的模型可能由于不符合各种开发规范，加上不断修改，质量较差，被抛弃</li></ul><p>适合一个全新的系统开发</p><h4 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h4><ul><li>逐步增加系统功能</li><li>第一个增量构件往往实现软件的基本需求，提供最核心的功能</li></ul><p>问题：</p><ul><li>加入构件必须不破坏已构造好的系统部分</li><li>容易退化为“边做边改”模型，从而使软件过程的控制失去整体性</li></ul><h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><ul><li>在每个阶段之前都增加了风险分析过程（瀑布模型）的快速原型模型</li></ul><p>适合大型复杂的系统</p><h4 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h4><ul><li>典型的面向对象生命周期模型</li><li>迭代：逐步求精</li><li>阶段间没有明显的界限</li></ul><h4 id="敏捷软件开发"><a href="#敏捷软件开发" class="headerlink" title="敏捷软件开发"></a>敏捷软件开发</h4><ul><li>迭代式开发</li><li>增量交付</li><li>开发团队和用户反馈推动产品开发</li><li>持续集成</li><li>开发团队自我管理</li></ul><p>敏捷宣言：</p><ul><li>个体和互动胜过流程和工具</li><li>工作的软件胜过详尽的文档</li><li>客户合作胜过合同谈判</li><li>相应变化胜过遵循计划</li></ul><p>优势</p><ul><li>精确</li><li>质量</li><li>速度</li><li>丰厚的投资回报率</li><li>高效的自我管理团队</li></ul><p>适合规模中小、需求变化频繁的系统开发，并且强调团队的作用，适合集中式的开发模式</p><h4 id="极限编程"><a href="#极限编程" class="headerlink" title="极限编程"></a>极限编程</h4><ul><li>e<strong>X</strong>treme <strong>P</strong>rogramming</li><li>目的是降低需求变化的成本</li><li>开发方法<ul><li>客户代表与开发团队紧密融合</li><li>结对编程 pair-programming</li></ul></li><li>开发流程<ul><li>编写用户故事</li><li>架构规范</li><li>实施规划</li><li>迭代计划</li><li>代码开发</li><li>单元测试</li><li>验收测试</li></ul></li><li>核心做法<ul><li>小规模，频繁的版本发布，短迭代周期</li><li>测试驱动开发 Test-driven development</li><li>结对编程 Pair programming</li><li>持续集成 Continuous integration</li><li>每日站立会议 Daily stand-up meeting</li><li>共同拥有代码 Collative code ownership</li><li>系统隐喻 System metaphor</li></ul></li></ul><h3 id="了解敏捷过程和极限编程的基本思想"><a href="#了解敏捷过程和极限编程的基本思想" class="headerlink" title="了解敏捷过程和极限编程的基本思想"></a>了解敏捷过程和极限编程的基本思想</h3><ul><li>Scrum 注重过程，XP 注重实践</li><li>需求被定义为产品需求积压 product backlogs</li><li>开发过程氛围多个冲刺周期 sprint</li><li>燃尽图 burn down 显示当前冲刺中未完成的数目</li></ul><p>Scrum 角色</p><ul><li>产品拥有者 Product Owner</li><li>利益相关者 Stakeholder</li><li>专家 Scrum Master</li><li>团队成员 Team Member</li></ul><p>DevOps 过程</p><ul><li>核心目标是自动化和可持续交付</li></ul><h2 id="软件架构的构件"><a href="#软件架构的构件" class="headerlink" title="软件架构的构件"></a>软件架构的构件</h2><h3 id="4-1-视图"><a href="#4-1-视图" class="headerlink" title="4+1 视图"></a>4+1 视图</h3><ul><li>逻辑视图 Logic View<ul><li>主要支持系统的功能性需求，即系统提供给最终用户的服务</li><li>功能描述</li><li>类模型</li></ul></li><li>开发视图 Development View （模块视图 Module View）<ul><li>软件模块的组织和管理</li><li>软件可通过程序库或子系统进行组织</li><li>子系统</li><li>接口</li></ul></li><li>进程视图 Process View （并发视图）<ul><li>系统的运行特性，主要关注非功能性需求</li><li>处理流程</li><li>并行性</li><li>同步</li></ul></li><li>物理视图 Physical View<ul><li>把软件映射到硬件上</li><li>考虑系统性能、规模、可靠性</li><li>目标硬件</li><li>网络</li></ul></li><li>场景视图 Scenarios View<ul><li>重要系统活动的抽象</li></ul></li></ul><h3 id="软件架构风格"><a href="#软件架构风格" class="headerlink" title="软件架构风格"></a>软件架构风格</h3><h4 id="管道与过滤器"><a href="#管道与过滤器" class="headerlink" title="管道与过滤器"></a>管道与过滤器</h4><h4 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h4><h4 id="仓库-黑板系统"><a href="#仓库-黑板系统" class="headerlink" title="仓库/黑板系统"></a>仓库/黑板系统</h4><ul><li>中央数据结构：说明当前状态</li><li>独立构件：在中央数据存储上执行</li></ul><p>若输入流中某类时间触发进程执行的选择，则仓库是一个传统型数据库<br>若中央数据结构的当前状态触发进程执行的选择，则仓库是一个黑板系统</p><h4 id="正交软件结构"><a href="#正交软件结构" class="headerlink" title="正交软件结构"></a>正交软件结构</h4><ul><li>组织层</li><li>线索</li></ul><h4 id="客户机-服务器结构"><a href="#客户机-服务器结构" class="headerlink" title="客户机/服务器结构"></a>客户机/服务器结构</h4><ul><li>服务器：管理系统的资源，服务器访问与并发性控制、服务器安全性、服务器的备份与恢复和全局数据完整性规则</li><li>客户应用程序：提供用户与服务器交互的界面、向服务器提交用户请求并接收来自服务器的信息、利用客户应用程序对存在于客户端的数据执行应用逻辑要求</li><li>网络：完成服务器和客户应用程序之间的数据传输</li></ul><h4 id="浏览器-服务器结构"><a href="#浏览器-服务器结构" class="headerlink" title="浏览器/服务器结构"></a>浏览器/服务器结构</h4><p>与 C/S 结构相比，B/S 结构增加了一个应用服务器，可以将整个应用逻辑保存在应用服务器上，客户端的压力大大减轻，负荷被均衡的分配给了服务器</p><h4 id="MVC-结构"><a href="#MVC-结构" class="headerlink" title="MVC 结构"></a>MVC 结构</h4><p>Model View Controller</p>          </div>]]></content>
    
    <summary type="html">
    
      Software Engineering Review
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Software Engineering Review</title>
    <link href="https://augists.top/NOTES/COURSES/Software_Engineering/Software-Engineering-Review/"/>
    <id>https://augists.top/NOTES/COURSES/Software_Engineering/Software-Engineering-Review/</id>
    <published>2021-12-19T07:06:30.000Z</published>
    <updated>2021-12-20T06:00:41.480Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h1 id="软件工程复习"><a href="#软件工程复习" class="headerlink" title="软件工程复习"></a>软件工程复习</h1><p>软件工程三要素： 方法 工具 和 过程</p><h2 id="软件开发方法"><a href="#软件开发方法" class="headerlink" title="软件开发方法*"></a>软件开发方法*</h2><h3 id="传统开发方法"><a href="#传统开发方法" class="headerlink" title="传统开发方法"></a>传统开发方法</h3><p>结构化方法：分阶段的，顺序的，依赖性</p><p>缺点：缺少灵活性，静态，缺少应对变化的能力</p><h3 id="面向对象方法"><a href="#面向对象方法" class="headerlink" title="面向对象方法"></a>面向对象方法</h3><p>将软件构件划分为<strong>类</strong>，并定义一组静态的<strong>变量</strong>和动态的<strong>方法</strong></p><p>利用父子类和<strong>继承</strong>的关系形成<strong>层次结构</strong>，</p><p><strong>封装性</strong>：对象间仅能通过发送消息互相联系</p><p>通过<strong>反复迭代</strong>开发软件，降低<strong>复杂性</strong>，提高<strong>可理解性</strong>，支持<strong>软件重用</strong></p><p>更好的应对变化</p><h2 id="软件开发各阶段活动及任务"><a href="#软件开发各阶段活动及任务" class="headerlink" title="软件开发各阶段活动及任务*"></a>软件开发各阶段活动及任务*</h2><ul><li>可行性分析：高层次需求分析 - 技术，经济，社会</li><li>需求分析：进行<strong>变更管理</strong>适应变化，分为功能性和非功能性，输出需求规格说明书</li><li>软件设计：概要+详细</li><li>程序编码</li><li>软件测试：单元-&gt;集成-&gt;系统，分为黑盒和白盒</li><li>软件维护：改正性，适应性，完善性，预防性</li></ul><h2 id="生命周期模型"><a href="#生命周期模型" class="headerlink" title="生命周期模型"></a>生命周期模型</h2><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型*"></a>瀑布模型*</h3><p>传统开发方法 <strong>最广泛</strong>，顺序性，依赖性</p><p>推迟写代码，每个阶段都写文档</p><p>缺点：用户参与少，静态</p><h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型*"></a>快速原型模型*</h3><p>看名</p><p>优点： 用户参与多了</p><p>缺点： 原型大概率抛弃</p><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><p>分为功能模块，逐步实现（开放架构）</p><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>瀑布+快速原型+风险分析</p><p>每阶段增加风险分析，降低风险</p><h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型*"></a>喷泉模型*</h3><p>迭代和无缝</p><p>总目标：线性过程</p><p><strong>迭代</strong> 逐步求精，面向对象</p><h2 id="敏捷"><a href="#敏捷" class="headerlink" title="敏捷"></a>敏捷</h2><h3 id="敏捷宣言"><a href="#敏捷宣言" class="headerlink" title="敏捷宣言"></a>敏捷宣言</h3><ul><li>个体 + 互动 &gt; 流程 + 工具</li><li>软件 &gt; 文档</li><li>客户合作 &gt; 合同谈判</li><li>相应变化 &gt; 遵循计划</li></ul><h3 id="增量和迭代"><a href="#增量和迭代" class="headerlink" title="增量和迭代"></a>增量和迭代</h3><p>系统由三个模块构成</p><ul><li><p>增量：一个个实现</p></li><li><p>迭代：实现三个垃圾模块，再一步步求精</p></li></ul><h3 id="SCRUM"><a href="#SCRUM" class="headerlink" title="SCRUM*"></a>SCRUM*</h3><p><strong>冲刺 Sprint</strong>：一个工作周期</p><ul><li>产品订单：项目的概要文档，以天为单位</li><li>冲刺订单：小文档，以 16 小时为单位</li><li>燃尽图：to-do list</li></ul><p>角色</p><ul><li>产品拥有者：甲方领导</li><li>利益相关者：客户</li><li>专家：技术总监</li><li>团队成员：程序员</li></ul><p>活动</p><ul><li>计划会：冲刺初制定计划</li><li>每日立会：每天15分钟</li><li>评审会：冲刺结束前</li><li>反思会/回顾会：冲刺结束后</li></ul><p>XP(极限编程) 于 SCRUM 区别</p><table><thead><tr><th></th><th>XP</th><th>SCRUM</th></tr></thead><tbody><tr><td>迭代长度</td><td>1-2周</td><td>3-4周</td></tr><tr><td>迭代中是否允许修改需求</td><td>yes</td><td>no</td></tr><tr><td>迭代中是否按优先级实现</td><td>yes</td><td>no</td></tr><tr><td>是否采用严格工程方法，保证进度质量</td><td>yes</td><td>no</td></tr></tbody></table><h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3><p>自动化，高度依赖工具</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="用户-amp-系统"><a href="#用户-amp-系统" class="headerlink" title="用户 &amp; 系统"></a>用户 &amp; 系统</h3><ul><li>系统需求是对用户需求的细化和完善</li><li>系统需求的阅读对象是开发者，用户需求是客户</li><li>系统需求是用户需求的开始</li><li>目标 &amp; 涉众</li></ul><h3 id="涉众"><a href="#涉众" class="headerlink" title="涉众"></a>涉众</h3><p>与目标系统相关的一切人和物</p><h3 id="系统功能的确定"><a href="#系统功能的确定" class="headerlink" title="系统功能的确定"></a>系统功能的确定</h3><p>正式和非正式的访谈</p><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>用例-&gt;规约用例并生成文档-&gt;活动图-&gt;文字功能性需求</p><h4 id="三种功能性需求"><a href="#三种功能性需求" class="headerlink" title="三种功能性需求"></a>三种功能性需求</h4><p>系统功能需求 + 交互需求 + 外部接口需求</p><h4 id="需求说明书"><a href="#需求说明书" class="headerlink" title="需求说明书"></a>需求说明书</h4><p>文档+涉众+目标+功能，非功能+交付物+验收标准+附件</p><h4 id="需求跟踪"><a href="#需求跟踪" class="headerlink" title="需求跟踪"></a>需求跟踪</h4><p>业务，需求，类模型 三者递归确定，互有对应</p><p>活动图，需求文档，类图</p><p>提高完备性，同时检查是否有冗余（有没有缺的，多的）</p><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><h3 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h3><p>构件 + 连接件 + 配置</p><h3 id="数据流风格"><a href="#数据流风格" class="headerlink" title="数据流风格"></a>数据流风格</h3><p><strong>管道与过滤器</strong>：信息隐藏，高内聚低耦合，可以灵活组合</p><p><strong>层次系统</strong>：计算机网络</p><p><strong>正交软件架构</strong>：</p><ul><li><p>层：一组具有相同抽象级别的构件</p></li><li><p>线索：用例形成的调用关系</p></li><li><p>好处：每个需求变动仅影响某一条线索</p></li></ul><p><strong>客户机服务器架构</strong>：</p><ul><li>一个服务器服务多个客户端</li><li>适应变化，灵活</li><li>易于对系统进行扩充和缩小</li><li>功能构建隔离</li></ul><p><strong>浏览器/服务器架构</strong>：基本同上+抽取client的function形成的web服务器</p><h3 id="独立构建风格"><a href="#独立构建风格" class="headerlink" title="独立构建风格"></a>独立构建风格</h3><h4 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构*"></a>MVC架构*</h4><ul><li><p>Model: 企业数据和业务规则</p></li><li><p>View: 用户看到并与之交互的界面</p></li><li><p>Controller: 根据输入调用模型和视图去完成用户的需求，不输出结果，不做任何处理</p></li></ul><h3 id="数据中心风格-仓库系统"><a href="#数据中心风格-仓库系统" class="headerlink" title="数据中心风格 - 仓库系统"></a>数据中心风格 - 仓库系统</h3><p>星型结构，中央数据库和周边client</p><p>黑板系统：中央数据库将状态通知client，由client决定选择</p><h2 id="类的分析与设计"><a href="#类的分析与设计" class="headerlink" title="类的分析与设计"></a>类的分析与设计</h2><p>迭代逐级细化</p><h3 id="类的种类"><a href="#类的种类" class="headerlink" title="类的种类"></a>类的种类</h3><ul><li>实体类：存储，传递数据的类，名词</li><li>控制类：管理类，体现执行逻辑，动宾</li><li>边界类：外部用户交互，界面类，数据交换类</li></ul><h4 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h4><p>初始类图-实体类</p><p><strong>实体类</strong> <code>&lt;&lt;entity&gt;&gt;</code></p><ul><li>类名：构造性</li><li>变量：<ul><li>可见性 (private, public ..) - (<code>-+_~</code>)</li><li>依赖（计算）属性，(<code>/</code>)</li><li>名字</li><li>类型：UML定义的，int String…</li><li>下划线：表示静态</li></ul></li></ul><p>没有方法</p><h4 id="类的关系"><a href="#类的关系" class="headerlink" title="类的关系*"></a>类的关系*</h4><ul><li>关联关系：静态，拥有，长期持久</li><li>导航方向：箭头，包含关系</li><li>依赖关系：动态，临时 - 避免双向依赖</li><li>依赖 包含 关联</li></ul><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul><li>对象名：类的类型</li><li>实例变量 = 初始值</li><li>对象名为空代表匿名对象，类名为空代表有上下文</li></ul><h4 id="管理类-amp-控制类"><a href="#管理类-amp-控制类" class="headerlink" title="管理类 &amp; 控制类"></a>管理类 &amp; 控制类</h4><table><thead><tr><th></th><th>管理类</th><th>控制类</th></tr></thead><tbody><tr><td></td><td>不考虑get，set方法</td><td>隔离边界与实体</td></tr><tr><td>对象</td><td>对于同类对象的协调和管理</td><td>不同类</td></tr><tr><td>层</td><td>Domain层</td><td>业务控制层</td></tr><tr><td>作用</td><td>创建对象，代理访问其他对象</td><td>一个用例一个</td></tr></tbody></table><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>利用抽象类隔离变化</p><p>空三角箭头表示继承</p><h4 id="枚举类-lt-lt-enumeration-gt-gt"><a href="#枚举类-lt-lt-enumeration-gt-gt" class="headerlink" title="枚举类 &lt;&lt;enumeration&gt;&gt;"></a>枚举类 <code>&lt;&lt;enumeration&gt;&gt;</code></h4><h4 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h4><p>对实体，生成 <code>ProjectMask</code> 代理类</p><h4 id="CASE工具"><a href="#CASE工具" class="headerlink" title="CASE工具"></a>CASE工具</h4><p>软件开发环境，计算机辅助软件工程</p><h2 id="类的关系-1"><a href="#类的关系-1" class="headerlink" title="类的关系"></a>类的关系</h2><h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><table><thead><tr><th>是否要求顺序</th><th>是否要求唯一性</th><th></th></tr></thead><tbody><tr><td>no</td><td>yes</td><td>Set</td></tr><tr><td>no</td><td>no</td><td>Bag/Multiset</td></tr><tr><td>yes</td><td>yes</td><td>OrderedSet</td></tr><tr><td>yes</td><td>no</td><td>List/Sequence</td></tr></tbody></table><p>适用模板类而非具体类</p><h4 id="聚合-聚集"><a href="#聚合-聚集" class="headerlink" title="聚合 - 聚集"></a>聚合 - 聚集</h4><p>部分与整体，共享</p><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>存在依赖性 - 同生共死</p><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>访问的瞬时性 - 用参数</p><h2 id="类的详细设计"><a href="#类的详细设计" class="headerlink" title="类的详细设计"></a>类的详细设计</h2><p>算法+数据结构+物理结构</p><p>其他设计+详细设计说明书+评审</p><p>什么是结构化的程序</p><h3 id="盒图"><a href="#盒图" class="headerlink" title="盒图"></a>盒图</h3><p>图例：不允许随意跳转 - 向里嵌套</p><h3 id="PAD图"><a href="#PAD图" class="headerlink" title="PAD图"></a>PAD图</h3><p>问题分析图 - 向右嵌套</p><h3 id="判定表"><a href="#判定表" class="headerlink" title="判定表"></a>判定表</h3><p>使用<code>—</code>来表 示对此条件的不关心或不适用</p><p>判定树：结点-选择，叶子-结果</p><h3 id="PDL"><a href="#PDL" class="headerlink" title="PDL"></a>PDL</h3><p>人话版的C语言</p><h3 id="OCL"><a href="#OCL" class="headerlink" title="OCL"></a>OCL</h3><h2 id="设计优化"><a href="#设计优化" class="headerlink" title="设计优化"></a>设计优化</h2><h3 id="smell"><a href="#smell" class="headerlink" title="smell"></a>smell</h3><p>僵化性，脆弱性，顽固性，粘滞性，复杂，重复，晦涩</p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><ul><li>与父类方法有相似的行为，细节调整</li><li>相同条件工作，子类不应具有比其父类更严格的条件限制 - <strong>Liskov 替换原则</strong></li><li>重写的方法最高不能超出父类方法的状态。</li></ul><p>循环依赖：提取接口</p><p>狎昵关系：两个类过分亲密，高耦合</p><p>接口隔离原则：接口的稳定，适应变化，同一个类提取不同的接口</p><p>依赖倒置原则：依赖于抽象</p><p>开放封闭原则：扩展开放，修改封闭</p><p>单一职责原则：单一功能</p><p>合成/聚合复用原则：尽量使用合成/聚合形式的委托重用，尽量不使用继承重用</p><blockquote><p>子类是父类的特殊类型</p></blockquote><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li>架构模式：MVC，层次等</li><li>设计模式：抽象工程之类的</li><li>实现模式：具体到写代码，类名，变量名，函数名</li></ul><table><thead><tr><th></th><th>创建模式</th><th>结构模式</th><th>行为模式</th></tr></thead><tbody><tr><td>类</td><td>抽象工厂</td><td>适配器</td><td>观察者模式</td></tr><tr><td>类</td><td>单例</td><td>桥 - 装饰</td><td>策略模式</td></tr><tr><td>类</td><td></td><td>代理</td><td>状态</td></tr><tr><td>类</td><td></td><td>门面</td><td></td></tr></tbody></table><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>工厂表示一组产品的打包，不同的工厂对应不同的组合</p><p>抽象工厂是一个接口，用于生成一组对象，实际对象根据类别又有自己的接口</p><p>低耦合，且添加新的更容易</p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>管理类或控制类系统中只需要一个实例，该实例在程序中被创建</p><p>要求类的构造方法是私有的，有公有的方法获取该类的实例，实例变量为私有或受保护的。</p><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>利用适配器进行接口的转换</p><h4 id="桥模式"><a href="#桥模式" class="headerlink" title="桥模式"></a>桥模式</h4><p>先将不同的变化维度（单一职责原则）分离，每个维度都有独立的抽象和继承结构，建立抽象耦合</p><h4 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h4><p>对于负数功能，若将其归入不同的变化维度太多了，归入装饰器</p><p>将 Bridge 中的抽象和实现合二为一了，是其特殊形式</p><h4 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h4><p>外部与一个子系统的通信必须通过一个统一的门面对象，且单例</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>中介，负责资源的中间处理，节省主体的时间</p><p>用来对有价值稀缺资源的管理，比如数据库的连接等，提高资源的利用率或系统性能</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>MVC 适用了观察者</p><p>当主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己</p><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>将每一个算法封装到具有共同接口的独立的类中</p><p>灵活可以相互替换</p><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p>使用一个具有多个子类的类，提前创建所有对应的子类，状态变化时换类</p><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p>测试的通过并不能用来证明整个系统是正确的</p><h3 id="测试V模型-测试"><a href="#测试V模型-测试" class="headerlink" title="测试V模型 + 测试*"></a>测试V模型 + 测试*</h3><table><thead><tr><th>测试名称</th><th>开发阶段</th><th>测试对象</th><th>测试方法</th></tr></thead><tbody><tr><td>单元测试</td><td>实现</td><td>类测试</td><td>白盒测试</td></tr><tr><td>集成测试</td><td>系统设计</td><td>包或系统测试-交互</td><td>灰盒测试</td></tr><tr><td>系统测试</td><td>系统需求</td><td>构件和接口测试</td><td>黑盒测试</td></tr><tr><td>验收测试</td><td>客户需求</td><td>现场复现</td><td>黑盒测试</td></tr></tbody></table><p>为什么要早修正</p><ul><li>涉及的范围越来越广泛</li><li>曾经付出的成本越来越高</li></ul><p>看一眼 P9 左下图</p><h5 id="非功能测试"><a href="#非功能测试" class="headerlink" title="非功能测试"></a>非功能测试</h5><p>峰值，尖峰，压力，浸泡</p><h4 id="软件度量"><a href="#软件度量" class="headerlink" title="软件度量"></a>软件度量</h4><h5 id="McCabe-控制流图"><a href="#McCabe-控制流图" class="headerlink" title="McCabe + 控制流图"></a>McCabe + 控制流图</h5><p>边数 - 点数 + 2 = 分支结点+1</p><h5 id="LCOM"><a href="#LCOM" class="headerlink" title="LCOM"></a>LCOM</h5><p><img src="https://s2.loli.net/2021/12/20/3BY8Z46qzw5btSX.png" alt=""></p><p>m为方法数，a为所含的实例变量数，为访问每个实例变量的方法数。</p><h4 id="等价类测试-黑盒"><a href="#等价类测试-黑盒" class="headerlink" title="等价类测试 - 黑盒"></a>等价类测试 - 黑盒</h4><ul><li>数值：一般，一个有效，两个无效</li><li>其他：一个有效，一个无效</li><li>传统 + 强等价类方法</li><li>边界值分析：对数值边界创建有效或无效等价类</li></ul><h4 id="控制流的覆盖测试-白盒"><a href="#控制流的覆盖测试-白盒" class="headerlink" title="控制流的覆盖测试 - 白盒"></a>控制流的覆盖测试 - 白盒</h4><ul><li>语句覆盖 - 结点</li><li>分支覆盖 - 边</li><li>条件覆盖 - 原子谓词真假</li></ul><p>满足分支覆盖要求一定会满足语句覆盖要求</p><ul><li><p>分支覆盖不能覆盖条件，因为条件是原子谓词判断，但对于组合条件可能会有诸如短路的情况</p></li><li><p>条件不能覆盖分支，因为是原子谓词，可能有没覆盖到的情况</p></li></ul><p>分支，条件并不完全覆盖，综合一下</p><ul><li><p>多条件组合覆盖 - 原子谓词及其组合覆盖</p></li><li><p>基本路径测试 - 独立路径 （ 独立路径要求在路径中至少含有一条未曾使用过的边）</p><ul><li><code>&lt;= V(G)</code></li></ul></li></ul><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><h4 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h4><p>可测试性 - 彼此依赖而需要模拟程序或桩</p><p>设计简单方法</p><p>避免私有方法</p><p>优先使用通用方法</p><p>组合优于继承</p><p>避免隐藏的依赖关系与全局状态</p><h4 id="人工测试"><a href="#人工测试" class="headerlink" title="人工测试"></a>人工测试</h4><p>审查 - 评审 - 走查</p><h2 id="CMMI"><a href="#CMMI" class="headerlink" title="CMMI"></a>CMMI</h2><p>统一的，明确定义的组织级软件工程</p><p>初始级 - 已管理 - 已定义 - 已量化管理 - 优化</p><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><p>注意同一个图中的用例在同一个抽象级别</p><h4 id="角色-Actor"><a href="#角色-Actor" class="headerlink" title="角色 Actor"></a>角色 Actor</h4><p>人或软件系统，使用系统，与系统有关系</p><h4 id="寻找用例"><a href="#寻找用例" class="headerlink" title="寻找用例"></a>寻找用例</h4><h4 id="包含关系-lt-lt-include-gt-gt"><a href="#包含关系-lt-lt-include-gt-gt" class="headerlink" title="包含关系 &lt;&lt;include&gt;&gt;"></a>包含关系 <code>&lt;&lt;include&gt;&gt;</code></h4><p>一些通用，共同基础过程的功能，避免重复实现 - 非逻辑分解</p><p>关键词：依赖，包含</p><h4 id="扩展关系-lt-lt-extend-gt-gt"><a href="#扩展关系-lt-lt-extend-gt-gt" class="headerlink" title="扩展关系 &lt;&lt;extend&gt;&gt;"></a>扩展关系 <code>&lt;&lt;extend&gt;&gt;</code></h4><p>特殊情况，需要有条件</p><p>关键词：错误，特殊情况</p><h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3><p>跨用例</p><h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><ul><li><strong>开始点</strong>：实心圆点</li><li><strong>结束点</strong>：实心加一圈</li><li><strong>动作</strong>：圆角矩形</li><li><strong>条件</strong>：菱形 - 可省略</li><li><strong>分支，汇聚</strong>：粗横线，{and}，{or}</li><li><strong>对象</strong>：直角矩形</li><li><strong>集合</strong>：多个动作（三叉戟）</li></ul><p>如果动作具有多个汇聚的箭头，需要等待所有分支都完成</p><h4 id="泳道"><a href="#泳道" class="headerlink" title="泳道"></a>泳道</h4><p>按角色划分</p><h4 id="基本事件流和备选"><a href="#基本事件流和备选" class="headerlink" title="基本事件流和备选"></a>基本事件流和备选</h4><p>利用中括号<code>[]</code>围绕子活动或者进入备选事件流的条件，可以另用活动图描述</p><h3 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h3><h4 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a>基本符号</h4><p>实体，处理，存储，流</p><h4 id="画法"><a href="#画法" class="headerlink" title="画法"></a>画法</h4><p>看课件</p><h3 id="包图"><a href="#包图" class="headerlink" title="包图"></a>包图</h3><p>大包嵌套小包，小包嵌套类</p><p>⊕：嵌套关系</p><p>虚线：层间的使用(依赖)关系</p><p>实线：包间的使用(依赖)关系</p><p>空心三角：继承</p><p>避免循环依赖</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><h4 id="领域模型-1"><a href="#领域模型-1" class="headerlink" title="领域模型"></a>领域模型</h4><h5 id="实体类-lt-lt-entity-gt-gt"><a href="#实体类-lt-lt-entity-gt-gt" class="headerlink" title="实体类 &lt;&lt;entity&gt;&gt;"></a>实体类 <code>&lt;&lt;entity&gt;&gt;</code></h5><ul><li>类名：构造性</li><li>变量：<ul><li>可见性 (private, public ..) - (<code>-+_~</code>)</li><li>依赖（计算）属性，(<code>/</code>)</li><li>名字：</li><li>类型：UML定义的，int String…</li><li>下划线：表示静态</li></ul></li><li>方法：<ul><li>同上</li><li>参数三种类型：in, out, inout</li></ul></li></ul><p>没有方法</p><h4 id="关联类"><a href="#关联类" class="headerlink" title="关联类"></a>关联类</h4><p>描述两个对象之间的联系</p><h3 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h3><p>表示一个用例，同步调用的方式（阻塞）</p><ul><li>控制焦点：长方形</li><li>生命线：竖虚线</li><li>同步消息：实心三角箭头（左右都可以）</li><li>返回消息：虚线左箭头</li><li>异步消息：创建对象，虚线右箭头</li></ul><p>结构：</p><ul><li>方括号 condition</li><li>可选：opt - 有条件执行的动作，不满足条件就不执行</li><li>多分支 alt - 不同的条件执行不同</li><li>循环 loop (start,end,condition)</li></ul><h3 id="通信图"><a href="#通信图" class="headerlink" title="通信图"></a>通信图</h3><p>可嵌套，或用编号 编号表示嵌套级别</p><p>其他与顺序图类似</p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p>唯一的开始状态，可以有多个结束状态，针对确定性行为</p><p>转台框中的三个状态：Entry - Do - Exit</p><h4 id="状态转换-过渡"><a href="#状态转换-过渡" class="headerlink" title="状态转换 - 过渡"></a>状态转换 - 过渡</h4><p>事件+[条件]+动作</p><p>在事件被触发并且满足某个特定条件的情况下才会进行</p><p>动作：entry 执行前，未进入状态时做的动作</p><p>层次化组织：框起来</p><p>分解：分解为互不依赖的子状态 - 子状态离开</p><p>并行：有两个输入，则都完成才会被触发</p><h2 id="体系结构风格"><a href="#体系结构风格" class="headerlink" title="体系结构风格"></a>体系结构风格</h2><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>从低到高排序</p><p>内聚程度：内部各个元素彼此结合的紧密程度 - 越高，模块独立性越强</p><ul><li>偶然内聚</li><li>逻辑内聚</li><li>时间内聚</li><li>通信内聚</li><li>顺序内聚</li><li>功能内聚</li></ul><p>耦合程度：模块之间互相连接的紧密程度 - 越低，模块独立性越强</p><p>非直接 &lt; 数据 &lt; 标记 &lt; 控制 &lt; 外部 &lt; 公共 &lt; 内容</p><h3 id="4-1-视图模型"><a href="#4-1-视图模型" class="headerlink" title="4+1 视图模型"></a>4+1 视图模型</h3><p>用例在中间，四周是逻辑视图（功能需求），开发试图（软件模块），进程视图（并发），物理视图（硬件）</p>          </div>]]></content>
    
    <summary type="html">
    
      Copyright (c) Dingsoul&lt;br&gt;Link: https://dingiso.github.io/2021/03/11/软件工程复习/
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Unix Network Programming Review</title>
    <link href="https://augists.top/NOTES/COURSES/Advanced_C/Unix-Network-Programming-Review/"/>
    <id>https://augists.top/NOTES/COURSES/Advanced_C/Unix-Network-Programming-Review/</id>
    <published>2021-12-16T07:52:12.000Z</published>
    <updated>2021-12-26T16:07:58.299Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>大小端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">union</span> un</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">short</span> a;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">  &#125;u;</span><br><span class="line"></span><br><span class="line">  u.a = <span class="number">0x0102</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(u.b[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; u.b[<span class="number">1</span>] == <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;big endian&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(u.b[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; u.b[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;small endian&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>intro/daytimetcpcli.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd, n;</span><br><span class="line">  <span class="keyword">char</span> recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;usage: a.out &lt;IPaddress&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = htons(<span class="number">13</span>);</span><br><span class="line">  <span class="keyword">if</span> (inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;inet_pton error for %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (connect(sockfd, (SA *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( (n = read(sockfd, recvline, MAXLINE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    recvline[n] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>) == EOF)</span><br><span class="line">      err_sys(<span class="string">&quot;fputs error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>intro/daytimetcpsrv.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">  <span class="keyword">char</span> buff[MAXLINE];</span><br><span class="line">  <span class="keyword">time_t</span> ticks;</span><br><span class="line"></span><br><span class="line">  listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  bzeros(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  servaddr.sin_port = htons(<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">  Bind(listenfd, (SA *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">  Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">    connfd = Accept(listenfd, (SA *) <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    ticks = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(buff, <span class="keyword">sizeof</span>(buff), <span class="string">&quot;%.24s\r\n&quot;</span>, ctime(&amp;ticks));</span><br><span class="line">    Write(connfd, buff, <span class="built_in">strlen</span>(buff));</span><br><span class="line"></span><br><span class="line">    Close(connfd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Concurrent Server</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> listenfd, connfd;</span><br><span class="line"></span><br><span class="line">listenfd = Socket ( ... );</span><br><span class="line"></span><br><span class="line">Bind(listenfd, ... );</span><br><span class="line">Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">  connfd = Accept(listenfd, ... );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (pid = Fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">    Close(listenfd);  <span class="comment">/* child closes listening socket */</span></span><br><span class="line">    doit(connfd);     <span class="comment">/* process the request */</span></span><br><span class="line">    Close(connfd);    <span class="comment">/* done with this client */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);          <span class="comment">/* child terminates */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   Close(connfd);     <span class="comment">/* parent close connected socket */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>TCP echo server<br><code>tcpdiserv/tcpserv01.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_echo</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> n;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">  <span class="keyword">while</span> ( (n = read(sockfd, buf, MAXLINE)) &gt; <span class="number">0</span>)</span><br><span class="line">    Writen(sockfd, buf, n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">    <span class="keyword">goto</span> again;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;str_echo: read error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">  <span class="keyword">pid_t</span> childpid;</span><br><span class="line">  <span class="keyword">socklen_t</span> clilen;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  listenfd = Socket (AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  servaddr.sin_port(SERV_PORT);</span><br><span class="line"></span><br><span class="line">  Bind(listenfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; ; )</span><br><span class="line">  &#123;</span><br><span class="line">    clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (childpid = fork()) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      Close(listenfd);</span><br><span class="line">      str_echo(connfd);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(connfd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tcpcliserv/tcpcli01.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    Writen(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Readline(sockfd, recvline, MAXLINE) == <span class="number">0</span>)</span><br><span class="line">      err_quit(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;usage: tcpcli &lt;IPaddress&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  sockfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">  Inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">  Connect(sockfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">  str_cli(<span class="built_in">stdin</span>, sockfd);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>UDP echo server<br><code>udpcliserv/udpserv01.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dg_echo</span><span class="params">(<span class="keyword">int</span> sockfd, SA *pcliaddr, <span class="keyword">socklen_t</span> clilen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">socklen_t</span> len;</span><br><span class="line">  <span class="keyword">char</span> mesg[MAXLINE];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; ; )</span><br><span class="line">  &#123;</span><br><span class="line">    len = clilen;</span><br><span class="line">    n = Recvfrom(sockfd, mesg, MAXLINE, <span class="number">0</span>, pcliaddr, &amp;len);</span><br><span class="line">    Sendto(sockfd, mesg, n, <span class="number">0</span>, pcliaddr, len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  sockfd = Socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">  Bind(sockfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">  dg_echo(sockfd, (SA *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UDP echo client<br><code>udpcliserv/udpcli01.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&quot;unp.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dg_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd, <span class="keyword">const</span> SA *pservaddr, <span class="keyword">socklen_t</span> servlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    Sendto(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>, pservaddr, servlen);</span><br><span class="line"></span><br><span class="line">    n = Recvfrom(sockfd, recvline, MAXLINE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    recvline[n] = <span class="number">0</span>;</span><br><span class="line">    Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;usage: udpcli &lt;IPaddress&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servadr.sin_port = htons(SERV_PORT);</span><br><span class="line">  Inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">  sockfd = Socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  dg_cli(<span class="built_in">stdin</span>, sockfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>信号处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用:Signal(SIGCHID,sig_chld);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_chld</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> stat;   <span class="comment">//value-result para</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>waitpid 可以通过指定 pid，指定终止某个子进程，wait 不能</li><li>在没有已经终止的子进程时，waitpid 可以不阻塞，但 wait 会阻塞，直到正在执行的子进程终止。</li></ul><hr><ul><li>解释datalink access，写出一个datalink access的实现<ul><li>操作系统为应用程序提供访问数据链路层的功能，这种功能可提供如下能力:<ul><li>能够监视由数据链路层接收的分组</li><li>能够作为普通应用进程而不是内核的一部分运行某些程序，例如: RARP<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL));</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><hr><ul><li>写出重启被中断的accept函数程序片段<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">  clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">  <span class="keyword">if</span> (connfd = accept(listenfd, (SA *)&amp;cliaddr, &amp;clilen) &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      err_sys(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>TCP echo 程序如何区分服务器进程终止和服务器崩溃<ul><li>进程终止: 客户端收到一个 FIN 并返回一个 ACK，但客户进程此时处于 fgets 调用的阻塞中，等待从客户端接收到一行文本。(此时客户端并不知道服务器子进程已经终止，只是单纯的接收到了一个 FIN) 而后，我们在客户上再键入一行文本。<code>str_cli</code> 调用 writen 发送数据给服务子进程，但由于服务子进程已经关闭，于是发送一个RST。我们客户端 readline 时若先收到第二步中的 FIN，则立即返回 0，如果先接收到 RST，则返回一个 <code>ECONNRESET</code> (对方复位连接错误)</li><li>服务器崩溃: 在客户端上键入一行文本，由 writen 写入内核。writen 成功返回后，客户随后阻塞于 readline 调用，客户端持续重传数据分节，试图从服务器上接收一个 ACK。然而服务器已崩坏，没有任何响应，最终 readline 调用上返回一个错误。如果是主机崩溃，则返回超时 <code>ETIMEOUT</code></li><li>进程终止: 服务器发送 FIN</li><li>崩溃: 服务器不会在已有网络上发送任何信号</li></ul></li></ul><hr><ul><li><code>fork()</code> 和 <code>exec()</code><ul><li>fork<ul><li>子进程复制父进程的所有进程内存到其内存地址空间。父，子进程的数据段，堆栈段和代码段完全相同</li><li>子进程拥有自己的进程ID</li></ul></li><li>exec<ul><li>进程调用 <code>exec()</code> 后，将在同一块进程内存里用一个新程序来代替调用 <code>exec()</code> 的那个进程，当前进程的“数据段”，“堆栈段”和“代码段”被新程序改写</li><li>新程序会保持调用 <code>exec()</code> 进程的 ID 不变</li></ul></li></ul></li></ul><hr><ul><li>原始套接字提供的三种UDP/TCP不具备的特点<ul><li>读写ICMPv4，ICMPv6，IGMPv4分组</li><li>读写内核不处理其协议字段的IPv4数据报</li><li>使用 <code>IP_HDRINCL</code> 套接字选项自行构造IPv4首部</li></ul></li></ul><hr><ul><li>defunct<ul><li>进程所谓的“僵死”状态。一个子进程结束了，但是它的父进程并没有 wait/waitpid 它，则它的状态是 defunct，进程早已死亡，但仍占有一个 pid</li></ul></li></ul><hr><ul><li>traceroute<ul><li>原理是利用了IPv4的TTL字段或IPv6的跳限字段，一开始设置为1，然后中间节点会返 回一个ICMP”time exceeded in transmit”(传输中超时)错误，接着逐渐增大TTL，从而逐 步确定下一跳路由地址。直至目的节点返回一个ICMP”port unreachable”(端口不可达)错 误，则表示到达目的节点(这要求目的节点没有在该端口上开启服务，即发送ICMP包时，目 的端口号应该选择一个未被目的主机使用的端口号 ==&gt; traceroute选择了一个大于30000值 作为目的端口号，因为UDP协议要求端口号必须小于30000，所以目的主机如果接收到必然 会会一个ICMP端口不可达错误)。</li><li>tracert 有一个固定的时间等待响应(ICMP TTL到期消息)。如果这个时间过了，它将打印出一系列的<code>*</code>号表明：在这个路径上，这个设备不能在给定的时间内发出ICMP TTL到期消息的响应。然后，Tracert给TTL记数器加1，继续进行</li></ul></li></ul><hr><p>setsockopt 和 getsockopt</p><table><thead><tr><th>level</th><th>optname</th><th>description</th></tr></thead><tbody><tr><td>SO_SOCKET</td><td>SO_KEEPALIVE</td><td>周期性测试连接是否还存在</td></tr><tr><td>SO_SOCKET</td><td>SO_LINGER</td><td>若有数据待发送则延迟关闭</td></tr><tr><td>IPPROTO_IP</td><td>IP_HDRINCL</td><td>随数据包含的IP首部</td></tr><tr><td>IPPROTO_IP</td><td>IP_TTL</td><td>Time to Live</td></tr><tr><td>IPPROTO_TCP</td><td>TCP_MAXSEG</td><td>TCP最大报文大小</td></tr><tr><td>IPPROTO_TCP</td><td>TCP_NODELAY</td><td>禁止nagle算法</td></tr></tbody></table><hr><h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><p>考著名的人物：</p><ul><li>K&amp;R: Kernighan 和 Ritchie</li><li>c语言作者，unix 作者: Ken Thompson 和 Dennis M. Ritchie</li><li>GNU 创建者/Emacs 作者: Richard Matthew Stallman </li><li>linux 作者: Linus Benedict Torvalds</li><li>vim 作者: Bram Moolenaar</li><li>Tex 作者: Donald Knuth 高德纳</li></ul><h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><p>TCP 状态转换图 ， 2.9 常用的Port Number ，2.10 Concurrent Server ， 2.12 services</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">21端口：FTP 文件传输服务</span><br><span class="line">22端口：SSH 端口</span><br><span class="line">23端口：TELNET 终端仿真服务</span><br><span class="line">25端口：SMTP 简单邮件传输服务</span><br><span class="line">53端口：DNS 域名解析服务</span><br><span class="line">80端口：HTTP 超文本传输服务</span><br><span class="line">110端口：POP3 “邮局协议版本3”使用的端口</span><br><span class="line">443端口：HTTPS 加密的超文本传输服务</span><br><span class="line">**********************************</span><br><span class="line">1433端口：MS SQL*SERVER数据库 默认端口号</span><br><span class="line">1521端口：Oracle数据库服务</span><br><span class="line">1863端口：MSN Messenger的文件传输功能所使用的端口</span><br><span class="line">3306端口：MYSQL 默认端口号</span><br><span class="line">3389端口：Microsoft RDP 微软远程桌面使用的端口</span><br><span class="line">5631端口：Symantec pcAnywhere 远程控制数据传输时使用的端口</span><br><span class="line">5632端口：Symantec pcAnywhere 主控端扫描被控端时使用的端口</span><br><span class="line">5000端口：MS SQL Server使用的端口</span><br><span class="line">8000端口：腾讯QQ</span><br></pre></td></tr></table></figure><h2 id="Chapter-3，4，5，6"><a href="#Chapter-3，4，5，6" class="headerlink" title="Chapter 3，4，5，6"></a>Chapter 3，4，5，6</h2><h3 id="Socket-Address-Structures"><a href="#Socket-Address-Structures" class="headerlink" title="Socket Address Structures"></a>Socket Address Structures</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span>         s_addr;           <span class="comment">/* 32-bit IPv4 address */</span></span><br><span class="line">                                <span class="comment">/* network byte ordered */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         sin_len;         <span class="comment">/* length of structure (16) */</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>       sin_family;   <span class="comment">/* AF_INET */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>            sin_port;       <span class="comment">/* 16-bit TCP or UDP port number */</span></span><br><span class="line">                                                <span class="comment">/* network byte ordered */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>        <span class="comment">/* 32-bit IPv4 address */</span></span><br><span class="line">                                                <span class="comment">/* network byte ordered */</span></span><br><span class="line">    <span class="keyword">char</span>                   sin_zero[<span class="number">8</span>];  <span class="comment">/* unused */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IPV4</span></span><br><span class="line">inet_addr inet_ntoa</span><br><span class="line"><span class="comment">// IPV4/6</span></span><br><span class="line">inet_pton inet_ntop</span><br></pre></td></tr></table></figure><ul><li>in_addr 是结构的原因是早期将其定义为 union 方便A，B，C类地址的访问</li><li>sin_zero 置0</li></ul><h3 id="Generic-socket-address-structure"><a href="#Generic-socket-address-structure" class="headerlink" title="Generic socket address structure"></a>Generic socket address structure</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>       sa_len;</span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;      <span class="comment">/* address family: AF_xxx value */</span></span><br><span class="line">    <span class="keyword">char</span>             sa_data[<span class="number">14</span>]; <span class="comment">/* protocol-specific address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span>, struct sockaddr *, <span class="keyword">socklen_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span>    <span class="comment">/* IPv4 socket address structure */</span></span><br><span class="line"><span class="comment">/* fill in serv&#123;&#125; */</span></span><br><span class="line">bind(sockfd, (struct sockaddr *) &amp;serv, <span class="keyword">sizeof</span>(serv));</span><br></pre></td></tr></table></figure><p>用于定义函数时适配各种不同类型的地址结构，</p><p>若不转换，编译器报 <code>warning: passing arg 2 of &#39;bind&#39; from incompatible pointer type</code></p><h3 id="Sockaddr-in6"><a href="#Sockaddr-in6" class="headerlink" title="Sockaddr_in6"></a>Sockaddr_in6</h3><p>128-bits ipv6 地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>     s6_addr[<span class="number">16</span>];  <span class="comment">/* 128-bit IPv6 address */</span></span><br><span class="line">                                        <span class="comment">/* network byte ordered */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIN6_LEN                 <span class="comment">/* required for compile-time tests */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>             sin6_len;           <span class="comment">/* length of this struct (28) */</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>       sin6_family;       <span class="comment">/* AF_INET6 */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>           sin6_port;           <span class="comment">/* transport layer port# */</span></span><br><span class="line">                                                    <span class="comment">/* network byte ordered */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>             sin6_flowinfo;  <span class="comment">/* flow information, undefined */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>           <span class="comment">/* IPv6 address */</span></span><br><span class="line">                                                    <span class="comment">/* network byte ordered */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>             sin6_scope_id;  <span class="comment">/* set of interfaces for a scope */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>The <code>sin6_flowinfo</code> member is divided into two fields:<ul><li>The low-order 20 bits are the flow label</li><li>The high-order 12 bits are reserved</li></ul></li></ul><h3 id="Value-Result"><a href="#Value-Result" class="headerlink" title="Value-Result"></a>Value-Result</h3><p>当我们把 <code>SA*</code> 从用户进程传入内核时长度作为值 value ，内核处理完返回时结构的大小可能会改变，因此长度作为一个结果 result 传回 , 引用是因为需要函数内部去赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户进程 =&gt; 内核</span></span><br><span class="line"><span class="comment">// bind connect sendto </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* fill in serv&#123;&#125; */</span></span><br><span class="line">connect(sockfd, (SA *) &amp;serv, <span class="keyword">sizeof</span>(serv));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核 =&gt; 用户进程</span></span><br><span class="line"><span class="comment">// accept recvfrom getsockname getpeername </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cli</span>;</span> <span class="comment">/* Unix domain */</span></span><br><span class="line"><span class="keyword">socklen_t</span> len;</span><br><span class="line"></span><br><span class="line">len = <span class="keyword">sizeof</span>(cli);           <span class="comment">/* len is a value */</span></span><br><span class="line">getpeername(unixfd, (SA *) &amp;cli, &amp;len);</span><br><span class="line"><span class="comment">/* len may have changed */</span></span><br></pre></td></tr></table></figure><h3 id="字节序-Byte-Ordering"><a href="#字节序-Byte-Ordering" class="headerlink" title="字节序 Byte Ordering"></a>字节序 Byte Ordering</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字节序转换函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> host16bitvalue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> host32bitvalue)</span></span>;</span><br><span class="line">                                     Both <span class="keyword">return</span>: value in network byte order</span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> net16bitvalue);</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> net32bitvalue)</span></span>;</span><br><span class="line">                                    Both <span class="keyword">return</span>: value in host byte order</span><br></pre></td></tr></table></figure><p>n - network , h - host , s - short 16 位, l - long 32 位</p><h3 id="Byte-Manipulation"><a href="#Byte-Manipulation" class="headerlink" title="Byte Manipulation"></a>Byte Manipulation</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bcopy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">void</span> *dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">bcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1, <span class="keyword">const</span> <span class="keyword">void</span> *ptr2, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line">                                    Returns: <span class="number">0</span> <span class="keyword">if</span> equal, nonzero <span class="keyword">if</span> unequal</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">int</span> c, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1, <span class="keyword">const</span> <span class="keyword">void</span> *ptr2, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line">                        Returns: <span class="number">0</span> <span class="keyword">if</span> equal, &lt;<span class="number">0</span> <span class="keyword">or</span> &gt;<span class="number">0</span> <span class="function"><span class="keyword">if</span> <span class="title">unequal</span> <span class="params">(see text)</span></span></span><br></pre></td></tr></table></figure><h3 id="地址转换函数"><a href="#地址转换函数" class="headerlink" title="地址转换函数"></a>地址转换函数</h3><h4 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// converts the C character string pointed to by strptr into</span></span><br><span class="line"><span class="comment">// its 32-bit binary network byte ordered value, </span></span><br><span class="line"><span class="comment">// which is stored through the pointer addrptr </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *strptr, struct in_addr *addrptr)</span></span>;</span><br><span class="line">                    Returns: <span class="number">1</span> <span class="keyword">if</span> <span class="built_in">string</span> was valid, <span class="number">0</span> on error</span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *strptr)</span></span>;</span><br><span class="line">                    Returns: <span class="number">32</span>-bit binary network byte ordered IPv4 address; INADDR_NONE <span class="keyword">if</span> error</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr inaddr)</span></span>;</span><br><span class="line">                    Returns: pointer to dotted-decimal <span class="built_in">string</span></span><br></pre></td></tr></table></figure><ul><li><p><code>inet_aton</code> 将字符串 <code>strptr</code> 转换为 32 比特二进制网络字节序地址 <code>addrptr</code></p></li><li><p><code>inet_addr</code> 作用同上，出错返回 <code>INADDR_NONE</code> 255.255.255.255, 所以不能处理该地址（被废弃）</p></li><li><p><code>inet_ntoa</code> 32bit 网络字节序到点分十进制 IPV4 字符串，储存在静态内存，不可重入</p></li></ul><h4 id="IPV4-6"><a href="#IPV4-6" class="headerlink" title="IPV4/6"></a>IPV4/6</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> *strptr, <span class="keyword">void</span> *addrptr)</span></span>;</span><br><span class="line">                                Returns: <span class="number">1</span> <span class="keyword">if</span> OK, <span class="number">0</span> <span class="keyword">if</span> input <span class="keyword">not</span> a valid presentation format, −<span class="number">1</span> on error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">void</span> *addrptr, <span class="keyword">char</span> *strptr, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line">                                Returns: pointer to result <span class="keyword">if</span> OK, <span class="literal">NULL</span> on error</span><br></pre></td></tr></table></figure><p>p - presentation , n - numeric</p><ul><li><code>family</code>: <code>AF_INET</code> / <code>AF_INET6</code> 不支持 errno= <code>EAFNOSUPPORT</code></li><li><code>inet_pton</code>: 字符串 strptr 转换为 addrptr 二进制地址结果</li><li><code>inet_ntop</code>: 相反，len 位 strptr 大小，防止溢出 - len太小，返回空指针 errno= <code>ENOSPC</code></li></ul><h3 id="读写函数"><a href="#读写函数" class="headerlink" title="读写函数"></a>读写函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writen</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readline</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> maxlen)</span></span>;</span><br><span class="line">                    All <span class="keyword">return</span>: number of bytes read <span class="keyword">or</span> written, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>readline 每次读一个字符，极端地慢</p><h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><p>基本 TCP 套接字编程</p><h3 id="Socket-函数"><a href="#Socket-函数" class="headerlink" title="Socket 函数"></a>Socket 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">                Returns: non-negative descriptor <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>AF_INET</th><th>AF_INET6</th><th>AF_LOCAL</th><th>AF_ROUTE</th><th>AF_KEY</th></tr></thead><tbody><tr><td>SOCK_STREAM</td><td>TCP SCTP</td><td>TCP SCTP</td><td>YES</td><td></td><td></td></tr><tr><td>SOCK_DGRAM</td><td>UDP</td><td>UDP</td><td>YES</td><td></td><td></td></tr><tr><td>SOCK_SEQPACKET</td><td>SCTP</td><td>SCTP</td><td>YES</td><td></td><td></td></tr><tr><td>SOCK_RAW</td><td>IPV4</td><td>IPV6</td><td></td><td>YES</td><td>YES</td></tr></tbody></table><h3 id="Connect-函数"><a href="#Connect-函数" class="headerlink" title="Connect 函数"></a>Connect 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">                                    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>client 用于与 server 连接，内核会自己选择临时端口</p><ul><li>75 s 无响应后返回 <code>ETIMEDOUT</code></li><li>若相应 RST 则马上返回 <code>ECONNREFUSED</code> - 指定端口没有等待连接</li><li>目的不可达，返回 <code>EHOSTUNREACH</code>, <code>ENETUNREACH</code></li></ul><p>错误</p><ul><li>如果给不存在的机器发送，因为没有 ARP reply , <code>ETIMEOUT</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect error: Connection timed out</span><br></pre></td></tr></table></figure><ul><li>如果给未运行 server 的机器发送，收到 RST ，<code>ECONNREFUSED</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect error: Connection refused</span><br></pre></td></tr></table></figure><ul><li>给不可达发送， 收到 ICMP 不可达错误，<code>EHOSTUNREACH</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect error: No route to host</span><br></pre></td></tr></table></figure><p>每次 connect 失败后，都需要关闭 sockfd 重新调用 socket 函数</p><h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind 函数"></a>bind 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">                                    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>32b ipv4 / 128b ipv6 + 16b TCP/UDP port number</p><p>Servers 会在启动时调用 bind 端口（程序定义） ，若没有则当调用 connect 或 listen 时，内核会选择一个临时端口 或 根据 SYN 的目的地址</p><p>Client 通常不会 bind 而是 connect 时由内核根据路径选择</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>wildcard 通配符</p><p>ipv4 : <code>INADDR_ANY</code> 0.0.0.0，内核等到TCP连接，UDP报文发送后选择ip地址</p><p>ipv6 : <code>in6addr_any</code> 由系统预先分配并置为 <code>IN6ADDR_ANY_INIT</code></p><p>RPC 例外，会通过 端口映射器注册</p><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p><code>EADDRINUSE</code> : <code>Address already in use</code> 地址已使用</p><h3 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen 函数"></a>listen 函数</h3><p>Server : convert unconnected socket into a passive socket</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line">                    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p><code>backlog</code> : 内核队列中排队的最大连接数</p><p>调用时间： socket bind 后， accept 前</p><p>为 listening socket 保持两个队列</p><ul><li><code>incomplete connection queue</code> 未完成连接队列，未完成握手，<code>SYN_RCVD</code> 态</li><li><code>completed connection queue</code> 已完成连接队列，完成握手，<code>ESTABLISHED</code> 态</li></ul><p>两队之和不超过 backlog</p><h3 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept 函数"></a>accept 函数</h3><p>返回已完成连接队列队头，如果为空，进程睡眠</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *cliaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">                        Returns: non-negative descriptor <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><ul><li><code>sockfd</code> : listening socket 监听</li><li><code>return</code> : connected socket 已连接</li><li><code>cliaddr</code> &amp; <code>addrlen</code> ：对端的地址和长度</li><li>一对多的关系，监听socket 保持打开，连接socket完成对一个客户的服务就关闭</li></ul><h4 id="bind-错误"><a href="#bind-错误" class="headerlink" title="bind 错误"></a>bind 错误</h4><ul><li>非超级用户：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> error: Permission denied</span><br></pre></td></tr></table></figure><h3 id="fork-和-exec-函数"><a href="#fork-和-exec-函数" class="headerlink" title="fork 和 exec 函数"></a>fork 和 exec 函数</h3><p>fork 是唯一生成新进程的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">            Returns: <span class="number">0</span> in child, process ID of child in parent, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><h3 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h3><p>父进程 listenfd 监听，子进程 connfd 负责接收数据和实际操作</p><h3 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line">                        Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>为了方便多个进程使用套接字，它是引用计数的。</p><p>内核会发完所有等待发送的数据，然后 TCP 连接终止过程</p><p>如果只想发送FIN，改用 <code>shutdown</code> 函数</p><h3 id="地址函数"><a href="#地址函数" class="headerlink" title="地址函数"></a>地址函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *localaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *peeraddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">                            Both <span class="keyword">return</span>: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>sock 本地，peer 连接对端</p><p>重点基本都要求掌握、5.13不要求掌握</p><p>6.9，6.20 不要求掌握</p><h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><h3 id="TCP-Echo-Server"><a href="#TCP-Echo-Server" class="headerlink" title="TCP Echo Server"></a>TCP Echo Server</h3><p>Port : 5000 - 49152</p><h3 id="Normal-Startup"><a href="#Normal-Startup" class="headerlink" title="Normal Startup"></a>Normal Startup</h3><p>server 阻塞在 accept （还未启动用户）</p><p>client 阻塞在 fgets 调用</p><p>连接</p><p>服务器阻塞在 read ，父进程阻塞在 accept</p><p>此时 三个进程 STAT 都是 S- sleeping - （已阻塞）</p><p>WCHAN 父进程 wait_for_connect , server tcp_data_wait , client - read_chan</p><h3 id="Normal-Termination"><a href="#Normal-Termination" class="headerlink" title="Normal Termination"></a>Normal Termination</h3><p>Client ： EOF 字符（Control+D) 终止服务器</p><p>客户端进入 <code>TIME_WAIT</code> 状态</p><h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><p><code>SIGKILL</code> &amp; <code>SIGSTOP</code> 不能被捕获</p><p>信号处理函数是一个仅有一个整数参数且不返回值的函数</p><h4 id="wait-amp-waitpid"><a href="#wait-amp-waitpid" class="headerlink" title="wait &amp; waitpid"></a>wait &amp; waitpid</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *statloc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line">                        Both <span class="keyword">return</span>: process ID <span class="keyword">if</span> OK, <span class="number">0</span> <span class="keyword">or</span> −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>处理已终止的子进程</p><ul><li>返回值： 已终止子进程的进程 ID 号，通过 statloc 指针返回的子进程终止状态（一个整数）</li><li>对于同种类型的信号，主机只会执行一次信号处理函数</li></ul><h4 id="accept-返回前连接中止"><a href="#accept-返回前连接中止" class="headerlink" title="accept 返回前连接中止"></a>accept 返回前连接中止</h4><p>connect 后，accept 前，客户端发送 RST 报文</p><p>POSIX : <code>ECONNABORTED</code> - <code>software caused connection abort</code></p><h4 id="服务器进程终止"><a href="#服务器进程终止" class="headerlink" title="服务器进程终止"></a>服务器进程终止</h4><p>服务器进程崩溃后，如果 client 不操作，会阻塞在 fgets，输入字符后，readline 因接收到 FIN 返回 0（EOF），client 返回 : <code>str_cli: server terminated prematurely</code> - 程序定义的并结束</p><p>如果先收到了 RST，会返回 <code>ECONNRESET</code> - <code>connection reset by peer</code></p><p>RST 会因为并没有与该客户端连接但是接收到该客户端发送的内容而被服务器发送</p><h4 id="服务器主机崩溃"><a href="#服务器主机崩溃" class="headerlink" title="服务器主机崩溃"></a>服务器主机崩溃</h4><p>同上面不同的是，服务器并不会有任何反应，会有以下两种情况：</p><ul><li>一直没有响应 <code>ETIMEOUT</code></li><li>中间路由器判断不可达，响应一个 <code>destination unreachable</code> 的 ICMP，返回的错误是 <code>EHOSTUNREACH</code> 或 <code>ENETUNREACH</code></li></ul><h4 id="服务器主机崩溃后重启"><a href="#服务器主机崩溃后重启" class="headerlink" title="服务器主机崩溃后重启"></a>服务器主机崩溃后重启</h4><p>当服务器主机崩溃后重启时，它的 TCP 丢失了崩溃前的所有连接信息，因此服务器 TCP 对于所收到的来自客户的数据分节响应以一个RST</p><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>服务器读入换行符，所搜索的只是换行符</p><p>二进制 : <code>sscanf</code> 转换到结构体 binary ，发送后，对方也用同样的结构体接收。</p><p>大小端不同 ， 同样 int 型长度不同，结构体的打包方式不同 都会导致负数不行，</p><p>解决方法： 发送 string ， 用 XDR（external data representation) 发送</p><h2 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h2><h3 id="I-O-Model"><a href="#I-O-Model" class="headerlink" title="I/O Model"></a>I/O Model</h3><p>分为两个部分：等待对端发送数据 ，将数据从内核拷贝到用户</p><ul><li>blocking: 调用接收函数后就一直等到两步都完成再返回</li></ul><p><img src="https://s2.loli.net/2021/12/24/k7NsibMYlA4BnCG.jpg" alt=""></p><ul><li>Nonblocking: 第一阶段不断循环 call，知道收到完整包</li></ul><p><img src="https://s2.loli.net/2021/12/24/1Qs5ucmSPpXRVaD.jpg" alt=""></p><ul><li>Multiplexing: 第一步调用 select，直到返回 readable，然后调用 recvfrom 完成第二步<ul><li>好处: 可以等待多个描述符</li></ul></li></ul><p><img src="https://s2.loli.net/2021/12/24/gFw2hGWOmPx1Mas.jpg" alt=""></p><ul><li>Signal-Driven: 调用后立即返回，signal handler 会在 data 准备好后发出信号，调用 recvfrom 完成第二步</li></ul><p><img src="https://s2.loli.net/2021/12/24/xACoPEYT3g4prwD.jpg" alt=""></p><ul><li>Asynchronous: 告知内核启动某个操作，并让内核在两步操作完成后通知我们</li></ul><p><img src="https://s2.loli.net/2021/12/24/NBrtk7uoz5AKxlc.jpg" alt=""></p><h3 id="select-函数"><a href="#select-函数" class="headerlink" title="select 函数"></a>select 函数</h3><p>告诉内核等待多个事件，有事件发生或 Timeout 后唤醒他</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br><span class="line">    Returns: positive count of ready descriptors, <span class="number">0</span> on timeout, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><ul><li><code>maxfdp1</code>: 待测试的最大描述符值 +1</li><li><code>set</code>: 告诉内核 what descriptors we are interested in ，不关心设为空，三个参数都是 value-result 类型的，调用时为关心的描述符的值，返回时指示哪些描述符已就绪<ul><li><code>readset</code>: Any of the descriptors in the readset are ready for reading</li><li><code>writeset</code>: Any of the descriptors in the writeset are ready for reading</li><li><code>exceptset</code>: Any of the descriptors in the exceptset have an exception condition pending</li></ul></li><li><code>timeout</code>: how long to wait - 信号中断 - 不准<ul><li>设置为空: 永远等待</li><li>值: 固定时间</li><li>0: 根本不等待- 轮询（polling）</li></ul></li><li><code>Returns</code>: 就绪的数目，timeout=0，error=-1</li><li>这是系统函数，descriptor 和 socket 无关，socket 可以 select 任意 descriptor</li><li>错误处理 - 不考</li></ul><h4 id="fd-set-数据结构"><a href="#fd-set-数据结构" class="headerlink" title="fd_set 数据结构"></a>fd_set 数据结构</h4><p>每一位代表一个描述符，每一bit为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;          <span class="comment">/* clear all bits in fdset */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">/* turn on the bit for fd in fdset */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">/* turn off the bit for fd in fdset */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">/* is the bit for fd on in fdset ? */</span></span><br></pre></td></tr></table></figure><ul><li>利用 <code>FD_ZERO</code> 进行初始化十分重要，因为是 value-result 值会变化</li><li><code>FD_SETSIZE</code>: 1024</li></ul><h4 id="读-ready-的条件"><a href="#读-ready-的条件" class="headerlink" title="读 ready 的条件"></a>读 ready 的条件</h4><ul><li>收到的数据高于 low-water 低水位了</li><li>连接关闭了，read 返回 0 （EOF）</li><li>是监听套接字，且有已完成的连接 ？</li><li>套接字有错误待处理，返回 -1 ， errno 设置成确切的错误条件</li></ul><h4 id="写-ready-的条件"><a href="#写-ready-的条件" class="headerlink" title="写 ready 的条件"></a>写 ready 的条件</h4><ul><li>已连接（udp不需要），可写空间超过 low-water</li><li>写半边关闭了 （有未完成发送的数据，要发送出去）</li><li>non-blocking connect 建立了连接或失败了</li><li>套接字有错误待处理，返回 -1 ， errno 设置成确切的错误条件</li></ul><h4 id="exceptiong-ready"><a href="#exceptiong-ready" class="headerlink" title="exceptiong ready"></a>exceptiong ready</h4><p>如果一个套接字存在带外数据或者仍处于带外标记，那么它有异常条件待处理</p><h3 id="str-cli"><a href="#str-cli" class="headerlink" title="str_cli"></a>str_cli</h3><p>阻塞在 select，将原本的待前后顺序的阻塞，变成同时的阻塞</p><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>给服务器发送一个FIN，告诉它我们已经完成了数据发送，但是 仍然保持套接字描述符打开以便读取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br><span class="line">                    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><ul><li>不动引用计数就激发 TCP 的正常连接终止序列</li><li>close 终止读和写两个方向的数据传送，shutdown 还可以继续读</li><li>三种可选项<ul><li><code>SHUT_RD</code>: 关闭连接的读这一半</li><li><code>SHUT_WR</code>: 关闭连接的写这一半</li><li><code>SHUT_RDWR</code>: 连接的读半部和写半部都关闭</li></ul></li></ul><h3 id="str-cli-pipeline版"><a href="#str-cli-pipeline版" class="headerlink" title="str_cli pipeline版"></a>str_cli pipeline版</h3><p>加入 shutdown，模拟先连续发送数据，关闭写半部，然后再连续接收返回数据的 pipeline 操作</p><h3 id="TCP-echo-程序-select-版"><a href="#TCP-echo-程序-select-版" class="headerlink" title="TCP echo 程序- select 版"></a>TCP echo 程序- select 版</h3><p>client 数组存储已连接 accept 描述符的值</p><p>省去了 fork 新进程的开销</p><p>rset 数组保存 0-stdin，1-stdout，2-stderr ，3–都是已连接描述符</p><ul><li>客户发送 FIN，4 变为可读 read 将返回 0。关闭该套接字并把 <code>client[0]</code> 的值置为 -1，把描述符集中描述符 4 的位设置为 0。注意，<strong>maxfd 的值没有改变</strong></li></ul><h2 id="Chapter-7"><a href="#Chapter-7" class="headerlink" title="Chapter 7"></a>Chapter 7</h2><h3 id="sockopt-函数"><a href="#sockopt-函数" class="headerlink" title="_sockopt 函数"></a>_sockopt 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line">                                    Both <span class="keyword">return</span>: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><ul><li>sockfd ： 打开的套接字描述符</li><li>level ：指代系统中解释该选项的代码</li><li>optval ：存储 option 的数据结构 - 是标志 0 为不启用，值为启用</li><li>optlen ：长度 - value-result</li></ul><p>sockopt :掌握 7.2 原理 - SO_LINGER / SO_KEEPALIVE / SO_DONTROUTE</p><h3 id="SO-KEEPALIVE"><a href="#SO-KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h3><p>保活</p><h3 id="SO-LINGER-？"><a href="#SO-LINGER-？" class="headerlink" title="SO_LINGER ？"></a>SO_LINGER ？</h3><p>关闭 close 时是否丢弃保留在套接字发送缓冲区中的任何数据，</p><p>设置正的延滞时间</p><h3 id="SO-DONTROUTE"><a href="#SO-DONTROUTE" class="headerlink" title="SO_DONTROUTE"></a>SO_DONTROUTE</h3><p>是否绕过下层协议的路由机制</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP : IP_HDRINCL / IP_TTL </span><br></pre></td></tr></table></figure><h3 id="IP-HDRINCL"><a href="#IP-HDRINCL" class="headerlink" title="IP_HDRINCL"></a>IP_HDRINCL</h3><p>设置了就需要自己构建IP头</p><h3 id="IP-TTL"><a href="#IP-TTL" class="headerlink" title="IP_TTL"></a>IP_TTL</h3><p>设置和获取系统用在从某个给定套接字的默认 TTL 值</p><h3 id="TCP-TCP-MAXSEG"><a href="#TCP-TCP-MAXSEG" class="headerlink" title="TCP : TCP_MAXSEG"></a>TCP : TCP_MAXSEG</h3><p>允许我们获取或设置TCP连接的最大分节大小</p><p>SYN中通告的MSS</p><h2 id="Chapter-8"><a href="#Chapter-8" class="headerlink" title="Chapter 8"></a>Chapter 8</h2><p>8.1 图，并发程序设计 - 重点注意区别</p><p><code>sendto()</code> <code>recvfrom()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct sockaddr *from, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> struct sockaddr *to, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">            Both <span class="keyword">return</span>: number of bytes read <span class="keyword">or</span> written <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>echo 程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="服务器进程未运行"><a href="#服务器进程未运行" class="headerlink" title="服务器进程未运行"></a>服务器进程未运行</h3><p>返回 ICMP 异步错误</p><p>sendto 成功返回仅表示接口输出队列中有存放数据报的空间</p><p>仅在进程已将其 UDP 套接字连接到一个对端后，这些异步错误才返回给进程</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><ul><li>不需要再指定目的 IP 和端口号</li><li>不用 recvfrom 用 read 就行</li><li>返回异步错误</li></ul><h2 id="Chapter-11"><a href="#Chapter-11" class="headerlink" title="Chapter 11"></a>Chapter 11</h2><p>简单前面部分 DNS 操作 11.3、11.4、11.5</p><p>使用 UDP 查询，如果答案太长，超出了 UDP 承载能力，换成 TCP</p><h3 id="gethostbyname"><a href="#gethostbyname" class="headerlink" title="gethostbyname"></a>gethostbyname</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *hostname)</span></span>;</span><br><span class="line">            Returns: non-null pointer <span class="keyword">if</span> OK, <span class="literal">NULL</span> on error with h_errno <span class="built_in">set</span></span><br></pre></td></tr></table></figure><p>只能返回 ipv4，getaddrinfo 能够处理 4 和 6</p><h3 id="gethostbyaddr"><a href="#gethostbyaddr" class="headerlink" title="gethostbyaddr"></a>gethostbyaddr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">socklen_t</span> len, <span class="keyword">int</span> family)</span></span>;</span><br><span class="line">            Returns: non-null pointer <span class="keyword">if</span> OK, <span class="literal">NULL</span> on error with h_errno <span class="built_in">set</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct servent *<span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *servname, <span class="keyword">const</span> <span class="keyword">char</span> *protoname)</span></span>;</span><br><span class="line">Returns: non-null pointer <span class="keyword">if</span> OK, <span class="literal">NULL</span> on erro</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct servent *<span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *protoname)</span></span>;</span><br><span class="line">Returns: non-null pointer <span class="keyword">if</span> OK, <span class="literal">NULL</span> on error</span><br></pre></td></tr></table></figure><h2 id="Part-3-Advanced-Sockets"><a href="#Part-3-Advanced-Sockets" class="headerlink" title="Part 3 Advanced Sockets"></a>Part 3 Advanced Sockets</h2><p>12，13，14，15 ，17，18.5,20,21,22,23,24，30，31不考 Daemon Process 了解一下</p><p>19 Introduction</p><p>特权 SA ， SADB</p><p>25 掌握，结合第 5 章看</p><p>26 掌握 基本概念，线程和进程区别</p><p>27 结合前面的 Options 一起看，简单看看。</p><p>28 重点掌握</p><p>读写ICMP，读写非内核处理的协议段的数据报，构建ip首部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sockfd = socket(AF_INET, SOCK_RAW, protocol)</span><br><span class="line"><span class="comment">// 例 ： protocol IPPROTO_ICMP</span></span><br><span class="line"><span class="comment">// 开启 IP_HDRINCL</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &amp;on, <span class="keyword">sizeof</span>(on)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 出错处理</span></span><br></pre></td></tr></table></figure><p>29 掌握 基本概念，如何抓包</p><p>libpcap 公开分组捕获函数库</p><p>A.3 C.1 netstat tcpdump</p><p>简答题（解释名词） ， 编程题（补充小的片段）上机+上课 ， 实验分析题（分析实验的结果）例如： 服务端没起来 报什么错误</p><p>最开始 那个 带函数的函数</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>P180，P165，LINGER 的意思是什么</p><p>ioctl 实现 sockopt 进行读写操作 - 了解功能</p><p>函数原型 ： 名字 + 参数</p><p>ping ， recvmsg 如果被中断 <code>EINTR</code>，continue 重新执行，函数重启</p><p>5.10 wait / waitpid 要求</p><p>server ， server host 情况</p><p>raw socket 适用于什么情况 routing 、key</p><p>29 introduction</p><p>信号处理函数 5 章 signal handler</p><p>signal driven 不要求</p><p>tcp函数的顺序图</p>          </div>]]></content>
    
    <summary type="html">
    
      Base on Copyright (c) Dingsoul&lt;br&gt;Link: https://dingiso.github.io/2021/03/13/UNIX%20%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%A4%8D%E4%B9%A0/
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Slice Growth in Golang</title>
    <link href="https://augists.top/NOTES/CODE_LANGUAGE/GOLANG/Slice-Growth-in-Golang/"/>
    <id>https://augists.top/NOTES/CODE_LANGUAGE/GOLANG/Slice-Growth-in-Golang/</id>
    <published>2021-11-21T15:45:42.000Z</published>
    <updated>2021-11-21T16:09:23.543Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>前两天在看《GO程序设计语言》的关于 Slice 的代码的时候产生了一个疑问，书里的代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gopl.io/ch4/append</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendInt</span><span class="params">(x []<span class="keyword">int</span>, y <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> z []<span class="keyword">int</span></span><br><span class="line">  zlen := <span class="built_in">len</span>(x) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> zlen &lt;= <span class="built_in">cap</span>(x) &#123;</span><br><span class="line">    z = x[:zlen]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    zcap := zlen</span><br><span class="line">    <span class="keyword">if</span> zcap &lt; <span class="number">2</span>*<span class="built_in">len</span>(x) &#123;</span><br><span class="line">      zcap = <span class="number">2</span> * <span class="built_in">len</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">    z = <span class="built_in">make</span>([]<span class="keyword">int</span>, zlen, zcap)</span><br><span class="line">    <span class="built_in">copy</span>(z, x)</span><br><span class="line">  &#125;</span><br><span class="line">  z[<span class="built_in">len</span>(x)] = y</span><br><span class="line">  <span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个当对切片使用 append 添加时进行判断是否需要扩容的操作，尽管这是书中的代码，但是它可能和源码稍有差别<br>我从网上查询到的源码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">        newcap = <span class="built_in">cap</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">            newcap = doublecap</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">                newcap += newcap / <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    <span class="comment">//内存对齐操作</span></span><br><span class="line">    capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">    newcap = <span class="keyword">int</span>(capmem / ptrSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始我在想，为什么它需要去判断一下 <code>zcap &lt; 2*len(x)</code>，而不是直接赋值呢<br>其实当时想的时候漏掉了 <code>len(x) == 0</code> 的情况<br>如果 <code>len(x)</code> 为大于等于 1 的正整数时，无论如何 <code>zcap &lt;= 2*len(x)</code><br>如果 <code>len(x)</code> 为 0 时，就需要让新的容量等于 <code>zcap == zlen == len(x) + 1 == 1</code></p><p>那么此时就会产生两个问题：</p><ol><li>为什么不直接采用 <code>zcap = 2*len(x) + 1</code>，如此省去判断步骤</li><li>为什么不直接判断是否 <code>len(x) == 0</code>，而是判断 <code>zcap &lt; 2*len(x)</code></li></ol><p>对于第一个问题，这涉及到内存对齐操作。尽管在以前的 C Family 语言学习和计算机组成原理课程中学习过，但是并没有迁移到 Go 这里来思考问题<br>这里推荐我看到的一篇<a href="https://www.jianshu.com/p/f035a22e094d">文章</a>，我通过这篇重新学习了 Go 语言中的内存对齐</p><p>对于第二个问题，我到现在也没有 get 到原因。按理说这本书是由创始人编写的，依照在《C程序设计语言》中的严谨程度，这里应该会有什么特别的用意。但是我想如果只判断 <code>len(x) == 0</code> 在操作及时间上都要好于书中的示例代码。此处仍然留有疑问</p>          </div>]]></content>
    
    <summary type="html">
    
      A Question while reading the book *Go Programming Language*
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="GOLANG" scheme="https://augists.top/tags/GOLANG/"/>
    
  </entry>
  
  <entry>
    <title>Get Root Privilege in Linux by Docker or Dirty COW</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/Get-Root-Privilege-in-Linux-by-Docker-or-Dirty-COW/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/Get-Root-Privilege-in-Linux-by-Docker-or-Dirty-COW/</id>
    <published>2021-11-15T08:41:59.000Z</published>
    <updated>2021-11-15T08:44:30.944Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <div class="note info">            <p>计算机病毒入侵与检测课程大作业</p>          </div><h1 id="Docker-和-DirtyCow-两种方式的-Linux-提权"><a href="#Docker-和-DirtyCow-两种方式的-Linux-提权" class="headerlink" title="Docker 和 DirtyCow 两种方式的 Linux 提权"></a>Docker 和 DirtyCow 两种方式的 Linux 提权</h1><h2 id="Docker-用户组及本地映射"><a href="#Docker-用户组及本地映射" class="headerlink" title="Docker 用户组及本地映射"></a>Docker 用户组及本地映射</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Docker 作为近年来兴起的技术经常被极客们热议。作为容器化思想的典型代表，它与虚拟机类似，但在原理上不尽相同。Docker 是将操作系统底层进行虚拟化，而虚拟机是对计算机硬件进行虚拟，如通过软件虚拟出一套硬件设备提供给虚拟机程序进行使用。可以说，在实现思路上，两者就有天然的差异性。由于 Docker 可以只构造单一软件所需要的环境，或是直接使用操作系统本地进行文件映射，所以相比于虚拟机来说，Docker 更便携、高效。它允许用户将基础设施中的应用单独分割出来，形成更小的颗粒（容器），从而提高交付软件的速度。</p><p>Docker 利用 Linux 核心中的资源分离机制，例如 cgroups，以及 Linux 核心 namespace，来创建独立的容器。这可以在单一 Linux 实体下运作，避免启动一个虚拟机造成的额外负担。Linux 核心对名字空间的支持完全隔离了工作环境中应用程序的视野，包括行程树、网络、用户 ID 与挂载文件系统，而核心的 cgroup 提供资源隔离，包括 CPU、存储器、block I/O 与网络。从 0.9 版本起，Docker 在使用抽象虚拟是经由 <code>libvirt</code> 的 <code>LXC</code> 与 <code>systemd - nspawn</code> 提供界面的基础上，开始包括 <code>libcontainer</code> 库做为以自己的方式开始直接使用由 Linux 核心提供的虚拟化的设施。</p><p>在这里，我们可以对比使用 Docker 与使用安装包。当想要发布一款软件时，我们假设软件是在 python 3.7 版本进行了测试，而开发者并不确定它是否在其他诸如最新的 3.10 或是较老的版本中是否也可以像自己在 python 3.7 版本中运行一样稳定。如果是一个较为激进的开发者，可能会选择优先检测用户电脑中的环境变量里是否已经安装了 python 3，如果有则直接安装打包后的软件部分。如果是一个稳妥的开发者，更可能选择将 python 3.7 与软件一同打包给用户进行使用，这样可以保证软件基本能够正常稳定的与开发者相同环境下运行，但不是绝对，每个人的操作系统也大不相同，系统的版本，打的补丁都可能不一样，这样多复杂的因素都可能导致软件在运行过程中崩溃，与开发者的测试环境不一致，这就会导致各种环境问题。又或者，当团队在开发自己的软件时，每个人的编写环境不同，安装的依赖也可能不一样。为了方便软件在开发者与用户之间能有相同或相似的运行环境，解决团队在开发过程中的依赖问题，Docker 将他们融入 Dockerfile 进行管理，使开发者能够确保用户使用时 <code>pull</code> 了开发者选择或者相同的 <code>image</code>，从而保证或避免一些因为环境和依赖导致的问题。</p><p>在 Docker 的官网上，Docker 团队提出了自己的 slogan: Accelerate how you build, share, and run modern applications。Docker 可以让开发变得更加高效，并能对一些问题提前预知。通过将开发工作转移到 Docker 上，开发者可以更为方便的搭建环境、在不同设备之间进行分享、更少的性能损失来运行服务。也正是这一点让我非常着迷。</p><blockquote><p>Docker takes away repetitive, mundane configuration tasks and is used throughout the development lifecycle for fast, easy and portable application development - desktop and cloud. Docker’s comprehensive end to end platform includes UIs, CLIs, APIs and security that are engineered to work together across the entire application delivery lifecycle.</p></blockquote><h3 id="Docker-隔离性与安全性"><a href="#Docker-隔离性与安全性" class="headerlink" title="Docker 隔离性与安全性"></a>Docker 隔离性与安全性</h3><p>就 Docker 来说，安全性主要为两点：</p><ol><li>不会对主机造成影响</li><li>不会对其他容器造成影响</li></ol><p>从这里也可以看出，安全性更大程度上依赖的是 Docker 的隔离性。在这里又会想到与虚拟机进行对比。</p><p>传统的虚拟机其实并非 100% 安全，只需攻破 Hypervisor 便足以令整个虚拟机毁于一旦，问题是有谁能随随便便就攻破吗？Docker 的隔离性主要运用 Namespace 技术。传统上 Linux 中的 <code>PID</code> 是唯一且独立的，在正常情况下，用户不会看见重复的 <code>PID</code>。然而在 Docker 采用了 Namespace，从而令相同的 <code>PID</code> 可于不同的 Namespace 中独立存在。举个例子，A Container 之中 PID=1 是 A 程序，而 B Container 之中的 PID=1 同样可以是 A 程序。虽然 Docker 可透过 Namespace 的方式分隔出看似是独立的空间，然而 Linux 内核却不能 Namespace，所以即使有多个 Container，所有的 system call 其实都是通过主机的内核处理，这便为 Docker 留下了不可否认的安全问题。传统的虚拟机同样地很多操作都需要通过内核处理，但这只是虚拟机的内核，并非宿主主机内核。因此万一出现问题时，最多只影响到虚拟系统本身。</p><p>有一点是 Docker 非常有意思的特点，也是本次实验对 Docker 漏洞的利用之处。Docker 在主机与容器的映射上，有非常多的文件没有进行隔离：</p><ul><li><p><code>/proc</code>、<code>/sys</code> 等</p></li><li><p><code>top</code>, <code>free</code>, <code>iostat</code> 等命令展示的信息</p></li><li><p><code>root</code> 用户</p></li><li><p><code>/dev</code> 设备</p></li><li><p>内核模块</p></li><li><p>SELinux、time、syslog 等所有现有 Namespace 之外的信息</p></li></ul><p>这也使得 Docker 的安全性一直备受热议。即便本次实验中的 Docker 提权漏洞已经被 Docker 官方所了解，但是他们似乎并不打算对这个漏洞进行修复，因为这也属于他们对主机与容器建立本地映射的一部分。</p><p>Docker 的另一个好处就是，它是由 Docker 团队打造并且积极拥抱开源。开源社区甚至是 Red Hat 都在给 Docker 贡献代码，连同 Docker 一起改进安全性，改进项主要包括保护宿主不受容器内部运行进程的入侵、防止容器之间相互破坏。开源社区在解决 Docker 安全性问题上的努力包括：</p><ul><li><p>Audit namespace</p><ul><li>作用：隔离审计功能</li><li>未合入原因：意义不大，而且会增加 audit 的复杂度，难以维护。</li></ul></li><li><p>Syslog namespace</p><ul><li>作用：隔离系统日志</li><li>未合入原因：很难完美的区分哪些 log 应该属于某个 container。</li></ul></li><li><p>Device namespace</p><ul><li>作用：隔离设备（支持设备同时在多个容器中使用）</li><li>未合入原因：几乎要修改所有驱动，改动太大。</li></ul></li><li><p>Time namespace</p><ul><li>作用：使每个容器有自己的系统时间</li><li>未合入原因：一些设计细节上未达成一致，而且感觉应用场景不多。</li></ul></li><li><p>Task count cgroup</p><ul><li>作用：限制 cgroup 中的进程数，可以解决 fork bomb 的问题</li><li>未合入原因：不太必要，增加了复杂性，<code>kmemlimit</code> 可以实现类似的效果。(最近可能会被合入)</li></ul></li><li><p>隔离 <code>/proc/meminfo</code> 的信息显示</p><ul><li>作用：在容器中看到属于自己的 <code>meminfo</code> 信息</li><li>未合入原因：cgroupfs 已经导出了所有信息，<code>/proc</code> 展现的工作可以由用户态实现，比如 fuse。</li></ul></li></ul><p>不过，从 08 年 cgroup/ns 基本成型后，至今还没有新的 namespace 加入内核，cgroup 在子系统上做了简单的补充，多数工作都是对原有 subsystem 的完善。内核社区对容器技术要求的隔离性，本的原则是够用就好，不能把内核搞的太复杂。</p><p>一些企业也做了很多工作，比如一些项目团队采用了层叠式的安全机制，这些可选的安全机制具体如下：</p><ol><li><p>文件系统级防护</p><p>文件系统只读：有些 Linux 系统的内核文件系统必须要 <code>mount</code> 到容器环境里，否则容器里的进程就会罢工。这给恶意进程非常大的便利，但是大部分运行在容器里的 App 其实并不需要向文件系统写入数据。基于这种情况，开发者可以在 <code>mount</code> 时使用只读模式。比如下面几个： <code>/sys</code> 、<code>/proc/sys</code> 、<code>/proc/sysrq-trigger</code> 、<code>/proc/irq</code>、<code>/proc/bus</code></p><p>写入时复制（Copy-On-Write）：Docker 采用的就是这样的文件系统。所有运行的容器可以先共享一个基本文件系统镜像，一旦需要向文件系统写数据，就引导它写到与该容器相关的另一个特定文件系统中。这样的机制避免了一个容器看到另一个容器的数据，而且容器也无法通过修改文件系统的内容来影响其他容器。在第二个 DirtyCow 实验中，就是利用的 Copy-On-Write。</p></li><li><p>Capability 机制</p><p>Linux 对 Capability 机制阐述的还是比较清楚的，即为了进行权限检查，传统的 UNIX 对进程实现了两种不同的归类，高权限进程（用户 ID 为 0，超级用户或者 <code>root</code>），以及低权限进程（<code>UID</code> 不为 0 的）。高权限进程完全避免了各种权限检查，而低权限进程则要接受所有权限检查，会被检查如 <code>UID</code>、<code>GID</code> 和组清单是否有效。从 2.2 内核开始，Linux 把原来和超级用户相关的高级权限划分成为不同的单元，称为 Capability，这样就可以独立对特定的 Capability 进行使能或禁止。通常来讲，不合理的禁止 Capability，会导致应用崩溃，因此对于 Docker 这样的容器，既要安全，又要保证其可用性。开发者需要从功能性、可用性以及安全性多方面综合权衡 Capability 的设置。目前 Docker 安装时默认开启的 Capability 列表一直是开发社区争议的焦点，作为普通开发者，可以通过命令行来改变其默认设置。</p></li><li><p>NameSpace 机制</p><p>Docker 提供的一些命名空间也从某种程度上提供了安全保护，比如 <code>PID</code> 命名空间，它会将全部未运行在开发者当前容器里的进程隐藏。如果恶意程序看都看不见这些进程，攻击起来应该也会麻烦一些。另外，如果开发者终止 <code>pid</code> 是 1 的进程命名空间，容器里面所有的进程就会被全部自动终止，这意味着管理员可以非常容易地关掉容器。此外还有网络命名空间，方便管理员通过路由规则和 iptable 来构建容器的网络环境，这样容器内部的进程就只能使用管理员许可的特定网络。如只能访问公网的、只能访问本地的和两个容器之间用于过滤内容的容器。</p></li><li><p>Cgroups 机制</p><p>主要是针对拒绝服务攻击。恶意进程会通过占有系统全部资源来进行系统攻击。Cgroups 机制可以避免这种情况的发生，如 CPU 的 cgroups 可以在一个 Docker 容器试图破坏 CPU 的时候登录并制止恶意进程。管理员需要设计更多的 cgroups，用于控制那些打开过多文件或者过多子进程等资源的进程。</p></li><li><p>SELinux</p><p>SELinux 是一个标签系统，进程有标签，每个文件、目录、系统对象都有标签。SELinux 通过撰写标签进程和标签对象之间访问规则来进行安全保护。它实现的是一种叫做 MAC（Mandatory Access Control）的系统，即对象的所有者不能控制别人访问对象。</p></li></ol><h3 id="Docker-用户组"><a href="#Docker-用户组" class="headerlink" title="Docker 用户组"></a>Docker 用户组</h3><p>本次实验中使用 Docker 本地映射进行提权的一个必要的前提条件就是 Docker 用户组会在 Docker 内获得 root 权限。</p><blockquote><p>The Docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user <code>root</code> and other users can only access it using <code>sudo</code>. The Docker daemon always runs as the <code>root</code> user.</p><p>If you don’t want to preface the <code>docker</code> command with <code>sudo</code>, create a Unix group called <code>docker</code> and add users to it. When the Docker daemon starts, it creates a Unix socket accessible by members of the <code>docker</code> group.</p><blockquote><p>Warning</p><p>The <code>docker</code> group grants privileges equivalent to the <code>root</code> user. For details on how this impacts security in your system, see <a href="https://docs.docker.com/engine/security/#docker-daemon-attack-surface"><em>Docker Daemon Attack Surface</em></a>.</p></blockquote></blockquote><p>大概解释一下，就是本身 Docker 由于要和端口进行绑定，会默认使用 <code>root</code> 用户对 Docker 进行管理。所以 Docker 允许宿主机 <code>root</code> 将需要使用 Docker 服务的用户添加进 Docker 用户组，以便于该用户可以在 Docker 中获得 <code>root</code> 权限，使用所有需要在 Docker 中使用的诸如映射本地文件、开放端口等服务。</p><p>可以说，Docker 为了避开让用户必须使用 <code>root</code> 用户权限才能使用，增加了对 Docker 用户组的权限认证。解决了 <code>sudo</code> 的麻烦，但是也使得本次实验中利用的漏洞暴露出来。</p><h3 id="提权方式：Docker-本地映射"><a href="#提权方式：Docker-本地映射" class="headerlink" title="提权方式：Docker 本地映射"></a>提权方式：Docker 本地映射</h3><h4 id="提权过程演示"><a href="#提权过程演示" class="headerlink" title="提权过程演示"></a>提权过程演示</h4><p>在上文中提到，Docker 一方面使用 Docker 用户组来让普通用户不通过 <code>sudo</code> 也可以在 Docker 中获得最高权限，从而方便普通用户的使用。另一方面，它使用的内核进行了本地与容器内文件的映射，同时也允许用户自己添加本地文件映射。也就是说，一个在 Docker 用户组的普通用户，可以直接映射本地 <code>root</code> 权限的文件进入容器内，并作为容器内的 <code>root</code> 用户对宿主机的高权限文件进行修改。</p><p>自然，我们就可以想到，作为被添加进 Docker 用户组的普通用户，可以通过使用 Docker，将本地对用户权限进行管理的 <code>/etc/sudoers</code> 文件映射进容器内，然后作为 <code>root</code> 用户对其进行一定的修改。在实际操作时，我们可以直接将整个 <code>/etc</code> 映射入容器内。</p><p>下面将演示使用 Docker 用户组及本地映射为普通用户提权。本次实验运行于 Azure Hong Kong 云服务器上，配置为单核 CPU，1G 内存，Ubuntu 20.04。</p><p>首先，我们使用 <code>root</code> 添加 Docker 用户组。通常在安装 Docker 时，Docker 用户组已经被创建好并且分配好权限。</p><p><img src="https://i.loli.net/2021/11/15/VHlTxg3WkXYhyOq.png" alt="Screen Shot 2021-10-28 at 10.23.53 PM"></p><p>查看到 <code>/etc/sudoers</code> 文件的权限为只读，即便是作为 <code>root</code> 用户也没有可写权限，并且并没有为任何用户添加申请 <code>root</code> 的权限。</p><p><img src="https://i.loli.net/2021/11/15/yEe4LBV5QGJOrut.png" alt="Screen Shot 2021-10-28 at 10.27.05 PM"></p><p><img src="https://i.loli.net/2021/11/15/Hdlgn1UA7GtFExs.png" alt="Screen Shot 2021-10-28 at 10.30.24 PM"></p><p>我们添加一个用于本次实验的 test 用户，可以看到其权限为最低。将它加入到 docker 用户组。</p><p><img src="https://i.loli.net/2021/11/15/ecmDuHbwfM5OlBv.png" alt="Screen Shot 2021-10-28 at 10.54.38 PM"></p><p>重启 Docker 后，test 用户生效，被 Docker 赋予容器内的 <code>root</code> 权限。</p><p><img src="https://i.loli.net/2021/11/15/WZ3TQHdE4iDKlNr.png" alt="Screen Shot 2021-10-28 at 11.57.39 PM"></p><p>首先可以通过 <code>usermod -aG root test</code> 命令将 test 用户添加进 <code>root</code> 用户组。此时如果退出 Docker 就会看到 test 用户已经被添加了管理员权限。</p><p><img src="https://i.loli.net/2021/11/15/UlbS4nGZj2em6ip.png" alt="Screen Shot 2021-10-29 at 12.00.41 AM"></p><p>但是此时 test 用户并不能登陆 <code>root</code> 用户。其实也就是 <code>/etc/sudoers</code> 文件内并没有添加对 test 用户的许可，而只是赋予了权限的可能。所以我们可以在容器内对 <code>/etc/sudoers</code> 文件进行修改，将 test 用户部分 <code>test ALL=(ALL) ALL</code> 写入文件末尾。普通 Docker 用户组用户到这里已经提权成功。</p><p><img src="https://i.loli.net/2021/11/15/QaWXHxBbwI2Vvij.png" alt="Screen Shot 2021-10-29 at 12.06.19 AM"></p><p><img src="https://i.loli.net/2021/11/15/ef1PTvZCXWjp5Y8.png" alt="Screen Shot 2021-10-29 at 12.08.06 AM"></p><h4 id="rootplease"><a href="#rootplease" class="headerlink" title="rootplease"></a>rootplease</h4><p>在 Docker Hub 上已经有人通过这个漏洞制作好了专门用于将普通用户提权为 <code>root</code> 用户的容器，可以通过运行镜像一键提权。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /:/hostOS -i -t chrisfosterelli/rootplease</span><br></pre></td></tr></table></figure><p>它是通过将宿主机根目录直接映射到容器内的 <code>/hostOS</code> 目录，然后在容器中 <code>chroot /hostOS /bin/sh</code> 将根目录改到 <code>/chroot</code> 目录。获得宿主机的 <code>root</code> 权限并启动 shell。</p><h3 id="Docker-涉及到的其他安全风险及解决方案举例"><a href="#Docker-涉及到的其他安全风险及解决方案举例" class="headerlink" title="Docker 涉及到的其他安全风险及解决方案举例"></a>Docker 涉及到的其他安全风险及解决方案举例</h3><p><img src="https://s.secrss.com/anquanneican/8d894075fbc696d1402f5bb6b9eae223.png" alt=""></p><h4 id="镜像安全风险"><a href="#镜像安全风险" class="headerlink" title="镜像安全风险"></a>镜像安全风险</h4><h5 id="Dockerfile-安全问题"><a href="#Dockerfile-安全问题" class="headerlink" title="Dockerfile 安全问题"></a>Dockerfile 安全问题</h5><p>Docker 容器使用的 Docker Hub 中镜像不仅由官方上传，个人开发者也可以自由上传。其数量丰富、版本多样，但质量参差不齐，甚至存在包含恶意漏洞的恶意镜像，因而可能存在较大的安全风险。具体而言，Docker 镜像的安全风险分布在创建过程、获取来源、获取途径等方方面面。</p><p>Docker 镜像的生成主要包括两种方式，一种是对运行中的动态容器通过 <code>docker commit</code> 命令进行打包，另一种是通过 <code>docker build</code> 命令执行 Dockerfile 文件进行创建。为了确保最小安装原则，同时考虑容器的易维护性，一般推荐采用 Dockerfile 文件构建容器镜像，即在基础镜像上进行逐层应用添加操作。</p><p>Dockerfile 文件内容在一定程度上决定了Docker镜像的安全性，其安全风险具体包括但不限于以下情况：</p><ul><li>如果 Dockerfile 存在漏洞或被插入恶意脚本，那么生成的容器也可能产生漏洞或被恶意利用。例如，攻击者可构造特殊的 Dockerfile 压缩文件，在编译时触发漏洞获取执行任意代码的权限。</li><li>如果在 Dockerfile 中没有指定 USER，Docker 将默认以 root 用户的身份运行该 Dockerfile 创建的容器，如果该容器遭到攻击，那么宿主机的 root 访问权限也可能会被获取。</li><li>如果在 Dockerfile 文件中存储了固定密码等敏感信息并对外进行发布，则可能导致数据泄露的风险。</li><li>如果在 Dockerfile 的编写中添加了不必要的应用，如 SSH、Telnet 等，则会产生攻击面扩大的风险。</li></ul><h5 id="镜像漏洞"><a href="#镜像漏洞" class="headerlink" title="镜像漏洞"></a>镜像漏洞</h5><p>镜像漏洞安全风险具体包括镜像中的软件含有 CVE(Common Vulnerabilities &amp; Exposures) 漏洞、攻击者上传含有恶意漏洞的镜像等情况。</p><ul><li><p>CVE 漏洞</p><ul><li>由于镜像通常由基础操作系统与各类应用软件构成，因此，含有 CVE 漏洞的应用软件同样也会向 Docker 镜像中引入 CVE 漏洞。</li></ul></li><li><p>恶意漏洞</p><ul><li>恶意用户可能将含有后门、病毒等恶意漏洞的镜像上传至官方镜像库。</li><li>2018年6月，安全厂商 Fortinet 和 Kromtech 在 Docker Hub 上发现 17 个包含用于数字货币挖矿恶意程序的 Docker 镜像，而这些恶意镜像当时已有 500 万次的下载量。</li></ul></li></ul><h5 id="镜像仓库安全"><a href="#镜像仓库安全" class="headerlink" title="镜像仓库安全"></a>镜像仓库安全</h5><p>作为搭建私有镜像存储仓库的工具，Docker Registry 的应用安全性也必须得到保证。镜像仓库的安全风险主要包括仓库本身的安全风险和镜像拉取过程中的传输安全风险。</p><ul><li>仓库自身安全<ul><li>如果镜像仓库特别是私有镜像仓库被恶意攻击者所控制，那么其中所有镜像的安全性将无法得到保证。</li><li>例如，如果私有镜像仓库由于配置不当而开启了 2357 端口，将会导致私有仓库暴露在公网中，攻击者可直接访问私有仓库并篡改镜像内容，造成仓库内镜像的安全隐患。</li></ul></li><li>镜像拉取安全<ul><li>由于 Docker 以明文形式拉取镜像，如果用户在与镜像仓库交互的过程中遭遇了中间人攻击，导致拉取的镜像在传输过程中被篡改或被冒名发布恶意镜像，会造成镜像仓库和用户双方的安全风险。</li><li>Docker 已在其 1.8 版本后采用内容校验机制解决中间人攻击的问题。</li></ul></li></ul><h4 id="容器虚拟化安全风险"><a href="#容器虚拟化安全风险" class="headerlink" title="容器虚拟化安全风险"></a>容器虚拟化安全风险</h4><p>与传统虚拟机相比，Docker容器不拥有独立的资源配置，且没有做到操作系统内核层面的隔离，因此可能存在资源隔离不彻底与资源限制不到位所导致的安全风险。</p><h5 id="容器隔离问题"><a href="#容器隔离问题" class="headerlink" title="容器隔离问题"></a>容器隔离问题</h5><p>对于 Docker 容器而言，由于容器与宿主机共享操作系统内核，因此存在容器与宿主机之间、容器与容器之间隔离方面的安全风险，具体包括进程隔离、文件系统隔离、进程间通信隔离等。隔离问题已经在安全性与隔离性中讨论，在此不再赘述。</p><p>针对容器隔离安全风险问题，主要存在以下两种隔离失效的情况：</p><ul><li>攻击者可能通过对宿主机内核进行攻击达到攻击其中某个容器的目的。</li><li>由于容器所在主机文件系统存在联合挂载的情况，恶意用户控制的容器也可能通过共同挂载的文件系统访问其他容器或宿主机，造成数据安全问题。</li></ul><h5 id="容器逃逸攻击"><a href="#容器逃逸攻击" class="headerlink" title="容器逃逸攻击"></a>容器逃逸攻击</h5><p>容器逃逸攻击指的是容器利用系统漏洞，“逃逸”出了其自身所拥有的权限，实现了对宿主机和宿主机上其他容器的访问。由于容器与宿主机共享操作系统内核，为了避免容器获取宿主机的 root 权限，通常不允许采用特权模式运行 Docker 容器。容器逃逸攻击在本次病毒学大作业开题前曾被作为组队的最主要课题内容。</p><p>在容器逃逸案例中，最为著名的是 <code>shocker.c</code> 程序，其通过调用 <code>open_by_handle_at</code> 函数对宿主机文件系统进行暴力扫描，以获取宿主机的目标文件内容。由于 Docker 1.0 之前版本对容器能力使用黑名单策略进行管理，并没有限制 <code>CAP_DAC_READ_SEARCH</code> 能力，所以 <code>shocker.c</code> 可以调用 <code>open_by_handle_at</code> 函数，导致容器逃逸的发生。因此，对容器能力的限制不当是可能造成容器逃逸等安全问题的风险成因之一。所幸的是，Docker 在后续版本中对容器能力采用白名单管理，避免了默认创建的容器通过 <code>shocker.c</code> 案例实现容器逃逸的情况。</p><p>后来在 Black Hat USA 2019 会议中，来自 Capsule8 的研究员也给出了若干 Docker 容器引擎漏洞与容器逃逸攻击方法，包括 <strong>CVE-2019-5736</strong>、<strong>CVE-2018-18955</strong>、<strong>CVE-2016-5195</strong> 等可能造成容器逃逸的漏洞。</p><ul><li>CVE-2019-5736 是 <code>runC</code> 的一个安全漏洞，导致 18.09.2 版本前的 Docker 允许恶意容器覆盖宿主机上的 <code>runC</code> 二进制文件。<code>runC</code> 是用于创建和运行 Docker 容器的 CLI 工具，该漏洞使攻击者能够以 <code>root</code> 身份在宿主机上执行任意命令。</li><li>CVE-2018-18955 漏洞涉及到 User 命名空间中的嵌套用户命名空间，用户命名空间中针对 <code>uid</code> 和 <code>gid</code> 的 ID 映射机制保证了进程拥有的权限不会逾越其父命名空间的范畴。该漏洞利用创建用户命名空间的子命名空间时损坏的ID映射实现提权。</li><li>CVE-2016-5195 脏牛（Dirty COW）Linux内核提权漏洞可以使低权限用户在多版本 Linux 系统上实现本地提权，进而可能导致容器逃逸的发生。本次病毒学大作业也将 Dirty COW 作为第二个研究的内容。</li></ul><h5 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h5><p>由于容器与宿主机共享 CPU、内存、磁盘空间等硬件资源，且 Docker 本身对容器使用的资源并没有默认限制，如果单个容器耗尽宿主机的计算资源或存储资源（例如进程数量、存储空间等）可能导致宿主机或其他容器的拒绝服务。</p><p>针对 Docker 的 Dos 攻击主要有两种：</p><ol><li><p>计算型 DoS 攻击</p><p>Fork Bomb 是一类典型的针对计算资源的拒绝服务攻击手段，其可通过递归方式无限循环调用 <code>fork()</code> 系统函数快速创建大量进程。由于宿主机操作系统内核支持的进程总数有限，如果某个容器遭到了 Fork Bomb 攻击，那么就有可能存在由于短时间内在该容器内创建过多进程而耗尽宿主机进程资源的情况，宿主机及其他容器就无法再创建新的进程。</p></li><li><p>存储型 DoS 攻击</p><p>针对存储资源，虽然 Docker 通过 <code>Mount</code> 命名空间实现了文件系统的隔离，但 CGroups 并没有针对 AUFS 文件系统进行单个容器的存储资源限制，因此采用 AUFS 作为存储驱动具有一定的安全风险。如果宿主机上的某个容器向 AUFS 文件系统中不断地进行写文件操作，则可能会导致宿主机存储设备空间不足，无法再满足其自身及其他容器的数据存储需求。</p></li></ol><h4 id="网络安全风险"><a href="#网络安全风险" class="headerlink" title="网络安全风险"></a>网络安全风险</h4><p>网络安全风险是互联网中所有信息系统所面临的重要风险，不论是物理设备还是虚拟机，都存在难以完全规避的网络安全风险问题。而在轻量级虚拟化的容器网络环境中，其网络安全风险较传统网络而言更为复杂严峻。</p><h5 id="容器网络攻击"><a href="#容器网络攻击" class="headerlink" title="容器网络攻击"></a>容器网络攻击</h5><p>Docker提供桥接网络、MacVLAN、覆盖网络（Overlay）等多种组网模式，可分别实现同一宿主机内容器互联、跨宿主机容器互联、容器集群网络等功能。</p><ol><li><p>网桥模式</p><p>Docker 默认采用网桥模式，利用 iptables 进行 NAT 转换和端口映射。Docker 将所有容器都通过虚拟网络接口对连接在一个名为 <code>docker0</code> 的虚拟网桥上，作为容器的默认网关，而该网桥与宿主机直接相连。由于容器网络直接与 <code>docker0</code> 相连，不同容器间可以通过网桥直接通信，而宿主机外部无法访问容器。</p><p>由于缺乏容器间的网络安全管理机制，无法对同一宿主机内各容器之间的网络访问权限进行限制。如果容器间没有防火墙等保护机制，则攻击者可通过某个容器对宿主机内的其他容器进行 ARP 欺骗、嗅探、广播风暴等攻击，导致信息泄露、影响网络正常运行等安全后果。</p></li><li><p>MacVLAN</p><p>MacVLAN 是一种轻量级网络虚拟化技术，通过与主机的网络接口连接实现了与实体网络的隔离性。它允许为同一个物理网卡配置多个拥有独立 MAC 地址的网络接口并可分别配置 IP 地址，实现了网卡的虚拟化。但是它仍然没有解决在同一 VLAN 内部的容器之间进行网络攻击的风险。</p></li><li><p>Overlay 网络</p><p>Overlay 网络架构主要用于构建分布式容器集群，通过 VxLAN 技术在不同主机之间的 Underlay 网络上建立虚拟网络，以搭建跨主机容器集群，实现不同物理主机中同一 Overlay 网络下的容器间通信。与其他组网模式一样，Overlay 网络也没有对同一网络内各容器间的连接进行访问控制。此外，由于 VxLAN 网络流量没有加密，需要在设定 IPSec 隧道参数时选择加密以保证容器网络传输内容安全。</p></li></ol><h5 id="网络-DoS-攻击"><a href="#网络-DoS-攻击" class="headerlink" title="网络 DoS 攻击"></a>网络 DoS 攻击</h5><p>Docker 容器网络的 DoS 攻击分为内部威胁和外部威胁两种主要形式。</p><ul><li><p>内部威胁</p><ul><li>基于容器网络攻击，DoS 攻击可直接在容器之间进行，攻击者通过某个容器向其他容器发起 DoS 攻击可能降低其他容器的网络数据处理能力。</li></ul></li><li><p>外部威胁</p><ul><li>由于同一台宿主机上的所有容器共享宿主机的物理网卡资源，若外部攻击者使用包含大量受控主机的僵尸网络向某一个目标容器发送大量数据包进行 DDoS 攻击，将可能占满宿主机的网络带宽资源，造成宿主机和其他容器的拒绝服务。</li></ul></li></ul><h2 id="Dirty-COW-漏洞"><a href="#Dirty-COW-漏洞" class="headerlink" title="Dirty COW 漏洞"></a>Dirty COW 漏洞</h2><blockquote><p>The Dirty COW vulnerability (CVE-2016-5195) is a recent (and interesting) privilege escalation vulnerability in the Linux kernel.  By exploiting this vulnerability, an ordinary, non-privileged user already on a machine can take complete control. Dirty COW works by taking advantage of a flaw in how the Linux kernel manages memory – more specifically, an optimization technique in how memory pages are utilized.</p></blockquote><p>相比于上一个 Docker 设计的漏洞，Dirty COW 是利用的了内存读写的编程漏洞，强行通过刷写内存达到写入只读文件的目的。</p><h3 id="Dirty-COW-漏洞分析及代码解释"><a href="#Dirty-COW-漏洞分析及代码解释" class="headerlink" title="Dirty COW 漏洞分析及代码解释"></a>Dirty COW 漏洞分析及代码解释</h3><h4 id="Copy-on-Write"><a href="#Copy-on-Write" class="headerlink" title="Copy on Write"></a>Copy on Write</h4><p>在微软的官方文档里，详细的解释了 Copy on Write 优化。它允许多个进程映射到同一个物理页面进行共享，直到某一进程想要修改页面。通过 Copy on Write 技术，操作系统可以将内存合理安排，在非必要的情况下不执行操作，以达到节省物理内存和时间的目的。</p><p>例如我们有两个进程被映射到了同物理页面内（如图）</p><p><img src="https://docs.microsoft.com/en-us/windows/win32/memory/images/mem1.png" alt=""></p><p>如果程序不需要对内容进行修改，则可以最大化利用物理内存页面。如果 Process 1 想要对 Page 2 进行修改，操作系统会先将 Page B 复制到一个新的物理页面 Page D，并为 Process 1 更新虚拟内存映射。按照我的想法，此后操作系统会寻找合适的时机，即两进程可能长期不会再进行修改时再将其进行合并操作。（如图）</p><p><img src="https://docs.microsoft.com/en-us/windows/win32/memory/images/mem2.png" alt=""></p><p>在 Windows 系统上，文档中提到，在加载应用程序时，每个实例都在自己的受保护虚拟地址空间中运行。然而，他们的实例句柄（<em>hInstance</em>）通常具有相同的值。此值表示应用程序虚拟地址空间中的基本地址。如果每个实例都可以加载到默认基地址，它可以通过 Copy on Write 保护映射到其他实例并与他们共享相同的物理页面。系统允许这些实例共享相同的物理页面，直到其中一个实例修改页面。如果由于某种原因无法将其中一个实例加载到所需的基地址中，它将接收自己的物理页面。</p><p>也就是说，只要进程只从这些内存页面读取，它们就会被共享，优化就会生效。如果其中一个进程在任何时候写入这些共享页面之一，则数据将被复制到一个新的物理页面，并更新虚拟到物理内存映射以反映更改。这种技术用于许多不同的场景，如加载的dll、分叉进程、文件系统数据块等。</p><h4 id="并发多线程"><a href="#并发多线程" class="headerlink" title="并发多线程"></a>并发多线程</h4><p>操作系统通常对并发的多线程访问共享数据时添加锁。通过互斥条件使对同一变量的不同访问分开，或使用其他的方式，如 Windows 上的 InterlockedIncrement()，使它们成为原子。当发生 Race Condition 时，就会产生一些小的时间窗口，时间窗口内一些预期之外的操作就可以被执行。</p><blockquote><p>A race condition is when the end result of an operation or sequence of operations is dependent on the order or timing of the operation(s). </p></blockquote><p>通常来说，时间窗口的大小决定了这个漏洞可以被利用的难易程度。比如 VMware 博客的作者提到他在调试一个文件系统时，可以利用的时间窗口只有 3μs，这也导致他很难对这个漏洞进行复现，从而使得它难以修复。</p><p>在 Dirty COW 漏洞中，病毒进程通过循环尝试 100,000,000 次来加大漏洞可以被利用的概率，提高 Copy on Write 的成功率。</p><h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><p>Dirty COW 的伪代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Main:</span><br><span class="line">    fd = open(filename, O_RDONLY)</span><br><span class="line">    fstat(fd, &amp;st)</span><br><span class="line">    <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, st.st_size , PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>)</span><br><span class="line">    start Thread1</span><br><span class="line">    start Thread2</span><br><span class="line">    </span><br><span class="line">Thread1：</span><br><span class="line">    f = open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR)</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">        lseek(f, <span class="built_in">map</span>, SEEK_SET)</span><br><span class="line">        write(f, shellcode, <span class="built_in">strlen</span>(shellcode))</span><br><span class="line">        </span><br><span class="line">Thread2：</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">        madvise(<span class="built_in">map</span>, <span class="number">100</span>, MADV_DONTNEED)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作为只有读文件权限的普通用户，在打开文件时必须先使用 Read Only，然后使用 MAP_PRIVATE 标记映射文件到内存区域。完成后就可以启动两个线程开始竞争了。Thread 1 以读写权限打开 <code>/proc/self/mem</code>。由于在内核中使用的 OOP 思想，其通用的抽象类结构源自于 <code>/proc/&#123;pid&#125;/men</code>，它包含了以下结构体内变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">proc_mem_operations</span> = &#123;</span></span><br><span class="line">    .llseek  = mem_lseek,</span><br><span class="line">    .read    = mem_read,</span><br><span class="line">    .write   = mem_write,</span><br><span class="line">    .open    = mem_open,</span><br><span class="line">    .release = mem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也就是说，当我们需要写入一个虚拟文件时，内核将调用 <code>mem_write</code> 函数，它本质上也是对 <code>mem_rw</code> 函数的封装。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">mem_rw</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos, <span class="keyword">int</span> write)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> addr = *ppos;</span><br><span class="line">    <span class="keyword">ssize_t</span> copied;</span><br><span class="line">    <span class="keyword">char</span> *page;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mm)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate an exchange buffer */</span></span><br><span class="line">    page = (<span class="keyword">char</span> *)__get_free_page(GFP_TEMPORARY);</span><br><span class="line">    <span class="keyword">if</span> (!page)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    copied = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!atomic_inc_not_zero(&amp;mm-&gt;mm_users))</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> this_len = <span class="keyword">min_t</span>(<span class="keyword">int</span>, count, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* copy user content to the exchange buffer */</span></span><br><span class="line">        <span class="keyword">if</span> (write &amp;&amp; copy_from_user(page, buf, this_len)) &#123;</span><br><span class="line">            copied = -EFAULT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this_len = access_remote_vm(mm, addr, page, this_len, write);</span><br><span class="line">        <span class="keyword">if</span> (!this_len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!copied)</span><br><span class="line">                copied = -EIO;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!write &amp;&amp; copy_to_user(buf, page, this_len)) &#123;</span><br><span class="line">            copied = -EFAULT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buf += this_len;</span><br><span class="line">        addr += this_len;</span><br><span class="line">        copied += this_len;</span><br><span class="line">        count -= this_len;</span><br><span class="line">    &#125;</span><br><span class="line">    *ppos = addr;</span><br><span class="line"></span><br><span class="line">    mmput(mm);<span class="built_in">free</span>:</span><br><span class="line">    free_page((<span class="keyword">unsigned</span> <span class="keyword">long</span>) page);</span><br><span class="line">    <span class="keyword">return</span> copied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会在开始时分配一个临时内存 buffer，用来在源进程（要写的只读文件）和目的进程（<code>/proc/self/mem</code>）之间进行内存交换。因为 Copy on Write 的两个进程的虚拟地址空间不能直接互相访问，所以它将拷贝源进程的 buffer 到新物理页面。<code>access_remote_vm</code> 函数允许内核读写另一个进程的虚拟地址空间，它是所有 out-of-band 访问内存方式的核心实现。<code>madvise</code> 系统调用的作用是给系统对于内存使用的一些建议，<code>MADV_DONTNEED</code> 参数告诉系统未来不访问该内存了，内核可以释放内存页了。内核函数 <code>madvise_dontneed</code> 中会移除指定范围内的用户空间 page。可以看到，写操作由两步完成： 将应用层传进的数据写到目标page中 以及将page设置为脏页。<code>madvise(MADV_DONTNEED)</code> 基本功能是清除被管理的内存映射的物理页。就当前情况而言， 在调用完该函数后，提到的这些页将被clear。当下一次用户尝试访问这些内存区域时，原始的内容会重新从磁盘或者页缓存中导入，而对于匿名的堆内存，则会填充零。 </p><p>如果我们直接访问一个基于文件的只读映射，一个段错误将会产生。但是，为什么我们使用写 <code>/proc/self/mem</code> 确返回了一个 Dirty COW 页呢？这个原因取决于当在一个进程内发生内存访问和当采用 out-of-band, <code>/proc/&#123;pid&#125;/mem</code> 内存访问时，内核如何处理页错误的情况。这两种情况最终都会调 <code>handle_mm_fault</code> 来处理页错误。但是后者使用 <code>faultin_page</code> 来模拟页错误，页错误直接导致触发 MMU，将直接进入中断处理器，之后所有的路径都进入到平台独立的内核处理函数 <code>__do_page_fault</code> 中。而在直接写只读内存区域时，hanler 将检测到访问违例在函数 <code>access_error</code> 中，同时在 <code>handle_mm_fault</code> 处理之前，直接触发信号 <code>SIGEGV</code> 在函数 <code>bad_aea_access_error</code> 中。</p><h3 id="Dirty-COW-漏洞复现中的困难"><a href="#Dirty-COW-漏洞复现中的困难" class="headerlink" title="Dirty COW 漏洞复现中的困难"></a>Dirty COW 漏洞复现中的困难</h3><p>在尝试复现 DirtyCow 内核漏洞代码的过程中，遇到了非常多的困难和挫折。我先后在日常使用的 macOS、Docker Ubuntu 20.04、Docker Ubuntu 14.04 上简单试运行了 dirtyc0w 病毒程序，均未能成功。</p><p>macOS 本身使用 XNU 内核，其前身 NeXT 系统是基于 Mach 内核和 BSD 代码库创建，与后来的 Linux 内核尽管功能性上有很多相似想通之处，但是在底层上相去甚远。macOS 内嵌 Mach 微内核和 BSD 宏内核，而 Linux 仅有一个负责对 CPU、内存、进程间通信、设备驱动、文件系统和系统服务调用进行管理的宏内核。并且 macOS 本身为闭源，无从将其与 Linux 内核代码进行比较。</p><p>由于使用及前半部分选题的原因，我首先尝试使用 Docker 的 Ubuntu 来对 DirtyCow 漏洞进行复现。在 Docker 本地映射提权中使用的 Ubuntu 20.04 中运行时，病毒文件只对进程本身做出相应，即 <code>main</code> 中进行的 <code>mmap</code>，而无法进入两个运行的线程中并正常执行。例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmap 7f03ac372000</span><br></pre></td></tr></table></figure><p>第一个想到的是，是否是由于目前版本已经对 Dirty COW 漏洞进行了修复。所以我查看了 Linux 在 GitHub 上的源代码仓库，发现并没有有关 DirtyCow 的提交或 issue。查阅到 <code>linux/mm/madvise.c</code> 和 <code>linux/tools/perf/trace/beauty/mmap.c</code> 与本病毒项目可能存在相关性。（后续查阅到 Dirty COW 的影响范围为影响范围：Linux 内核 &gt;= 2.6.22（2007 年发行）开始就受影响了，直到 2016 年 10 月 18 日才修复</p><p>于是改用了旧版本的 Ubuntu 14.04，但是其系统内核为 4.4，应该也是 Ubuntu LTS 长期支持，从 Docker Hub 拉取的 Ubuntu 14.04 使用的是更新后的系统内核版本，推理应该是作为安全性更新得到了修补。但是当时并没有意识到可能有这个问题。由于 Docker 在本地与容器的映射问题，我当时怀疑的对象是 Docker 在默认映射部分将我系统中修补后的内容映射到了容器里，没有意识到尽管使用了旧版本的 Ubuntu 发行版，内核版本可能已经不是当时使用的内核版本了。在运行 Dirty COW 核心代码时，出现了 Docker 占用率拉高，致使风扇狂转的现象。我在程序假死半个小时后才强制结束运行。</p><p>其实我们可以以 Ubuntu 为例，查询发行版年代以及对应的内核版本。可以看到 Ubuntu 14.04 LTS 开发代号 Trusty Tahr，于 2014 年 4 月发行，使用 3.13 版本的 Linux 内核，原计划于 2019 年停止对系统的维护，但是开发团队将维护时间延长到了 2022 年。这也就是我为什么能从官方途径直接找到仍然在维护支持的 Ubuntu 14.04 版本的原因。</p><p>在放弃在 Docker Ubuntu 中直接复现 DirtyCow 漏洞后，我转而使用 Windows 下的虚拟机重新搭建了一个 Ubuntu Server 14.04 实验环境。虽然后来发现系统版本为 4.4（其为 Ubuntu 16.04 LTS 版本在发布时使用的内核版本，发布于 2016 年 4 月，仍早于该漏洞被修复的时间）。在虚拟机环境中，我也“成功”运行了 DirtyCow 程序，但是可能仅有一次在刷写 <code>/etc/passwd</code> 文件时成功将 <code>test</code>（权限为 1001）用户的密码写入了文件，而在对只读测试文件（权限为 0404 或 704）的写入中失败。但是程序正常结束了运行。例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line">1234567890</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./dirtyc0w test.txt 00000</span><br><span class="line">mmap 7f8b6aaae000</span><br><span class="line"></span><br><span class="line">madvise 0</span><br><span class="line"></span><br><span class="line">procselfmem 500000000</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line">1234567890</span><br></pre></td></tr></table></figure><p>在复现添加用户进入 <code>sudoers</code> 时同样无法生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./dirtyc0w /etc/group <span class="string">&quot;<span class="subst">$(sed &#x27;s/\(sudo:x:.*:\)/\1test1/g&#x27; /etc/group)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>在与老师讨论后，选择尝试将系统的 Linux 内核进行降级。前后共尝试了 3 个 ubuntu 发行版，为 14.04 及 ubuntu 12，其中 14 内核降级为 3.14 版本时出现了在常规情况下正常，但启动病毒程序进行刷写内存时出现系统崩溃以及引导故障的问题。</p><p><img src="https://i.loli.net/2021/11/15/blFgufXzAsK4OLW.jpg" alt="IMG_4034"></p><p><img src="https://i.loli.net/2021/11/15/qgdoIxN7Ty9BL2M.jpg" alt="IMG_4035"></p><p><img src="https://i.loli.net/2021/11/15/1wvXYKjCycHab4U.png" alt="6383A801DE9D67BB2E9F892B2AAE963D"></p><p>如图所示，我在尝试了将 Linux 内核进行降级后仍然无法复现病毒样本。现在网络上能找到的 Ubuntu 14.04 发行版均采用了 4.4 版本的内核，Ubuntu 12 采用 3.1x 版本内核。在第一次给 Ubuntu 14 降级内核版本至 3.14 后，系统维持正常运行，但是每当长时间运行高负载的进程时，系统引导就会崩溃并在提示引导错误后直接死机。这也是在本次复现 Dirty COW 病毒的过程中遇到的最无法解释的错误。事实上，可能是早期的 Ubuntu 发行版的问题，我每次安装都可能有不一样的问题，通常一个 iso 需要安装很多次，找到运行最稳定的一次。例如经常会有安装完系统后报 dpkg error 等，再重新安装就可以解决。</p><p>在 Linux 内核降级时，无论是指定 Advanced Option 还是直接设定启动运行的内核版本，系统都会将 4.4 作为启动的优先选项。在多次尝试无果后，我选择了降级后删除原 4.4 版本的内核，从而迫使系统使用旧版本的内核来启动。</p><p>我的三次系统内核降级的尝试分别选择了 3.14，3.13-100（后也尝试了72），2.6 版本。后两次在现在看来是理论上是应该可以成功的。我们可以查询 Dirty COW 的 wiki 上对于补丁版本的说明。对于每个发行版的补丁时间，在其他人对漏洞分析里都没有提到，所有提到漏洞可以利用的版本时都说的是“对Linux内核2.6.22以上的版本都有效果“，可事实上漏洞修复的很快，在 2021 年能找到的系统镜像都早以修复了它。网络上的复现实例都是写于 2016 年。</p><p><img src="https://i.loli.net/2021/11/15/PqWQpE7xTX9hl1A.png" alt="Screen Shot 2021-11-05 at 2.08.16 PM"></p><p>基本上每次尝试运行病毒样本的花销都是在半个小时左右。从前期的正常运行但无法得出结果，到中期运行后崩溃报错，再到最后降级到理论可复现的系统内核版本后每次运行都死机。前后大概花了一个月时间用于 Dirty COW 病毒，但实质上仍然没有成功复现出来。</p><h3 id="Dirty-COW-总结"><a href="#Dirty-COW-总结" class="headerlink" title="Dirty COW 总结"></a>Dirty COW 总结</h3><ol><li>Dirty COW 漏洞究其原因是 Copy on Write 这种对于内存利用的尝试的技术漏洞。尽管它非常有效的提升了内存的利用，但是在当时对于这部分内容的编写者来说可能并没有注意到它可能存在的问题并进行修补，导致最终暴露出问题。Dirty COW 漏洞最后由 Linus 本人亲自对其进行修复。</li><li><code>MADV_DONTNEED</code> 在 Linux 上的行为一直都是有争议的，它并没有完全服从 POSIX 的标准。事实上，正式它非标准的行为导致 Dirty COW 的攻击变为可能。 </li><li>漏洞可以体现出在对于并发处理上旧版本仍有瑕疵。一直以来，并发处理都被认为是很难处理的事情，这也是 Golang 自推出以来就一直很受欢迎的原因之一。</li><li>一开始我对于网络上别人对于漏洞的说明有些盲目信任，这也导致了我在尝试复现的初期踩了很多坑。</li></ol><h2 id="Preference-List"><a href="#Preference-List" class="headerlink" title="Preference List"></a>Preference List</h2><ol><li><a href="https://cve.mitre.org/index.html">CVE List</a></li><li><a href="https://www.dell.com/community/数据存储和保护-资料文档/浅谈Docker隔离性和安全性/ta-p/7181817A">浅谈Docker隔离性和安全性</a></li><li><a href="https://www.freebuf.com/articles/network/226210.html">针对Docker的恶意行为分析</a></li><li><a href="https://www.secrss.com/articles/16228">Docker容器安全性分析</a></li><li><a href="http://blog.lujun9972.win/blog/2019/05/13/为什么说创建docker用户组不是个好选择/">为什么说创建docker用户组不是个好选择</a></li><li><a href="https://docs.docker.com/engine/install/linux-postinstall/">Post-installation steps for Linux</a></li><li><a href="https://szukevin.site/2020/05/31/利用docker提权的一次尝试/">利用Docker进行提权的一次尝试</a></li><li><a href="https://github.com/zeroby0/virus/blob/master/virus.sh">copy to all script</a></li><li><a href="https://blogs.vmware.com/security/2016/12/dirty-truth-dirty-cow-cve-2016-5195.html">The Dirty Truth About “Dirty COW” (CVE-2016-5195)</a></li><li><a href="https://dirtycow.ninja">CVE-2016-5195 homepage</a></li><li><a href="https://github.com/dirtycow/dirtycow.github.io">Dirty COW source code</a></li><li><a href="https://zhuanlan.zhihu.com/p/27604276">从内核角度分析Dirty Cow原理</a></li><li><a href="https://blog.csdn.net/wanzt123/article/details/81879680">DirtyCow（脏牛）漏洞复现</a></li><li><a href="https://blog.jenisec.org/security/dirtycow.html">DirtyCow 漏洞利用</a></li><li><a href="https://blog.lovetecnet.xyz/2018/04/5ed11002857793053427715c/">脏牛（CVE-2016-5195）漏洞分析</a></li><li><a href="https://www.cnblogs.com/xiaozi/p/14264210.html">Linux提权的几种常用姿势</a></li><li><a href="https://linux.cn/article-9850-1.html">macOS 和 Linux 的内核有什么区别</a></li><li><a href="https://hub.docker.com/_/ubuntu">Docker Hub</a></li><li><a href="https://zh.wikipedia.org/wiki/Ubuntu">Ubuntu发行版列表</a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection?redirectedfrom=MSDN">内存保护</a></li><li><a href="https://www.bbsmax.com/A/n2d9a7vdDv/">dirtycow不死机exploit</a></li><li><a href="https://github.com/torvalds/linux/blob/7cca308cfdc0725363ac5943dca9dcd49cc1d2d5/mm/madvise.c">linux kernel madvise</a></li><li><a href="https://github.com/torvalds/linux/blob/5bfc75d92efd494db37f5c4c173d3639d4772966/tools/perf/trace/beauty/mmap.c">linux kernel mmap</a></li><li><a href="http://www.cnblogs.com/bonelee/p/6900243.html">LMDB中的mmap、copy on write深入理解</a></li><li><a href="https://www.anquanke.com/post/id/84851">深入解读脏牛Linux本地提权漏洞（CVE-2016-5195）</a></li><li><a href="http://pwn4.fun/2017/07/14/Dirty-COW（CVE-2016-5195）漏洞分析/">Dirty COW（CVE-2016-5195）漏洞分析</a></li></ol>          </div>]]></content>
    
    <summary type="html">
    
      Homework for Computer Virus Detect Course
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
      <category term="VIRUS" scheme="https://augists.top/tags/VIRUS/"/>
    
  </entry>
  
  <entry>
    <title>Bit Operation: Average of Two Integer</title>
    <link href="https://augists.top/NOTES/COURSES/Network_Protocol_Stack/bit-operation-average-of-two-integer/"/>
    <id>https://augists.top/NOTES/COURSES/Network_Protocol_Stack/bit-operation-average-of-two-integer/</id>
    <published>2021-11-12T04:59:34.000Z</published>
    <updated>2021-11-12T05:15:00.196Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>如何求两个整数的平均值？</p><p>问题看起来简单，如果用代码实现起来却有很多值得研究的地方。</p><p>下面我们使用Java代码来实现。</p><h2 id="普通实现1"><a href="#普通实现1" class="headerlink" title="普通实现1"></a>普通实现1</h2><p>求两个整数的平均值，最简单的实现方法就是两个数相加再除以二。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mean</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x + y) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是, 如果传入的是两个整数都是<code>Integer.MAX_VALUE</code>， 下面的断言就过不了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertEquals(Integer.MAX_VALUE, </span><br><span class="line">    mean(Integer.MAX_VALUE, Integer.MAX_VALUE));</span><br></pre></td></tr></table></figure><p>我们期望的结果是<code>Integer.MAX_VALUE</code>，但是实际上返回的结果却是-1。因为 <code>Integer.MAX_VALUE + Integer.MAX_VALUE = -2</code>， 结果已经溢出了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.AssertionError</span>: </span><br><span class="line"><span class="selector-tag">Expected</span> <span class="selector-pseudo">:2147483647</span></span><br><span class="line"><span class="selector-tag">Actual</span>   <span class="selector-pseudo">:-1</span></span><br></pre></td></tr></table></figure><h2 id="普通实现2"><a href="#普通实现2" class="headerlink" title="普通实现2"></a>普通实现2</h2><p>如果我们使用无符号的右移运算符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mean1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x + y) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样虽然可以得到我们想要的结果<code>Integer.MAX_VALUE</code>, 但是却是不支持负数。</p><p>比如我们求-9和-3的平均值,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertEquals(-<span class="number">6</span>, mean1(-<span class="number">9</span>, -<span class="number">34</span>));</span><br></pre></td></tr></table></figure><p>期望返回的结果是-6,但是实际上却返回了2147483642</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.AssertionError: </span><br><span class="line">Expected :-<span class="number">6</span></span><br><span class="line">Actual   :<span class="number">2147483642</span></span><br></pre></td></tr></table></figure><h2 id="普通实现3"><a href="#普通实现3" class="headerlink" title="普通实现3"></a>普通实现3</h2><p>那么如果我们不把两个整数直接相加, 而是分别除以2再相加, 是不是就不会溢出了呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mean3</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &gt;&gt; <span class="number">1</span>) + (y &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现的话, 确实是不会溢出了，但是精度也丢失了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.AssertionError: </span><br><span class="line">Expected :<span class="number">2147483647</span></span><br><span class="line">Actual   :<span class="number">2147483646</span></span><br></pre></td></tr></table></figure><p>那么有没有一种实现方式, 既不会溢出,又可以同时支持正负整数呢?</p><p>答案是不止一种!</p><h2 id="位运算实现1"><a href="#位运算实现1" class="headerlink" title="位运算实现1"></a>位运算实现1</h2><p>我们来看看Google的guava工具类是怎么实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IntMath#mean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@link</span> https://github.com/google/guava/blob/master/guava/src/com/google/common/math/IntMath.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 小数 向下取整</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">meanRoundDown</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &amp; y) + ((x ^ y) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过集合来理解上面的代码。</p><p>比如我们求整数9和3的平均值。</p><p>9的二进制是1001, 3的二进制是0011,</p><p>那么这两个数的交集就是<code>9&amp;3=0001</code>,</p><p>差集就是1010。<code>0001+(1010&gt;&gt;1)</code>结果就是6。</p><p>我们都知道二进制数字都是一串0和1，那么可以把整数x和y都看作是一个有很多不同的0和1组成的集合。</p><p>那么<code>x &amp; y</code>就表示两个集合的交集, 因为<code>1&amp;1=1</code>；</p><p><code>x ^ y</code>得到的就是两个集合的差集, 因为<code>1^1=0</code>,<code>1^0=1</code>；</p><p>交集加上差集的一半, 就得到了两个数的二进制平均值。</p><h2 id="位运算实现2"><a href="#位运算实现2" class="headerlink" title="位运算实现2"></a>位运算实现2</h2><p>下面我们来看看用位运算的第二种实现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小数 向上取整</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">meanRoundUp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x | y) - ((x ^ y) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码怎么理解呢？</p><p><code>x | y</code> 得到的就是两个集合的去重并集。</p><p>并集减去差集的一半，就得到了两个数的二进制平均值。</p><h2 id="两种方式的区别"><a href="#两种方式的区别" class="headerlink" title="两种方式的区别"></a>两种方式的区别</h2><p>如果两个整数的平均值是小数时，</p><p>第一种方式是向下取整；</p><p>第二种方式是向上取整。</p><p>比如我们求整数9和4的平均值，这两个数的平均值应该是6.5，向上取整就是7，向下取值就是6。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertEquals(<span class="number">6</span>, meanRoundDown(<span class="number">9</span>, <span class="number">4</span>)); <span class="comment">// 6</span></span><br><span class="line">Assert.assertEquals(<span class="number">7</span>, meanRoundUp(<span class="number">9</span>, <span class="number">4</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>上面探讨的只是求两个整数的平均值, 那么求多个整数的平均值又有哪些值得参考的实现方式呢?</p><p>同样我们来看看Google的guava工具类是怎么实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Stats#meanOf</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@link</span> https://github.com/google/guava/blob/master/guava/src/com/google/common/math/Stats.java</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * Returns the &lt;a href=&quot;http://en.wikipedia.org/wiki/Arithmetic_mean&quot;&gt;arithmetic mean&lt;/a&gt; of the</span></span><br><span class="line"><span class="comment">   * values. The count must be non-zero.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;The definition of the mean is the same as &#123;<span class="doctag">@link</span> Stats#mean&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> values a series of values</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalArgumentException if the dataset is empty</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">meanOf</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">  checkArgument(values.length &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">double</span> mean = values[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">1</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    <span class="keyword">double</span> value = values[index];</span><br><span class="line">    <span class="keyword">if</span> (isFinite(value) &amp;&amp; isFinite(mean)) &#123;</span><br><span class="line">      <span class="comment">// Art of Computer Programming vol. 2, Knuth, 4.2.2, (15)</span></span><br><span class="line">      mean += (value - mean) / (index + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mean = calculateNewMeanNonFinite(mean, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意这句注释:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Art of Computer Programming vol. <span class="number">2</span>, Knuth, <span class="number">4.2</span>.<span class="number">2</span>, (<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p>Guava的实现是参考了高德纳老爷子的经典之作《计算机编程的艺术》, 这套书规划有 7 卷, 目前已经出版了 4 卷。</p><p>比尔盖茨给出的评价是：“如果你能读完此书，你绝对得给我发份简历。”</p><blockquote><p>速记卡</p><p>求两个整数的平均值<br><code>(x &amp; y) + ((x ^ y) &gt;&gt; 1)</code>向下取整；<br><code>(x | y) - ((x ^ y) &gt;&gt; 1)</code>向上取整；</p></blockquote>          </div>]]></content>
    
    <summary type="html">
    
      Network Protocol Stack Notes
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="C/C++" scheme="https://augists.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Why Su &amp; Why Sudo</title>
    <link href="https://augists.top/NOTES/TERMINAL/Why-su-Why-sudo/"/>
    <id>https://augists.top/NOTES/TERMINAL/Why-su-Why-sudo/</id>
    <published>2021-11-10T04:13:15.000Z</published>
    <updated>2021-11-10T04:21:09.809Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <div class="note info">            <p>作者 | Jun Tao<br>来源 | <a href="https://tanjuntao.github.io/">https://tanjuntao.github.io/</a><br>转自 | <a href="https://mp.weixin.qq.com/s/iMF-3NXgWk5yEfLlQp1MqQ">https://mp.weixin.qq.com/s/iMF-3NXgWk5yEfLlQp1MqQ</a></p>          </div><p>之前一直对 su 和 sudo 这两个命令犯迷糊，最近专门搜了这方面的资料，总算是把两者的关系以及用法搞清楚了，这篇文章来系统总结一下。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>因为本篇博客中涉及到用户切换，所以我需要提前准备好几个测试用户，方便后续切换。</p><p>Linux 中新建用户的命令是 useradd ，一般系统中这个命令对应的路径都在 PATH 环境变量里，如果直接输入 useradd 不管用的话，就用绝对路径名的方式：/usr/sbin/useradd 。</p><p>useradd 新建用户命令只有 root 用户才能执行，我们先从普通用户 ubuntu 切换到 root 用户（如何切换后文会介绍）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ su -</span><br><span class="line">Password:                                         <span class="comment"># 输入 root 用户登录密码</span></span><br><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># useradd -m test_user       # 带上 -m 参数</span></span><br><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># ls /home</span></span><br><span class="line">test_user  ubuntu                                 <span class="comment"># 可以看到 /home 目录下面有两个用户了</span></span><br></pre></td></tr></table></figure><p>因为还没有给新建的用户 test_user 设置登录密码，这就导致我们无法从普通用户 ubuntu 切换到 test_user，所以接下来，我们需要用 root 来设置 test_user 的登录密码。需要用到 passwd 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># passwd test_user</span></span><br><span class="line">Enter new UNIX password:                          <span class="comment"># 输出 test_user 的密码</span></span><br><span class="line">Retype new UNIX password:       </span><br><span class="line">passwd: password updated successfully</span><br><span class="line">root@VM-0-14-ubuntu:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>接着我们输入 exit 退出 root 用户到 普通用户 ubuntu：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">logout</span></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$</span><br></pre></td></tr></table></figure><p>可以看到，命令提示符前面已经由 root 变成 ubuntu，说明我们现在的身份是 ubuntu 用户。</p><h2 id="su-命令介绍及主要用法"><a href="#su-命令介绍及主要用法" class="headerlink" title="su 命令介绍及主要用法"></a>su 命令介绍及主要用法</h2><p>首先需要解释下 su 代表什么意思。</p><p>之前一直以为 su 是 super user，查阅资料之后才知道原来表示 switch user。</p><p>知道 su 是由什么缩写来的之后，那么它提供的功能就显而易见了，就是切换用户。</p><h3 id="参数"><a href="#参数" class="headerlink" title="- 参数"></a><code>-</code> 参数</h3><p>su 的一般使用方法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su  &lt;user_name&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - &lt;user_name&gt;</span><br></pre></td></tr></table></figure><p>两种方法只差了一个字符 -，会有比较大的差异：</p><p>如果加入了 - 参数，那么是一种 login-shell 的方式，意思是说切换到另一个用户 <user_name> 之后，当前的 shell 会加载 <user_name> 对应的环境变量和各种设置；<br>如果没有加入 - 参数，那么是一种 non-login-shell 的方式，意思是说我现在切换到了 <user_name>，但是当前的 shell 还是加载切换之前的那个用户的环境变量以及各种设置。<br>光解释会比较抽象，我们看一个例子就比较容易理解了。</p><p>我们首先从 ubuntu 用户以 non-login-shell 的方式切换到 root 用户，比较两种用户状态下环境变量中 PWD 的值（su 命令不跟任何 <user_name> ，默认切换到 root 用户）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ env | grep ubuntu</span><br><span class="line">USER=ubuntu</span><br><span class="line">PWD=/home/ubuntu                                         <span class="comment"># 是 /home/ubuntu</span></span><br><span class="line">HOME=/home/ubuntu</span><br><span class="line"><span class="comment"># 省略......</span></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$ su                              <span class="comment"># non-login-shell 方式</span></span><br><span class="line">Password:                                                <span class="comment"># 输入 root 用户登录密码</span></span><br><span class="line">root@VM-0-14-ubuntu:/home/ubuntu<span class="comment"># env | grep ubuntu</span></span><br><span class="line">PWD=/home/ubuntu                                         <span class="comment"># 可以发现还是 /home/ubuntu</span></span><br><span class="line">root@VM-0-14-ubuntu:/home/ubuntu<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>我们的确是切换到 root 用户了，但是 shell 环境中的变量并没有改变，还是用之前 ubuntu 用户的环境变量。</p><p>接着我们从 ubuntu 用户以 login-shell 的方式切换到 root 用户，同样比较两种用户转台下环境变量中 PWD 的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ env | grep ubuntu</span><br><span class="line">USER=ubuntu</span><br><span class="line">PWD=/home/ubuntu                               <span class="comment"># 是 /home/ubuntu</span></span><br><span class="line">HOME=/home/ubuntu</span><br><span class="line"><span class="comment"># 省略.......</span></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$ su -                  <span class="comment"># 是 login-shell 方式</span></span><br><span class="line">Password:</span><br><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># env | grep root</span></span><br><span class="line">USER=root</span><br><span class="line">PWD=/root                                      <span class="comment"># 已经变成 /root 了</span></span><br><span class="line">HOME=/root</span><br><span class="line">MAIL=/var/mail/root</span><br><span class="line">LOGNAME=root</span><br><span class="line">root@VM-0-14-ubuntu:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>可以看到用 login-shell 的方式切换用户的话，shell 中的环境变量也跟着改变了。</p><p>总结：具体使用哪种方式切换用户看个人需求：</p><p>如果不想因为切换到另一个用户导致自己在当前用户下的设置不可用，那么用 non-login-shell 的方式；<br>如果切换用户后，需要用到该用户的各种环境变量（不同用户的环境变量设置一般是不同的），那么使用 login-shell 的方式。</p><h3 id="切换到指定用户"><a href="#切换到指定用户" class="headerlink" title="切换到指定用户"></a>切换到指定用户</h3><p>前面已经介绍了，如果 su 命令后面不跟任何 <user_name>，那么默认是切换到 root 用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ su -</span><br><span class="line">Password:                                       <span class="comment"># root 用户的密码</span></span><br><span class="line">root@VM-0-14-ubuntu:/home/ubuntu<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>因为我们在 1. 准备工作 部分已经新建了一个 test_user 用户，并且我们也知道 test_user 用户的登录密码（root 用户设置的），我们就能从 ubuntu 用户切换到 test_user 用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ su - test_user</span><br><span class="line">Password:                                       <span class="comment"># test_user 用户的密码</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="c-参数"><a href="#c-参数" class="headerlink" title="-c 参数"></a>-c 参数</h3><p>前面的方法中，我们都是先切换到另一个用户（root 或者 test_user），在哪个用户的状态下执行命令，最后输入 exit 返回当前 ubuntu 用户。</p><p>还有一种方式是：不需要先切换用户再执行命令，可以直接在当前用户下，以另一个用户的方式执行命令，执行结束后就返回当前用户。这就得用到 -c 参数。</p><p>具体使用方法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - -c <span class="string">&quot;指令串&quot;</span>                                  <span class="comment"># 以 root 的方式执行 &quot;指令串&quot;</span></span><br></pre></td></tr></table></figure><p>我么看个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ cat /etc/shadow</span><br><span class="line">cat: /etc/shadow: Permission denied                <span class="comment"># ubuntu 用户不能直接查看 /etc/shadow 文件内容</span></span><br><span class="line"></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$ su - -c <span class="string">&quot;tail -n 4 /etc/shadow&quot;</span></span><br><span class="line">Password:                                          <span class="comment"># 输入 root 用户密码</span></span><br><span class="line">ubuntu:<span class="variable">$1</span><span class="variable">$fZKcWEDI</span><span class="variable">$uwZ64uFvVbwpHTbCSgim0</span>/:18352:0:99999:7:::</span><br><span class="line">ntp:*:17752:0:99999:7:::</span><br><span class="line">mysql:!:18376:0:99999:7:::</span><br><span class="line">test_user:<span class="variable">$6</span>$.ZY1lj4m<span class="variable">$ii0x9CG8h</span>.JHlh6zKbfBXRuolJmIDBHAd5eqhvW7lbUQXTRS//89jcuTzRilKqRkP8YbYW4VPxmTVHWRLYNGS/:18406:0:99999:7:::</span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$                            <span class="comment"># 执行完马上返回 ubuntu 用户而不是 root 用户</span></span><br></pre></td></tr></table></figure><p>这种执行方式和后面要介绍的 sudo 很像，都是临时申请一下 root 用户的权限。但还是有差异，我们接着往后看。</p><h2 id="sudo-命令介绍及主要用法"><a href="#sudo-命令介绍及主要用法" class="headerlink" title="sudo 命令介绍及主要用法"></a>sudo 命令介绍及主要用法</h2><p>首先还是解释下 sudo 命令是什么意思。</p><p>sudo 的英文全称是 super user do，即以超级用户（root 用户）的方式执行命令。这里的 sudo 和之前 su 表示的 switch user 是不同的，这点需要注意，很容易搞混。</p><p>我们先介绍 sudo 命令能做什么事情，然后说明为何能做到这些，以及如何做到这些。</p><p>我们开始。</p><h3 id="主要用法"><a href="#主要用法" class="headerlink" title="主要用法"></a>主要用法</h3><p>我们在 Linux 中经常会碰到 Permission denied 这种情况，比如以 ubuntu 用户的身份查看 /etc/shadow 的内容。因为这个文件的内容是只有 root 用户能查看的。</p><p>那如果我们想要查看怎么办呢？这时候就可以使用 sudo :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ tail -n 3 /etc/shadow</span><br><span class="line">tail: cannot open <span class="string">&#x27;/etc/shadow&#x27;</span> <span class="keyword">for</span> reading: Permission denied      <span class="comment"># 没有权限</span></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$ sudo !!                                    <span class="comment"># 跟两个惊叹号</span></span><br><span class="line">sudo tail -n 3 /etc/shadow</span><br><span class="line">ntp:*:17752:0:99999:7:::</span><br><span class="line">mysql:!:18376:0:99999:7:::</span><br><span class="line">test_user:<span class="variable">$6</span>$.ZY1lj4m<span class="variable">$ii0x9CG8h</span>.JHlh6zKbfBXRuolJmIDBHAd5eqhvW7lbUQXTRS//89jcuTzRilKqRkP8YbYW4VPxmTVHWRLYNGS/:18406:0:99999:7:::</span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$</span><br></pre></td></tr></table></figure><p>实例中，我们使用了 sudo !! 这个小技巧，表示重复上面输入的命令，只不过在命令最前面加上 sudo 。</p><p>因为我已经设置了 sudo 命令不需要输入密码，所以这里 sudo !! 就能直接输出内容。如果没有设置的话，需要输入当前这个用户的密码，例如本例中，我就应该输入 ubuntu 用户的登录密码。</p><p>两次相邻的 sudo 操作，如果间隔在 5min 之内，第二次输入 sudo 不需要重新输入密码；如果超过 5min，那么再输入 sudo 时，又需要输入密码。所以一个比较省事的方法是设置 sudo 操作不需要密码。后面介绍如何设置。</p><p>sudo 除了以 root 用户的权限执行命令外，还有其它几个用法，这里做简单介绍。</p><p>切换到 root 用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su -</span><br></pre></td></tr></table></figure><p>这种方式也能以 login-shell 的方式切换到 root 用户，但是它和 su - 方法是由区别的：</p><p>前者输入 sudo su - 后，需要提供当前用户的登录密码，也就是 ubuntu 用户的密码；<br>后者输入 su - 后，需要提供 root 用户的登录密码。<br>还有一个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -i</span><br></pre></td></tr></table></figure><p>这个命令和 sudo su - 效果一致，也是切换到 root 用户，也是需要提供当前用户（ubuntu 用户）的登录密码。</p><p>我们现在切换到 test_user 用户，尝试显示 /etc/shadow 文件的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ su - test_user</span><br><span class="line">Password:                                       <span class="comment"># test_user 的密码</span></span><br><span class="line">$ sudo cat /etc/shadow</span><br><span class="line">[sudo] password <span class="keyword">for</span> test_user:                  <span class="comment"># test_user 的密码</span></span><br><span class="line">test_user is not <span class="keyword">in</span> the sudoers file.  This incident will be reported.</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>我们会看到倒数第二行中的错误提示信息，我们无法查看 /etc/shadow 的内容，这是为什么？为什么 ubuntu 可以使用 sudo 但是 test_user 不行呢？</p><p>这就涉及到 sudo 的工作原理了。</p><h3 id="sudo-工作原理"><a href="#sudo-工作原理" class="headerlink" title="sudo 工作原理"></a>sudo 工作原理</h3><p>一个用户能否使用 sudo 命令，取决于 /etc/sudoers 文件的设置。</p><p>从 3.1 节中我们已经看到，ubuntu 用户可以正常使用 sudo ，但是 test_user 用户却无法使用，这是因为 /etc/sudoers 文件里没有配置 test_user。</p><p>/etc/sudoers 也是一个文本文件，但是因其有特定的语法，我们不要直接用 vim 或者 vi 来编辑它，需要用 visudo 这个命令。输入这个命令之后就能直接编辑 /etc/sudoers 这个文件了。</p><p>需要说明的是，只有 root 用户有权限使用 visudo 命令。</p><p>我们先来看下输入 visudo 命令后显示的内容。</p><p>输入（root 用户）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># visudo</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># User privilege specification</span></span><br><span class="line">root    ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment"># Members of the admin group may gain root privileges</span></span><br><span class="line">%admin ALL=(ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment"># Allow members of group sudo to execute any command</span></span><br><span class="line">%sudo   ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment"># See sudoers(5) for more information on &quot;#include&quot; directives:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#includedir /etc/sudoers.d</span></span><br><span class="line">ubuntu  ALL=(ALL:ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure><p>解释下每一行的格式：</p><p>第一个表示用户名，如 root 、ubuntu 等；<br>接下来等号左边的 ALL 表示允许从任何主机登录当前的用户账户；<br>等号右边的 ALL 表示：这一行行首对一个的用户可以切换到系统中任何一个其它用户；<br>行尾的 ALL 表示：当前行首的用户，能以 root 用户的身份下达什么命令，ALL 表示可以下达任何命令。<br>我们还注意到 ubuntu 对应的那一行有个 NOPASSWD 关键字，这就是表明 ubuntu 这个用户在请求 sudo 时不需要输入密码，到这里就解释了前面的问题。</p><p>同时我们注意到，这个文件里并没有 test_user 对应的行，这也就解释了为什么 test_user 无法使用 sudo 命令。</p><p>接下来，我们尝试将 test_user 添加到 /etc/sudoers 文件中，使 test_user 也能使用 sudo 命令。我们在最后一行添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">test_user  ALL=(ALL:ALL)  ALL       <span class="comment"># test_user 使用 sudo 需要提供 test_user 的密码</span></span><br><span class="line">接下来我们再在 test_user 账户下执行 sudo ：</span><br><span class="line"></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$ su - test_user</span><br><span class="line">Password:</span><br><span class="line">$ tail -n 3 /etc/shadow</span><br><span class="line">tail: cannot open <span class="string">&#x27;/etc/shadow&#x27;</span> <span class="keyword">for</span> reading: Permission denied</span><br><span class="line">$ sudo tail -n 3 /etc/shadow                   <span class="comment"># 加上 sudo</span></span><br><span class="line">ntp:*:17752:0:99999:7:::</span><br><span class="line">mysql:!:18376:0:99999:7:::</span><br><span class="line">test_user:<span class="variable">$6</span>$.ZY1lj4m<span class="variable">$ii0x9CG8h</span>.JHlh6zKbfBXRuolJmIDBHAd5eqhvW7lbUQXTRS//89jcuTzRilKqRkP8YbYW4VPxmTVHWRLYNGS/:18406:0:99999:7:::</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>可以看到，现在已经可以使用 sudo 了。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>我们已经看到了，如果一个用户在 /etc/sudoers 文件中，那么它就具有 sudo 权限，就能通过 sudo su - 或者 sudo -i 等命令切换到 root 用户了，那这时这个用户就变成 root 用户了，那这不对系统造成很大的威胁吗？</p><p>实际上的确是这样的。所以如果在编辑 /etc/sudoers 文件赋予某种用户 sudo 权限时，必须要确定该用户是可信任的，不会对系统造成恶意破坏，否则将所有 root 权限都赋予该用户将会有非常大的危险。</p><p>当然，root 用户也可以编辑 /etc/sudoers 使用户只具备一部分权限，即只能执行一小部分命令。有兴趣的读者可以参考 Reference 部分第二条，这篇文章不再赘述。</p><h2 id="二者的差异对比"><a href="#二者的差异对比" class="headerlink" title="二者的差异对比"></a>二者的差异对比</h2><p>我们已经看到：</p><p>使用 su - ，提供 root 账户的密码，可以切换到 root 用户；<br>使用 sudo su - ，提供当前用户的密码，也可以切换到 root 用户<br>两种方式的差异也显而易见：如果我们的 Linux 系统有很多用户需要使用的话，前者要求所有用户都知道 root 用户的密码，这显然是非常危险的；后者是不需要暴露 root 账户密码的，用户只需要输入自己的账户密码就可以，而且哪些用户可以切换到 root，这完全是受 root 控制的（root 通过设置 /etc/sudoers 实现的），这样系统就安全很多了。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.rootusers.com/the-difference-between-su-and-sudo-commands-in-linux/">https://www.rootusers.com/the-difference-between-su-and-sudo-commands-in-linux/</a></li><li>《鸟哥的 Linux 私房菜》13.4 节：使用者身份切换</li><li><a href="https://github.com/ustclug/Linux101-docs/blob/master/docs/Ch05/index.md">https://github.com/ustclug/Linux101-docs/blob/master/docs/Ch05/index.md</a></li><li><a href="https://www.maketecheasier.com/differences-between-su-sudo-su-sudo-s-sudo-i/">https://www.maketecheasier.com/differences-between-su-sudo-su-sudo-s-sudo-i/</a></li><li><a href="https://stackoverflow.com/questions/35999671/whats-the-difference-between-sudo-i-and-sudo-su?r=SearchResults">https://stackoverflow.com/questions/35999671/whats-the-difference-between-sudo-i-and-sudo-su?r=SearchResults</a></li><li><a href="https://www.zhihu.com/question/51746286">https://www.zhihu.com/question/51746286</a></li><li><a href="https://www.linuxidc.com/Linux/2017-06/144916.htm">https://www.linuxidc.com/Linux/2017-06/144916.htm</a></li></ul>          </div>]]></content>
    
    <summary type="html">
    
      Copyright@Jun Tao&lt;br&gt;From https://tanjuntao.github.io
    
    </summary>
    
    
    
      <category term="TERMINAL" scheme="https://augists.top/tags/TERMINAL/"/>
    
  </entry>
  
</feed>

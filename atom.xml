<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Augists-ZDCZ</title>
  
  <subtitle>LESS is MORE</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://augists.top/"/>
  <updated>2022-11-01T08:17:28.172Z</updated>
  <id>https://augists.top/</id>
  
  <author>
    <name>Augists</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Open Case Design</title>
    <link href="https://augists.top/SELF/SHARING/LIFE/open-case-design/"/>
    <id>https://augists.top/SELF/SHARING/LIFE/open-case-design/</id>
    <published>2022-11-01T08:12:28.000Z</published>
    <updated>2022-11-01T08:17:28.172Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h1 id="开放式机箱设计方案"><a href="#开放式机箱设计方案" class="headerlink" title="开放式机箱设计方案"></a>开放式机箱设计方案</h1><div class="note danger">            <p>项目已经放在<a href="https://github.com/Augists/openCase">GitHub 仓库</a></p>          </div><p>由于市面上的机箱设计方案便宜的普遍不好看，好看又优秀的设计又导致机箱特别贵。正好我也在计划着装一台自己的电脑，所以就想能不能自己设计一套符合自己审美，又能拿出来看的机箱</p><p>在最开始我曾非常坚定的想要做壁挂主机，把所有的电脑配件都挂到洞洞板上立起来，也可以钉到墙上。后来在看了很多视频后，决定做成桌面的开放式机箱。壁挂机箱的最大缺点就是，硕大的电源也需要挂上去，成为整个壁挂主机最不和谐的地方</p><p>所以我就想，能不能把这个方块的电源藏起来，甚至让它作为机箱的一部分起到某种作用呢？</p><p><img src="https://github.com/Augists/openCase/raw/main/img/sample.JPG" alt="sample"></p><p>上图是我在浏览购物平台时发现的一套分体水的开放式机箱，店家也是专做水冷的，名字叫 bykski。感兴趣可以去搜索一下这个机箱 B-CE-X 的效果，这也是我这次设计的模仿</p><p>这套机箱为了能实现分体水冷和显卡的支撑，将 atx 主板旋转了 90 度摆放。作为一台开放式主机，风冷散热器可能并不合适直接放置在外面，所以尽管没有能力做分体水，我也选择了一体水作为我的开放式机箱的散热支持</p><img alt="手绘" src="https://github.com/Augists/openCase/raw/main/img/手绘设计图 ver. 2.PNG"><p>在第一次的构想里，我把水冷放在了机箱背板的顶部。整个结构想要通过背板和电源以及支架来倾斜放置，然后将水冷放在较为中心的位置以平衡整个机箱结构的重心。由于我目前手边并没有台式机，只能依靠之前触碰的印象进行猜测。电源应该是在不考虑显卡的情况下电脑配件里最笨重的一个了，将它倾斜作为支点，同时分担平衡主板的重量，感觉还是挺合理的</p><p>另外有一点，我特意将主板正放，不同于 B-CE-X，以便我可以在没有前置 IO 的情况下能方便的使用主板的 IO 接口</p><img alt="ver 1" src="https://github.com/Augists/openCase/raw/main/img/ver. 1/main pad.PNG"><p>于是我就开始用 Sharp3D 着手进行设计，并参考了网上的 m-atx 主板的尺寸以及螺丝孔位，为主板和CPU供电预留了两个应该够大的走线孔。右下角的圆形开孔是我从淘宝找到的主板开机键跳线和按钮，商家提供了 12/16/22mm 等直径的开机按键，我在这里只是以最小的 12mm 直径为例</p><p>通过简单的组合可以预估到装机后的情况，由于第一版设计需要分开部件单独制作并组装，在水冷架上就发现一开始的构想存在问题</p><img alt="com" src="https://github.com/Augists/openCase/raw/main/img/ver. 1/主视图.PNG"><p>m-atx 主板的大小是 244x244mm，这也意味着在不太突出水冷的情况下，不能选择 360 大小的水冷，最大可能就只能通过延长机箱背板让它支持 240 规格的水冷。在询问了利民 240 冰封幻境的规格后我才发现，水冷排的尺寸并非简单的两把 120 风扇拼接，而是 277x120x27，也就意味着我的背板需要至少 280 的长度才可以，并且再加上 25mm 高的风扇，整个水冷的厚度已经到了 52mm，放在机箱里可能没有什么感觉，但是在我的这种结构里，如此厚重的水冷无疑是灾难</p><blockquote><p>这块机箱背板我找了一家铝板定制，报价为 85r，如果加厚到 5mm，预估会在 100r 出头</p></blockquote><p>所以在第二版的设计里，我将水冷转移到了背板的侧面，让它改为立式的放置方式，同时由于 52mm 的厚度，我觉得不应该将整个背板再继续延长来支撑它，而是将散热器架到水冷架的外侧进行固定</p><img src="https://github.com/Augists/openCase/raw/main/img/ver. 2/底部视角.PNG"><p>我也在背板的底部添加了两个小的开孔，想让主板下面的例如开机跳线、sata线等穿过这个孔洞来进行整理。整个机箱的装饰风格也从第一版的模仿 B-CE-X 改为这种房子🏠形状的开孔和凹槽</p><p>不过我在给朋友看这套设计的时候，他提到如果我用的是铝材料做机箱，它在强度和刚性上可能会不足，所以我就在第三版里将水冷架延伸到桌面进行支撑，并且加厚了背部的电源支架和机箱脚</p><img src="https://github.com/Augists/openCase/raw/main/img/ver. 3/前视角.PNG"><img src="https://github.com/Augists/openCase/raw/main/img/ver. 3/斜视角.PNG"><img src="https://github.com/Augists/openCase/raw/main/img/ver. 3/底部视角.PNG"><p>不过很可惜，这个开放式机箱的项目流产了（PS 最近流产的项目有点多，感觉自己很浮躁），因为我找到的商家无法直接 cnc 这么大的三维结构，而改用其他材料又会出现很多限制，而我又急于得到一个可以使用的机箱</p><p>我的模型文件 ver.1 对应 <code>case1.step</code>，ver.3 对应 <code>case2.step</code></p><p>希望能等到一个有缘人，看到我的这个不是很成熟的开放式机箱设计方案，记得和我说一声给我看看装机的图片让我也开心一下</p>          </div>]]></content>
    
    <summary type="html">
    
      A open case structure designed by myself
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
      <category term="DESIGN" scheme="https://augists.top/tags/DESIGN/"/>
    
  </entry>
  
  <entry>
    <title>DLUT-EDA Network List Has Been Rewritten Using Beego</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/DLUT-EDA-Network-List-Has-Been-Rewritten-Using-Beego/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/DLUT-EDA-Network-List-Has-Been-Rewritten-Using-Beego/</id>
    <published>2022-10-09T16:28:56.000Z</published>
    <updated>2022-10-09T16:35:39.001Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>前几天重新拾起来 <a href="https://github.com/beego/beego">Beego</a> （重新学习），把之前的一个想法💡用 beego 的 MVC 重新实现出来了一个 baseline</p><p><a href="https://github.com/Augists/DLUT-EDA-NetworkList">项目地址</a></p><p>我得承认这个项目是我的愿景，有些不够切合实际</p><p>我的想法💡是，大家都有自己的熟人小圈子：</p><ul><li>每个人每个月对校园网的需求都是波动的</li><li>上个月用了 20 G，下个月我可能又会需要用 120 G</li><li>5 个人的小圈子，可能总共只会用 3 个人的量</li></ul><p>所以我就想，通过这种方式，让大家均摊校园网的成本，同时也能让你在超量使用的情况下收到来自小圈子里别人的“援手”</p><p>它可能有点乌托邦了，但是我相信这能帮助一些人在一定程度上解决校园网的窘境</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> 将 shell 脚本转化为 golang，不再依赖 <a href="https://github.com/bboymega/dlut-eda-shell-login">mega 的 DLUT-EDA-Login</a> 项目</li><li><input disabled="" type="checkbox"> 随机选择账户登陆失败后，继续随机下一个</li><li><input disabled="" type="checkbox"> 打包为 Release 发布，多平台</li></ul>          </div>]]></content>
    
    <summary type="html">
    
      This is a simple but interesting idea💡 for campus network&lt;br&gt;And I have accomplished a baseline using beego framework
    
    </summary>
    
    
    
      <category term="GOLANG" scheme="https://augists.top/tags/GOLANG/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Git Amend Cause Bifurcation</title>
    <link href="https://augists.top/SELF/ERROR/git-amend-cause-Bifurcation/"/>
    <id>https://augists.top/SELF/ERROR/git-amend-cause-Bifurcation/</id>
    <published>2022-09-11T16:35:13.000Z</published>
    <updated>2022-09-11T17:55:18.808Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>今学长拿着下面的这几张图问了我一个问题，为什么他用 <code>git commit --amend</code> 之后就会出现分支分叉的情况</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/photo_2022-09-12 00.58.29.jpeg"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/photo_2022-09-12 00.58.31.jpeg"><p>我们先来了解一些 <code>git</code> 的 <code>amend</code> 指令是干什么的</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/photo_2022-09-12 01.02.57.jpeg"><p>简单来说，它就是会修改你上一次的 <code>commit</code>。直观上看，修改的是上一次 <code>commit</code> 中写的提交信息；但是隐性的说，在你上一次 <code>commit</code> 之后再做的修改也会被包含到这次的 <code>commit --amend</code> 中</p><p>我问学长要了他 git 分叉的两条路径节点的信息</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/photo_2022-09-12 00.58.34.jpeg"><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/photo_2022-09-12 00.58.37.jpeg"><p>可以看到，蓝色的分支里 Branches 的信息为 <code>master | origin</code>，而粉色分支的信息为 <code>origin/master</code>。来看看 <code>origin</code> 指代的是什么意思</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/photo_2022-09-12 01.10.12.jpeg"><p>可以把他理解成一个起别名为 <code>origin</code> 的指针，指向了某一个远端的 git 服务器地址。关于这一点，可以参考 <code>.git/config</code> 文件，这里我以博客仓库中的为例</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/photo_2022-09-12 01.11.53.jpeg"><p>如果你是使用 HTTPS 协议作为 git 的传输协议，那么在 <code>[branch &quot;master&quot;]</code> 中应该看到的是</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[branch &quot;master&quot;]</span></span><br><span class="line">  <span class="attr">remote</span> = origin</span><br><span class="line">  <span class="attr">merge</span> = ...</span><br></pre></td></tr></table></figure><p>相比 SSH 协议的写法，HTTPS 版本看的更加明显。<code>remote</code> 指向了 <code>origin</code> 别名，而 <code>origin</code> 又指向 <code>[remote &quot;origin&quot;]</code> 部分</p><p>同样，如果我们添加一个 <code>mirror</code>，用它来指向一个新的仓库地址，HTTPS 版本的写法就可以大概写为</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[core]</span></span><br><span class="line">  ...</span><br><span class="line"><span class="section">[remote &quot;origin&quot;]</span></span><br><span class="line">  <span class="attr">url</span> = ...</span><br><span class="line">  <span class="attr">fetch</span> = ...</span><br><span class="line"><span class="section">[remote &quot;mirror&quot;]</span></span><br><span class="line">  <span class="attr">url</span> = ...</span><br><span class="line">  <span class="attr">fetch</span> = ...</span><br><span class="line"><span class="section">[branch &quot;master&quot;]</span></span><br><span class="line">  <span class="attr">remote</span> = origin</span><br><span class="line">  <span class="attr">merge</span> = ...</span><br></pre></td></tr></table></figure><p>这时如果 <code>git push</code> 就只会发 <code>origin</code>，想要给 <code>mirror</code> 发送就需要写成 <code>git push mirror master</code>（大概是，没试过<br>如果此时修改 <code>remote = mirror</code>，你省略写法 <code>git push</code> 就会发给 <code>mirror</code> 指向的仓库</p><p>回到正题，实际上导致学长 git 的分支分叉的流程是<br>change file -&gt; <code>git add &amp; commit</code> -&gt; <code>git push</code> -&gt; change file -&gt; ‘git add &amp; commit –ammend’ -&gt; <code>git push</code></p><p>发送到远端的服务器之后，又通过 <code>amend</code> 修改了本地上一次的提交，这就导致了本地和远端出现分叉的情况</p><p>事实上，如果提交够规范，每一次 <code>commit</code> 都是一次功能实现或更新，<code>amend</code> 只能说是为了提交更规范的一种补救措施。学长考虑的是维护 git 提交更干净，所以才想到用 <code>git commit --amend</code> 替换 <code>git commit</code> 的做法，而在规范提交的情况下，就没有必要再花费精力去维护提交干净了</p><hr><blockquote><p>另外，代码块好像不能识别 <code>.ini</code> 文件，也可能是 markdown 的代码块不应该写 ini 格式。借着这个机会还顺便了解了一点几种配置文件的区别，尤其是 ini 和 TOML</p></blockquote><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>cht.sh</li><li><a href="https://www.bilibili.com/video/BV1v3411n7Wh?spm_id_from=333.337.search-card.all.click&vd_source=970c58530383d2118b4d7ea7b310c0ca">git 合并两个 commit</a></li><li><a href="https://www.cnblogs.com/bwar/p/9297343.html">git 多远程仓库</a></li><li><a href="https://blog.csdn.net/winter_wu_1998/article/details/103469213">常见配置文件格式</a></li><li><a href="https://tao-fu.gitee.io/2020/12/03/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%9E%B6%E6%9E%84/config_format/">Config 文件对比</a></li></ul>          </div>]]></content>
    
    <summary type="html">
    
      git branch bifurcation caused by git commit --amend command
    
    </summary>
    
    
    
      <category term="GIT" scheme="https://augists.top/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title>BGP Summary</title>
    <link href="https://augists.top/NOTES/PAPER/BGP-Summary/"/>
    <id>https://augists.top/NOTES/PAPER/BGP-Summary/</id>
    <published>2022-09-05T08:25:21.000Z</published>
    <updated>2022-09-10T18:15:54.020Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <div class="note danger">            <p>Copyright: Looo~ye<br>Source: <a href="https://blog.csdn.net/keith6785753/article/details/107088632">CSDN</a><br>对文章排版进行修改，学习过程中顺带，并对一些有歧义或有问题的地方进行修改（只看了需要看的，所以可能还是会有地方有小问题</p>          </div><h1 id="Border-Gateway-Protocol"><a href="#Border-Gateway-Protocol" class="headerlink" title="Border Gateway Protocol"></a><strong>B</strong>order <strong>G</strong>ateway <strong>P</strong>rotocol</h1><blockquote><p>动态路由协议可以按照工作范围分为IGP以及EGP。IGP工作在同一个AS内，主要用来发现和计算路由，为AS内提供路由信息的交换；而EGP工作在AS与AS之间，在AS间提供无环路的路由信息交换。BGP是为了取代EGP而创建的（维基百科）。BGP是一种增强的路径矢量路由协议，同时BGP是拥有丰富的策略控制技术的外部网关协议。多运行于AS与AS之间。</p></blockquote><h2 id="BGP-概述"><a href="#BGP-概述" class="headerlink" title="BGP 概述"></a>BGP 概述</h2><p><strong>BGP 其着眼点不在于自动发现网络拓扑，而在于在AS之间选择最佳路由和控制路由的传播。</strong></p><ul><li>BGP使用TCP作为其传输层协议（监听端口号为179），提高了协议的可靠性，且不需要专门的机制来确保连接的可控性。<ul><li>BGP进行域间的路由选择，对协议的稳定性要求非常高。因此用TCP协议的高可靠性来保证BGP协议的稳定性。</li><li>BGP的对等体之间必须在逻辑上连通，并进行TCP连接。目的端口号为179，本地端口号任意。</li></ul></li><li>路由更新时，BGP只发送更新的路由，大大减少了BGP传播路由所占用的带宽，适用于在Internet上传播大量的路由信息。</li><li>BGP从设计上避免了环路的发生。<ul><li>AS之间：BGP通过携带AS路径信息来标记途经的AS，带有本地AS号的路由将被丢弃，从而避免了域间产生环路。</li><li>AS内部：BGP在AS内学到的路由不再通告给AS内的BGP邻居，避免了AS内产生环路。</li></ul></li><li>支持CIDR 无类域间路由</li><li>BGP提供了丰富的路由策略；提供了防止路由振荡的机制；BGP也易于扩展</li></ul><h2 id="BGP-基本概念"><a href="#BGP-基本概念" class="headerlink" title="BGP 基本概念"></a>BGP 基本概念</h2><ul><li>自治系统AS（Autonomous System ）是指在一个实体管辖下的拥有相同选路策略的IP网络。<ul><li>每个AS都有唯一的自治系统编号，这个编号是由IANA分配的。</li><li>编号范围是1~65535（其中1到64511是注册的因特网编号，64512到65535是私有网络编号）</li></ul></li><li>EBGP和IBGP（External BGP /Internal BGP）<br><img src="https://img-blog.csdnimg.cn/20200702173513321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlaXRoNjc4NTc1Mw==,size_16,color_FFFFFF,t_70" alt=""><ul><li>IBGP：运行于同一AS内部的BGP称为IBGP</li><li>EBGP：运行于不同AS之间的BGP称为EBGP</li></ul></li><li>BGP报文交互中的角色<ul><li>Speaker：发送BGP消息的路由器称为BGP发言者，它接收或产生新的路由信息，并发布给其它BGP Speaker</li><li>Peer：相互交换消息的BGP Speaker之间互称对等体（Peer），若干相关的对等体可以构成对等体组（Peer Group）</li></ul></li></ul><h2 id="BGP-工作原理"><a href="#BGP-工作原理" class="headerlink" title="BGP 工作原理"></a>BGP 工作原理</h2><h3 id="BGP报文"><a href="#BGP报文" class="headerlink" title="BGP报文"></a>BGP报文</h3><ul><li>Open消息：是TCP连接建立后发送的第一个消息，用于建立BGP对等体之间的连接关系。对等体在接收到Open消息并协商成功后，将发送Keepalive消息确认并保持连接的有效性。确认后，对等体间可以进行Update、Notification、Keepalive和Route-Refresh消息的交换</li><li>Update消息：用于在对等体之间交换路由信息。Update消息可以发布多条属性相同的可达路由信息，也可以撤销多条不可达路由信息</li><li>Keepalive消息：BGP会周期性的向对等体发出Keepalive消息，用来保持连接的有效性</li><li>Notification消息：当BGP检测到错误状态时，就向对等体发出Notification消息，之后BGP连接会立即中断</li><li>Route-Refresh消息：通过OPEN消息告知BGP peer本地支持路由刷新能力（Route-Refresh capability）</li></ul><p>这5种消息的应用：</p><ul><li>通过TCP建立BGP连接时，发送OPEN消息</li><li>连接建立后，如果有路由需要发送或路由变化时，发送UPDATE消息通告对端</li><li>稳定后要定时发送KEEPALIVE消息以保持BGP连接的有效性</li><li>当本地BGP在运行中发现错误时，要发送NOTIFICATION消息通告BGP对等体</li><li>ROUTE-REFRESH消息用来通知对等体自己支持路由刷新</li></ul><p>报文格式</p><p><img src="https://img-blog.csdnimg.cn/2020070219233669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlaXRoNjc4NTc1Mw==,size_16,color_FFFFFF,t_70" alt=""></p><p>上图展开了BGP报文中的报文头Header</p><ul><li>Marker（标记）：16字节，固定为1</li><li>Length（长度）：两字节无符号整数。指定了消息的全长，包括头部</li><li>Type（类型）：1 字节，指示报文类型，如OPEN、UPDATE报文等<ul><li>1 – OPEN</li><li>2 – UPDATE</li><li>3 – NOTIFICATION</li><li>4 – KEEPALIVE</li></ul></li></ul><p>以 open 消息的具体报文格式为例<br><img src="https://img-blog.csdnimg.cn/20200702194159619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlaXRoNjc4NTc1Mw==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>BGP有限状态机共有六种状态，分别是Idle、Connect、Active、OpenSent、OpenConfirm和Established</p><ul><li>Idle状态是BGP初始状态。在Idle状态下，BGP拒绝邻居发送的连接请求。只有在收到本设备的Start事件后，BGP才开始尝试和其它BGP对等体进行TCP连接，并转至Connect状态<ul><li>Start事件是由一个操作者配置一个BGP过程，或者重置一个已经存在的过程或者路由器软件重置BGP过程引起的</li><li>任何状态中收到Notification报文或TCP拆除链路通知等Error事件后，BGP都会转至Idle状态</li></ul></li><li>在Connect状态下，BGP启动连接重传定时器（Connect Retry，缺省为32秒），等待TCP完成连接<ul><li>如果TCP连接成功，那么BGP向对等体发送Open报文，并转至OpenSent状态</li><li>如果TCP连接失败，那么BGP转至Active状态</li><li>如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP继续尝试和其它BGP对等体进行TCP连接，停留在Connect状态</li><li>如果发生其他事件（由系统或者操作人员启动的），则退回到Idle状态</li></ul></li><li>在Active状态下，BGP总是在试图建立TCP连接<ul><li>如果TCP连接成功，那么BGP向对等体发送Open报文，关闭连接重传定时器，并转至OpenSent状态</li><li>如果TCP连接失败，那么BGP停留在Active状态</li><li>如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP转至Connect状态</li></ul></li><li>在OpenSent状态下，BGP等待对等体的Open报文，并对收到的Open报文中的AS号、版本号、认证码等进行检查<ul><li>如果收到的Open报文正确，那么BGP发送Keepalive报文，并转至OpenConfirm状态；</li><li>如果发现收到的Open报文有错误，那么BGP发送Notification报文给对等体，并转至Idle状态。</li></ul></li><li>在OpenConfirm状态下，BGP等待Keepalive或Notification报文。如果收到Keepalive报文，则转至Established状态，如果收到Notification报文，则转至Idle状态</li><li>在Established状态下，BGP可以和对等体交换Update、Keepalive、Route-refresh报文和Notification报文<ul><li>如果收到正确的Update或Keepalive报文，那么BGP就认为对端处于正常运行状态，将保持BGP连接</li><li>如果收到错误的Update或Keepalive报文，那么BGP发送Notification报文通知对端，并转至Idle状态</li><li>Route-refresh报文不会改变BGP状态。 如果收到Notification报文，那么BGP转至Idle状态</li><li>如果收到TCP拆链通知，那么BGP断开连接，转至Idle状态</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20200702200955159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlaXRoNjc4NTc1Mw==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="BGP对等体之间交互原则"><a href="#BGP对等体之间交互原则" class="headerlink" title="BGP对等体之间交互原则"></a>BGP对等体之间交互原则</h3><ul><li>从IBGP对等体获得的BGP路由，BGP设备只发布给它的EBGP对等体（这样的水平分割是为了防止IBGP内部环路）</li><li>从EBGP对等体获得的BGP路由，BGP设备发布给它所有EBGP和IBGP对等体（即发给所有BGP对等体）</li><li>当存在多条到达同一目的地址的有效路由时，BGP设备会选择最优路由给自己使用，即用来发给邻居，同时上送给路由表</li><li>路由更新时，BGP设备只发送更新的BGP路由</li></ul><h3 id="BGP与IGP同步"><a href="#BGP与IGP同步" class="headerlink" title="BGP与IGP同步"></a>BGP与IGP同步</h3><p>事实上，上面第一条从IBGP对等体学到的BGP路由，不是一定会发送给它的EBGP对等体的，前提条件是需要BGP与IGP同步</p><p><img src="https://img-blog.csdnimg.cn/2020070220371341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlaXRoNjc4NTc1Mw==,size_16,color_FFFFFF,t_70" alt=""></p><p>BGP的主要任务之一就是向其它自治系统发布该自治系统的网络可达信息。如图所示，RTB会把去往10.1.1.0/24 的路由信息封装在BGP报文中，通过由RTB、RTE建立的TCP连接通告给RTE，如果RTE不考虑同步问题，直接接受了这条路由信息并通告给RTF。那么，如果RTF或RTE有去往10.1.1.0/24 的数据报文要发送，这个数据报文要想到达目的地必须经过RTD和RTC。但是，由于先前没有考虑同步问题，RTD和RTC的路由表中没有去往10.1.1.0/24的路由信息，数据报文到了RTD就会被丢弃。因此，BGP必须与IGP（如RIP、OSPF等）同步。也就是说，当一个路由器从IBGP对等体收到一条路由更新信息，在把它通告给它的EBGP对等体之前，要试图验证该目的地能否通过自治系统内部到达（即验证该目的地是否存在于IGP发现的路由表内，非BGP路由器是否可以传递报文到该目的地）。若能通过IGP知道这个目的地，才会把这样一条路由信息通告给EBGP对等体，否则认为BGP与IGP不同步，不进行通告。</p><h2 id="BGP-与-IGP-交互"><a href="#BGP-与-IGP-交互" class="headerlink" title="BGP 与 IGP 交互"></a>BGP 与 IGP 交互</h2><p>上面刚刚介绍了从IBGP对等体学到的BGP路由发送给它的EBGP对等体的前提条件是BGP同步，而同步是通过BGP路由表与IGP路由表的相互引入</p><p>BGP引入IGP路由：</p><p>BGP的主要工作是在自治系统之间传递路由信息，而不是去发现和计算路由信息。所以，路由信息需要通过配置命令的方式注入到BGP中。</p><h3 id="network-命令"><a href="#network-命令" class="headerlink" title="network 命令"></a>network 命令</h3><p>逐条引入，通过Network命令注入到BGP路由表里的路由信息必须存在于IP路由表中<br><img src="https://img-blog.csdnimg.cn/20200703095406255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlaXRoNjc4NTc1Mw==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>按协议类型引入，也可以引入静态或直连路由</p><p><img src="https://img-blog.csdnimg.cn/20200703095512612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlaXRoNjc4NTc1Mw==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="BGP-属性特点"><a href="#BGP-属性特点" class="headerlink" title="BGP 属性特点"></a>BGP 属性特点</h2><p>BGP路由属性分为4类：</p><ul><li>公认必遵(Well-known mandatory)：所有BGP路由器都可以识别，且必须存在于Update消息中 如果缺少这种属性，路由信息就会出错</li><li>公认任意(Well-known discretionary)： 所有BGP路由器都可以识别，但不要求必须存在于Update消息中，即就算缺少这类属性，路由信息也不会出错</li><li>可选过渡(Optional transitive)：在AS之间具有可传递性的属性 BGP路由器可以选择是否在Update消息中携带这种属性。接收的路由器如果不识别这种属性，可以转发给邻居路由器，邻居路由器可能会识别并使用到这种属性</li><li>可选非过渡(Optional non-transitive)：BGP路由器可以选择是否在Update消息中携带这种属性。如果接受的BGP路由器不支持此属性，则相应的这类属性会被忽略，且不会传递给其他对等体</li></ul><p>列出几种常见属性（下文会重点介绍和后面要说的BGP选路规则有关的属性）：</p><ul><li>Origin：起点属性。定义路由信息的来源，标记一条路由是怎样成为BGP路由的。（属于公认必遵）<br><img src="https://img-blog.csdnimg.cn/20200703173009194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlaXRoNjc4NTc1Mw==,size_16,color_FFFFFF,t_70" alt=""></li></ul><p>有3种类型：</p><ol><li>IGP（标识为 i）：具有最高的优先级。通过路由始发AS的IGP得到的路由信息，比如通过network命令注入到BGP路由表的路由，其Origin属性为IGP。</li><li>EGP（标识为 e）：优先级次之。通过EGP得到的路由信息，其Origin属性为EGP。</li><li>Incomplete（标识为 ？）：优先级最低。通过其他方式学习到的路由信息。比如BGP通过import-route命令引入的路由，其Origin属性为Incomplete。</li></ol><ul><li>As_PATH：AS路径属性。是路由经过的AS的序列，即列出此路由在传递过程中经过了哪些AS。它可以防止路由循环，并用于路由的过滤和选择。（公认必遵）</li></ul><p><img src="https://img-blog.csdnimg.cn/20200703173127693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlaXRoNjc4NTc1Mw==,size_16,color_FFFFFF,t_70" alt=""></p><p>上图中：当R4将网段10.0.0.0/24通告给AS400和AS100时，会在AS_PATH中添加自己的AS号。当R5将网段10.0.0.0/24通告给AS100使，也会添加添加自己的AS号。当AS100内的R1和R3再将网段10.0.0.0/24通告给本AS域内的R2时，AS_PATH属性不会改变，且R2在其他BGP选路条件相同的前提下选择AS_PATH路径最短的，即选择通过R3到达网段10.0.0.0/24。</p><ul><li><p>Next hop：下一跳属性。包含到达更新消息所列网络的下一跳边界路由器的IP地址。（公认必遵）</p></li><li><p>Local-Preference：本地优先级属性。用于在AS内优选到达某一目的地的路由。反映了BGP Speaker对每条BGP路由的偏好程度。属性值越大越优。（公认任意）<br><img src="https://img-blog.csdnimg.cn/20200703173619159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlaXRoNjc4NTc1Mw==,size_16,color_FFFFFF,t_70" alt=""></p></li></ul><p>上图中：R1从本AS内的R2学到网络10.0.0.0/24的Local_Pref为300，从本AS内的R3学到网络10.0.0.0/24的Local_Pref为200时，R1会选择经由R2到达目的网络10.0.0.0/24。</p><ul><li>MED属性：当某个AS有多个入口时，可以用MED属性来帮助其外部的AS选择一个较好的入口路径。一条路由的MED值越小，其优先级越高。（可选非过渡）<br><img src="https://img-blog.csdnimg.cn/20200703173748997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlaXRoNjc4NTc1Mw==,size_16,color_FFFFFF,t_70" alt=""></li></ul><p>上图中：R1和R2将网段10.0.0.0/24传递给各自的EBGP邻居R3和R4，R3和R4在其他条件相同的情况下，优先选择MED值较低的路径，即均选择经由R1访问网络10.0.0.0/24。</p><ul><li>Community：团体属性。团体属性标识了一组具有相同特征的路由信息，与它所在的IP子网或自治系统无关。（可选过渡）</li></ul><h2 id="BGP-选路规则与负载分担"><a href="#BGP-选路规则与负载分担" class="headerlink" title="BGP 选路规则与负载分担"></a>BGP 选路规则与负载分担</h2><p>当到达同一目的地存在多条路由时，BGP采取如下策略进行路由选择：</p><ol><li>如果此路由的下一跳不可达，忽略此路由</li><li>优选协议首选值（PrefVal）最高的路由 （华为设备特有属性）</li><li>优选本地优先级（Local_Pref）最高的路由</li><li>优选本地生成的路由</li><li>优选AS路径（AS_Path）最短的路由</li><li>比较Origin属性，依次优选Origin类型为IGP、EGP、Incomplete的路由</li><li>优选MED值最低的路由</li><li>优选从EBGP邻居学来的路由</li><li>优选到BGP下一跳IGP Metric较小的路由</li></ol><p>当以上全部相同，则为“等价路由”，可以负载分担<br>注：AS_PATH必须一致；当负载分担时，以下3条原则无效<br>优选Cluster_List最短的路由<br>优选Originator_ID 或者Router ID最小的路由器发布的路由<br>比较对等体的IP Address，优选从具有较小IP Address的对等体学来的路由</p><p>根据BGP的选路原则以及BGP常用的路径属性，我们可以总结出9个影响BGP选路的重要参数，分别为：</p><ul><li>Preferred Value</li><li>LOCAL_PREF</li><li>AS_PATH</li><li>ORIGIN</li><li>MED</li><li>邻居类别是EBGP还是IBGP</li><li>IGP内部开销值</li><li>Cluster List /ROUTER_ID</li><li>COMMUNITY</li></ul><p>以上参数都能直接地影响BGP的路径选择，其中我们常用的参数分别为LOCAL_PREF, AS_PATH和MED属性。</p><h2 id="BGP-拓展特性"><a href="#BGP-拓展特性" class="headerlink" title="BGP 拓展特性"></a>BGP 拓展特性</h2><h3 id="安全特性"><a href="#安全特性" class="headerlink" title="安全特性"></a>安全特性</h3><ul><li>MD5：BGP使用TCP作为传输层协议，为提高BGP的安全性，可以在建立TCP连接时进行MD5认证。但BGP的MD5认证并不能对BGP报文认证，它只是为TCP连接设置MD5认证密码，由TCP完成认证。如果认证失败，则不建立TCP连接。</li><li>GTSM（Generalized TTL Security Mechanism 即通用TTL安全保护机制）：使能BGP的GTSM策略后，接口板对所有BGP报文的TTL值进行检查。根据实际组网的需要，对于不符合TTL值范围的报文，GTSM可以设置为通过或丢弃。配置GTSM缺省动作为丢弃时，可以根据网络拓扑选择合适的TTL有限值范围，不符合TTL值范围的报文会被接口板直接丢弃，这样就避免了网络攻击者模拟的“合法”BGP报文占用CPU。该功能与EBGP多跳互斥。</li><li>限制从对等体接收的路由数量，防止资源耗尽性攻击。</li><li>AS_Path长度保护。通过在入口和出口两个方向对AS_Path的长度进行限定，直接丢弃AS_Path超限的报文。</li></ul><h3 id="路由衰减（eBGP）"><a href="#路由衰减（eBGP）" class="headerlink" title="路由衰减（eBGP）"></a>路由衰减（eBGP）</h3><p>路由衰减（Route Dampening）用来解决路由不稳定的问题，即路由表中的某条路由反复消失和重现，也就是路由振荡。多数情况下，BGP协议都应用于复杂的网络环境中，路由变化十分频繁。为了防止持续的路由振荡带来的不利影响，BGP使用路由衰减来抑制不稳定的路由。</p><p><img src="https://img-blog.csdnimg.cn/20200703195448601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlaXRoNjc4NTc1Mw==,size_16,color_FFFFFF,t_70" alt=""></p><p>BGP衰减使用惩罚值来衡量一条路由的稳定性，惩罚值越高则说明路由越不稳定。路由每发生一次振荡（路由从激活状态变为未激活状态，称为一次路由振荡），BGP便会给此路由增加一定的惩罚值（1000）。当惩罚值超过抑制阈值时，此路由被抑制，不加入到路由表中，也不再向其他BGP对等体发布更新报文。<br>被抑制的路由每经过一段时间（900S），惩罚值便会减少一半，这个时间称为半衰期（Half-life）。当惩罚值降到再使用阈值时，此路由变为可用并被加入到路由表中，同时向其他BGP对等体发布更新报文</p><p>路由衰减只适用于EBGP路由。对于从IBGP收来的路由不能进行衰减，因为IBGP路由经常含有本AS的路由，内部网络路由要求转发表尽可能一致，IGP快速收敛就是为了达到信息同步，转发一致。如果衰减对IBGP路由起作用，不同设备的衰减参数不一致时，会导致转发表不一致。</p>          </div>]]></content>
    
    <summary type="html">
    
      BGP summary note from Internet&lt;br&gt;Copyright https://blog.csdn.net/keith6785753/article/details/107088632
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="BGP" scheme="https://augists.top/tags/BGP/"/>
    
  </entry>
  
  <entry>
    <title>Color Map Generator</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/Color-Map-Generator/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/Color-Map-Generator/</id>
    <published>2022-08-20T02:12:20.000Z</published>
    <updated>2022-08-20T03:09:10.477Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>前天偶然想到要做一个自动采集图片颜色，并且按照比例和颜色排成色卡的小工具，顺便敲敲代码<br>因为没有上升到直方图的层次，所以对于图片的判断并没有很大的辅助效果，它只能帮助更直观的体现图片的颜色层次和范围<br>本身对于图片的颜色提取到最后的绘制 color map 都很简单，Golang 也有标准库 image 来提供对不同格式图片的编码和解码<br>但是在对于提取后的颜色排序上，遇到了一些很有意思的问题</p><hr><p>提取后的颜色结果存储形式是 <code>color.Color</code>，在官方文档里是这样写的</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Screen Shot 2022-08-20 at 10.34.53.png"><ul><li>注意到，它返回的是 <em>alpha-permultiplied red, green, blue and alpha values*，并非我们平时直接用到的 RGB 值。平常理解的值是 0-255 范围，而这里是 0-65535，但是它可以转换为普通的 RGB 值，并且直接以 *alpha-premultiplied</em> 的 RGB 进行排序也是可以的</li><li>直接打印 <code>color.Color</code> 对象会发现它输出的并不是 RGB 值，这在一开始对我产生了很大的误导。我在排序后查看 log 中存储的 <code>color.Color</code> 结果时发现一直是乱序，让我一直以为我的排序不起作用</li><li>由于我将输出设定为固定高度 50px，在尝试将宽度设置为原图的长x宽后发现会导致编码后的图片可能由于长宽比过于夸张而无法读取（width: 19w px, height: 50px）。经过测试，最终选择用 step 的方式将宽度固定为原图等宽，也可以宽 50px 长度等长，这样就可以将 color map 与原图放在一起生成图片</li><li>通常的调色盘是如下图这种形式。通过将左边拉到右上角，调整右边的颜色滑块，观察 RGB 值可以看到，所有颜色被分为了六个部分</li></ul><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/D5826E381AB434B0940EC19F32DD890B.jpg"><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ffxx00: 00-ff</span><br><span class="line">xxff00: ff-00</span><br><span class="line">00ffxx: 00-ff</span><br><span class="line">00xxff: ff-00</span><br><span class="line">xx00ff: 00-ff</span><br><span class="line">ff00xx: ff-00</span><br></pre></td></tr></table></figure><p>其中 xx 的变化范围在右边。这也就说明，对于任意一个颜色，需要优先判断它所处的颜色范围，例如 <code>#ff0301</code> 需要先划分到 <code>#ff0300</code> 属于第一种颜色范围。如果将 <code>#ff0301</code> 与 <code>#ff0103</code> 进行对比排序，他们的颜色范围分别是 <code>#ff0300</code> 和 <code>#ff0003</code>，也即 <code>#ffxx00</code> 和 <code>#ff00xx</code>，分属不同颜色范围。但如果是 <code>#ff0301</code> 和 <code>#ff0302</code> 比较，他们同属于 <code>#ffxx00</code> 中，就是在同一颜色范围中进行比较，就会涉及到对左侧色盘的调整。你很难说 <code>#ff0302</code> 和 <code>#ff0504</code> 谁应该放在前面，是否在同一颜色范围内应该以 xx 作为第一排序原则。同时，若是 <code>#fe0302</code> 就需要找最靠近标准值的两个颜色，也即 <code>fe</code> 和 <code>02</code>，这时在同一颜色范围又该如何判断</p><ul><li>除了上面这种非常复杂的排序方案，我也考虑了一些简单的排序并在这里附上他们的效果图。测试图片由顾景提供</li></ul><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/colormaptest.jpg"><hr><p>按照先排 R，再排 G，最后排 B 的顺序</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/DF693CF0583BFD479E02771CC1BAE7BF.png"><hr><p>按照 <code>r1 &lt; r2 &amp;&amp; g1 &lt; g2 &amp;&amp; b1 &lt; b2</code> 排序</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/B91446BCDB5D9838F480D59B2150D234.png"><p>注意判断的顺序</p><hr><p>去掉了优先级排序中对于相同值的判断</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/F05A1ED7761CD4FA818F7B183D5C7E5B.png"><p>似乎影响不大，但是它将左边的蓝色大块打散消掉了</p><hr><p>单 R 值排序</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/34E667A4C8B86CCDE4DC9E481ED8BECD.png"><p>对于这张照片来说，单 R 和前一种效果最好</p><hr><p>单 G 值排序</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/42A62092F071E6872F888DCE704CC36A.png"><hr><p>单 B 值排序</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/4CBCB6A27BD6F540EDF726EF9EDE1642.png"><hr><p>以明度值排序也放在代码里，但是好像效果不是很好</p><hr><p>想要做到颜色的平滑过渡似乎并不容易，我更希望能通过改进第一种算法达到如下图的效果</p><img src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Screen Shot 2022-08-20 at 11.01.16.png"><p>代码放在了 <a href="https://github.com/Augists/imgColorMapGenerator">GitHub 仓库</a> 里，最后的实现效果虽然没有达到最预期，但是也是看了几种不同的实现效果</p><p>后续想要改进和实现第一种，可以加如对于聚类的一些思想。Reference 中的文章可以参考，我这里的排序都是在自己摸索规律</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://adrianlikins.com/2011/07/color-sorting/">color sorting</a></li><li><a href="https://github.com/alikins/sortpal.js/blob/master/sortpal.js">sortpal.js</a></li><li><a href="https://mathematica.stackexchange.com/questions/87588/how-to-sort-colors-properly">How to sort colors properly?</a></li><li><a href="http://www.alanzucconi.com/2015/09/30/colour-sorting/">The incredibly challenging task of sorting colours</a></li></ul>          </div>]]></content>
    
    <summary type="html">
    
      A simple tool for generating color map by given image
    
    </summary>
    
    
    
      <category term="GOLANG" scheme="https://augists.top/tags/GOLANG/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Review the THREE Years as an Undergraduator</title>
    <link href="https://augists.top/SELF/REVIEW/Review-the-THREE-years-as-an-undergraduator/"/>
    <id>https://augists.top/SELF/REVIEW/Review-the-THREE-years-as-an-undergraduator/</id>
    <published>2022-08-01T16:21:41.000Z</published>
    <updated>2022-10-11T16:43:05.865Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <blockquote><p>大三结束了，随着 5 月 29 日最后一门本科的考试英语草率收场，让我觉得突然我的大学就要结束了 :(。当时在寝室里收拾东西的时候还颇为感慨，大学本科四年，19 年入学半年后的 20 年寒假就遇上了疫情，学校开始居家、线上、封校，可惜了只过了半年的正常大学生活。相比于 20 级的惨在于，它像是让你见识了大城市的繁华，突然把你打回乡下。巨大的落差感让人对大学生活充满幻想，又不得不向现实低头<br>从进入大学之后，我便会每年在 12 月 31 日前回顾自己一年的收获和反思，并将它整理成一点文字。尽管我没有什么文笔，写的可能也只能代表一小部分，但是我仍然希望如果有人因为看到了我对于自己本科学习生活、社会工作、科研科创等方面的回顾和思考，对自己的目标或态度有所影响。希望它不管是对我自己的反思和回忆还是对看到我所写的回顾的你都有帮助</p></blockquote><h2 id="Self"><a href="#Self" class="headerlink" title="Self"></a>Self</h2><p>先简单自我介绍一下，详细的一些内容会在 review 部分里写。</p><div class="note danger">            <p>Augists，SSDUTer，网络工程系网络安全方向大四</p><ul><li>学委，常年教务对线，尤其是 2021 年小学期网络推荐课表全部被挤掉一事与学校沟通的代表</li><li>DV Studio 副部，一整个大二都在给学院和校区干活</li><li>校区心协理事部部长，办活动总指挥+苦力</li><li>网络与开源软件协会NAOSI会长，<a href="https://github.com/NAOSI-DLUT">详见</a></li></ul>          </div><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h3 id="大一上"><a href="#大一上" class="headerlink" title="大一上"></a>大一上</h3><p>对于大部分人来说，在进入大学前，可能都没有接触过编程，甚至很多人都没有接触过计算机。这一点在高中改为 3+3 模式后应该后明显的减少，但是在我们这一届，明显很多人都是被调剂到软院的。在大学入学前，我也是这里的大部分人：没有接触过编程，对电子设备的了解浮于表面，只会背背参数，听听别人说谁好<br>编程对我来说是一个完全没有接触过的领域（其实小学的时候看过一眼 VB，但是仅限于会添加一个 <code>print on click</code> 组件）。高考从一模的全青岛市100名左右到最后高考考砸，再加上被甩，对我的打击确实非常大，但是这也导致我在大一上期间试图让自己把所有精力放在我需要干的事情上，而不是坐在那里空想<br>高中说实话，我一直认为自己只学了一年多一点点。高二的6月份搬进高三楼的那一个月时间刷透了一整本物理的《龙门专题》之后，物理就基本不怎么需要学了。高中的前两年英语一直是班里的倒数，属于天天被英语老师揪到办公室骂的成员之一，也在我高三上刷完一整本《天利38套》英语卷之后就稳定在了135-140左右。数学这种学科更是从小就没需要学过，所以我的高中除了化学是因为特别喜欢老师所以一直有在学习之外，其他学科都只学了很短的时间，就打通关了<br>但是到了大学之后，作为一个高中学习《中等数学》的人来说，我可能没有遗传到家族里的《高等数学》。大学数学对我来说和前面的数学跨了一道很大的鸿沟，因为那种根本不需要学、题目看一看就自己全悟明白了的感觉一去不复返了（在这一点上，很对不起自己遗传的天分。在应该发挥能力的时候贪玩了<br>尽管我知道数学很难，但是我还是一如既往对它没有什么兴趣。所以我大一上的时间都花在了编程的入门上。我一直非常感谢能在大一上的编程入门选择软国院长樊鑫老师的双语C，课程使用C圣经《The C Programming Language》作为课本。一方面老师在课堂上会注意将所有的专业术语都用英语表述和强调，另一方面也会对于每一个例题现场用记事本进行编写和debug，讲透了每一个例子中的精妙的设计。因为对这些都没有接触过，其实最开始是基本没有完全自己编写代码的能力的。印象里大一上是每天去图书馆，对着xcode，捧着英文版的C圣经，一边读和标记不认识的单词，一边照着书上的示例代码敲。毕竟是C源码，书里的一些代码设计在当时看来特别妙，有的需要反复看才能明白为什么这么写更好，也有的会在老师点的那一下悟到。<br>一开始对着书上的示例代码“临摹”，也在一定程度上帮我确定了初期的代码规范，这在近些天看到新生问问题的时候给我看的代码时让我特别感概。我在最开始没有接触过formatter等的情况下就一直在模仿K&amp;R的缩进风格，并且对于代码设计的研究也让我自认为在大一的时候肉眼debug能力要强于绝大多数同学。印象比较深的是嘤嘤奇的链表错误，无法通过报错信息反推到具体的错误位置的时候，我直接眼看debug发现的if条件内判断顺序的问题<br>因为没有基础等因素，让我在大一上没有接触acm，这一直让我感觉非常遗憾，这也是让我非常耿耿于怀的一点。同样没有基础的高中同学，在neu和ouc都成为acm成员参与到比赛里拿牌子（甚至非cs/se专业），而在ssdut，很难。尽管如此，在大一上最后的新生赛（acm组面向新生的算法比赛）里，还是拿到了二等奖（我没记错的话，并且最后只有一等奖发了奖金:( ），并且在题解过程中我明确的知道后面我没有写出来的题目我有准确但是超出我能力范围的思路。不管怎么说，算法直到现在对我来说仍然是一个遗憾</p><p>除了专业学习，每当我返回头来看我的大一上，都会觉得是个奇迹。作为班级学委，邀请过学长和老师给大家讲过指针和导论、办过导师的科研方向讲座、在考试前组织英语和数学的模拟考试、在大一下疫情在家期间合办线上自习室等等，我班大一最后也成功拿到“优良学风班”。进入DV工作室，认真参与例会、完成作业，最后也作为拍摄参与了第一个微电影的制作。现在了解的多了，看过别人是怎么规划和度过大一生活之后，会觉得自己在专业上扩展的不够，只是最重要的是收获了用编程的思维去思考的能力（这个时候还不能说是用计算机的思维思考），然后把专业之外的时间贡献给了社会工作。可能以当代大学生的标准来看，我的大一上可能非常充实和精彩了，学习和工作都有个还不错的结果。但是以专业的角度来看，缺少了那一位能帮我指明方向和规划学习的学长<br>其实在入学不久后，我就进了wilna实验室，但是也仅限于每周去旁听例会的程度，一直没有勇气往前迈出下一步，科研。对于不确定的事情会自然的产生自卑感<br>最后，大一上的成绩排名在软院的20多名。在我对数学完全没有兴趣学习的前提下，这个结果也是合理的。我眼里的大一上可能就只剩下C和yjn老师每次上课先跑半小时的体育了（顺便，大一我班由于教务安排的问题，体育基本只能选乒乓球和足球的选课事故已在后来的督导会要求教务道歉</p><p>总的来说，在完全没有学长学姐指引的情况下，大一上整体还是充实着度过的。因为高中戒掉了游戏，空余时间都被我用更有意义的事情填满了。比较遗憾的只有在专业上没有更进一步深入</p><blockquote><p>题外话：大一上计算过自己的开销💰，在每个月保持着至少一次出去玩的前提下，我每个月的花销还是控制在了800r左右。从小对金钱的观念就非常保守，一直到大二才有非常大的改观。并且我一直不是固定生活费，我习惯没钱了再要，所以生活费周期不固定，但是肯定间隔都会超过一个月的时间</p></blockquote><h3 id="大一下"><a href="#大一下" class="headerlink" title="大一下"></a>大一下</h3><p>寒假，疫情爆发。也是这个寒假，我<a href="https://augists.top/SELF/REVIEW/Typing-Practice/">纠正了我十多年来错误的打字习惯</a>，先后购买了罗技k480（用了一个月就卖掉了，短键加上薄膜其实挺适合练习打字的，但是入门之后就不是很合适了）和ikbc poker（后来借“song”给了高中同学用，加上我自己改的陶瓷键帽</p><p><a href="https://augists.top/SELF/REVIEW/Typing-Practice/"><img src="https://i.loli.net/2020/07/31/hAmZS8tnREuj64l.png" alt=""></a></p><p>同样是这个寒假，我通过<a href="https://github.com/theniceboy">TheCW</a>接触到了Vim。作为远古编辑器，它仍然值得我花费一整个寒假甚至更长时间去学习，直到现在我也无法说我掌握了Vim。不同的模式切换和hjkl，让我认识到手指移动距离缩短的概念，也让我最后选择poker这款60配列的键盘作为我的主力，这个观念一直影响我到现在<br>有关于远古编辑器是否还有存在的价值，以及与现代IDE的比较，我可能还没有资格去下定结论。但是，编辑与编译的分离和接触CLI对我来说的意义要比学习和使用Vim本身对我更重要，我坚信CLI是每一个coder的必修课，当然这绝不只是因为它看起来更酷。让更多人接触到CLI也是我下一年NAOSI最希望能做成的一件事</p><p>大一下天天在家线上上课。众所周知，线上约等于没有，我得承认我大一下就是不怎么好好听课。每天起床挂上会议就学自己的去了。这也导致我工数2这么没用但是学分最高的课我只有79分，最后的成绩单里，在一群100、99、98的人中间，赫然有一个79分(●°u°●) 」，最终的大一全年成绩排名降到了60多名（成绩这些东西我不怎么关注，所以可能会有记错的地方<br>那每天不上课在干啥呢？折腾Terminal。从Vim开始，我对CLI的热爱和执着就有点一发不可收拾。自学的坏处就是，当你没有一个明确的方向或规划时，就会做很多无用功，转化率也很低。但是好在，搭建了博客，开始用云服务器 and so on，因为本科生没有什么复杂的东西，所以姑且就说是向运维发展了吧，不知不觉间给后面能参与到项目里打基础</p><p>小学期似乎也是在家线上做的，那个时候我应该还沉浸在各种奇怪的知识里。不过课程设计是我第一次开始试图做一个完整的项目。因为大一期间一直选的是双语课，C/C++的项目大作业我最多只是辅助班里的同学，并没有我认为的实际参与进去。作为第一个GUI程序，我一开始想要写保卫萝卜，但是那个时候就觉得，所有人物、子弹都应该是同时进行，所以我理所当然的引入了我并没有学过的多线程编程，并且不出意外的在变量的共享上遇到了当时无法跨过去的问题。最后是学了一个GitHub上的2048，并且还第一次知道设计模式（因为人家用了，所以我也搬进去了）。尽管没有能完全自己实现一个项目，但是这个过程对我来说还是非常有意思的</p><h3 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h3><p>软件学院在进入大二之后的某个时间点，会进行专业分流，分为软件工程和网络工程，软件工程下设软件开发与测试、大数据、软件与金融、嵌入式（智能系统控制系）、水下机器人方向，网络工程下也分网络安全和物联网两个方向。实际上，不管是软工，网络工程，还是软国，只有在本科生阶段才有区分，不同的方向区分其实也没有那么夸张，只在几个专业选修课会有不一样。但是两个专业的人数、学习难度、课程分配等方面都会有很大区别，从我的角度看，肯定更推荐网络工程，但是我也希望你是真的喜欢网络等相关的才这么选择，整体上来说，选择什么专业根据兴趣来即可。<br>我们应该是在大二入学后的11月（忘记了）进行专业分流，我也完全没有犹豫就选择了网络工程系的网络安全，回忆起来，理由大概有以下几个：</p><ol><li>我不喜欢随大流。网络工程系只有100余人，我们这届最后只有119人。相比较去人最多的软测或是排名靠前基本都会选的当前大热的大数据，我更喜欢找一个人少的地方做我更感兴趣的东西，即便它不那么火</li><li>在大一下期间，我接触的很多是和服务器等相关的，从名称上来看，相比与软件，我对网络的兴趣更大</li><li>大一结束之后的某个假期，我托我妈同事带我去她们的信息部门玩了一下午，和一位外派进的做安全的哥哥聊了很久的天。虽然时间不长，不能说有多么深入，但是也让我对安全相关有了一些了解</li><li>正好是选课之前，codesheep 做了一期有关大数据的学习路线图。相比于其他方向，从我对大数据工程师的理解上来看，它的要求非常低，学起来也不会很难，没有必要把这种内容放在课内进行学习，而网安的课程看起来更有意思</li></ol><p>总之，最后就选了网路工程系，由于软件和网络分开排名，最终在网络排第五（忘了，也可能是第四</p><p>大二一年我感觉就没那么多好说的，我每天就是早上起来就去工作室，一直呆到晚上教学楼关门。几乎每天都会有大大小小的活找上来，可能是同学、部门、学院、校区。忙完迎新的一个月，dv出去大聚了一次，一晚上断断续续喝了4瓶多就被拦住了。瞧了所有大物和一部分数据结构啥的课，给工作室干活。由于正好各种事情都撞一年了，再加上隔壁软国没人、记者团翻脸等等多种因素，导致我们这一年的工作量非常离谱，挤占了非常多学习时间（换句话说，大二因为工作室的原因，没怎么学习），期末考试前的倒数第二周每天晚上都留在教学楼做图到凌晨，不到一个周时间带着10个干事出了不下100张图。不过我也因此接触了一些电脑硬件，经常给工作室的台式机清灰、换件，组环绕屏，装NAS，给工作室升级了一整套网络设备，跑测速跑出了 900Mbps（孩子见识少），还包括搭建了工作室的 ipv6 代理服务器等等。</p><p>大二重要的课不是那么多，但是考试并不很好。我当时觉得自己机组学的还不错，结果分就很低（顺带一提，我机组实验是全年级最高分）。这种情况还是挺多的，像是数据库、计网、OS这种，我在平时折腾的时候都已经积累了很多经验了，无论是在课堂理解上还是动手实践上，都要强过别人很多，但是他们三个我好像都只拿了90。大三的网综实验（可以理解为计网实验），每节课我组都早早做完，被一群人围着学（抄），出分后发现还不如后八周上课的同学（因为疫情等原因，后八周上课确实非常曲折，大三上的课一直拖到大三结束才弄完，所以合理怀疑给他们了主观额外加分<br>学习就说到这里，大二因为不怎么学习，加上我认为我能力很强的专业课都没有拿到高分，相当于摆烂了一整年，结果在网络排 15 名，大家这一年都在摆烂。最终前两年总成绩排在第 9（所有和成绩分数、排名等相关的东西我只能努力回忆，不能保证没有偏差，放出来是我觉得可以作为参考，我不怎么记得住这些东西</p><p>比较值得提及的是在科创方面。我觉得是比较幸运，遇上了合得来又很好的人。我们在大二下的4月底开始了DUTyard论坛项目，最开始站长其实是从淘宝买服务开始，到我们一点一点找项目搭建。一开始还搭建在我的树莓派上，挂载了一个硬盘盒和一块机械硬盘，晚上蹲在它旁边，论坛服务炸了就物理重启。晚上经常去找 mega 一块给论坛加各种插件。最终论坛在我还在维护的那半年成绩还算不错，注册了上千名用户，一共有7000多条讨论，并且还做了资料库，引入了课程评价等。这个项目也被我们用于参加了“互联网+”的普通赛道和企业赛道，并且在与华为高管的沟通交流中，很受赞赏（因为学校延迟同步的比赛通知，导致我们在省赛阶段错过了提交材料的时间，最后只拿到了省银，但我记得在与华为沟通的时候，对方已经明确说我们的项目有很大希望能拿到国金了，可惜尽管是企业赛道，评委会并不是企业，这件事对我们的打击还挺大的<br>通过DUTyard平台，也让大连的其他学校开始有人找我们做项目、打比赛。与经管的合作情况比较离谱，所以只拿了省铜，倒也无所谓了。和主校区的合作就比较让人大跌眼镜了，我们的项目和策划书等内容在已经提交并且不知情的情况下，被主校区经管、人文的某些同学重复提交，并且将奖颁给了他们，而他们是通过提出想要与我们在DUTyard的基础上进行新的合作连理知论坛的前提下拿到了我们DUTyard的项目。最终双方不欢而散，他们也用我们嘉禾连理的名字注册了公司（并且公司与我们无瓜，企查查可查），这件事被老师和书记压下去了，我这里只陈述事实不做评价</p><p>大二的小学期期间还去华晨宝马的沈阳工厂去打了个 Hackathon 的比赛，三天两夜的时间，题目我们做的是和零件运输和装车相关的。只记得玩的很开心，宝马的伙食也很好，每天晚上食堂给我们开自助（每天都能吃撑），中午虽然不能去西餐区打饭，但是几个中餐岛的饭都很好吃！（我直接恨不得住进食堂）。虽然吃饭也都算是比赛时间里，3天的时间自己规划和利用，但是这么好吃的饭(●°u°●)」（有点没出息）。我一开始做的有关python转换读取以及一些💡，想要用数据库的方法对数据直接进行处理，但是其他几个人的电脑都没有搭建好数据库环境，在第一天的尝试里把这个方案放弃了。于是就是，讨论算法，嘤嘤奇用c++实现，学长和我们把它转换成python以及做一些数据的读取和写入等，但是大家在第一天都比较放松。去打比赛的队伍里，我和嘤嘤奇一起报，正好遇上认识的本校学长，在主办方的协调下，我们最终五个人组成了Scream队，是唯一一个本科生组成的队伍。其他队伍还有清华、浙大、美国高校的学长，就导致我们从一开始就冲着成功参赛、快乐为主的想法了，甚至第一天还忙里偷闲去玩了会垫球，赢了手提包和圆珠笔。第一天吃完饭我回帐篷（对，宝马给每个人都发了一个帐篷，可以在他们会议室或者大厅搭起来睡觉）躺了一会因为放松直接睡着了，队友也没有管我，一直睡到8点猛然惊醒发现忘了是在比赛了。<br>第二天就比较紧张，因为我们发现题目比想象的还要难，比赛一共有三个方向的题目，选择我们那个题目的没有一个队伍将结果实现出来。我在第二天提出仿Tetris的装车优化方案，但是由于大家都无法得出比较好的结果，装车就只是由我和学长进行模拟并以动画的形式演示，它对于题目实现本身优化不会有运输问题的提升大。我们组在多次（多到评委都觉得挺烦的）和宝马的工程师们沟通交流后，成为了第一个通过 judgement 的组，并且在持续优化后得到了比评委之前所得到的结果更优的零件运输方案。无论是Tetris模拟还是我们对问题探索的精神，都得到了来自德国总部的工程师的肯定和赞赏，也是这些让他们在最后决定将冠军颁给我们（应该说弯道超车，我们和thu佬不是同一个题目，他们在他们的题目上做的非常出色，并且人家全英文答辩）。第二天晚上，我们组除了一轮答辩的汇报成员，都通宵了。我记得我们得到比评委的结果更优的方案已经是凌晨1点了，再加上做一轮的答辩汇报方案等，最后我又提前做了二轮答辩的方案。你见过凌晨四五点的沈阳嘛，我见过。那种忙碌两天两夜得到了最后的最优结果的感觉，几个人早上一起从会场出来，在宝马的园区里看太阳升起的感觉</p><h3 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h3><p>大三转去心协做理事部部长，说实话前两年在dv我就认不全人，大聚一下七八十个人，然后来了心协发现好家伙，也70个人，还因为叫人家粉帽子被嘲笑了，我自己部门也二十多个人，到最后也没认全了(●°u°●)」在心协的任务就是筹备和举办活动，但是只能说天时地利人和不能全要，二百多人参加的桌游活动因为操场的大风，剧本杀组被迫搬到了食堂进行。大三下的关心杯因为反复的疫情一直没法线下办，最后我一个人剪完了一整场关心杯改成了线上直播，也算是疫情妥协下能有个比较圆满的结局了。相比之下我们想的很多其他的活动就没有那么幸运了，有的因为疫情或是时间等原因被拖到无法举办。心协的海烧也没有办法出校门。</p><p>课程方面倒也没什么，网络的课程都集中在了前两年，大三只剩下一堆专业选修课还都是交大作业。我自认为我在几门例如病毒学、系统安全、网络协议栈、无线网络安全等课程学的还不错，病毒学做了一个Docker本地提权的实验和Dirty CoW病毒的实验，工作量非常大还很难实现，因为我所选择的题目比较难做，和孙伟峰老师也沟通请教了很多次，最后也整理成<a href="https://augists.top/SELF/SHARING/STUDY/Get-Root-Privilege-in-Linux-by-Docker-or-Dirty-COW/">文档</a>放在了我的博客里。仅Preference就有26个，那一个月的时间投入了非常大的精力在这个课题上。网络协议栈里我也把整个协议的源码做了解析，最终生成的报告就有100页左右。最感兴趣的应该是姚琳老师的无线网络安全课里所介绍的位置隐私，我在课程里提出的有关解决位置隐私的想法，虽然说的比较空，但是我自认为是在认真思考之后形成的。</p><p>在这一年我也接触到了游戏主机，这也算是对我影响比较大的一个事情。我在高中把游戏戒掉之后，发现能给我省出来非常多的空余时间。并且本身因为自己很菜，对游戏就没有很上瘾。大三之后不管是借的PS5、Switch还是后来自己买了Xbox、Switch，都是我对新鲜事物第一次接触。大三下又接触到番剧，在比较短的时间里看了不少动漫。大三的时间对我来说，一直都在接触新的东西，包括正经的做科研、转了Golang，去公司实习了一个月。相对放松的生活、没有那么大的学习压力之后，我好像把很多时间放在了见世面上，很多都是以前不想、甚至不敢去尝试的领域，借着大三这段时间去深入的了解了。我相信对于任何一个领域的判断都应该建立在一定的深入了解上，也是这个原因让我在寻找研究生方向时最先pass掉了ai相关。有关保研的我之前以为过了928就可以比较畅快的写了，但是直到现在我也不清楚自己该如何下笔，不过可以看我组织的NAOSI保研wo谈会</p><p>2021 年到 2022 年也是一定程度上实现了财富自由，上半年花压岁钱，下半年花自己挣的，从心理上花自己的钱不用问爸妈要还是很舒服。由于我的生活支出比较小，💰基本都花在了购买大件上。HHKB键盘总共花了2.7k，给家里添了把人体工学椅用了1.5k，买Xbox再加个额外手柄和购买西瓜皮以及游戏总共是3k左右，还和同学一起买了Switch和游戏又要小2k，显示器加上支架是1.6k等等，还有一些便宜一点的以及给工作室买了一个落地扇。总共算下来这一年不到的时间挣了有2w不止，可惜自己拿钱多了就败家，现在还想着要组台台式机（梦碎了，已经麻了</p><blockquote><p>这篇 Review 断断续续写了好久，有的时候想写但是又不敢写，导致这个文件从8月2号就创建开始编辑，一直到现在10月12号了，勉强把前面补完，还留了保研不想写<br>今天受到的打击比较大，连着摆了好几天了，总归不太合适，就回来把这篇 Review 补完了。整个人精神状态都很差，心里难受加上愤怒，让这篇博客草率收尾<br>希望看到的人能受得了我的流水账，从中获得一点对自己有用的东西或者能了解一个默默付出了三年多却不怎么收到回报的人的唠叨<br>不知道年底还有没有心情写今年的回顾，可能那个时候会愿意回过头来看看自己吧。活了二十多年了，锻炼的也不少，但是心态仍然是影响我的最大的一个因素。我从没质疑过自己的能力，也相信自己比别人更强，但是内心过于自闭的感性也让我有时候无法处理好我所遇到的事情<br>但是不管有什么心态的变化，我永远相信 Tech. 是我乃至社会最重要的部分，追求技术的心是不会变的，这也是我坚持到现在，无论遇到几次低谷，不管多慢我都能爬上来的精神支柱</p></blockquote><h2 id="发展路线规划"><a href="#发展路线规划" class="headerlink" title="发展路线规划"></a>发展路线规划</h2><div class="note danger">            <p>我也不觉得成绩和奖学金能代表一个人的能力，对我自己来说也一直没有看重成绩，对于一些别的方面也是后来才知道的</p><p>我所总结的合适的本科发展路线是：</p><ul><li>大一入学后的第一学期是打基础，转换思维的，可以做的是<ul><li>C Programming Language 学透，圣经，里面所有的代码都是源码级的，很多地方必须亲手试一下才能明白为什么这么写更好</li><li>科普性质的 计算机基础、计算机网络、操作系统等，可以参考《图解》系列和《网络是怎样连接的》系列</li><li>基础的数据结构，了解程度超过顺序表（课程内会接触到链表），能学到简单的树和图的存储最好</li><li>简单接触 Linux，有能力进行安装和简单的使用</li></ul></li><li>大一下第一次选择一个特定的方向进行尝试，可以做<ul><li>选择一个更细的方向并尝试学习到能用来参与项目的程度，一些方向举例<ul><li>java 基础和一些框架的开发使用</li><li>web 后端，可以基于 java、Go、Python 学习语言基础和 web 框架</li><li>深度学习，学习 python 基础和深度学习课程，如李宏毅、李沐、吴恩达等老师，准备参与科研</li><li>前端，学完 HTML、CSS 后开始看如 vue、react 等框架，能配合 node 做完整的应用（开发区比较缺前端，可能能更容易的参与到项目中）</li><li>移动端开发，如 iOS 开发需要学 Swift，安卓开发看 java 和 kotlin 等，了解一些移动端的设计思路</li><li>服务器运维，相对比较简单，多折腾和搭建，对参与项目和后续的课程都有一些帮助</li><li>网络安全，下也有很多细分，可以参加 CTF</li><li>一些方向开发区并没有充足的资源，例如计算机体系结构、分布式系统等。在读研选择方向时并不占优势</li></ul></li><li>也可以加入实验室，学习实验室的研究方向，如王雷老师的 wilna 实验室做无线感知。也有的实验室会给新人安排学习任务和对应的学长学姐进行指导</li><li>跟随 C++ 课程学习 OOP 思想</li><li>根据自己感兴趣的方向决定数学的重心，如做深度学习可以多关注线代、做密码学需要在离散上多下功夫</li><li>听闻课改后大一下的课程变得繁忙了，所以目标比较少，主要在于尝试一个细分方向</li></ul></li><li>大一小学期如果不前往东软实习的话，就会比较水<ul><li>C++ 深入 STL，这对于后面的保研等需要做算法题的时候会有很大帮助</li><li>QT/MFC 是第一次课程内抛弃黑窗，去做一个 GUI 的应用。了解 QT 的消息通道思想，对大部分人来说这个没有用处</li><li>前端作业，很水，对于不想做前后端的来说了解前端的代码模式就可以</li><li>大一小学期开始，可以做第二次细分方向的尝试。由于大二的课程比较多，所以从小学期一直到大二结束都作为这次尝试的时间段。需要注意的是，在大二结束的时候一般来说自己大概要做什么方向就或多或少有一个比较明确的定位了</li><li>多关注一些比赛，项目类的如“互联网+”、挑战杯，竞赛类的可能更多一些</li></ul></li><li>软院把大二的课程安排的非常繁琐，尽管核心专业课很多，但是注水课也非常多，需要尽早甄别<ul><li>在有了大一的成绩排名之后，就能大概预估出自己是否要往保研上走了。如果成绩比较好，可以考虑分一些精力出来，加入到实验室里。软院本科生科研的氛围不算很好，但是每年还是会有很多本科生参与发论文。有一定的科研经历，甚至能有论文作为佐证对于保研的时候来说帮助非常明显，我的巨佬同学本科到现在都已经有三篇论文了</li><li>大二的专业核心课比较多，但是课内涉及的不够深入，并且考试比较迷，还是应该自己向外拓展和实践。比如计算机网络可以多去看看自己家的路由器，做一些网络设备；操作系统在 Linux 接触的时候也会有一定的了解</li><li>大二全年的课程代码量都很小，除了数据结构会写一点模拟之外基本就不怎么敲了。所以一定要通过项目或算法题来让自己持续敲代码的状态</li><li>大二上大概在 11 月左右会继续细分专业，从 20 级开始只分软件工程系和网络工程系了，但是课程主体并没有修改，所以可以参考之前的细分专业：<ul><li>软件工程：智能系统控制（嵌入式）、软件测试与开发、大数据、软件金融、水下机器人</li><li>网络工程：网络安全、物联网（共约 120 人）<br>课改之后，只区分软件工程和网络工程，细分专业的课程只要在自己系内都可以选修。以课改前我们的经验，网络相较于软件会在大二课更多更忙，但是大三网络只有选修课，并且很多注水，就显得网络系大三都没啥事。就努力程度和保研难度来说，网络会更好一些，但是相对的是自己放弃了纯软件工程的 title，做网安对于想要出国的同学来说也会稍微麻烦一点，顾忌更多<br>就我所在的网络工程-网络安全为例来说，课程设计并不合理。有关 CTF 的网络攻防实践被安排在了大三下学期，而此时对于本科阶段想要入门 CTF 来说已经很晚了</li></ul></li><li>大二下开始有细分专业后的专业选修课，但是作为分完专业的第一个学期，专业课必然是注水的，其目的更多的是在让大家了解一些细化的研究方向，多数课程名字里也会带上“导论”。这些课很多人都不会认真听，也带着有些老师会不愿意讲课。除了摆烂的时候，我会在课程开始的时候多听一听，对这个方向有一个大概的初步了解，可能并不深入，但是会有一个第一反应来决定我是否对它感兴趣，这会成为我后面对课程内容关注程度的一个重要参考。一定不要所有选修课都水过去，会让自己感觉分专业毫无用处，学不到东西</li><li>一些课程如大数据导论、以及大三的软件工程课都会有翻转课堂，积极参加和准备，不管准备到什么程度，在将一个新内容尝试学习并转化成内容输出的过程中会学到很多东西</li></ul></li><li>大二小学期是一个比较特殊的时间点<ul><li>这个小学期之前只开设 java 课程，现在加了 python 可以二选一。课程比较简单，但是对于前面上双语课的同学来说可能是第一次团队合作开发项目，最好可以尝试一些团队管理的方案，这个时间点不管是课内还是课外都已经接触了很多工具了，就不要再用 QQ 互相之间发代码文件，可以开始学着用 Git 做团队项目的管理，去处理冲突，把自己放在真实的工程的角度去考虑开发这件事</li><li>大二的暑假前后是参与比赛比较多的一个时期，我个人的很多比赛和奖都是在这段时间拿的。可以多关注和参与，不一定只看学院目前认可的，多抓住机会出去看看，和别的学校的团队交流，有很多比赛学院老师也不知道呢</li><li>能力强的同学可以在大二就参与春招了，然后在这个小学期的时间去公司实习。即便最终没有拿到实习 offer 也无所谓，大二有能力去实习的人不多，但是能有机会提前参与企业的笔试面试，可以帮自己在下一年确定需要补的方面</li><li>对于已经确定要工作的同学，可以考虑在大二小学期提前选修大三小学期的课程。如果有时间冲突可以找教务处理课程冲突，这样大三小学期就有一个完整的暑假时间来进行企业的实习。对于保研的同学来说有实习经历并不一定是好事，对学校的老师来说，更希望自己的学生能读到博士，有更多时间来深入的进行科研学习，而不是早早的就确定要工作</li><li>大二结束后，每个人的意向就应该明确了。保研、考研、工作、出国、考公，这是每个人都绕不开的问题，如果一直到了大三中间都还在犹豫，那很可能哪边都做不好</li></ul></li><li>由于课程设置的原因，大三会有大把的时间交给自己来支配<ul><li>大三的最核心的课程可能就是软件工程，但是对于很多人来说，它的意义主要体现在考研本院的时候考试的范围</li><li>这时候的专业选修课基本摆脱了“导论”性质，一些课程就比较有意思了，不论对这个方向感不感兴趣都可以做深入了解。先把面打开，再从里面找自己最想做的点。并且对于要读研选方向的同学来说，可能很多方向都或多或少在专业选修里接触过一点</li><li>网综实验其实就是计算机网络实验，这是比机组实验专业贴合度更高的实验课，也是软院唯二的两门专业实验课之一。学完记得想想自己家的网络拓扑，增添点新设备</li><li>大三课程多为大作业形式，尤其是网络系。有空余时间多去准备一些东西<ul><li>工作：常规来说春招是金三银四，三月是投简历的高峰期，但是不代表 1 月 2 月就没有机会拿到 offer。如果想要找工作，最好从 1 月就开始陆续投递简历，趁寒假再补充补充项目经历、算法能力和八股。22 年的情况表明，金三银四的规律可能已经不再那么明显了，很多公司开始泡池子，拖发 offer 等。但是，大环境不好不代表有能力的人找不到实习，适当降低要求和不要纠结互联网厂是很多人的出路</li><li>考研：我周围准备考研的同学大多在寒假回家左右开始准备，舍友回家带了一个大箱子的张宇数学。也有一些同学在大三下返校后开始学习考研的内容。需要注意想报考的学校的考试内容，之前也出现过快要考研了学校突然修改考试科目的情况。就算要考本校这种只考软件工程的，也要准备一些 408 内容</li><li>保研：算法题需要尽早开始刷，不要像我一样很畏惧，觉得自己什么都不会不敢做。保研同样注重专业课，一些学校如中科大，面试会以专业课为重心进行提问，对你的其他方面反而关注较少。不过总体来说，rank &gt;= 科研经历 &gt; 科创竞赛 = 项目经历 &gt; 社会工作经历</li><li>出国：就当前国际形势来说出国可能并不是最优选，但是无疑本科毕业这个时间点是出国比较好的时候，国外找工作的话短期的硕士是非常不错的选择。出国要求在 rank 不低的情况下尽量多去兼顾科研、实习和志愿活动，也可以考虑像 kzm 类似的交换项目并在结束后申请当地的硕士，门槛会低一些</li></ul></li></ul></li></ul><p>如果不那么看重成绩排名，建议能选出对自己重要的课程，把重心放在它们上。明确有些如高等数学、大学物理等课程是普适的教育，可以减少在它们上花费的精力（但不是不学<br>软院本科四年的核心专业课是：C、C++、数据结构、计算机组成原理、计算机网络、操作系统、数据库，以及你希望深入学习的方向专业选修课。如果你想继续在这个专业走下去，这些课程都非常重要，一定不能仅限于课内的那点东西<br>专业书籍参考大黑书系列和动物系列，其中大黑书大部分都可以闭眼买了看，都为学术巨著，有很大的参考性和权威性；动物系列是书籍封面有一个代表性的动物，多为一些编程语言和框架的研究</p><p>学院对某些竞赛非常看重，甚至对于某些过于看重，出现了明显的德才不配位的情况。如果你对自己有信心，可以去学习 acm 算法，不过参考 cyq 佬，如果你想拿到一个比较好的成绩，可能需要一定程度上对课内的内容进行取舍甚至放弃。不过对应的，acm 的含金量还是非常高的，不管对于你其他的学习还是工作、保研都有很大帮助（尽管也出现过小公司 HR 说他们不喜欢 acm 选手的情况）。比较可惜的是，开发区的 acm 整体氛围并不好，对于没有 NOI 基础的同学来说很不友好，据我观察，在别的学校是不存在这种情况的，我在东北大学和中国海洋大学的同学都在 acm 铜牌以上，他们在入学前也没有基础<br>数模比赛在我眼里是一个非常水、门槛低、但是在学校眼里含金量很高的比赛大类，如果你能坚持把全年的数模打完，基本上科创奖学金就没跑了。在和同学的交流中，我的结论是，数模 10 个人中可能有 9 个并没有相应的水平，它的奖对于大部分来说，只是个奖，并不代表你学到了它的思想或是怎样，这也就意味着，对于和我有同样想法的 HR 或者老师来说，如果有一个数模选手和一个软件设计类比赛选手放在一起，我会选择第二个，因为数模这个有很大可能不是有水平。同时，它门槛低到不管你是否了解它，都可以随便报名参加。我在本科期间直接参加了两次数模，组队的成员均为从来不打数模比赛、对相关知识并不了解的同学，我们每次都从零开始，拿到一个国三和一个美赛 H 奖，过后反过来看也只是累了三天而已，并没有什么收获。可能对于大佬来说这两个奖啥也不算，我也并没有看不起数模大佬，但是在这个类别中水分很大，真正有能力的比较少，导致我并不喜欢数模。我的建议是，如果你能找到大佬带，就一定要去参加学习一下，但是如果不是必须要科创奖学金，这三天甚至它的附加时间，我建议不如去参与到一个开源项目中，对你带来的收获可能更大。可以参加，但最好不要在这上面花费很多精力<br>还有创新创业类比赛，也可以积极参加，但是我作为一个参与比较多这类的过来人的感觉是，它更像是一个 PPT 和关系比赛。没有一个“优秀”的指导老师、没有唬人的 PPT，你的项目很难在这条路上走得远，即便走出去一片光明，身处开发区的不利地理位置也可能让你止步。可以提供一个比较有意思的思路，创新创业类比赛对参赛团队成员的学校和专业都没有限制，可以挂靠和参与到别的学校的团队中，每年这类比赛开始后都会有一些相对较低的高校的经管之类专业的同学来寻找组队，并且大创类比赛的项目门槛较低，很多东西都靠吹，不一定真的要做实现，其他高校的竞争压力会小非常多</p><h2 id="推荐课程列表"><a href="#推荐课程列表" class="headerlink" title="推荐课程列表"></a>推荐课程列表</h2><ul><li><a href="https://b23.tv/WNRydPs">计算机科学速成课</a>，虽然叫速成课，但是对于计算机的基础学习非常全面，按照一层层抽象讲也能让你对计算机体系有一个宏观的认识</li><li><a href="https://www.bilibili.com/video/BV19W411B7w1">C语言程序设计-浙大翁恺</a>，对入门 C 语言来说，翁恺老师的课是最能讲到思想的，配合 <em>C Programming Language</em> 这本圣经一起看帮助非常大</li><li><a href="https://www.bilibili.com/video/BV1dE41167hJ">C++语言程序设计-浙大翁恺</a>，同一个老师，C++ 相对来说不如他的 C 语言课程，但是仍然是非常好的课程</li><li><a href="https://www.bilibili.com/video/BV1rJ411U7EC">计算机组成原理-南大袁春风</a>，朋友推荐，大二的课程南大应该做的相对更好一些</li><li><a href="https://www.bilibili.com/video/BV1Cm4y1d7Ur">操作系统：设计与实现-南大蒋炎岩</a>，这课一开始看真的很震撼，后来发现主体依照 CSAPP，但是老师的一些思想和操作都很亮眼，男神级人物，有幸借面试机会和蒋老师聊天，完完全全被碾压</li><li><a href="https://www.bilibili.com/video/BV16Z4y1U7oU">线性代数-MIT</a>，MIT 的神仙课程，光这个课程就已经翻录过了，老师把线代从设计思想上讲活了。尽管和课内的思路不同，但是非常推荐学习，我也做了这门课程的笔记</li><li><a href="https://www.bilibili.com/video/BV1x7411H7wa">The Missing Semester of Your CS Education</a>，MIT 的神仙课程，补足一些你在课内不会有机会学习的东西，重点在了解和引起兴趣，非常优秀的课程，博客内也有以前看这门课的笔记</li><li><a href="https://www.bilibili.com/video/BV1hp4y1C7Zm">玩转 Linux 命令行</a>，花花自己制作的课程，对于稍微接触了一点命令行的同学来说会收获很大</li></ul>          </div>          </div>]]></content>
    
    <summary type="html">
    
      Recommand schedule for CS learning
    
    </summary>
    
    
    
      <category term="REVIEW" scheme="https://augists.top/tags/REVIEW/"/>
    
  </entry>
  
  <entry>
    <title>Knowledge Collection UP and Their Videos</title>
    <link href="https://augists.top/SELF/THINKING/knowledge-collection-UP-and-their-videos/"/>
    <id>https://augists.top/SELF/THINKING/knowledge-collection-UP-and-their-videos/</id>
    <published>2022-08-01T04:48:51.000Z</published>
    <updated>2022-08-01T05:32:25.993Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>今天中午我爸在看某“知识”区视频，大体在讲温室效应。听着听着我就感觉不对，他前后的逻辑关系根本没有很强的对应，各种说话的方式更像是一个“知识整合”区的“文科生”<br>事实上，现在这种只是在做知识整合的视频博主越来越多，包括我自己也有关注这种类型的 UP</p><hr><p>首先，我对于“知识整合”区的“文科生”的定义是</p><blockquote><p>在一个非自己本职或本研究方向的领域，通过网上搜集到的资料进行整合，并输出成视频传播给观众</p></blockquote><p>基于这个定义，例如 毕导、X.PIN 等人都会被我归为这一类分区。整体上他们都还是在做与自己方向有一定相关性的方向的知识整合输出<br>当然，也会有一些“什锦知识整合”区的“文科生”，对于任何一个方向的知识都敢直接查完整合就输出，上文中我爸看的有可能就是这种<br>对于“什锦知识整合”的人，一般就可以直接不看了。你在他的输出中能获得的东西并不一定比你自己了解的多，并且他们所提及的方向大多是追赶网络热度或是仿佛与普通人相关或更吸引眼球的<br>我关注的如 毕导、X.PIN 这种大多与他们自己的专业方向有一定相关性（X.PIN 我不是所有内容都看<br>而类似毕导这种，在偏娱乐向的同时，有科研训练为基础，对于新方向的学习深度也会比普通人更深</p><hr><p>前几天偶然和人聊起高中的语文演讲，感觉那时候的我就是“知识整合”区甚至“什锦知识整合”区，对于一个不一定是否有足够相关性的方向了解一些内容，就敢拿出来给全班讲<br>现在回想起高中讲的人工智能，只会感叹年轻真好，觉得自己懂一点就敢冲上去。但是这种“知识整合”真正留给自己的有用的又有多少呢？对于这些“知识整合”区的人来说，一个新方向的知识经过整合沉淀后的积累与它所带来的流量相比，哪个才是他们更想要的呢？</p>          </div>]]></content>
    
    <summary type="html">
    
      &quot;知识整合区&quot;和&quot;什锦知识整合区&quot;的&quot;文科生&quot;
    
    </summary>
    
    
    
      <category term="THINKING" scheme="https://augists.top/tags/THINKING/"/>
    
  </entry>
  
  <entry>
    <title>Preparation for Your Undergraduate Life in DUT-EDA</title>
    <link href="https://augists.top/SELF/SHARING/LIFE/Tips-of-DUT-EDA/"/>
    <id>https://augists.top/SELF/SHARING/LIFE/Tips-of-DUT-EDA/</id>
    <published>2022-07-22T16:21:55.000Z</published>
    <updated>2022-07-25T15:39:21.395Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <h1 id="嘉禾连理-大工人最大的非官方论坛dutyard-com"><a href="#嘉禾连理-大工人最大的非官方论坛dutyard-com" class="headerlink" title="嘉禾连理 大工人最大的非官方论坛dutyard.com"></a>嘉禾连理 大工人最大的非官方论坛dutyard.com</h1><p>欢迎萌新们来到大连理工大学开发区校区！本文详细描述了校园生活的详细细节, 仅代表往届经验，希望对新生们有所帮助~</p><p>本文共1w字，阅读需约30分钟，使用目录阅读效果更佳！</p><p>小技巧：用电脑浏览器打开，ctrl+F可以打开查找功能，搜索关键词；手机浏览器一般也带有搜索功能~</p><p><strong>本文为学长学姐自行撰写 , 仅代表往届经验,不一定适合22级 ,与校方无关，如有错误之处欢迎指正。</strong></p><p><strong>本文为学长学姐自行撰写 , 仅代表往届经验,不一定适合22级 ,与校方无关，如有错误之处欢迎指正。</strong></p><p><strong>本文为学长学姐自行撰写 , 仅代表往届经验,不一定适合22级 ,与校方无关，如有错误之处欢迎指正。</strong></p><p><strong>本文为学长学姐自行撰写 , 仅代表往届经验,不一定适合22级 ,与校方无关，如有错误之处欢迎指正。</strong></p><p><strong>本文为学长学姐自行撰写 , 仅代表往届经验,不一定适合22级 ,与校方无关，如有错误之处欢迎指正。</strong></p><p><strong>本文为学长学姐自行撰写 , 仅代表往届经验,不一定适合22级 ,与校方无关，如有错误之处欢迎指正。</strong></p><p><strong>本指南仅为经验之谈 存在纰漏 具体以22级培养方案 招办 学办 学校通知为准</strong></p><p><strong>本指南仅为经验之谈 存在纰漏 具体以22级培养方案 招办 学办 学校通知为准</strong></p><p><strong>本指南仅为经验之谈 存在纰漏 具体以22级培养方案 招办 学办 学校通知为准</strong></p><p>​                                                                                                                                            <strong>鸣谢长安学姐的帮助</strong></p><p>[TOC]</p><h2 id="1基础介绍"><a href="#1基础介绍" class="headerlink" title="1基础介绍"></a>1基础介绍</h2><h3 id="1-1生活费"><a href="#1-1生活费" class="headerlink" title="1.1生活费"></a>1.1生活费</h3><p>身边大部分同学生活费在1500-2000元左右,不需要携带现金</p><p>如果家庭困难的话,大工有很多奖学金和助学金,国家还有接近无息的助学贷款,完全不需要发愁,录取通知书里面有绿色通道的一封信,开学学校也会安排同学私下收集情况,还可以了解下勤工俭学和家教等项目,所以只需要好好学习就可以了</p><h3 id="1-2校园卡"><a href="#1-2校园卡" class="headerlink" title="1.2校园卡"></a>1.2校园卡</h3><p>我们的校园卡为玉兰卡,用于校园支付,寝室门开门,也可以当地铁公交卡,考试时候需要携带验证身份,丢失了可以去邮局或食堂二楼自助机器补办，宿舍门禁功能需要邮局刷入。注意玉兰卡与公交卡（大连明珠卡）需要分开充值，市内交通支持全国一卡通</p><h3 id="1-3-i大工"><a href="#1-3-i大工" class="headerlink" title="1.3 i大工"></a>1.3 i大工</h3><p>校园app,各大应用商店均有,课程表查看,考试安排,玉兰卡充值,各种信息都在上面可以查看,还有一个”匿名社区”我赞赞我吐槽,建议同学们谨慎发言,随时查水表。i大工的成绩信息、课程表、考试安排不确保准确，以教务网站为准</p><h3 id="1-4开发区生态"><a href="#1-4开发区生态" class="headerlink" title="1.4开发区生态"></a>1.4开发区生态</h3><p>生物鉴定 <a href="https://www.dutyard.com/d/432">https://www.dutyard.com/d/432</a></p><h3 id="1-5电脑选择"><a href="#1-5电脑选择" class="headerlink" title="1.5电脑选择"></a>1.5电脑选择</h3><p><a href="https://www.dutyard.com/d/1188">https://www.dutyard.com/d/1188</a></p><p><a href="https://augists.top/SELF/SHARING/LIFE/how-to-choose-laptop/">https://augists.top/SELF/SHARING/LIFE/how-to-choose-laptop/</a></p><h3 id="1-6课程资料"><a href="#1-6课程资料" class="headerlink" title="1.6课程资料"></a>1.6课程资料</h3><p><a href="https://github.com/NAOSI-DLUT/DLUT_SE_Courses">https://github.com/NAOSI-DLUT/DLUT_SE_Courses</a></p><img src="https://www.dutyard.com/assets/files/2022-07-25/1658760340-422174-image-20220723090538898.png"/><h2 id="2-寝室介绍"><a href="#2-寝室介绍" class="headerlink" title="2 寝室介绍"></a>2 寝室介绍</h2><p>新生群群相册中有寝室图片</p><h3 id="2-1-寝室位置"><a href="#2-1-寝室位置" class="headerlink" title="2.1 寝室位置"></a>2.1 寝室位置</h3><p>开发区校区分为两个部分,教学区与生活区,由一座桥相连(见下图),寝室位于生活区</p><ul><li>[校区地图]](<a href="http://map.dlut.edu.cn/#/home">http://map.dlut.edu.cn/#/home</a>)</li><li>宿舍楼一共有6栋<ul><li>1-5舍在生活区靠内(1舍为女寝,2-5舍为男寝)</li><li>6舍在食堂前面(男女混寝按楼层划分,辅导员也住在这里)</li><li>研究生抽签住6舍/教学楼C区负一楼/综合楼</li><li>中间的那个建筑为食堂</li><li>图中的篮球场被拆了,将会在23年左右建成新宿舍楼和新大学生活动中心</li><li>3舍楼下有洗衣店,超市,眼镜店,邮局</li><li>4舍楼下有一个移动营业厅</li></ul></li></ul><img src="https://www.dutyard.com/assets/files/2022-07-25/1658760378-837414-image-20220722193553950.png"/><h3 id="2-2-寝室内部结构"><a href="#2-2-寝室内部结构" class="headerlink" title="2.2 寝室内部结构"></a>2.2 寝室内部结构</h3><img src="https://www.dutyard.com/assets/files/2022-07-25/1658760433-478031-3.jpg"/><img src="https://www.dutyard.com/assets/files/2022-07-25/1658760455-32758-49f7ae7b-6ef3-4f7b-bba5-06c18c285b4f.jpg"/><img src="https://www.dutyard.com/assets/files/2022-07-25/1658760462-25875-img-20210305-215933jpg.jpg"/><p>五舍参考，每个楼稍有区别</p><ul><li><p>一个宿舍的同学大概率是同专业同班级，小概率是同专业不同班级。</p><ul><li><p>一个宿舍住4个同学，宿舍里一共有4张床（正常床0.9m*1.9m，可申请加长床0.9m*2.1m）、4个书桌（比较小，最多可放下27寸显示器,比较挤，据说32寸也行）、4把带靠背的椅子、4个衣柜。（衣柜0.42m*0.45m*1.8m，比较窄小，一般需要另外再买个衣柜放客厅)</p></li><li><p>宿舍外有一个大阳台(每层边缘寝室都没有,如上图,正常有的话会有个推拉门隔断阳台与寝室)，可以用来晾衣服和被子,也可以在楼下的晾衣线上晾衣服</p></li><li><p>每个寝室里面还有一个卫生间和洗漱室,开发区洗浴需要到澡堂或自己买洗浴神器,见下文生活篇</p></li><li><p>楼一共6层，寝室号以楼号开头（比如101、302、503）</p></li></ul></li><li><p>宿舍和床位是学校分好的，不需要抢。宿舍内的床位和桌位可以跟室友商量着换。床位和桌位分为1、2、3、4号。</p></li></ul><h3 id="2-3-寝室生活"><a href="#2-3-寝室生活" class="headerlink" title="2.3 寝室生活"></a>2.3 寝室生活</h3><p><strong>注：饮用水和洗澡水均是按时计费，需插玉兰卡之后开水龙头才会出水，计费时间是按照插玉兰卡的时间来算，按照约10s扣一次费计算，每次扣0.07元，所以用完水后不仅要关水龙头，还要记得把玉兰卡拔出来，不然会一直扣钱~</strong></p><ul><li><p>温度方面，冬天寝室会有暖器，温度适宜，但是在秋冬交接时,有时候温度不高,会感觉冷。春季学期寝室温度适宜，小学期会很热(盘锦校区正要装空调,我们可以再等等,小学期是什么?见下文)</p></li><li><p>洗澡：</p><ul><li>如果去澡堂洗澡,需要到一舍楼下的澡堂,刷卡洗澡,东北澡堂,没有隔间,时间一般是16:30-21:00,非封校情况下,周二周六不开门</li><li>如果购买洗浴神器的话,需要自己到双数楼层(2,4,6)（根据宿舍楼有调整）开水间打热水,在寝室自己洗</li></ul></li><li><p>喝水：</p><ul><li>宿舍楼的2,4,6层每层都有开水间，24小时开放，开水，打满一个热水壶约0.12元-0.15元；</li></ul></li><li><p>用电功率：</p><ul><li><strong>原则上讲每个寝室内用电总功率不能超过800w。请新生们牢记并转告给室友，不要刚开学就把寝室弄跳闸断电了！可能四台电脑+其他设备+灯可能达到更高的数值,但是未达临界值不会跳闸</strong></li><li>功率超了会跳闸</li><li>实际功率限制每个楼测试结果可能有不同，在此不做参考</li></ul></li><li><p>违禁电器：</p><ul><li><p>功率超过500w，或带有加热功能的电器，属于违禁电器，详情见大学生手册。</p></li><li><p>比如：锅、卷发棒、电热暖宝宝等。违禁电器原则上不允许使用，查寝时如果看到会扣分，查寝不会动手翻柜子，只会用眼睛看桌面摆出来的东西 , 不管如何,请记得一定要注意用电安全 , 记得断电</p></li></ul></li><li><p>供电时间：寝室内5:30-22:45有电。其余时间断电,考试周有可能不熄灯</p></li><li><p>洗衣服：</p><ul><li>懒人洗衣服有两种方式，3舍下，或者跟室友众筹自己买洗衣机。</li><li>众筹买洗衣机：记得量好各个门的大小,看看水龙头管子需不需要转接器,一般8kg洗衣机足够了,开发区往届都可以买,辅导也有购买,<strong>22级同学请到校之后,咨询辅导员,能不能购买洗衣机</strong>,主校区22级开始似乎不可以了</li><li>晾衣服一般在阳台晾晒，需要买晾衣杆</li></ul></li><li><p>电费：</p><ul><li>寝室和单元每学年都会有一定的用电免费额度</li><li>超出免费额度后会断电，需要自己充值电费，i大工-玉兰卡里可以充值电费和查询剩余额度，买完后过十分钟（一般立刻就）会自动恢复供电。</li><li>收费标准：0.5元/度。</li></ul></li><li><p>报修：宿舍内所有家具或房屋损坏，如桌椅台灯、掉墙皮漏水等问题，可前往一楼宿管阿姨处报修，维修师傅上门非常快。</p></li></ul><h3 id="2-4-常用尺寸"><a href="#2-4-常用尺寸" class="headerlink" title="2.4 常用尺寸"></a>2.4 常用尺寸</h3><ul><li>床：正常床0.9*1.9，加长床0.9*2.1，加长床可以在开学前新生电子注册时申请</li></ul><h2 id="3-地理位置和气候"><a href="#3-地理位置和气候" class="headerlink" title="3 地理位置和气候"></a>3 地理位置和气候</h2><h3 id="3-1-地理位置"><a href="#3-1-地理位置" class="headerlink" title="3.1 地理位置"></a>3.1 地理位置</h3><ul><li>金州区，地处辽东半岛南部、大连市中南部</li></ul><h3 id="3-2-交通"><a href="#3-2-交通" class="headerlink" title="3.2 交通"></a>3.2 交通</h3><ul><li><p>校区周围交通：</p><ul><li>到校路线：大连北站-打车到大连理工大学开发区校区生活区</li><li>大连站–坐轻轨1号线到保税区-打车到大连理工大学开发区校区生活区</li><li>也可以根据入学手册附录上其他路线到校</li></ul></li><li><p>到校交通方式：</p><ul><li><p>飞机：学校最近的机场是周水子机场</p></li><li><p>高铁：学校附近的高铁站是大连北站</p></li><li><p>火车站:大连站,金州站(距离校区最近)</p></li><li><p>一般机场和高铁站都会有学校的大巴车去接大一新生和家长，具体安排在录取通知书中应该有，待补充。</p></li></ul></li><li><p>学生票说明：</p><ul><li>火车或高铁可购买学生票，火车5折，高铁7.5折</li><li>学生票购买方法：网上购票时选择学生票，填写个人信息，学号在录取通知书上，之后携带录取通知书到火车站人工窗口取票。</li><li>学生票的优惠时间是每年的1、2、3、6、7、8、9、12月，其他时间不能买学生票，且一年只能购买四次，路线必须在登记的区间内即只能买学校和家之间的路线才可优惠。如果没有买到直达票，选择中转的话，只要一次性购票就算一次优惠。</li></ul></li><li><p>到主校区通勤车,按经验讲,不封校期间随便做,有时候会查辅修证</p><img src="https://www.dutyard.com/assets/files/2022-07-25/1658760728-898029-1658642220715.png"/></li></ul><h3 id="3-3-气候"><a href="#3-3-气候" class="headerlink" title="3.3 气候"></a>3.3 气候</h3><ul><li><p>校风很大，一年四季风都会很大。夏天日常三四级风，冬天日常六七级风(理论上讲,冬天最低温度-9%,但是风真的很大,所以可能会比标注的气温更冷,需要穿零下二三十度厚羽绒服)，希望大家不会被吹走。</p></li><li><p>因为这里是湿地，<strong>所以蚊子很多很毒</strong>，基本一年四季都有蚊子，高发季在5-10月左右</p></li><li><p>防蚊推荐：</p><ul><li><p>驱蚊水：雷达欧护驱蚊液、六神驱蚊花露水（需要买带有避蚊胺成分的）</p></li><li><p>药：无比滴、曼秀雷敦薄荷脑软膏</p></li><li><p>门帘：主要是用于阳台门和寝室门，跟室友商量好众筹一下，尺寸买0.8m*2.1m。</p></li><li><p>蚊帐：建议买全封闭的，需要自己买支架，外面还可以套个床帘。床是0.9m*1.9m，下铺高度118cm左右，上铺到天花板170cm左右，买带伸缩杆的就行，高度110cm就差不多，这样上下铺都能用。</p></li><li><p>电蚊拍：看个人能力，要是可以徒手打蚊子，这个就不用了。</p></li><li><p>电蚊香不需要，因为寝室晚上断电；普通蚊香也不建议，有火灾隐患。</p></li></ul></li><li><p>寝室内可能偶尔会有一些小虫子,但是应该没有蟑螂</p></li></ul><h3 id="3-4-周边设施"><a href="#3-4-周边设施" class="headerlink" title="3.4 周边设施"></a>3.4 周边设施</h3><p>必去景点：金石滩，星海广场，东港喷泉（夏天大概是晚8点有喷泉），俄罗斯风情街，老虎滩，发现王国，圣亚海洋世界<br>可选：动物园（内有索道），宜家（适合拍照），熊洞街，棒棰岛，日本风情街<br>购物：罗斯福购物中心，柏威年购物中心，时代广场，百年城，奥特莱斯，印象城，麦凯乐，凯丹广场，新玛特（比较破旧），开发区的安盛广场，万达广场，恒隆广场<br>娱乐：中山区的蹦迪场所较多，海伦斯酒馆（比较适合学生），卡丁车</p><h2 id="4-校内生活"><a href="#4-校内生活" class="headerlink" title="4 校内生活"></a>4 校内生活</h2><h3 id="4-1-食堂（待补充）"><a href="#4-1-食堂（待补充）" class="headerlink" title="4.1 食堂（待补充）"></a>4.1 食堂（待补充）</h3><ul><li><p>校区只有一个食堂,大连理工大学第六食堂,不能说很好吃,但是相对主校区还算可以</p><ul><li>一楼早餐+午晚餐 还有烧烤,炸鸡汉堡,小炒</li><li>二楼有各种小铺 轻食 奶茶店</li><li>三楼 铁板砂锅等 还有水果店 教工餐厅</li></ul></li><li><p>价格方面，早餐大概2~6元，午餐晚餐大概8~16元，想吃更便宜或者更贵的也有。可以刷玉兰卡或者微信支付</p></li><li><p>食堂如遇到食品安全问题，需及时拍照取证，拿回档口要求补偿，若档口拒绝赔偿，可联系食堂经理或学生会权益部进行维权。</p></li></ul><h3 id="4-2-校内消费"><a href="#4-2-校内消费" class="headerlink" title="4.2 校内消费"></a>4.2 校内消费</h3><ul><li><p>主要位于生活区</p></li><li><p>主要设施：</p><ul><li>【超市】：小型规模，卖食品和水果，生活用品<strong>(价格偏贵,可能不止一倍溢价,建议入学必备物品都网购,如盆,拖鞋,水壶等)。</strong>超市的支付方式：微信、支付宝、云闪付。</li><li>【理发店】：剪发25元，办卡20元,封校情况下需要预约(很难抢)</li><li>【公共澡堂】：无隔间，坦诚相待。澡堂开门时间：周一三四五日：16:30-21:00</li><li>【眼镜店】：老板人很好，简单的眼镜维修、清洗也都可以，甚至可能不会收钱</li><li>【打印店】：<ul><li>公益性：DV工作室内（教学楼a112），开放时间和形式由学校决定，免费</li><li>非公益性：教学区A320 普通打印0.2元/张,生活区也有很多宿舍提供打印服务,图书馆里面也提供打印服务</li></ul></li><li>【移动营业厅】：除了9月份开学向新生推销办卡之外，其他时候基本没人</li><li>【ATM机】：位于3舍楼下,可以说十分鸡肋,因为完全用不到现金,虽然超市可以现金支付</li></ul></li></ul><h3 id="4-3快递"><a href="#4-3快递" class="headerlink" title="4.3快递"></a>4.3快递</h3><ul><li>快递区：位于生活区二舍栅栏旋转门,封校期间每天13:00-19:00开放,除顺丰快递有时候需要超市取,所有快递都会堆放在这,根据号码取,天猫超市与美团优选买的东西也会存在这,不封校期间快递部分可入校区菜鸟驿站,和栅栏内外递交</li></ul><h3 id="4-4-医疗"><a href="#4-4-医疗" class="headerlink" title="4.4 医疗"></a>4.4 医疗</h3><p>【医务室】</p><ul><li>医务室位于6舍一楼，有一位医生，小病可以在医务室买药，大病还是需要去医院</li><li>原则上医务室24小时开门，但医生晚上会休息，若无紧急情况尽量白天去看诊。</li></ul><h3 id="4-5-校内上网"><a href="#4-5-校内上网" class="headerlink" title="4.5 校内上网"></a>4.5 校内上网</h3><p>校内上网两种方法：手机流量or校园网。</p><p>【手机流量】</p><ul><li><p>建议大家来学校之前在自己的城市办一张流量够用的手机卡。也可以办理校园卡</p></li><li><p>虽然当地的运营商会在开学时向同学们推销合适套餐的手机卡(2021年套餐是第一年29一月,200G校园+15G全国+30G免流第二年39)，但是大部分人毕业了就会想要销卡，销卡需要去校外的营业厅，封校不好出去，比较麻烦。</p></li><li><p>如果大家决定办理校园卡，建议只做上网用，不要绑定太多东西，不然毕业了想销卡更麻烦。</p></li><li><p><strong>校园手机卡不是必须办理，手机卡跟校园网没有任何关系。可以礼貌拒绝推销的学长学姐</strong></p></li><li><p><strong>除推销校园卡外的一切推销均视为外校人员，请联系保卫科把它们请出学校</strong></p></li></ul><p>【校园网】</p><ul><li><p>收费标准：20元100G</p></li><li><p>校园网无线wifi信号全校园无死角覆盖，不需要自行安装路由器。但是无线信号较差,ios设备连接无线校园网可能遇到各种问题</p></li><li><p>电脑想使用有线网也可以，寝室内有校园网的网口，但是仅能使用校园网，想自己办校外宽带是不可能的。如果是玩游戏的同学对延迟有要求，建议插网线使用有线网，延迟会稳定一些。</p></li><li><p>校园网的网速还算可以，如果是同学们集中上网课的时间，可能会有些卡。一般来说，非集中上网课的时间，网速都是ok的。</p></li><li><p>使用 登录<a href="http://172.20.20.1:801/srun_portal_pc.php?ac_id=3&amp;">http://172.20.20.1:801/srun_portal_pc.php?ac_id=3&amp;</a> 账号为自己学号,密码为身份证后八位,通过i大工app,玉兰卡入口充值,电费充值也在这里</p><img src="https://www.dutyard.com/assets/files/2022-07-25/1658760494-667541-d974d08e104c792ec9a6319dd71f5698.jpg"/></li></ul><h3 id="4-6锻炼"><a href="#4-6锻炼" class="headerlink" title="4.6锻炼"></a>4.6锻炼</h3><ul><li>教学区有一个大操场(含足球场)和一个体育馆,一个篮球场</li><li>体育馆里面可以打台球,羽毛球,乒乓球,排球,篮球,跳街舞,武术,还可以健身(不过设施不多),健身三元一次</li></ul><h3 id="4-7文体活动"><a href="#4-7文体活动" class="headerlink" title="4.7文体活动"></a>4.7文体活动</h3><ul><li>开发区有数十个社团,将会在新生入学约一个月后“百团大战”上进行宣传,感兴趣的同学记得参与</li><li>平时大学生活动中心会有不少表演,一般软院公众号（<strong>大工软件学院青年汇</strong>）和食堂门口可以获知最近的表演，部分活动会由b站<strong>大工软院青年汇</strong>或<strong>大工软国</strong>进行直播</li><li>定期还有心理健康协会组织的活动,狼人杀,趣味运动会等等</li><li>篮球赛,足球赛等每月也都会有</li></ul><h3 id="4-8科创活动"><a href="#4-8科创活动" class="headerlink" title="4.8科创活动"></a>4.8科创活动</h3><ul><li>想参与科创大概有<ul><li>自行组队参与各类比赛，包括但不限于“互联网+”、数模比赛</li><li>加入创新创业实践中心（创中）的组里,以参加比赛为主,比如CPC组,数模组,OurEda,螺丝工作室等等（开放例会，可旁听）创中各组介绍 <a href="https://mp.weixin.qq.com/s/VKYU2uPWHtTMC7DtWkPHVA">https://mp.weixin.qq.com/s/VKYU2uPWHtTMC7DtWkPHVA</a></li><li>也可以加一些小团体,大工有不少技术小群体,大家一起研究</li></ul></li></ul><h3 id="4-9科研"><a href="#4-9科研" class="headerlink" title="4.9科研"></a>4.9科研</h3><ul><li>科研指以研究和发论文为导向，一般依托于实验室和大创。注意分清科研和科创</li><li>参与方式<ul><li>自行联系老师，加入实验室（如网络系wilna、软件系红蚂蚁、软国数媒等，不包括OurEDA），建议直接查询软院老师信息</li><li>每年12月开始组队大学生创新创业项目，需联系老师，选择课题。大创时间为1年，科研性较弱</li></ul></li></ul><h3 id="4-10团委、学生会、心协、社联、模联、三团等"><a href="#4-10团委、学生会、心协、社联、模联、三团等" class="headerlink" title="4.10团委、学生会、心协、社联、模联、三团等"></a>4.10团委、学生会、心协、社联、模联、三团等</h3><ul><li>团委和学生会合称团学，架构非常复杂。整体团学一般包括三个大部分，分别为团委、学生会、学生组织联合会。以网络文化工作室为例，其下设多个大部门，宣传部属团委，创意中心（包括DV工作室、橙in工作室、文创产品中心）属学生会和学生组织联合会。架构每年会有微调。</li><li>心协、社团委员会等在开发区与团学平级，计算社会工作积分时低一级计分</li><li>三团包括话剧团、舞蹈团、合唱团</li><li>开发区包括三个学院的学生组织有阳光心理健康协会（心协）、青年志愿者协会（青协）、社团发展委员会（社联）、模拟联合国（模联）、三团等。其中心协、模联直接接轨主校区（社联不知道）。跨软件和软国的学生组织为DV工作室</li><li>第一学期中间会办团学的招新会（包括三团），大约在9月份忙完迎新活动后开始</li><li>创意中心（DV工作室：PS、PR、达芬奇、AE、摄影、航拍等，橙in工作室：音频相关软件Au等，文创产品中心：C4D等）开放例会，任何人都可以参加</li></ul><h2 id="5-军训"><a href="#5-军训" class="headerlink" title="5 军训"></a>5 军训</h2><ul><li><p>时间：正常是开学后过几天就开始军训，为期14天，遇到疫情会有变动。</p></li><li><p>作息：2021级的军训情况是：早上8点开训，中午11点半休息；下午1点半开训，5点结束。</p></li><li><p>地点：在学校操场，如果下小雨在体育馆，下大雨直接回宿舍休息。</p></li><li><p>感受：军训前几天会很累,后面习惯就好了</p></li><li><p>着装要求：学校会发军训服，军训期间必须穿军训服。<strong>发型、指甲方面没有要求，染发和美甲都ok。耳环、项链等饰品尽量不戴。可以化妆但不要太浓。</strong></p><ul><li><p>军训服包括：帽子、短袖T恤、长袖外套、长裤子、鞋子。<strong>大号尺码穿不上可以不穿(一定要和教官报备)</strong></p></li><li><p>入学前电子注册时需要填写鞋码，如果鞋子不合适可以换，实在换不到合适的跟教官协商，原则上必须穿学校发的鞋。</p></li><li><p><strong>鞋子会比较硬，建议开学前自己准备一个柔软舒适的鞋垫。</strong></p></li><li><p><strong>裤子的腰很肥，需要自己准备腰带，没有腰带裤子一定会掉。</strong></p></li><li><p>军训服每人只有一套，如果想洗衣服建议挑晴天的晚上，第一次穿之前建议洗一下。</p></li></ul></li><li><p>注意事项：</p><ul><li><strong>教官为大连舰艇学院大三大四学生，为了保护教官，请不要拍摄教官穿军装的正脸照片，如果拍了也不要上传到网络上。</strong></li><li>可以准备筋膜枪用来放松肌肉。</li><li><strong>务必准备好防晒和防蚊用品。</strong></li><li>军训期间会比较忙碌，因为刚开学会有各种事情，晚上可能有青春歌会训练（合唱比赛），大家做好非常忙的心理准备。军训和歌会结束后就会轻松很多。</li><li><strong>请不要跟教官谈恋爱。</strong></li><li><strong>请不要跟教官谈恋爱。</strong></li><li><strong>请不要跟教官谈恋爱。</strong></li><li><strong>千万不要逃军训,合理请假,累了可以在边上见习,但是一定要去</strong></li></ul></li></ul><h2 id="6-英语分级考试"><a href="#6-英语分级考试" class="headerlink" title="6 英语分级考试"></a>6 英语分级考试</h2><ul><li><strong>开发区取消了分级考试</strong>,分级考试并不是四六级考试</li></ul><h2 id="7-转校区、转专业、保研率"><a href="#7-转校区、转专业、保研率" class="headerlink" title="7 转校区、转专业、保研率"></a>7 转校区、转专业、保研率</h2><ul><li><p>一般来说，转校区=跨校区转专业，转专业=校区内转专业。</p></li><li><p>普通专业的同学，转校区和转专业原则上仅能在<strong>大一下学期结束时</strong>申请；</p></li><li><p>转专业申请转专业，22级原则按照<strong>“转出无门槛，转入有要求”</strong>的原则执行。学生转专业一般在第一学年末提出申请，按照转入专业的考核要求通过综合考评后，即可实现转专业学习,但是对应专业名额有限,<strong>想转专业同学一定要好好学习</strong></p></li><li><p>大部分专业，保研率约13%-15%</p></li></ul><h2 id="8-教学时间安排"><a href="#8-教学时间安排" class="headerlink" title="8 教学时间安排"></a>8 教学时间安排</h2><h3 id="8-1-校历"><a href="#8-1-校历" class="headerlink" title="8.1 校历"></a>8.1 校历</h3><ul><li><p><a href="https://www.dlut.edu.cn/ggfw/xqxl.htm">校历链接</a></p></li><li><p><strong>2022级本科生于8月27日和8月28日到学校报道，9月5日正式开学。</strong></p></li><li><p>根据校历安排，一年有52周，理想情况下，学校会分为三个学期：</p><ul><li><p>秋季学期，即第一学期，大概在9月-次年1月，包括15周教学周+1周考试周。</p></li><li><p>寒假，大概在1月中旬-2月末，共6周。</p></li><li><p>春季学期，即第二学期，大概在3月-6月，教学周15周+1周考试周。</p></li><li><p>夏季学期，即第三学期，又称小学期，大概在6月-7月，包括4周教学周。</p></li><li><p>暑假，大概在7月-8月末，共6周。</p></li></ul></li><li><p>寒暑假不一定按照校历来，大三大四阶段课比较少，有可能提前考完试就可以提前放假。小学期不一定要呆在学校，需要看每个专业具体的安排。</p></li><li><p>节假日安排，除了上面提到的寒暑假外，法定节假日均按国家规定放假，包括：元旦、春节、清明节、劳动节、端午节、中秋节、国庆节。</p></li><li><p>不理想情况，即受疫情影响，出现了开学推迟之类的情况，学校会根据实际情况灵活安排。（大概率是反人类安排，同学们做好准备）,<strong>在大工一定不要提前买票，等涨价也比让你退票改签好一点点</strong></p></li></ul><h3 id="8-2-上课时间"><a href="#8-2-上课时间" class="headerlink" title="8.2 上课时间"></a>8.2 上课时间</h3><ul><li><p><strong>不一定每节课都有排课，不一定每天都有排课，周六日不一定没课(可能会有对应数学的上机课,然后有的很负责的老师会占用空闲时间补课,还可能有形势与政策课,大学期间共需要上8节)</strong>。</p></li><li><p>课表可以在i大工上面看(不一定全面),更推荐校园门户-新版教学系统-我的课表查看。</p></li><li><p>上课时间，仅作为参考，实际可能会错峰10-20分钟（b区为正常时间，a和c区错峰），以实际通知为准,课程一般是两节一起上,也有可能是四节一起上(一般是晚上上机或者实验课)</p></li></ul><p>【上午】</p><p>第一节 8:00-8:45；第二节 8:50-9:35</p><p>第三节 10:05-10:50；第四节 10:55-11:40</p><p>【下午】</p><p>第五节 13:30-14:15；第六节 14:20-15:05</p><p>第七节 15:20-16:05；第八节 16:15-17:00</p><p>【晚上】</p><p>第九节 18:00-18:45；第十节 18:55-19:40</p><p>第十一节 19:50-20:35；第十二节 20:45-21:30</p><ul><li>课表举例，每周的排课可能会不同，学期末的时候课一般会少，大三大四课一般会少：</li></ul><img src="https://www.dutyard.com/assets/files/2022-07-25/1658760537-793881-image-20220722192314268.png"/><img src="https://www.dutyard.com/assets/files/2022-07-25/1658760537-843749-image-20220722192307482.png"/><h3 id="教学楼自习室"><a href="#教学楼自习室" class="headerlink" title="教学楼自习室"></a>教学楼自习室</h3><ul><li><p>教学楼教室仅开放部分作为自习室，b区2楼201、202、203长期开放，a区1楼101、201、301、1和2楼东侧小教室、2楼西侧小教室</p></li><li><p>a区4楼为考研自习室，非考研同学请不要打扰并在路过时减轻声音</p></li><li><p>c区2楼有公共机房</p></li></ul><h2 id="9-培养方案、选课、学费"><a href="#9-培养方案、选课、学费" class="headerlink" title="9 培养方案、选课、学费"></a>9 培养方案、选课、学费</h2><p>（这部分内容在开学时学校也会给大家讲）</p><ul><li>同学们在开学后会发书，其中有一本是《大连理工大学本科生人才培养方案 xx专业》，简称培养方案，这本书请务必<strong>仔细阅读、认真阅读、反复阅读、烂熟于心</strong>。</li><li>这本书描述了你所学专业的培养定位、培养目标和毕业要求。</li><li>书内会有一个大表格，帮你计划好了大学四年的每个学期需要学哪些课程，包括不同专业方向需要选的课程,大学的课程需要自己去选课系统里选，会经常有同学存在漏选、错选的情况，<strong>弄不好就会导致毕业受到影响</strong>。</li><li>表格中的学期安排只是建议，实际上只要大学四年内修完规定的课程学分即可毕业，哪个学期学哪门课可以自己灵活安排。但还是建议大家尽量按照表格里的学期安排来选课，这样不容易出错。</li><li>软件一般是三年上完课,大四实习或者考研等等,微电和软国情况过多,入学就知道了</li><li>课程分为必修和选修。选修也是必须要修的，选修的意思是会给你一个选课范围，在这个范围内你可以自由选择想学哪门课。但是需要选够对应分类足够的课才能毕业</li><li>大一上学期不需要选课，教务处会自动给大家安排好，从大一下学期开始就要自己选课，选课的时间一般在学期末去选下学期的课，比如秋季学期末的时候选春季学期的课。<strong>每次选课教学事务部都会发通知，选课通知跟培养方案一样重要，需要认真阅读。</strong></li></ul><p>【学费】</p><ul><li>学费不是入学就需要交的,大概9-10月甚至更晚</li></ul><ul><li><p>学费的交法：每年按照此学年的默认学费交，如软件大三需交16000；同时补交上一年额外的选修课，每学分80r。在大四毕业时，进行最后一轮多退少补（大部分同学应该是多交的，会收到教务退还多余的学费）</p></li><li><p>校区微电子专业的学费约为5000元一年,软件专业前两年各8000,后两年16000,软国专业一年63000（可能有调整）</p></li><li><p>普通专业每年的学费构成：住宿费1200元+专业费+本学年选课总学分*80元</p><ul><li><p>专业费每个专业会略有不同</p></li><li><p>学分费用是你只要选了课就要交钱，即使挂科也需要交钱，如果重修了还要再交一次钱，所以尽量不要挂科。</p></li></ul></li><li><p>大一开学时收的学费用于大四学年，毕业时多退少补。大二开学时收大一学年的学费，大三开学时收大二学年的学费，大四开学时收大三学年的学费。</p></li></ul><h2 id="10-校区常用QQ群汇总"><a href="#10-校区常用QQ群汇总" class="headerlink" title="10 校区常用QQ群汇总"></a>10 校区常用QQ群汇总</h2><ul><li>软院学长学姐帮帮群365953299(专业不限于软件,现在还是满人,可能需要开学后清毕业生才有位置)（此群动态清理，直接申请加入即可）</li><li>有偿帮助群793480506</li><li>二手交易群606682597   1129396771</li><li>拼车群490556708</li><li>2022开发区新生群669263964(群主是校区的一位老师)</li></ul><ul><li>群内如有任何问题均可私聊群主或管理员。<strong>注意防骗,不要信大家的私聊,不要随便点进新生群群邮件发给你的链接</strong></li></ul><h2 id="11-入学携带物品（待补充）"><a href="#11-入学携带物品（待补充）" class="headerlink" title="11 入学携带物品（待补充）"></a>11 入学携带物品（待补充）</h2><ul><li><p>行李太多可提前邮寄到学校，但需要在临近开学前邮寄，不能存放太久。<strong>开学前请务必提前买好所需物品，学校内超市真的贵。来了学校就尽量网购，超市是应急的。</strong></p><ul><li><p>学校地址：辽宁省大连市金州区湾里街道 大连理工大学开发区校区</p></li><li><p>邮编：116621</p></li></ul></li><li><p><strong>入学时携带的行李箱，最好贴个标签标上专业名字寝室号，开学的时候比较乱，万一丢了还能找回来。而且很可能会出现相同的行李箱，需要给自己的箱子做个标记。</strong></p></li><li><p>证件类：身份证、录取通知书、个人档案、团员/党组织关系档案、一寸&amp;二寸证件照若干(也可以来学校拍)。</p></li><li><p>银行卡：到学校后，学校会为新生统一办理中国建设银行的储蓄卡，无需自行办理。如果之前办理过建行卡，可以不用在学校办理，但是需要联系学校财务处绑定卡号。<strong>信用卡千万不要办理！</strong></p></li><li><p>厕所收纳架（四个人都可以挂到墙上放牙具，护肤用品），洗衣液，拖把，扫帚，各种收纳衣服的柜子，热水壶，台灯，充电宝，电脑支架（狗头），挂衣服衣架</p></li><li><p>床上用品：</p><ul><li><p>可以自己带，也可以用学校的。</p></li><li><p>学校的床上用品会提供一个大礼包，包括褥子（铺在床垫和床单之间的东西）、床单、被套、被子、枕头、枕巾、蚊帐，需要换洗的都是双份的，价格420元左右，可以选择不买。</p></li><li><p>自己携带的床上用品没有颜色样式要求，随便带。</p></li><li><p>学校卖的床上用品不提供床帘、支架、凉席等物品，有需要可自行购买，学校卖的蚊帐并不是全封闭的，建议自己买个全封闭的支架，装上蚊帐和床帘。</p></li><li><p>学校给每个人都提供床垫，免费的，但有点硬。</p></li></ul></li><li><p>电子产品：</p><ul><li><p>笔记本电脑（必备，台式也可，学业上对电脑没有要求，买什么样的看自己需求，尽量买高配）</p></li><li><p>手机（必备）</p></li><li><p>平板pad（可有可无）</p></li><li><p>3.5mm圆孔耳机（需插在电脑上用于英语分级考试听力部分）</p></li></ul></li><li><p>军训+防蚊：驱蚊水、止痒药、宿舍门帘、<strong>防晒霜</strong>、腰带、鞋垫,护膝护肘(可能需要匍匐前进,倒地上很痛)</p></li><li><p>生活类：1.5米插排(记得买大牌子安全的,插孔多的)、usb充电小风扇、usb充电小台灯</p></li><li><p>医药类：口罩、各种常备药品</p></li><li><p>日用品：太多了，洗发水纸巾什么的，建议去网上搜一下”大学生物品清单”之类的参考下。</p></li></ul><h2 id="12-一些小提示"><a href="#12-一些小提示" class="headerlink" title="12 一些小提示"></a>12 一些小提示</h2><ul><li><p>首先最重要的，注意防骗，全民反诈！除了社会上的电信诈骗外，在学校里也要提高警惕。</p><ul><li><p>线下：封校期间校内可能会相对安全，但不完全排除没有校外人员混进来。曾经有人混进来推销清洁剂、英语报纸、签字笔等等，都是常见的在校区内发生过的骗局。</p></li><li><p><strong>校园手机卡不是必须办理，信用卡除了学校发的那个别的不要办理。</strong></p></li><li><p>线上：每一个加好友的人要注意核实身份，新生群因为要保证高考生都能进群，所以可能会存在骗子，不一定每个加你的都是同学~<strong>比如”大学生四六级资料群”</strong> <strong>“大学生资料墙”</strong> <strong>“学ps分享资料”等等这些都是骗子。除此之外还有不写学校名称、学院名称、专业名称的”大学活动通知群” “教务处通知群”大概率都是骗子。这些群进去后会主动让你拉人，有些还会全员禁言，基本就能判断出是骗子群了。</strong>遇到可疑的人、可疑的事不好判断时，可以发到群里让大家一起帮你判断。</p></li></ul></li><li><p><strong>迎新系统的照片采集，规定里面说不可以美颜，实际可以！一定要好好美颜，这张照片会出现在很多地方，包括校园一卡通、准考证等，你的同学也会在迎新系统中看到你的照片，非常重要！必须是证件照，不可以是生活照。</strong></p></li><li><p>做好可能被封校四年的准备，目前的政策是辽宁省只要有疫情，大学就封校，泪目。</p></li><li><p>我们学校大一就可以考四六级，建议大一上学期就去考，高考前后会是很多人的英语水平巅峰,真的可以说是裸考四级随便过(但是大家还是好好准备)。报名费30元，一次只能考一门，报名了不去考试除了亏30元没有任何影响。四六级考试的听力部分需要通过广播收听，所以需要带有收音机功能的耳机，淘宝就能买到很便宜，不要买贵了。</p></li><li><p>如果玉兰卡丢失：可前往三舍楼下邮局补办，费用25元。i大工app可进行挂失。尽量不要丢失玉兰卡，可能会被其他人捡到盗刷、盗用身份，且新补办的卡字体不好看。</p></li></ul><h2 id="学长学姐寄语"><a href="#学长学姐寄语" class="headerlink" title="学长学姐寄语"></a><strong>学长学姐寄语</strong></h2><h3 id="盘锦校区毕业学姐"><a href="#盘锦校区毕业学姐" class="headerlink" title="盘锦校区毕业学姐"></a>盘锦校区毕业学姐</h3><ul><li><p>学会用各种软件各种途径获取信息，信息差本质上也是竞争的一种方法。</p><ul><li>互联网时代，很多事情都可以自己查询解决。比如要看路线可以用高德地图，查询周边商家可以用美团。一些客观的信息查询可以用百度，比如学校的邮编。学校内的新闻和活动，可以多关注相关的公众号、学校官网通知、以及各种群。比如选课的时候，哪些选修课比较轻松好过，同学们都会在大群里讨论，说这些事的时候建议大家多看看群。【查找消息记录】是个不错的功能。另外有空的话可以看看各种群的群公告、群文件、精华消息，也许会收获惊喜呢。</li></ul></li><li><p>学会看通知。</p><ul><li>在大学里，学习和生活都是自己安排的，不会再像高中一样需要做什么都帮你安排好，自己的事情要自己上心。一般来说重要的事情在专业群班级群都会有通知，要记得留意，如果错过了重要的事，可能同学会提醒你，但不一定每次都有人提醒哦。</li></ul></li><li><p>学会与人相处。</p><ul><li><p>人是一切社会关系的总和，不管再怎么社恐，都是无法避免与人接触的。在学校里，我们可能会需要找人帮忙，或者被别人寻求帮助。如果是前者，人情是最难还的东西，能给钱尽量用钱解决，不方便用钱的可以注意礼貌用语表达谢意，嘴甜一点不会吃亏。如果是后者，不想做的事情要在一开始就拒绝，不要委屈自己。</p></li><li><p>大学是集体生活，宿舍内部可能会有些小矛盾，作息习惯、卫生习惯每个人可能不同，不求合群但尽量不与人添麻烦，有了问题建议面对面及时沟通，当面说出来解决肯定比憋在心里强。</p></li></ul></li><li><p>对未来尽早规划。</p><ul><li>很多人都会对未来迷茫，但最好不要迷茫太久。根据2021年盘锦校区本科生落位报告，31%同学就业，32%同学保研和考研升学，12%同学出国升学，25%在统计时未落位。虽然不愿意承认，但现在的形势确实会比较卷，保研、考研、出国、考公、就业，每一条路看起来都已经是千军万马过独木桥，这意味着我们前期必须为未来做好打算。我的建议是最晚大二就要选一条路去努力，不管选哪条路我们学校都有很多学长学姐可以请教，学校会不定期有经验分享会，可以去听一听聊一聊。</li></ul></li></ul><h3 id="开发区校区大三学长"><a href="#开发区校区大三学长" class="headerlink" title="开发区校区大三学长"></a>开发区校区大三学长</h3><p><u>2022/7/20</u></p><h4 id="0x00-大方向概述"><a href="#0x00-大方向概述" class="headerlink" title="0x00 | 大方向概述"></a>0x00 | 大方向概述</h4><p>大学四年大方向总体有如下四种：就业、读研（保研、考研）、出国、考公</p><p>其中<strong>就业</strong>和<strong>读研</strong>占绝大多数</p><p>以下就这两个方向说说看法，个人认为：</p><p><strong>如果想定了就业：</strong>那么课内成绩是没有必要去拔尖的，不挂科即可。将自己的重心放在对口的技术学习与培养上，注重实践。理由是校内课程大部分和实际工业生产脱钩，当前来看未能做到产学结合，象牙塔里是培养不出新工科人才的</p><p><strong>如果想定了读研：</strong>那么课内成绩是很重要的，将是保研的门槛，软件工程的历届保研率大概15%。如果到大三结束成绩未能达到保研资格，则通过考研的方式也可。然而课内教的内容也比较浅，基本上是概念/常识，真正实用的理论内容还得自己拓展学习</p><p>总之自学是很重要的</p><blockquote><p>注：这里的课内成绩专指计入推免（保研）的课程加权成绩</p></blockquote><h4 id="0x01-关于我自己的经历"><a href="#0x01-关于我自己的经历" class="headerlink" title="0x01 | 关于我自己的经历"></a>0x01 | 关于我自己的经历</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>我的专业是软件工程大类（另外两个开发区的专业大类是软国和微电子）</p><p>在大一上还是比较混的，基本上没有做什么额外的，只是跟着上课，周末寝室打游戏，对编程也比较无感</p><p>过了这股大学的新鲜劲，大一下对技术比较感兴趣了，加入了创中的螺丝组学习网安</p><p>大二上分流到了网络工程，排名比较靠前</p><h5 id="社交圈发展"><a href="#社交圈发展" class="headerlink" title="社交圈发展"></a>社交圈发展</h5><p>在大一上的时候主要是认识舍友，班内的同学，以及通过ACG方式结交的同好</p><p>大一下逐渐认识了一些有趣的学长学姐，之后与舍友及其周围关系也更加不可分了，经常出去恰饭以及深夜喝酒jz之类的</p><p>然后大二某时间开始封校政策越来越严，大家都是呆在一个地方上网课了，平常也就见到舍友，只能网络社交…</p><h5 id="技术栈发展"><a href="#技术栈发展" class="headerlink" title="技术栈发展"></a>技术栈发展</h5><p>内容较长，详见附录</p><h4 id="0x02-绩点与技术的平衡"><a href="#0x02-绩点与技术的平衡" class="headerlink" title="0x02 | 绩点与技术的平衡"></a>0x02 | 绩点与技术的平衡</h4><p>保研不是目的，只是一个入场的门槛，个人认为不要把保研当作最终目标，否则多少有点鼠目寸光</p><p>绩点类比于经济基础，技术类比于上层建筑。因此在成绩稳健的情况下建议将一部分时间用来学习技术知识，优化时间分配，差异化竞争，毕竟解决实际问题的能力才是核心竞争力</p><p>但是也最好不要过分裁剪课内的“学习时间”，比如我大一下学期的近代史经常旷课，漏了一次签到，考试也没认真复习，最后才70+</p><p>我的平衡标准如下：保研课程不能逃，算分的作业得认真写（标准是写正确拿到分，没拿到分没用），平常上课基本能跟上就行，考前每门课至少得抽出大概2-3天用来复习。至于课上（或课前）自己弄懂了这节课的内容，剩下时间用来干嘛就无所谓了</p><h4 id="0x03-信息战"><a href="#0x03-信息战" class="headerlink" title="0x03 | 信息战"></a>0x03 | 信息战</h4><p>信息在任何地方的角逐与对抗中都是一个重要的因素。当前大学的信息流通强依赖于QQ这个软件，以及学校的官网，遍布信息鸿沟。按信息来源划分大致可以分为学校官方和学生民间</p><h5 id="学校官方"><a href="#学校官方" class="headerlink" title="学校官方"></a>学校官方</h5><p>大致来源有校园官网以及官方信息QQ群</p><h5 id="校园官网"><a href="#校园官网" class="headerlink" title="校园官网"></a>校园官网</h5><p>例如大连理工大学开发区官网<a href="http://eda.dlut.edu.cn/以及大连理工大学软件学院官网https://ssdut.dlut.edu.cn/">http://eda.dlut.edu.cn/以及大连理工大学软件学院官网https://ssdut.dlut.edu.cn/</a></p><p>大连理工大学的官网有很多子域名，在谷歌搜索中通过如下模式搜索可以检索到所有大工的子学院的官网</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">site:</span>dlut.edu.cn</span><br></pre></td></tr></table></figure><blockquote><p>出国人强烈推荐关注国际合作与交流处官网<a href="https://dutdice.dlut.edu.cn/">https://dutdice.dlut.edu.cn/</a></p></blockquote><h5 id="官方信息QQ群"><a href="#官方信息QQ群" class="headerlink" title="官方信息QQ群"></a>官方信息QQ群</h5><p>例如专门用来发布行政信息的班级群以及创中/团学组织的各类信息群</p><h5 id="学生民间"><a href="#学生民间" class="headerlink" title="学生民间"></a>学生民间</h5><h6 id="大环境"><a href="#大环境" class="headerlink" title="大环境"></a>大环境</h6><p>例如[软院学长学姐帮帮忙群]-(365953299)，多为学生自己组建的QQ群，信息交换速率比较快，很多有用的学习以及政策资料都在群文件中，一般都是前人遇到过的问题</p><h6 id="小团体"><a href="#小团体" class="headerlink" title="小团体"></a>小团体</h6><p>和关系密切的同学组建一个或多个信息共同体，载体可以是多样的，比如：某种同好交流群、寝室群都是可能的。在必要的时候自然而然就会有信息交流</p><h4 id="0x04-附录资料"><a href="#0x04-附录资料" class="headerlink" title="0x04 | 附录资料"></a>0x04 | 附录资料</h4><h5 id="我的技术栈发展"><a href="#我的技术栈发展" class="headerlink" title="我的技术栈发展"></a>我的技术栈发展</h5><p>2020/9</p><p>大学入学，第一次接触编程，学习c语言</p><p>2020/10</p><p>第一次接触Linux、第一次接触BurpSuite、sqlmap…</p><p>2021/1</p><p>第一次接触html</p><p>2021/2</p><p>学习了基础html、css、js，写了一个静态油管vtb导航页面</p><p>2021/3</p><p>学习使用charles对mumu安卓模拟器抓包流量分析</p><p>学习内网渗透（跟着教学视频打一遍）</p><p>2021/4-5</p><p>学习了php漏洞基础、sql注入基础、shell基础、Java以及SpringMVC基础，番外：扫到后台端口，不小心sql注入打爆了学长的毕设网站</p><p>2021/7</p><p>配置了自己的服务器以及域名，服务器apache、php、mysql环境配置</p><p>V1版本网站开发（纯静态html、css、js）</p><p>2022/8</p><p>网页版类chatapp开发（php、mysql）</p><p>2022/10</p><p>V2版本网站开发（php、mysql、jquery），并将chatapp作为站内应用加入，统一站内账户</p><p>2021/11</p><p>学习go-cqhttp，第一次搭建QQ机器人</p><p>2021/12</p><p>学习Django、vue3基础（花旗杯），还学到了ApiFox以及Axure等</p><p>2022/2</p><p>初学go语言以及iris框架，搭建通用测试机器人Kalina、监听机器人Hoshino，给监听数据建模并可视化</p><p>2022/3</p><p>学习Laravel开发以及Laravel反序列化链子、学习flask以及ssti注入基础</p><p>2022/4</p><p>学习gin框架，发现比iris好上手</p><p>2022/5</p><p>gin+vue3搭建V3版本的网站、以及HoshinoV2</p><h2 id="附录-学校常用官网"><a href="#附录-学校常用官网" class="headerlink" title="附录 学校常用官网"></a>附录 学校常用官网</h2><ul><li><strong><a href="https://zs.dlut.edu.cn/">大连理工大学本科生招生网</a>，查看招生简章、录取分数等信息</strong></li><li><strong><a href="http://yx.dlut.edu.cn/">大连理工大学迎新网</a>，新生进行电子注册和查看通知</strong></li><li><strong><a href="https://sso.dlut.edu.cn/">智慧大工</a>，包括选课系统等线上办公系统，部分功能跟i大工app同步</strong></li><li><a href="https://www.dlut.edu.cn/">大连理工大学</a></li><li><a href="http://panjin.dlut.edu.cn/">大连理工大学盘锦校区</a></li><li><a href="http://info.dlut.edu.cn/index.htm">大连理工大学信息公开网</a></li><li><a href="http://job.dlut.edu.cn/index.html">大工就业网</a></li><li><a href="http://dutdice.dlut.edu.cn/">大连理工大学国际合作与交流处</a></li></ul><p>嘉禾连理 大工人最大的非官方论坛dutyard.com,欢迎大家来玩</p>          </div>]]></content>
    
    <summary type="html">
    
      Tips of Dalian University of Technology - Economic Development Area
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Crazy for Tools</title>
    <link href="https://augists.top/SELF/THINKING/Crazy-for-Tools/"/>
    <id>https://augists.top/SELF/THINKING/Crazy-for-Tools/</id>
    <published>2022-07-17T11:24:12.000Z</published>
    <updated>2022-07-17T12:42:00.807Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>最近开始有一些反思，自己对于一些工具性质的东西是否执着的太过了</p><p>就比如对 vim 来说，我一直非常坚定的认为，它通过三种模式让手可以不离开键盘中心区域就能完成大部分甚至全部工作。确实，这对我个人的效率而言，我觉得有很大帮助。但是，这可能并非是一个值得被发散到每一个人身上的东西。对于大部分 coder 来说，手不离开键盘这件事并不重要</p><p>最近认识一个在做 Linux 推广的学弟，能看得出他对于 Linux 的狂热，他希望能将 Linux 推广到每一个人。如果你问我，愿不愿意把 Linux 推广到每个普通用户，放在以前我可能会做。我把家里电脑换成 Manjaro，换成 Deepin，让我家人开始尝试用 Linux 发行版。但是放到现在，我反而对这件事情持保留态度</p><p>并非是因为年纪大了，没那么有热情了。恰恰相反，就我自己来说，接触 coding 这些东西也是在上大学之后，一些思想观念由于接触的时间短，容易发生变化，甚至整个推翻</p><div class="note danger">            <p>工具是给人用的，不同工具就意味着有不同的面向人群（市场）。对于一个比较完善的工具来说，可能并不存在好坏之分。他们的区别只有对你自己来说是否更适用，解决更多痛点，实现更多你需要的功能。</p>          </div><p>我觉得谁也不能评判 vim 和 emacs 就好于现在的 IDEs。没有人能说 markdown 和 org-mode 孰优孰劣，他们又比 word 甚至 LaTeX 强什么。同样，我们不能说 Linux 就比 Windows 适用于更多人，我并不认为已经到了 Linux 的易用性替代 Windows 的时候，并且从最初的想法来看，Linux 可能永远都没有办法替代</p><p>今天看到一篇文章，<a href="https://sspai.com/post/61029">对工具狂热的反思</a>。作者以笔记软件为切入点聊了对于双链等过于狂热大环境下的一些思考，正巧我今天也在和一个学弟说有关笔记软件的选择。作者举了一个例子还挺有意思的</p><blockquote><p>之后我也陷入了知识管理的军备竞赛中，频繁查看各种讨论群及论坛。老实说，这没什么好奇怪的，回想起我们第一次接触 Markdown 及 RSS 等工具时，也是一样的狂热，恨不得将所有用法、技巧收入囊中，如用 Markdown 做 PPT，写结构复杂的论文，用 RSS 浏览社交媒体、YouTube 等等，但最后，我们发现当 Markdown 如同 Word 一般融入生活，当使用 RSS 如同刷朋友圈一样习惯时，我们只需要最基本的功能就能极大的地提升效率。</p></blockquote><p>前两天给老师讲完论文，老师最后问了我一个问题。我为什么要用这种 markdown 形式的 PPT 工具。其实一开始决定用 <a href="https://github.com/maaslalani/slides">slides</a> 做这次的汇报，就是单纯想试试这个工具玩。我并不能下“markdown 转 ppt 比直接做 ppt 更高效”的结论，事实上，同样的一个 slide，我用目前用的 keynote 做的更快。（<a href="https://github.com/slidevjs/slidev">slidev</a> 对我来说更像是一个一边做 ppt，一边学学前端的工具</p><p>在对于一些需要图片甚至动画来辅助理解的事情上，用 keynote （或者 powerpoint）做演示文稿更高效、更有用，同时，它门槛低，上手简单。这是否意味着，有时候我过于为了追求小众而把路走的太极端了。它们只是工具，对我们这些使用者来说，区别应该是在于哪个更好用更听话，而不是哪个用的人少、功能更新奇</p><p>其实对于工具狂热并不是不好，就像我在一开始接触 mac 的半年多，疯狂的寻找、试用各种软件，然后自己比较，确定出最适合自己的那一个。在这之后，我就很少关注那些所谓的软件推荐了，因为我很明确的知道我已经找到了最适合我的工具，我对它们之间的区别和优劣已经很清楚了</p><p>回过头来，对于推广 Linux 这件事，除非涉及到政治因素，否则我想我不会为了能让更多人了解 Linux 而把它强推给别人了</p><hr><p>另外，我博客上线了 About 页面。目前的想法是在里面放一点我个人的一点点小信仰。现在里面应该写了我对于 <code>Less is more</code> 和 <code>Geek</code> 的解释，仅代表个人观点</p>          </div>]]></content>
    
    <summary type="html">
    
      Discussion about extremely crazy utility of tools on computer
    
    </summary>
    
    
    
      <category term="THINKING" scheme="https://augists.top/tags/THINKING/"/>
    
  </entry>
  
  <entry>
    <title>&lt;Paper Reading&gt; Fast BGP Simulation of Large Datacenters</title>
    <link href="https://augists.top/NOTES/PAPER/FastPlane/Fast%20BGP%20Simulation%20of%20Large%20Datacenters/"/>
    <id>https://augists.top/NOTES/PAPER/FastPlane/Fast%20BGP%20Simulation%20of%20Large%20Datacenters/</id>
    <published>2022-07-12T15:44:46.000Z</published>
    <updated>2022-09-07T08:26:24.937Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h1 id="Fast-BGP-Simulation-of-Large-Datacenters"><a href="#Fast-BGP-Simulation-of-Large-Datacenters" class="headerlink" title="Fast BGP Simulation of Large Datacenters"></a>Fast BGP Simulation of Large Datacenters</h1><blockquote><p>VMCAI 2019 (CCF B)</p><p>Nuno P. Lopes and Andrey Rybalchenko</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@inproceedings&#123;lopes2019fast,</span><br><span class="line">  title&#x3D;&#123;Fast BGP simulation of large datacenters&#125;,</span><br><span class="line">  author&#x3D;&#123;Lopes, Nuno P and Rybalchenko, Andrey&#125;,</span><br><span class="line">  booktitle&#x3D;&#123;International Conference on Verification, Model Checking, and Abstract Interpretation&#125;,</span><br><span class="line">  pages&#x3D;&#123;386--408&#125;,</span><br><span class="line">  year&#x3D;&#123;2019&#125;,</span><br><span class="line">  organization&#x3D;&#123;Springer&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[toc]</p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>outage 运行中断</p><p>misconfigurations, maintenance, upgrades, hardware and firmware failures -&gt; production datacenters outage</p><table><thead><tr><th>RIP</th><th>OSPF</th></tr></thead><tbody><tr><td>DV</td><td>LS</td></tr><tr><td>Floyd</td><td>Dijkstra</td></tr></tbody></table><table><thead><tr><th>OSPF</th><th>BGP</th></tr></thead><tbody><tr><td>IGP</td><td>EGP</td></tr><tr><td>easily configured</td><td>complex</td></tr><tr><td>Dijkstra</td><td>Best path selection</td></tr><tr><td>Speed first</td><td>Best</td></tr></tbody></table><ul><li><p>LS</p><ul><li>链路状态路由算法</li><li>每个节点都周期性的向网络上所有其它节点广播自己到邻居节点的距离。每个节点都具有完整的网络信息，即知道网络上每条边的距离。于是，每个节点都可以彼此独立的使用Dijkstra最短路径算法来计算到网络上其它节点的最短路径。</li></ul></li><li><p>边界网关协议 BGP (Border Gateway Protocol)</p><ul><li>一种实现自治系统AS（Autonomous System）之间的路由可达，并选择最佳路由的距离矢量路由协议</li><li>外部网关协议 EGP (Exterior Gateway Protocol): 在 AS 之间动态交换路由信息，只发布网络可达，不优选，不考虑环路避免等问题</li><li>路由优选、避免路由环路、更高效率的传递路由和维护大量的路由信息<ul><li>采用认证和GTSM的方式，保证了<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A7890/pages/DZE0811M/09/DZE0811M/09/resources/dc/dc_feature_bgp_0006.html">网络的安全性</a></li><li>提供了丰富的路由策略，能够灵活的进行<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A7890/pages/DZE0811M/09/DZE0811M/09/resources/dc/dc_feature_bgp_0007.html">路由选路</a></li><li>提供了<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A7890/pages/DZE0811M/09/DZE0811M/09/resources/dc/dc_feature_bgp_0010.html">路由聚合</a>和<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A7890/pages/DZE0811M/09/DZE0811M/09/resources/dc/dc_feature_bgp_0011.html">路由衰减</a>功能用于防止路由振荡，有效提高了网络的稳定性</li><li>用TCP作为其传输层协议（端口号为179），并支持<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A7890/pages/DZE0811M/09/DZE0811M/09/resources/dc/dc_feature_bgp_0012.html">BGP与BFD联动</a>、<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A7890/pages/DZE0811M/09/DZE0811M/09/resources/dc/dc_feature_bgp_0013.html">BGP Tracking</a>和<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A7890/pages/DZE0811M/09/DZE0811M/09/resources/dc/dc_feature_bgp_0020.html">BGP GR</a>，提高了网络的可靠性</li></ul></li><li>角色<ul><li>Speaker: 接收或产生新的报文信息，并发布（Advertise）给其它BGP Speaker</li><li>Peer: 相互交换报文的Speaker之间互称对等体（Peer）。若干相关的对等体可以构成对等体组（Peer Group）</li></ul></li><li>报文<ul><li>Open报文：用于建立BGP对等体连接</li><li>Update报文：用于在对等体之间交换路由信息</li><li>Notification报文：用于中断BGP连接</li><li>Keepalive报文：用于保持BGP连接，周期性发送</li><li>Route-refresh报文：用于在改变路由策略后请求对等体重新发送路由信息。只有支持路由刷新（Route-refresh）能力的BGP设备会发送和响应此报文</li></ul></li></ul></li></ul><p><img src="https://pic1.zhimg.com/80/v2-a60f360061dd3d41d12ca88a5ee8f0dc_1440w.jpg" alt=""></p><ul><li>RIB (route information base)<ul><li>维护每种协议的网络拓扑和路由表。这将包括许多到达相同目的地前缀的路由。</li></ul></li><li>FIB (forwarding information base)<ul><li>是从下推的RIB中可能的许多协议到快速转发查找内存的最佳路径的最佳路由。</li></ul></li></ul><p>FASTPLANE - based on Dijkstra</p><ul><li>is two orders of magnitude faster than the state-of-the-art on small and medium datacenters (快两个数量级)</li><li>goes beyond the state-of-the-art by scaling to large datacenters</li></ul><p>静态检查无法处理一些路由器固件层面上的bug，因此需要用动态的模拟来寻找问题</p><p>总结：提出了一种快速可拓展的BGP系统模拟算法，它需要数据中心路由策略有单调性，用路由报文而非权重计算出单源最短路。</p><h2 id="Datacenters-and-BGP"><a href="#Datacenters-and-BGP" class="headerlink" title="Datacenters and BGP"></a>Datacenters and BGP</h2><p>ASN (autonomous system number)</p><p>路径属性的词典顺序(这里用的是ASN) 替代 跳数</p><p>RIB根据配置初始化，根据新收到的前缀和unreachable更新</p><h2 id="Illustration"><a href="#Illustration" class="headerlink" title="Illustration"></a>Illustration</h2><h3 id="Prefix-Interaction"><a href="#Prefix-Interaction" class="headerlink" title="Prefix Interaction"></a>Prefix Interaction</h3><p><code>(router,prefix,AS path)</code> 代表要到达 router，下一跳 prefix，中转路径 AS path</p><p>WL 中不止一个时，选择优先级最高的 (we need to visit a most preferred advertisement first)</p><p>优先级由 BGP 最优路径选择算法得出，即更短的 AS path 优先级更高。但并不总是可以比较的</p><ul><li>算法被用于单路由？而FASTPLANE被用于处理属于不同路由的报文</li><li>AS path length 可能相等</li></ul><p>最终优先级<strong>先判断路径长度，在长度相同时选择 ASN 小的 (an auxiliary lexicographic order on names of routers)</strong></p><p>路由根据自己是否已经在 AS path 中来决定是否要 reject 收到的报文</p><p>R2 此时 RIB 中不空且 <code>24 &gt; 16</code>，进行 aggregation，生成新的 <code>a&#39;&#39; = (R2, 10.0.0.0/16, &lt;&gt;)</code> 作为种子 </p><p>最后将 RIB 中每个前缀的最优报文交给 FIB</p><h3 id="Globally-vs-Locally-Preferred-Advertisements"><a href="#Globally-vs-Locally-Preferred-Advertisements" class="headerlink" title="Globally vs. Locally Preferred Advertisements"></a>Globally vs. Locally Preferred Advertisements</h3><p>当同一路由出现两个甚至多个竞争的报文时，选取并替换 WL</p><p>为什么 R4 就会等 R1 发的包呢？(by propagating only globally optimal advertisements)</p><h3 id="Necessity-of-Monotonic-Increase-of-Preference"><a href="#Necessity-of-Monotonic-Increase-of-Preference" class="headerlink" title="Necessity of Monotonic Increase of Preference"></a>Necessity of Monotonic Increase of Preference</h3><p>FASTPLANE 需要路由节点的优先级越来越低 (the preference of a route advertisement at the destination router cannot be higher than the preference of the originating advertisement at the source router)，但是又要求单调增？？？(ensure monotonic increase of preference)</p><p>最终优先级的判断修改为<strong>先判断配置中的优先级 local pref，再判断路径长度，最后在路径长度相同时选择 ASN 较小的一个</strong> (the adver- tisement with the highest local preference is preferred. If advertisements have an equal value of the local preference attribute, then the advertisement with the shortest AS path is preferred)</p><p><code>(router,prefix,local pref,AS path)</code></p><h2 id="Future-Work"><a href="#Future-Work" class="headerlink" title="Future Work"></a>Future Work</h2><p>本文提出了一种计算路由表的算法，该算法仅适用于使用BGP的特定特征子集。需要进一步重新搜索，以拓宽和准确描述哪些特征集合（或多组）可以一起使用，并且仍然与拟议的算法（或类似的单调推理方法）兼容。</p><p>双重而言，需要进一步研究来描述要避免的协议功能，以支持高效的验证。此外，对是否/如何用单调特征取代非单调特征知之甚少。这不仅可以提高网络验证的效率，还可以加快生产网络的融合时间，因为撤回的广告会更少。</p><p>另一个途径是研究控制平面上的非确定性。有时不是总顺序，这意味着网络中可能存在不同的稳定状态。这有缺点，例如使故障排除变得更加困难。我们目前的原型故意以一致、确定性的方式计算单个稳定状态，以便结果可以重现。然而，这种稳定状态可能与真实网络稳定的状态不同。</p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><ul><li><p>第一个例子中RIB初始化后，如果R1和R3都为<code>10.0.0.0/24</code>，R2应该怎么办</p><ul><li>对于相同的前缀长度，incomparable -&gt; pick either of them arbitrarily</li><li>挨个运行？</li></ul></li><li><p>遍历种子列表、prefix 选择等过程像是由主节点选择</p><ul><li>猜测报文在每一步都返回到单源路由，由单源路由计算后再发出下一步？</li></ul></li><li><p>计算单源最优路径，计算过程是由路由计算异步传播还是有中心计算并将结果给路由节点</p><ul><li>节点自行计算<ul><li>By running BGP each datacenter router participates in a distributed best path computation, where information about the best paths is ex- changed between direct neighbors</li><li>transBGP函数的OutRouteMap返回值和InRouteMap</li></ul></li></ul></li><li><p>三个示例中修改使得非最优路径会提前发送</p><ul><li>在后文中看到好像是会撤回后续节点RIB中的非最优路径，保留出现最优路径歧义节点RIB中的存储</li></ul></li><li><p>only deal with transBGP that is monotonically increasing，增 or 减？</p><ul><li>In a network, monotonicity implies that the weight of a walk does not decrease when it is extended by a new link (Paper: <em>An Algebraic Theory of Dynamic Network Routing</em>)</li></ul></li><li><p>初始状态多个路由器的配置有冲突，且交叉点有距离</p><ul><li>4.4</li></ul></li></ul><h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.youtube.com/watch?v=_Z29ZzKeZHc">BGP Overview</a></p><p><a href="https://www.techtarget.com/searchnetworking/definition/BGP-Border-Gateway-Protocol">BGP</a></p><p><a href="https://www.cisco.com/c/zh_cn/support/docs/ip/border-gateway-protocol-bgp/5441-aggregation.pdf">了解 BGP 中的路由聚合</a></p><p><a href="https://www.cisco.com/c/zh_cn/support/docs/ip/border-gateway-protocol-bgp/13753-25.pdf">BGP 最佳路径选择算法</a></p><h3 id="Slide"><a href="#Slide" class="headerlink" title="Slide"></a>Slide</h3><hr><h1 id="Batfish"><a href="#Batfish" class="headerlink" title="Batfish"></a>Batfish</h1><h2 id="ACLs-and-firewalls"><a href="#ACLs-and-firewalls" class="headerlink" title="ACLs and firewalls"></a>ACLs and firewalls</h2><p>Analysis Access Control Lists (ACLs) and Firewall Rules are permitting and denying traffic as intended.</p><ul><li>manually checking these rules</li><li>loading them onto a lab device in order to test behaviors on example packets of interest</li></ul><p>-&gt;</p><ul><li>time consuming</li><li>error-prone</li></ul><p>Batfish</p><ul><li>testfilters<ul><li>find how a given flow is treated</li></ul></li><li>searchfilters<ul><li>get guarantees for large spaces of flows</li></ul></li><li>filterLineReachability<ul><li>find unreachable lines</li></ul></li></ul><h2 id="Provably-Safe-ACL-and-Firewall-Changes"><a href="#Provably-Safe-ACL-and-Firewall-Changes" class="headerlink" title="Provably Safe ACL and Firewall Changes"></a>Provably Safe ACL and Firewall Changes</h2><ul><li>block access to critical services</li><li>expose sensitive resources</li></ul><p>Batfish</p><ol><li>Ensure that the intended traffic is not already permitted<ul><li>searchfilters: permit or deny</li></ul></li><li>Ensure that the intended traffic is permitted in the candidate change</li><li>Ensure that no collateral damage has occurred<ul><li>nothing but the intended traffic is impacted by the candidate change</li></ul></li><li>Step 2 again</li><li>Step 3 again</li></ol><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>![](<a href="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Screen">https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/Screen</a> Shot 2022-07-20 at 21.28.52.png)</p><p>With Batfish and Pandas you can easily retrieve the exact information you are looking for from the routing tables on ANY or ALL network devices for ANY or ALL VRFs.<br>This concludes the notebook. To recap, in this notebook we covered the foundational tasks for route analysis:</p><ol><li>How to get routes at all nodes in the network or only at a subset of them</li><li>How to retrieve routing entries that match a specific protocol or metric</li><li>How to find which nodes have an entry for a prefix or which ones do not</li></ol><hr><h1 id="Deep-Thinking"><a href="#Deep-Thinking" class="headerlink" title="Deep Thinking"></a>Deep Thinking</h1><p>在一个较大型的数据中心里，应该不会大量使用优先级来过多的影响报文的传播顺序。在本文这样的对于优先级数值单调性非常敏感的情况，可能在实际使用中只会在较为边缘的地方出现优先级不单调的节点配置。这样的话，示例3中的由于节点优先级变为200导致需要撤回已经发送的数据报文的情况就会少且影响范围不大。并且，通过作者举的三个例子可以看到，（如果我们将数据中心网络看作树形），FastPlane的运行流程可以视为一种BFS。由源路由节点作为根，在没有优先级变化的情况下相当于向外逐层拓展，层中根据字典序遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DEFAULT_PREF <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    ASN        <span class="keyword">int</span></span><br><span class="line">    local_pref <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFS</span><span class="params">(n []Node)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(n) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(n, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="comment">// preference check</span></span><br><span class="line">        <span class="comment">// 1. local_pref</span></span><br><span class="line">        <span class="comment">// 2. AS path length (inside BFS)</span></span><br><span class="line">        <span class="comment">// 3. auxiliary lexicographic order</span></span><br><span class="line">        <span class="keyword">if</span> n[i].local_pref == n[j].local_pref &#123;</span><br><span class="line">            <span class="keyword">return</span> n[i].ASN &lt; n[j].ASN</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n[i].local_pref &lt; n[j].local_pref</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// if local preference of node is more than default preference</span></span><br><span class="line">    <span class="comment">// it will be the new root of BFS and run prior BFS on it</span></span><br><span class="line">    <span class="keyword">if</span> n[<span class="number">0</span>].local_pref &gt; DEFAULT_PREF &#123;</span><br><span class="line">        BFS(findNeighbor(n[<span class="number">0</span>]))</span><br><span class="line">        <span class="comment">// remove n[0] from queue for its local_pref</span></span><br><span class="line">        n = n[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// next BFS layer</span></span><br><span class="line">    queue := []Node&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, node := <span class="keyword">range</span> n &#123;</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, findNeighbor(node)...)</span><br><span class="line">    &#125;</span><br><span class="line">    BFS(queue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNeighbor</span><span class="params">(n Node)</span> []<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="comment">// return neighbors of n</span></span><br><span class="line">    <span class="keyword">return</span> []Node&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    source := Node&#123;ASN: <span class="number">1</span>&#125;</span><br><span class="line">    queue := []Node&#123;source&#125;</span><br><span class="line">    BFS(queue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用Go简单表述一下意思。当出现优先级大于默认值100的报文（在这里以节点代替）时，就会出现此节点的抢占情况。由此节点作为根开始抢占运行新的BFS，原优先级的BFS将会在新BFS运行结束后继续运行。</p><p>由于是BFS，且出现非默认优先级通常处于较为边缘的位置，就会出现三种情况：</p><ul><li>整个系统运行后期，出现高优先级报文<ul><li>由于影响较小，仅需要撤回很少的错误报文，造成的额外开销也很小</li></ul></li><li>整个系统运行初期，出现高优先级报文<ul><li>直接以高优先级报文作为新的根开始BFS，从源节点到高优先级报文的节点路径不需要修改，其他节点路径由新的BFS决定</li></ul></li><li>整个系统运行中期，在辐射网中间的边缘位置出现高优先级报文<ul><li>影响较大</li></ul></li></ul><p>从刚才的表述中可以看到，如果说在系统运行前先找出非默认优先级的配置节点，先做由源节点到非默认节点的路径，然后再从此节点开始运行系统就可以。</p><p>仍需要考虑：系统中可能出现100、150、200等多个不同的优先级配置。尽管配置优先级时可以人为控制此因素，但是仍需要考虑100-150-200的初始路径，以及多个200的情况。</p>          </div>]]></content>
    
    <summary type="html">
    
      Note taken down during reading process
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="BGP" scheme="https://augists.top/tags/BGP/"/>
    
      <category term="PAPER" scheme="https://augists.top/tags/PAPER/"/>
    
  </entry>
  
  <entry>
    <title>How to Choose a Suitable Laptop for Freshmen Majoring in Software Engineering</title>
    <link href="https://augists.top/SELF/SHARING/LIFE/how-to-choose-laptop/"/>
    <id>https://augists.top/SELF/SHARING/LIFE/how-to-choose-laptop/</id>
    <published>2022-07-10T11:57:55.000Z</published>
    <updated>2022-07-10T16:00:55.764Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <blockquote><p>这是一篇给远古时代装机猿的<a href="https://www.bilibili.com/video/BV1kZ4y1i7Le?spm_id_from=333.999.0.0&vd_source=970c58530383d2118b4d7ea7b310c0ca">活动</a>的投稿<br>整理了对于 DUT （尤其）软件学院及相似专业的同学对电脑的需求，希望能对相关专业的学生提供参考<br>装机猿的<a href="https://www.bilibili.com/video/BV1Ga411Q78p?spm_id_from=333.999.0.0&vd_source=970c58530383d2118b4d7ea7b310c0ca">活动整理</a><br>（希望我能如愿得到装机猿 T 恤</p></blockquote><hr><blockquote><p>整理了我和周围同学以及工作室里使用的情况</p><p>每个人情况不一样，需求也不同。主要包括三个方面：代码开发、图片视频制作、游戏</p><p>我本人用19款mbp13 次丐版+xbox+switch+云服务器，外接27寸4k60Hz显示器（带65W反向充电c口）（代表低端mac用户）</p><p>同学A用mbp14 次顶配+win 2019款Y7000P+ps5，外接27寸2k75Hz显示器（代表高端mac用户）</p><p>同学B用win游戏本ROG gl504gx（代表win用户）</p><p>同学C用win轻薄本联想Yoga14s（代表win用户）</p><p>同学D用win台式机+win轻薄本（代表普通台式机用户）</p><p>工作室里组的win台式机+NAS+树莓派等（有额外需求的台式机用户）</p><p><strong>需要提的是，计算机专业意味着肯定不会只用一个系统。不管是双系统还是虚拟机等方式，win需要装Linux，mac需要win或主机来打游戏</strong></p></blockquote><h2 id="你在哪所学校和专业"><a href="#你在哪所学校和专业" class="headerlink" title="你在哪所学校和专业"></a>你在哪所学校和专业</h2><p>所有人都来自 大连理工大学 软件学院</p><p>工作室为软件学院DV工作室，负责校区的海报、视频等工作</p><h2 id="平时会用到什么软件"><a href="#平时会用到什么软件" class="headerlink" title="平时会用到什么软件"></a>平时会用到什么软件</h2><ul><li><p>自己（轻度开发，web后端方向，科研）</p><ul><li>终端：Kitty+Terminal（大部分东西例如敲代码、文件管理啥的都转移到终端里了，非GUI）</li><li>浏览器：Safari+Chrome</li><li>聊天工具：QQ、微信、Telegram、腾讯会议等</li><li>敲代码的：终端、VScode、少量使用IDE（如PyCharm）（大型IDE吃配置）</li><li>窗口管理器：yabai+rectangle+amethyst</li><li>数据库：Navicat Premium</li><li>代码辅助：Dash等（不吃性能）</li><li>显示器辅助：smcFanControl（用于风扇超频，电脑接4k输出压力比较大）</li><li>虚拟化：Docker（较吃内存）</li><li>直播：OBS（吃cpu，但是电脑足够用）（用来推流xbox做直播和其他工作室直播）</li><li><strong>在使用Proteus和Altum Designer这种电路设计软件时，用的是别人的win电脑。不过本身专业对这个需求很小，且可以用机房电脑</strong></li><li><strong>matlab使用的是别人的win电脑，mac可以用但是不想让自己的mac受罪。专业对matlab有需求，但是方向上只要不做数模的特定位置就可以避开。我不觉得这个有影响</strong></li></ul></li><li><p>同学A（嵌入式开发转Java开发方向、视频制作、大型游戏）</p><ul><li>主用大型IDE，如IDEA，PyCharm等</li><li>PS、PR、AE、达芬奇等，win本剪辑性能已经不够用，只能满足轻度的视频工作</li><li>3A大作电脑已经不太能带动了，飞行模拟类也跑的很慢，最近刚转到ps5主机</li><li>嵌入式方向会用到例如keil等，需要用串口调试，需要各种接口齐全</li><li>软件学院嵌入式方向人数比较少，很少有人需要考虑这个</li></ul></li><li><p>同学B（轻度开发、产品策划方向、大型游戏）</p><ul><li>玩各种游戏，各种类型都玩。今年的游戏只能跑到1080p的40-50fps</li><li>大型IDE，Visual Studio、PyCharm、Android Studio等</li></ul></li><li><p>同学C（轻度开发、轻度科研、轻度游戏）</p><ul><li>打游戏能明显感觉到显卡带不起来，虽然有一块高清的屏幕但是打游戏还是只能1080p60</li><li>要这2k90只能看视频</li><li>简单开发足够，但是需要多注意一下，例如断电后除了轻度文档工作，基本不太能干啥了</li><li>整理的专业软件清单<ul><li>大一：Dev C++/Codeblock</li><li>大二：Visual Studio/Visual Studio Code</li><li>大三：Pycharm、IntelliJ IDEA/Eclipse</li><li>其他应用：Android Studio、VMWare、Proteus、MATLAB、AD</li></ul></li></ul></li><li><p>同学D（科研，后端开发）</p><ul><li>大型IDE，以Visual Studio、Visual Studio Code、PyCharm为主</li><li>跑深度学习，3060Ti不够用，比较慢，只能跑较简单的模型</li></ul></li><li><p>工作室（视频制作、大型游戏）</p><ul><li>轻度开发，偶尔使用大型IDE</li><li>以PS、PR、AE、达芬奇、LR等为主，在应付学校的海报、视频等设计工作时，正常工作勉强够用。有一次ps工程开大了，临时文件150G多，是搬到我自己的mbp上做的。基本上在达到<code>.psb</code>级别或者中度视频剪辑任务（4k60少轨道或1080p60多轨道）的时候，渲染开1/4就比较勉强。如果是个人的小活还是可以的</li></ul></li></ul><h2 id="需要什么配置"><a href="#需要什么配置" class="headerlink" title="需要什么配置"></a>需要什么配置</h2><ul><li>自己<ul><li>unix系的系统（mac或Linux）</li><li>16G+的内存，目前的内存影响较大，SWAP区有时候可以用到10G以上</li><li>显卡带的动外接4k显示器，雷电或USB4</li><li>CPU上没有遇到明显的瓶颈，编译速度慢这一点影响不大</li><li>存储比较小，自己还用到1T机械盘+500G固态盘（另外还有1T机械盘+1T专用固态拓展盘给xbox装游戏）</li></ul></li></ul><h2 id="装的啥配置"><a href="#装的啥配置" class="headerlink" title="装的啥配置"></a>装的啥配置</h2><ul><li><p>自己</p><ul><li>19款macbook pro 13<ul><li>8代i5 1.4GHz 四核</li><li>8G LPDDR3 2133MHz</li><li>Intel Iris Plus Graphics 645</li></ul></li></ul></li><li><p>同学A</p><ul><li><p>14寸macbook pro</p><ul><li>m1pro，10核中央处理器，14核图形处理器，16核神经网络引擎</li><li>32G统一内存</li><li>1T SSD</li></ul></li><li><p>19款联想Y9000P</p><ul><li>i7-9750H</li><li>8G</li><li>1T SSD</li><li>GTX 1660Ti</li><li>15.6英寸 1080p144Hz</li></ul></li></ul></li><li><p>同学B</p><ul><li>ROG gl504gx 19款</li></ul></li><li><p>同学C</p><ul><li><p>联想Yoga14s</p><ul><li>i5-11300H</li><li>MX450</li><li>2880p</li><li>他觉得是当时5k档最好的笔记本</li></ul></li><li><p>大学头两年有一个微星游戏本</p><ul><li>9代i7</li><li>1660Ti</li><li>南桥有问题修不好</li><li>嫌弃太沉，换了轻薄本</li></ul></li></ul></li><li><p>同学D</p><ul><li><p>台式机</p><ul><li>cpu i7 10700k 加九州风神360水冷</li><li>主板华硕TUFB56QQM-PWA</li><li>显卡 铭瑄电竞之心3060ti</li><li>内存海盗船16G*3200l两条</li><li>WD固态硬盘 1T 海盗船VS650</li></ul></li><li><p>轻薄本为19款华为matebook pro x</p><ul><li>散热大问题，CPU和主板也有问题，一般做轻度ppt、word等任务</li><li>触控屏很舒服，3000*2000分辨率</li></ul></li></ul></li><li><p>工作室</p><ul><li><p>台式机</p><ul><li>i5 6500</li><li>双1070，STI，偶尔接三1080p屏组 nvidia surround</li><li>4*8G内存条DDR4</li><li>其他配置已无法查证，电脑比较老，学校资产</li><li>这台电脑一直我在用</li><li>接群晖DS1511+，2T*5，用于工作室素材存储和工程备份</li></ul></li><li><p>树莓派4B</p><ul><li>4G内存，专门用做网络代理和简单Linux服务器</li><li>放在这里主要为了说<strong>专业内设备多而杂，入学买的电脑不代表固定死，需求的解决方案可以有很多</strong></li></ul></li></ul></li></ul><h2 id="如何进行优化"><a href="#如何进行优化" class="headerlink" title="如何进行优化"></a>如何进行优化</h2><ul><li><p>mac</p><ul><li>14寸macbook pro，m1pro+32G内存<ul><li>性能已经足够完美，同学A的这款学生优惠后2w，没有遇到过任何性能瓶颈（除了不能打游戏），开虚拟机也没有什么影响</li><li>唯一差的一点在于如果要走例如计算机视觉方向，对GPU需求会提高。一般可以用到实验室的服务器或者使用colab的免费显卡</li></ul></li><li>13寸新macbook air，m2<ul><li>对于刚入学的同学来说，不管哪一款mac的性能都已经足够了。可能内存需要加一下，尽量上16G内存或者更高（目前不清楚m2还会不会有刷内存的情况）</li></ul></li></ul></li><li><p>win</p><ul><li>买mac<ul><li>有非常多当时买了win，对打游戏需求没有特别大的同学都后悔没有买mac，并且大三出现了大面积换14寸或16寸mbp的情况</li><li>软件工程专业，基本可以无脑选mac，即便是后面想做AI方向，也可以通过其他方式补足</li></ul></li><li>游戏本<ul><li><strong>如果有游戏需求，按照游戏需求选就可以了</strong>。专业软件性能需求基本都可以满足，深度学习性能需求没有上限。所以根据游戏需求来就行</li><li>如果想要做硬件相关的，例如嵌入式方向，就需要找一个接口齐全的win本。通常被迫购买游戏本，还经常需要到处搬（很惨</li></ul></li><li>台式机<ul><li>台式机的同学说再给他一次机会，他一定买mac</li><li>深度学习的性能需求没有上限，而且对于大多数情况，都可以使用实验室的服务器来跑</li></ul></li></ul></li></ul>          </div>]]></content>
    
    <summary type="html">
    
      This is an analysis of the computer needs of software engineering students, and it encompasses most of the different computer needs around me.&lt;br&gt;Hopefully it will help you!
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Yan DP Analysis</title>
    <link href="https://augists.top/NOTES/CODE_LANGUAGE/Yan-DP-Analysis/"/>
    <id>https://augists.top/NOTES/CODE_LANGUAGE/Yan-DP-Analysis/</id>
    <published>2022-06-21T02:28:16.000Z</published>
    <updated>2022-06-21T03:29:37.454Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h1 id="闫氏DP分析法"><a href="#闫氏DP分析法" class="headerlink" title="闫氏DP分析法"></a>闫氏DP分析法</h1><p><img src="https://cdn.acwing.com/media/article/image/2020/03/23/27426_73d9c53a6c-2.png" alt=""></p><p><a href="https://www.acwing.com/activity/content/code/content/246257/">示例</a></p><h2 id="dp问题的下标"><a href="#dp问题的下标" class="headerlink" title="dp问题的下标"></a>dp问题的下标</h2><ol><li>若状态转移方程中有<code>dp[i - 1]</code>这种状态, 下标(状态转移那部分代码)尽量从1开始</li><li>否则就最好从0开始</li></ol><h2 id="dp问题的时间复杂度"><a href="#dp问题的时间复杂度" class="headerlink" title="dp问题的时间复杂度"></a>dp问题的时间复杂度</h2><p>状态数量(n^几个约束维度) * 转移状态的时间复杂(状态转移代码的时间复杂度)</p><h2 id="dp的集合划分依据-gt-寻找最后一个不同操作"><a href="#dp的集合划分依据-gt-寻找最后一个不同操作" class="headerlink" title="dp的集合划分依据 -&gt; 寻找最后一个不同操作"></a>dp的集合划分依据 -&gt; 寻找最后一个不同操作</h2><p>eg. 加不加这个背包, 数字三角形最后一步是由左边还是右边走过来的呀(根据操作的不同来对集合进行划分)<br>使得划分之后的小集合可以递推求出当前集合, 且最小集合已知</p><p>集合划分要不漏，但是不一定不重。当dp数组维护的特性是集合的max或min时，集合划分可以有重复（最长公共子序列）</p><ol><li><code>dp[i][j]</code>维护的是a字符串的前i个字符组成的字符串和b字符串前j个字符组成的字符串的公共子序列的最大长度，应该按照端点划分为：含不含a的第i个字符和含不含b的第j个字符，共分为四个部分。<code>dp[i][j-1]+dp[i-1][j]+dp[i-1][j-1]+1+dp[i-1][j-1]</code>大于<code>dp[i][j]</code></li><li>如果是求max或min的话，A和B集合有重合部分，同样只需要单独求后再取一次最值就可以</li></ol><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/406072/">链接</a></p>          </div>]]></content>
    
    <summary type="html">
    
      How to analyse DP problem?
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
  </entry>
  
  <entry>
    <title>Read and Write Mutex in Operating System</title>
    <link href="https://augists.top/NOTES/CODE_LANGUAGE/GOLANG/Read-and-Write-Mutex-in-Operating-System/"/>
    <id>https://augists.top/NOTES/CODE_LANGUAGE/GOLANG/Read-and-Write-Mutex-in-Operating-System/</id>
    <published>2022-05-15T10:51:38.000Z</published>
    <updated>2022-05-16T08:00:01.012Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在操作系统的进程管理中，会遇到有关同步和互斥的问题，其中读写就是一种非常经典的同步问题</p><p>通常我们在对数据访问权限进行限制时，会要求：</p><ul><li>写时不可读</li><li>写时不可写</li><li>读时不可写</li><li>读时可以读</li></ul><p>也就是说，为了防止不一致的情况出现，只会允许同时的读数据，而禁止其他的操作同时发生</p><h2 id="常规实现"><a href="#常规实现" class="headerlink" title="常规实现"></a>常规实现</h2><p>这里使用一个 <code>count</code> 记录正在进行读操作的进程数量，一个互斥量 <code>count_mutex</code> 用于对 <code>count</code> 加锁，一个互斥量 <code>data_mutex</code> 用于对读写操作的数据加锁<br>可以写出第一种进程读写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        read();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当有 reader 读（第一个 reader 进入后），会给 data 上锁，从而使得 writer 无法对数据进行修改。只有当所有 reader 都读完后，才会释放 <code>data_mutex</code> 锁。这就会导致当一直有读进程时，writer 无法拿到 <code>data_mutex</code> 锁，造成写饥饿<br>换种思路来理解，当 writer 因为没有拿到 <code>data_mutex</code> 锁而在排队等待时，reader 可以通过不拿锁进行插队</p><h2 id="读写公平"><a href="#读写公平" class="headerlink" title="读写公平"></a>读写公平</h2><p>那么，如何才能拒绝 reader 的插队，实现读写公平</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore balance = <span class="number">1</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;balance)</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        up(&amp;balance)</span><br><span class="line">        read();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;balance)</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">        up(&amp;balance)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过增加互斥量 <code>balance</code> 让 writer 在进入时先抢占 <code>balance</code> 锁，从而使后续到达的 reader 因为无法抢占到 <code>balance</code> 锁而排在 writer 后面无法插队，实现了读写的公平<br>这样，writer 到达后会等待前面的 reader 读完，将 <code>data_mutex</code> 释放后修改数据，即读写操作下的 FIFO</p><h2 id="深入和案例思考"><a href="#深入和案例思考" class="headerlink" title="深入和案例思考"></a>深入和案例思考</h2><p>但是，我觉得以上的讨论都没有把读写的频率和读写的消耗考虑进去。例如，在算法题中，如果对数据只进行少量修改，更多的需要读取时，我们会使用空间来换取时间，维护一个方便读的结构来提高效率<br>通常来说，读可能更重要，更普遍，而且更快，或者说需要它更快<br>举个<a href="https://www.bilibili.com/video/BV1kA4y1Q7tD?spm_id_from=333.337.search-card.all.click">之前看到的实例</a>。如果让你去构建一个 Twitter 后端，你如何设计后台的数据存储方式。你需要考虑，当用户量很大时，对于同一条推文的阅读会以数量级增多。<br>那么，可能会让推文的读提前拿出来交给所有的 followers，让他们能更快速的读，而不是去每个 following 看看是否有新的推文。这时，读就显得尤其重要，值得用空间来换取时间。这种情况下，读写锁就不再需要考虑公平，因为是一对一的读写<br>但是，如果这个人是个 follower 很大的用户，显然就无法将新推文维护到所有 followers 里。此时，就只能让每个 follower 都去他的 following 里读数据。这种情况下，读写锁就是一写N读。你需要考虑读带来的损耗，是否值得让所有读都去等待写进程的完成，写是否需要等待所有读都将锁释放掉再开始<br>分布式的存储是否可以将读写进行分离，从而不再需要读写锁，只进行分布式系统之间的同步<br>除此之外，脏读也是需要考虑的一环。如果读写的平衡是读可以无视写，仅读取旧数据，那是不是就会有不同的 follower 同时读到新旧不同的推文</p><h2 id="Copy-on-Write-机制"><a href="#Copy-on-Write-机制" class="headerlink" title="Copy-on-Write 机制"></a>Copy-on-Write 机制</h2><p>还有一种 Copy-on-Write 的方式来实现对于读写的分离，达到类似的效果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mutex_;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;data&gt; <span class="title">G_data</span><span class="params">(<span class="keyword">new</span> data())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;data&gt; Temp;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        Temp = G_data;</span><br><span class="line">    &#125;</span><br><span class="line">    Temp-&gt;read_something();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!G_data.unique())&#123;</span><br><span class="line">        G_data.reset(<span class="keyword">new</span> data(*G_data));</span><br><span class="line">    &#125;</span><br><span class="line">    G_data-&gt;write_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们现在有一个 ThreadA 为读线程，有一个 ThreadB 为写线程，ThreadA 去执行 <code>read()</code>, 其中首先把构造防止锁外, 减小锁的粒度以及保证异常安全, 在得到锁后进行赋值。<br>此时 <code>G_data</code> 引用计数为 2, 现在 ThreadA 执行至 <code>read_something()</code> 之前, guard 作用域之后<br>ThreadB 此时得到锁，进行 <code>unique()</code>, 因为 ThreadA 执行了拷贝, 所以 <code>unique()</code> 返回 false, 进入 if 中,这就是关键所在<br>进行拷贝, 并对 <code>G_data</code> 进行 <code>reset</code>, 此时两个线程持有的是不同的 <code>shared_ptr</code>, ThreadA 对旧数据进行读取, 而 ThreadB 对新数据进行修改, 这时显然其它再有的读线程无法持有锁, 其持有锁时 ThreadB 已经修改完毕，这样就做到了避免写锁中的饥饿问题<br>有些人看到后可能会觉得眼熟, 这其实类似于 linux 内核中的 RCU(read-copy-update) 锁, RCU 的核心理念其实就是读线程访问时，写线程可以去更新保护数据的副本，但写线程需要等待所有读线程完成读取后，才可以删除老对象</p><p>其实去年我的病毒学大作业中有一个就是 DirtyCOW 漏洞，通过 linux 中的 Copy-on-Write 机制的漏洞来实现提权，只是一直对 Copy-on-Write 机制不是很了解</p><h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p>在 Java8 中引入了一种新的机制，StampedLock 类，是对读写锁 ReentrantReadWriteLock 的增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = sl.writeLock();    <span class="comment">//涉及对共享资源的修改，使用写锁-独占操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sl.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用乐观读锁访问共享资源</span></span><br><span class="line"><span class="comment">     * 注意：乐观读锁在保证数据一致性上需要拷贝一份要操作的变量到方法栈，并且在操作数据时候可能其他写线程已经修改了数据，</span></span><br><span class="line"><span class="comment">     * 而我们操作的是方法栈里面的数据，也就是一个快照，所以最多返回的不是最新的数据，但是一致性还是得到保障的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = sl.tryOptimisticRead();    <span class="comment">// 使用乐观读锁</span></span><br><span class="line">        <span class="keyword">double</span> currentX = x, currentY = y;      <span class="comment">// 拷贝共享资源到本地方法栈中</span></span><br><span class="line">        <span class="keyword">if</span> (!sl.validate(stamp)) &#123;              <span class="comment">// 如果有写锁被占用，可能造成数据不一致，所以要切换到普通读锁模式</span></span><br><span class="line">            stamp = sl.readLock();             </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123; <span class="comment">// upgrade</span></span><br><span class="line">        <span class="comment">// Could instead start with optimistic, not read mode</span></span><br><span class="line">        <span class="keyword">long</span> stamp = sl.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp);  <span class="comment">//读锁转换为写锁</span></span><br><span class="line">                <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123;</span><br><span class="line">                    stamp = ws;</span><br><span class="line">                    x = newX;</span><br><span class="line">                    y = newY;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                    stamp = sl.writeLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sl.unlock(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try 系列获取锁的函数，当获取锁失败后会返回为 0 的 stamp 值。当调用释放锁和转换锁的方法时候需要传入获取锁时候返回的 stamp 值。<br>StampedLockd 的内部实现是基于 CLH 锁的，CLH 锁原理：锁维护着一个等待线程队列，所有申请锁且失败的线程都记录在队列。一个节点代表一个线程，保存着一个标记位 locked, 用以判断当前线程是否已经释放锁。当一个线程试图获取锁时，从队列尾节点作为前序节点，循环判断所有的前序节点是否已经成功释放锁。</p><p>可以看到，这里使用了乐观锁的概念。乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p><ul><li>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</li><li>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</li></ul><p>可以看到，示例中的 <code>distanceFromOrigin</code> 方法使用饿了乐观读锁，使得读写可以并发执行。乐观读也是在实现 Copy-on-Write 机制，它遵循以下模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.tryOptimisticRead();  <span class="comment">// 非阻塞获取版本信息</span></span><br><span class="line">copyVaraibale2ThreadMemory();           <span class="comment">// 拷贝变量到线程本地堆栈</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;              <span class="comment">// 校验</span></span><br><span class="line">    <span class="keyword">long</span> stamp = lock.readLock();       <span class="comment">// 获取读锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        copyVaraibale2ThreadMemory();   <span class="comment">// 拷贝变量到线程本地堆栈</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock(stamp);              <span class="comment">// 释放悲观锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">useThreadMemoryVarables();              <span class="comment">// 使用线程本地堆栈里面的数据进行操作</span></span><br></pre></td></tr></table></figure><h2 id="Golang-源码"><a href="#Golang-源码" class="headerlink" title="Golang 源码"></a>Golang 源码</h2><p>可以在 <code>/usr/local/go/src/sync</code> 中查看 rwmutex.go 的源码</p><blockquote><p>A RWMutex is a reader/writer mutual exclusion lock.<br>The lock can be held by an arbitrary number of readers or a single writer.<br>The zero value for a RWMutex is an unlocked mutex.</p></blockquote><p>可以在 Golang 的注释里看到，它采用的是读写公平的加锁方式</p><blockquote><p>If a goroutine holds a RWMutex for reading and another goroutine might<br>call Lock, no goroutine should expect to be able to acquire a read lock<br>until the initial read lock is released. In particular, this prohibits<br>recursive read locking. This is to ensure that the lock eventually becomes<br>available; a blocked Lock call excludes new readers from acquiring the<br>lock.</p></blockquote><p>其中对于 RWMutex 的定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w           Mutex  <span class="comment">// held if there are pending writers</span></span><br><span class="line">    writerSem   <span class="keyword">uint32</span> <span class="comment">// semaphore for writers to wait for completing readers</span></span><br><span class="line">    readerSem   <span class="keyword">uint32</span> <span class="comment">// semaphore for readers to wait for completing writers</span></span><br><span class="line">    readerCount <span class="keyword">int32</span>  <span class="comment">// number of pending readers</span></span><br><span class="line">    readerWait  <span class="keyword">int32</span>  <span class="comment">// number of departing readers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reader 的最大数量被定义为 <code>1 &lt;&lt; 30</code><br>而 happens-before 关系可以表示为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Unlock  -&gt; Lock:  readerSem</span><br><span class="line">Unlock  -&gt; RLock: readerSem</span><br><span class="line">RUnlock -&gt; Lock:  writerSem</span><br></pre></td></tr></table></figure><p>当读者进入后，会调用 <code>rw.w.Lock()</code>，使后续不再有读者可以读取数据，并通过</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line"><span class="comment">// Wait for active readers.</span></span><br><span class="line"><span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">    runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来等待当前的读进程的结束，而写进程完成后 <code>Unlock()</code> 将所有在等待中的 reader 唤醒</p><p>读进程 <code>RLock()</code> 在 <code>rw.w.state</code> 后，进行 <code>atomic.AddInt32(&amp;rw.readerCount, 1) &lt; 0</code> 的判断，如果有写进程正在执行，就会通过 runtime 把自己加入到读的等待队列中去</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#_2-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98">CS NOTE</a><br><a href="https://blog.csdn.net/wuli_xin/article/details/103794404">PV经典问题之读写者问题</a><br><a href="https://blog.csdn.net/weixin_43705457/article/details/104150455">读写锁中的饥饿问题</a><br><a href="https://cloud.tencent.com/developer/article/1470988">一篇文章搞定——JDK8中新增的StampedLock</a><br><a href="https://www.bilibili.com/video/BV1kA4y1Q7tD?spm_id_from=333.337.search-card.all.click">马斯克都要把twitter买了，要不来学一下twitter的架构？</a></p>          </div>]]></content>
    
    <summary type="html">
    
      How to write an optimized PV operation for reading and writing
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="OS" scheme="https://augists.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Pass Value or Reference in Golang</title>
    <link href="https://augists.top/NOTES/CODE_LANGUAGE/GOLANG/pass-value-or-reference-in-Golang/"/>
    <id>https://augists.top/NOTES/CODE_LANGUAGE/GOLANG/pass-value-or-reference-in-Golang/</id>
    <published>2022-04-19T05:35:35.000Z</published>
    <updated>2022-04-19T07:13:24.581Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>昨天在写 LeetCode 39 的时候，遇到了一个奇怪的问题，会自动让我的 <code>res</code> 在返回的时候发生变化<br>按照意思简单复原一下部分代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> r []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    res = [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    r = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    solve(<span class="number">5</span>)</span><br><span class="line">    fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solve</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    r = <span class="built_in">append</span>(r, i)</span><br><span class="line">    r[<span class="number">0</span>] = i</span><br><span class="line">    res = <span class="built_in">append</span>(res, r)</span><br><span class="line">    solve(i - <span class="number">1</span>)</span><br><span class="line">    r = r[:<span class="built_in">len</span>(r)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，最终输出的 <code>res</code> 里变量非常奇怪<br>这个情况主要由于 Golang 中的切片以及在函数参数传递的过程中发生的浅拷贝</p><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>我们可以把切片理解为一个结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice <span class="keyword">struct</span> &#123;</span><br><span class="line">  data  <span class="keyword">uintptr</span></span><br><span class="line">  <span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">  <span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片的浅拷贝是指，当它在赋值时，相当于创建了新的副本，结构体中的三个变量的值进行了复制。也就是说，虽然指向的是同一个 data 地址，并且 len 和 cap 都相同，但是从二级指针的角度来看，是一个新的变量了<br>而 append 虽然它直接被写成了汇编，但是它的实现是在切片存储的数据小于 1024 时进行 cap 翻倍，在大于时扩容到 1.25 倍。如果发生了切片的扩容，就会返回一个新开辟的内存空间用来存放数据；否则就会返回原地址</p><h2 id="Pass"><a href="#Pass" class="headerlink" title="Pass"></a>Pass</h2><p>对于 Golang 的函数传参是传值还是传引用一直都有争议。有人把变量分成了值类型和引用类型。但是实际上，通过上面对于 Slice 的拷贝可以看到，Golang 对于函数传参一直都是传值。但是值得注意的是，虽然在不发生扩容的情况下在函数中修改切片的内容会反馈到原切片（由于 data 指针），但是切片的 len 和 cap 都是在函数中创建了新的拷贝<br>也就是说，如果有如下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAppend</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  nums := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">  myAppend(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，尽管在 <code>myAppend</code> 中对于 nums 添加 1 成功反馈给了 <code>main</code> 中的 nums，但是由于 <code>main</code> 中 nums 的 len 仍为 3，所以如果这时输出 nums，会发现似乎对它并没有任何反馈的影响</p><hr><p>回到开头的例子。由于 res 可以看作二级指针，而 r 可以看作一级指针，这就导致对 r 仍然在 len 中的元素的修改会影响到最终的 res 的结果，而若由于 append 发生了扩容，后续就会使用新的切片地址，就不会对原切片产生影响</p>          </div>]]></content>
    
    <summary type="html">
    
      A discussion about passing to function in Golang origin from `res = append(res, r)`
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="GOLANG" scheme="https://augists.top/tags/GOLANG/"/>
    
  </entry>
  
  <entry>
    <title>Nil Pointer Error in Golang During webChat Development on Database</title>
    <link href="https://augists.top/SELF/ERROR/nil-pointer-error-in-golang-during-webChat-development-on-database/"/>
    <id>https://augists.top/SELF/ERROR/nil-pointer-error-in-golang-during-webChat-development-on-database/</id>
    <published>2022-03-26T03:19:08.000Z</published>
    <updated>2022-03-30T02:36:13.747Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>前几天在进行 <a href="https://github.com/Augists/webChat">webChat</a> 的 Server 端的数据库部分代码调试的时候，一直被一个奇怪的错误缠着。</p><p>我在前面全局变量里声明了数据库引擎的指针</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  DBdriver = <span class="string">&quot;mysql&quot;</span></span><br><span class="line">  DBinfo   = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">  DBengine *xorm.Engine</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后在数据库初始化时</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DBengine, err := xorm.NewEngine(DBdriver, DBinfo)</span><br></pre></td></tr></table></figure><p>因为 golang 在一定程度上对变量类型进行了弱化，添加了类似于 C++ 中的 auto 对类型进行自动判断，所以为了区分新变量，Go 中使用 <code>:=</code> 运算符作为新变量开辟并初始化的标志<br>例如这里，将 <code>xorm.NewEngine</code> 函数的返回值赋给新变量。由于 Go 中函数可以进行多返回值，当左值中存在新变量时，就需要使用 <code>:=</code><br>在这里就产生了歧义。err 是新的局部变量，同时 DBengine 也被编译器认为是新本地变量，这就使得这行代码并没有给全局的 DBengine 进行赋值<br>所以即使进行了初始化，全局变量中的 DBengine 依旧为 nil</p><p>解决的方法其实也不难，在这之前将 err 创建好就可以消除误解了</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">DBengine, err = xorm.NewEngine(DBdriver, DBinfo)</span><br></pre></td></tr></table></figure><p>这算一个比较隐性的 bug，不是很容易被发现。我感觉，这是由于 Go 对于语法及特性妥协导致的，这种情况必定会导致歧义，如果让编译器将这种情况处理为先去寻找是否有更高层级已经声明的变量 DBengine 并优先赋值，将会使得这种情况只能通过修改变量命名来解决局部与全局的冲突，亦或局部声明 <code>var DBengine *xorm.Engine</code><br>我感觉后一种逻辑更容易理解吧，想尝试在 Go 社区中提 issue 询问一下</p><p>解释：<br>当同一包名下存在多个文件时，如果 complier 在检索完局部变量后再去检索全局变量，并优先对全局变量赋值而不是创建新变量，那么如果在同名包的别的文件里对变量进行了定义，就会对 coder 造成很大的问题</p><p>详细内容可见<a href="https://forum.golangbridge.org/t/some-thought-about-while-creating-a-new-variable/26874/4">Go Forum</a></p>          </div>]]></content>
    
    <summary type="html">
    
      During the developing process of Database Engine of webChat, an undiscoverable error occured&lt;br&gt;and I blamed it on golang itself
    
    </summary>
    
    
    
      <category term="ERROR" scheme="https://augists.top/tags/ERROR/"/>
    
      <category term="CODE" scheme="https://augists.top/tags/CODE/"/>
    
      <category term="GOLANG" scheme="https://augists.top/tags/GOLANG/"/>
    
  </entry>
  
  <entry>
    <title>Watch Later or Store in History List</title>
    <link href="https://augists.top/SELF/SHARING/LIFE/watch-later-or-store-in-history-list/"/>
    <id>https://augists.top/SELF/SHARING/LIFE/watch-later-or-store-in-history-list/</id>
    <published>2022-02-03T15:57:55.000Z</published>
    <updated>2022-02-04T04:39:35.402Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>今天在 xbox 上看游戏的时候，突然有注意到一个“稍后再玩”的 list。同样在 b 站上，也有一个“稍后再看”的 list<br>其实 我早先的习惯是使用历史记录来做存储。如果看到一个想要保留的视频内容以后在看，我都是点进去看几秒确认一下就退出来，这样它就会自动被添加到历史记录里了。再加上有整理历史记录的习惯，偶尔进去把没用的删掉，提醒自己看完想看的视频<br>我的很多会员账号是与别人一起使用的，例如 Netflix，Apple Music 等等，定期清理历史记录对我而言既麻烦又有必要，所以这个习惯坚持了挺长时间的<br>它有一点问题，历史记录通常都不是无限长的，过于久远的历史记录会被清理掉，并且早期 b 站手机端是不能看到专栏的历史记录的，这也使得能够存储的条目莫名其妙的变少<br>现在开始使用“稍后再看”，但是里面只能存放 100 个，目前我一直是在 80 个左右“稍后再看”的视频<br>比较难受的一点是，如果想要把视频添加到“稍后再看”，需要点进视频，在没有最大化视频的情况下，点击右上角的三个点，选择添加到“稍后再看”，步骤非常繁琐<br>并且如果有空闲时间可以去看看自己之前存储过的视频时，在网页端，需要在收藏的最下面才能找到“稍后再看”列表。删除列表中刚刚看完的视频也需要从视频中退出来<br>我感觉，watch or play later 这个功能并没有像它名字那样美好，入口和常用功能都比较繁琐</p>          </div>]]></content>
    
    <summary type="html">
    
      When I have something to watch later, I should throw it into watch-later or store in history list&lt;br&gt; Compare these two
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Google RE2 Syntax</title>
    <link href="https://augists.top/NOTES/CODE_LANGUAGE/REGEX/RE2Syntax/"/>
    <id>https://augists.top/NOTES/CODE_LANGUAGE/REGEX/RE2Syntax/</id>
    <published>2022-01-20T06:37:37.000Z</published>
    <updated>2022-01-20T06:45:06.524Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>Regular expressions are a notation fordescribing sets of character strings.When a particular string is in the setdescribed by a regular expression,we often say that the regular expression<i>matches</i>the string.</p><p>The simplest regular expression is a single literal character.Except for the metacharacters like<code>*+?()|</code>,characters match themselves.To match a metacharacter, escape it witha backslash:<code>\+</code>matches a literal plus character.</p><p>Two regular expressions can be alternated or concatenated to form a newregular expression:if <i>e</i><sub>1</sub> matches<i>s</i>and <i>e</i><sub>2</sub> matches<i>t</i>,then <i>e</i><sub>1</sub><code>|</code><i>e</i><sub>2</sub> matches<i>s</i>or<i>t</i>,and<i>e</i><sub>1</sub><i>e</i><sub>2</sub>matches<i>st</i>.</p><p>The metacharacters<code>*</code>,<code>+</code>,and<code>?</code>are repetition operators:<i>e</i><sub>1</sub><code>*</code>matches a sequence of zero or more (possibly different)strings, each of which match <i>e</i><sub>1</sub>;<i>e</i><sub>1</sub><code>+</code>matches one or more;<i>e</i><sub>1</sub><code>?</code>matches zero or one.</p><p>The operator precedence, from weakest to strongest binding, isfirst alternation, then concatenation, and finally therepetition operators.Explicit parentheses can be used to force different meanings,just as in arithmetic expressions.Some examples:<code>ab|cd</code>is equivalent to<code>(ab)|(cd)</code>;<code>ab*</code>is equivalent to<code>a(b*)</code>.</p><p>The syntax described so far is most of the traditional Unix<i>egrep</i>regular expression syntax.This subset suffices to describe all regularlanguages: loosely speaking, a regular language is a setof strings that can be matched in a single pass throughthe text using only a fixed amount of memory.Newer regular expression facilities (notably Perl andthose that have copied it) have addedmany new operators and escape sequences, which make the regularexpressions more concise, and sometimes more cryptic, but usuallynot more powerful.</p><p>This page lists the regular expression syntax accepted by RE2.<p>It also lists some syntax accepted by PCRE, PERL, and VIM.<table><tr><th>kinds of single-character expressions</th><th>examples</th></tr><tr><td>any character, possibly including newline (s=true)</td><td><code>.</code></td></tr><tr><td>character class</td><td><code>[xyz]</code></td></tr><tr><td>negated character class</td><td><code>[^xyz]</code></td></tr><tr><td>Perl character class <a href="#perl">(link)</a></td><td><code>\d</code></td></tr><tr><td>negated Perl character class</td><td><code>\D</code></td></tr><tr><td>ASCII character class <a href="#ascii">(link)</a></td><td><code>[[:alpha:]]</code></td></tr><tr><td>negated ASCII character class</td><td><code>[[:^alpha:]]</code></td></tr><tr><td>Unicode character class (one-letter name)</td><td><code>\pN</code></td></tr><tr><td>Unicode character class</td><td><code>\p&#123;Greek&#125;</code></td></tr><tr><td>negated Unicode character class (one-letter name)</td><td><code>\PN</code></td></tr><tr><td>negated Unicode character class</td><td><code>\P&#123;Greek&#125;</code></td></tr></table><table><tr><th></th><th>Composites</th></tr><tr><td><code>xy</code></td><td><code>x</code> followed by <code>y</code></td></tr><tr><td><code>x|y</code></td><td><code>x</code> or <code>y</code> (prefer <code>x</code>)</td></tr></table><table><tr><th></th><th>Repetitions</th></tr><tr><td><code>x*</code></td><td>zero or more <code>x</code>, prefer more</td></tr><tr><td><code>x+</code></td><td>one or more <code>x</code>, prefer more</td></tr><tr><td><code>x?</code></td><td>zero or one <code>x</code>, prefer one</td></tr><tr><td><code>x&#123;n,m&#125;</code></td><td><code>n</code> or <code>n</code>+1 or ... or <code>m</code> <code>x</code>, prefer more</td></tr><tr><td><code>x&#123;n,&#125;</code></td><td><code>n</code> or more <code>x</code>, prefer more</td></tr><tr><td><code>x&#123;n&#125;</code></td><td>exactly <code>n</code> <code>x</code></td></tr><tr><td><code>x*?</code></td><td>zero or more <code>x</code>, prefer fewer</td></tr><tr><td><code>x+?</code></td><td>one or more <code>x</code>, prefer fewer</td></tr><tr><td><code>x??</code></td><td>zero or one <code>x</code>, prefer zero</td></tr><tr><td><code>x&#123;n,m&#125;?</code></td><td><code>n</code> or <code>n</code>+1 or ... or <code>m</code> <code>x</code>, prefer fewer</td></tr><tr><td><code>x&#123;n,&#125;?</code></td><td><code>n</code> or more <code>x</code>, prefer fewer</td></tr><tr><td><code>x&#123;n&#125;?</code></td><td>exactly <code>n</code> <code>x</code></td></tr><tr><td><font color='#808080'><code>x&#123;&#125;</code></font></td><td>(≡ <code>x*</code>) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>x&#123;-&#125;</code></font></td><td>(≡ <code>x*?</code>) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>x&#123;-n&#125;</code></font></td><td>(≡ <code>x&#123;n&#125;?</code>) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>x=</code></font></td><td>(≡ <code>x?</code>) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr></table><p>Implementation restriction: The counting forms <code>x&#123;n,m&#125;</code>, <code>x&#123;n,&#125;</code>, and <code>x&#123;n&#125;</code> reject forms that create a minimum or maximum repetition count above 1000. Unlimited repetitions are not subject to this restriction.<table><tr><th></th><th>Possessive repetitions</th></tr><tr><td><font color='#808080'><code>x*+</code></font></td><td>zero or more <code>x</code>, possessive <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>x++</code></font></td><td>one or more <code>x</code>, possessive <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>x?+</code></font></td><td>zero or one <code>x</code>, possessive <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>x&#123;n,m&#125;+</code></font></td><td><code>n</code> or ... or <code>m</code> <code>x</code>, possessive <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>x&#123;n,&#125;+</code></font></td><td><code>n</code> or more <code>x</code>, possessive <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>x&#123;n&#125;+</code></font></td><td>exactly <code>n</code> <code>x</code>, possessive <small>(NOT SUPPORTED)</small></td></tr></table><table><tr><th></th><th>Grouping</th></tr><tr><td><code>(re)</code></td><td>numbered capturing group (submatch)</td></tr><tr><td><code>(?P&lt;name&gt;re)</code></td><td>named & numbered capturing group (submatch)</td></tr><tr><td><font color='#808080'><code>(?&lt;name&gt;re)</code></font></td><td>named & numbered capturing group (submatch) <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?'name're)</code></font></td><td>named & numbered capturing group (submatch) <small>(NOT SUPPORTED)</small></td></tr><tr><td><code>(?:re)</code></td><td>non-capturing group</td></tr><tr><td><code>(?flags)</code></td><td>set flags within current group; non-capturing</td></tr><tr><td><code>(?flags:re)</code></td><td>set flags during re; non-capturing</td></tr><tr><td><font color='#808080'><code>(?#text)</code></font></td><td>comment <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?|x|y|z)</code></font></td><td>branch numbering reset <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?&gt;re)</code></font></td><td>possessive match of <code>re</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>re@&gt;</code></font></td><td>possessive match of <code>re</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>%(re)</code></font></td><td>non-capturing group <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr></table><p><a name="flags"></a></p><table><tr><th></th><th>Flags</th></tr><tr><td><code>i</code></td><td>case-insensitive (default false)</td></tr><tr><td><code>m</code></td><td>multi-line mode: <code>^</code> and <code>$</code> match begin/end line in addition to begin/end text (default false)</td></tr><tr><td><code>s</code></td><td>let <code>.</code> match <code>\n</code> (default false)</td></tr><tr><td><code>U</code></td><td>ungreedy: swap meaning of <code>x*</code> and <code>x*?</code>, <code>x+</code> and <code>x+?</code>, etc (default false)</td></tr></table><p>Flag syntax is <code>xyz</code> (set) or <code>-xyz</code> (clear) or <code>xy-z</code> (set <code>xy</code>, clear <code>z</code>).<table><tr><th></th><th>Empty strings</th></tr><tr><td><code>^</code></td><td>at beginning of text or line (<code>m</code>=true)</td></tr><tr><td><code>$</code></td><td>at end of text (like <code>\z</code> not <code>\Z</code>) or line (<code>m</code>=true)</td></tr><tr><td><code>\A</code></td><td>at beginning of text</td></tr><tr><td><code>\b</code></td><td>at ASCII word boundary (<code>\w</code> on one side and <code>\W</code>, <code>\A</code>, or <code>\z</code> on the other)</td></tr><tr><td><code>\B</code></td><td>not at ASCII word boundary</td></tr><tr><td><font color='#808080'><code>\g</code></font></td><td>at beginning of subtext being searched <small>(NOT SUPPORTED)</small> <small>PCRE</small></td></tr><tr><td><font color='#808080'><code>\G</code></font></td><td>at end of last match <small>(NOT SUPPORTED)</small> <small>PERL</small></td></tr><tr><td><font color='#808080'><code>\Z</code></font></td><td>at end of text, or before newline at end of text <small>(NOT SUPPORTED)</small></td></tr><tr><td><code>\z</code></td><td>at end of text</td></tr><tr><td><font color='#808080'><code>(?=re)</code></font></td><td>before text matching <code>re</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?!re)</code></font></td><td>before text not matching <code>re</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?&lt;=re)</code></font></td><td>after text matching <code>re</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?&lt;!re)</code></font></td><td>after text not matching <code>re</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>re&amp;</code></font></td><td>before text matching <code>re</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>re@=</code></font></td><td>before text matching <code>re</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>re@!</code></font></td><td>before text not matching <code>re</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>re@&lt;=</code></font></td><td>after text matching <code>re</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>re@&lt;!</code></font></td><td>after text not matching <code>re</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\zs</code></font></td><td>sets start of match (= \K) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\ze</code></font></td><td>sets end of match <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%^</code></font></td><td>beginning of file <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%$</code></font></td><td>end of file <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%V</code></font></td><td>on screen <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%#</code></font></td><td>cursor position <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%'m</code></font></td><td>mark <code>m</code> position <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%23l</code></font></td><td>in line 23 <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%23c</code></font></td><td>in column 23 <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%23v</code></font></td><td>in virtual column 23 <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr></table><table><tr><th></th><th>Escape sequences</th></tr><tr><td><code>\a</code></td><td>bell (≡ <code>\007</code>)</td></tr><tr><td><code>\f</code></td><td>form feed (≡ <code>\014</code>)</td></tr><tr><td><code>\t</code></td><td>horizontal tab (≡ <code>\011</code>)</td></tr><tr><td><code>\n</code></td><td>newline (≡ <code>\012</code>)</td></tr><tr><td><code>\r</code></td><td>carriage return (≡ <code>\015</code>)</td></tr><tr><td><code>\v</code></td><td>vertical tab character (≡ <code>\013</code>)</td></tr><tr><td><code>\*</code></td><td>literal <code>*</code>, for any punctuation character <code>*</code></td></tr><tr><td><code>\123</code></td><td>octal character code (up to three digits)</td></tr><tr><td><code>\x7F</code></td><td>hex character code (exactly two digits)</td></tr><tr><td><code>\x&#123;10FFFF&#125;</code></td><td>hex character code</td></tr><tr><td><code>\C</code></td><td>match a single byte even in UTF-8 mode</td></tr><tr><td><code>\Q...\E</code></td><td>literal text <code>...</code> even if <code>...</code> has punctuation</td></tr><tr><td><font color='#808080'><code>\1</code></font></td><td>backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\b</code></font></td><td>backspace <small>(NOT SUPPORTED)</small> (use <code>\010</code>)</td></tr><tr><td><font color='#808080'><code>\cK</code></font></td><td>control char ^K <small>(NOT SUPPORTED)</small> (use <code>\001</code> etc)</td></tr><tr><td><font color='#808080'><code>\e</code></font></td><td>escape <small>(NOT SUPPORTED)</small> (use <code>\033</code>)</td></tr><tr><td><font color='#808080'><code>\g1</code></font></td><td>backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\g&#123;1&#125;</code></font></td><td>backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\g&#123;+1&#125;</code></font></td><td>backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\g&#123;-1&#125;</code></font></td><td>backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\g&#123;name&#125;</code></font></td><td>named backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\g&lt;name&gt;</code></font></td><td>subroutine call <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\g'name'</code></font></td><td>subroutine call <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\k&lt;name&gt;</code></font></td><td>named backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\k'name'</code></font></td><td>named backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\lX</code></font></td><td>lowercase <code>X</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\ux</code></font></td><td>uppercase <code>x</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\L...\E</code></font></td><td>lowercase text <code>...</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\K</code></font></td><td>reset beginning of <code>$0</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\N&#123;name&#125;</code></font></td><td>named Unicode character <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\R</code></font></td><td>line break <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\U...\E</code></font></td><td>upper case text <code>...</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\X</code></font></td><td>extended Unicode sequence <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\%d123</code></font></td><td>decimal character 123 <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%xFF</code></font></td><td>hex character FF <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%o123</code></font></td><td>octal character 123 <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%u1234</code></font></td><td>Unicode character 0x1234 <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\%U12345678</code></font></td><td>Unicode character 0x12345678 <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr></table><table><tr><th></th><th>Character class elements</th></tr><tr><td><code>x</code></td><td>single character</td></tr><tr><td><code>A-Z</code></td><td>character range (inclusive)</td></tr><tr><td><code>\d</code></td><td>Perl character class</td></tr><tr><td><code>[:foo:]</code></td><td>ASCII character class <code>foo</code></td></tr><tr><td><code>\p&#123;Foo&#125;</code></td><td>Unicode character class <code>Foo</code></td></tr><tr><td><code>\pF</code></td><td>Unicode character class <code>F</code> (one-letter name)</td></tr></table><table><tr><th></th><th>Named character classes as character class elements</th></tr><tr><td><code>[\d]</code></td><td>digits (≡ <code>\d</code>)</td></tr><tr><td><code>[^\d]</code></td><td>not digits (≡ <code>\D</code>)</td></tr><tr><td><code>[\D]</code></td><td>not digits (≡ <code>\D</code>)</td></tr><tr><td><code>[^\D]</code></td><td>not not digits (≡ <code>\d</code>)</td></tr><tr><td><code>[[:name:]]</code></td><td>named ASCII class inside character class (≡ <code>[:name:]</code>)</td></tr><tr><td><code>[^[:name:]]</code></td><td>named ASCII class inside negated character class (≡ <code>[:^name:]</code>)</td></tr><tr><td><code>[\p&#123;Name&#125;]</code></td><td>named Unicode property inside character class (≡ <code>\p&#123;Name&#125;</code>)</td></tr><tr><td><code>[^\p&#123;Name&#125;]</code></td><td>named Unicode property inside negated character class (≡ <code>\P&#123;Name&#125;</code>)</td></tr></table><p><a name="perl"></a></p><table><tr><th></th><th>Perl character classes (all ASCII-only)</th></tr><tr><td><code>\d</code></td><td>digits (≡ <code>[0-9]</code>)</td></tr><tr><td><code>\D</code></td><td>not digits (≡ <code>[^0-9]</code>)</td></tr><tr><td><code>\s</code></td><td>whitespace (≡ <code>[\t\n\f\r ]</code>)</td></tr><tr><td><code>\S</code></td><td>not whitespace (≡ <code>[^\t\n\f\r ]</code>)</td></tr><tr><td><code>\w</code></td><td>word characters (≡ <code>[0-9A-Za-z_]</code>)</td></tr><tr><td><code>\W</code></td><td>not word characters (≡ <code>[^0-9A-Za-z_]</code>)</td></tr><tr><td><font color='#808080'><code>\h</code></font></td><td>horizontal space <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\H</code></font></td><td>not horizontal space <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\v</code></font></td><td>vertical space <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>\V</code></font></td><td>not vertical space <small>(NOT SUPPORTED)</small></td></tr></table><p><a name="ascii"></a></p><table><tr><th></th><th>ASCII character classes</th></tr><tr><td><code>[[:alnum:]]</code></td><td>alphanumeric (≡ <code>[0-9A-Za-z]</code>)</td></tr><tr><td><code>[[:alpha:]]</code></td><td>alphabetic (≡ <code>[A-Za-z]</code>)</td></tr><tr><td><code>[[:ascii:]]</code></td><td>ASCII (≡ <code>[\x00-\x7F]</code>)</td></tr><tr><td><code>[[:blank:]]</code></td><td>blank (≡ <code>[\t ]</code>)</td></tr><tr><td><code>[[:cntrl:]]</code></td><td>control (≡ <code>[\x00-\x1F\x7F]</code>)</td></tr><tr><td><code>[[:digit:]]</code></td><td>digits (≡ <code>[0-9]</code>)</td></tr><tr><td><code>[[:graph:]]</code></td><td>graphical (≡ <code>[!-~]</code> ≡ <code>[A-Za-z0-9!"#$%&amp;'()*+,\-./:;&lt;=&gt;?@[\\\]^_</code><code>`</code><code>&#123;|&#125;~]</code>)</td></tr><tr><td><code>[[:lower:]]</code></td><td>lower case (≡ <code>[a-z]</code>)</td></tr><tr><td><code>[[:print:]]</code></td><td>printable (≡ <code>[ -~]</code> ≡ <code>[ [:graph:]]</code>)</td></tr><tr><td><code>[[:punct:]]</code></td><td>punctuation (≡ <code>[!-/:-@[-</code><code>`</code><code>&#123;-~]</code>)</td></tr><tr><td><code>[[:space:]]</code></td><td>whitespace (≡ <code>[\t\n\v\f\r ]</code>)</td></tr><tr><td><code>[[:upper:]]</code></td><td>upper case (≡ <code>[A-Z]</code>)</td></tr><tr><td><code>[[:word:]]</code></td><td>word characters (≡ <code>[0-9A-Za-z_]</code>)</td></tr><tr><td><code>[[:xdigit:]]</code></td><td>hex digit (≡ <code>[0-9A-Fa-f]</code>)</td></tr></table><table><tr><th></th><th>Unicode character class names--general category</th></tr><tr><td><code>C</code></td><td>other</td></tr><tr><td><code>Cc</code></td><td>control</td></tr><tr><td><code>Cf</code></td><td>format</td></tr><tr><td><font color='#808080'><code>Cn</code></font></td><td>unassigned code points <small>(NOT SUPPORTED)</small></td></tr><tr><td><code>Co</code></td><td>private use</td></tr><tr><td><code>Cs</code></td><td>surrogate</td></tr><tr><td><code>L</code></td><td>letter</td></tr><tr><td><font color='#808080'><code>LC</code></font></td><td>cased letter <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>L&amp;</code></font></td><td>cased letter <small>(NOT SUPPORTED)</small></td></tr><tr><td><code>Ll</code></td><td>lowercase letter</td></tr><tr><td><code>Lm</code></td><td>modifier letter</td></tr><tr><td><code>Lo</code></td><td>other letter</td></tr><tr><td><code>Lt</code></td><td>titlecase letter</td></tr><tr><td><code>Lu</code></td><td>uppercase letter</td></tr><tr><td><code>M</code></td><td>mark</td></tr><tr><td><code>Mc</code></td><td>spacing mark</td></tr><tr><td><code>Me</code></td><td>enclosing mark</td></tr><tr><td><code>Mn</code></td><td>non-spacing mark</td></tr><tr><td><code>N</code></td><td>number</td></tr><tr><td><code>Nd</code></td><td>decimal number</td></tr><tr><td><code>Nl</code></td><td>letter number</td></tr><tr><td><code>No</code></td><td>other number</td></tr><tr><td><code>P</code></td><td>punctuation</td></tr><tr><td><code>Pc</code></td><td>connector punctuation</td></tr><tr><td><code>Pd</code></td><td>dash punctuation</td></tr><tr><td><code>Pe</code></td><td>close punctuation</td></tr><tr><td><code>Pf</code></td><td>final punctuation</td></tr><tr><td><code>Pi</code></td><td>initial punctuation</td></tr><tr><td><code>Po</code></td><td>other punctuation</td></tr><tr><td><code>Ps</code></td><td>open punctuation</td></tr><tr><td><code>S</code></td><td>symbol</td></tr><tr><td><code>Sc</code></td><td>currency symbol</td></tr><tr><td><code>Sk</code></td><td>modifier symbol</td></tr><tr><td><code>Sm</code></td><td>math symbol</td></tr><tr><td><code>So</code></td><td>other symbol</td></tr><tr><td><code>Z</code></td><td>separator</td></tr><tr><td><code>Zl</code></td><td>line separator</td></tr><tr><td><code>Zp</code></td><td>paragraph separator</td></tr><tr><td><code>Zs</code></td><td>space separator</td></tr></table><table><tr><th>Unicode character class names--scripts</th></tr><tr><td><code>Adlam</code></td></tr><tr><td><code>Ahom</code></td></tr><tr><td><code>Anatolian_Hieroglyphs</code></td></tr><tr><td><code>Arabic</code></td></tr><tr><td><code>Armenian</code></td></tr><tr><td><code>Avestan</code></td></tr><tr><td><code>Balinese</code></td></tr><tr><td><code>Bamum</code></td></tr><tr><td><code>Bassa_Vah</code></td></tr><tr><td><code>Batak</code></td></tr><tr><td><code>Bengali</code></td></tr><tr><td><code>Bhaiksuki</code></td></tr><tr><td><code>Bopomofo</code></td></tr><tr><td><code>Brahmi</code></td></tr><tr><td><code>Braille</code></td></tr><tr><td><code>Buginese</code></td></tr><tr><td><code>Buhid</code></td></tr><tr><td><code>Canadian_Aboriginal</code></td></tr><tr><td><code>Carian</code></td></tr><tr><td><code>Caucasian_Albanian</code></td></tr><tr><td><code>Chakma</code></td></tr><tr><td><code>Cham</code></td></tr><tr><td><code>Cherokee</code></td></tr><tr><td><code>Chorasmian</code></td></tr><tr><td><code>Common</code></td></tr><tr><td><code>Coptic</code></td></tr><tr><td><code>Cuneiform</code></td></tr><tr><td><code>Cypriot</code></td></tr><tr><td><code>Cypro_Minoan</code></td></tr><tr><td><code>Cyrillic</code></td></tr><tr><td><code>Deseret</code></td></tr><tr><td><code>Devanagari</code></td></tr><tr><td><code>Dives_Akuru</code></td></tr><tr><td><code>Dogra</code></td></tr><tr><td><code>Duployan</code></td></tr><tr><td><code>Egyptian_Hieroglyphs</code></td></tr><tr><td><code>Elbasan</code></td></tr><tr><td><code>Elymaic</code></td></tr><tr><td><code>Ethiopic</code></td></tr><tr><td><code>Georgian</code></td></tr><tr><td><code>Glagolitic</code></td></tr><tr><td><code>Gothic</code></td></tr><tr><td><code>Grantha</code></td></tr><tr><td><code>Greek</code></td></tr><tr><td><code>Gujarati</code></td></tr><tr><td><code>Gunjala_Gondi</code></td></tr><tr><td><code>Gurmukhi</code></td></tr><tr><td><code>Han</code></td></tr><tr><td><code>Hangul</code></td></tr><tr><td><code>Hanifi_Rohingya</code></td></tr><tr><td><code>Hanunoo</code></td></tr><tr><td><code>Hatran</code></td></tr><tr><td><code>Hebrew</code></td></tr><tr><td><code>Hiragana</code></td></tr><tr><td><code>Imperial_Aramaic</code></td></tr><tr><td><code>Inherited</code></td></tr><tr><td><code>Inscriptional_Pahlavi</code></td></tr><tr><td><code>Inscriptional_Parthian</code></td></tr><tr><td><code>Javanese</code></td></tr><tr><td><code>Kaithi</code></td></tr><tr><td><code>Kannada</code></td></tr><tr><td><code>Katakana</code></td></tr><tr><td><code>Kayah_Li</code></td></tr><tr><td><code>Kharoshthi</code></td></tr><tr><td><code>Khitan_Small_Script</code></td></tr><tr><td><code>Khmer</code></td></tr><tr><td><code>Khojki</code></td></tr><tr><td><code>Khudawadi</code></td></tr><tr><td><code>Lao</code></td></tr><tr><td><code>Latin</code></td></tr><tr><td><code>Lepcha</code></td></tr><tr><td><code>Limbu</code></td></tr><tr><td><code>Linear_A</code></td></tr><tr><td><code>Linear_B</code></td></tr><tr><td><code>Lisu</code></td></tr><tr><td><code>Lycian</code></td></tr><tr><td><code>Lydian</code></td></tr><tr><td><code>Mahajani</code></td></tr><tr><td><code>Makasar</code></td></tr><tr><td><code>Malayalam</code></td></tr><tr><td><code>Mandaic</code></td></tr><tr><td><code>Manichaean</code></td></tr><tr><td><code>Marchen</code></td></tr><tr><td><code>Masaram_Gondi</code></td></tr><tr><td><code>Medefaidrin</code></td></tr><tr><td><code>Meetei_Mayek</code></td></tr><tr><td><code>Mende_Kikakui</code></td></tr><tr><td><code>Meroitic_Cursive</code></td></tr><tr><td><code>Meroitic_Hieroglyphs</code></td></tr><tr><td><code>Miao</code></td></tr><tr><td><code>Modi</code></td></tr><tr><td><code>Mongolian</code></td></tr><tr><td><code>Mro</code></td></tr><tr><td><code>Multani</code></td></tr><tr><td><code>Myanmar</code></td></tr><tr><td><code>Nabataean</code></td></tr><tr><td><code>Nandinagari</code></td></tr><tr><td><code>New_Tai_Lue</code></td></tr><tr><td><code>Newa</code></td></tr><tr><td><code>Nko</code></td></tr><tr><td><code>Nushu</code></td></tr><tr><td><code>Nyiakeng_Puachue_Hmong</code></td></tr><tr><td><code>Ogham</code></td></tr><tr><td><code>Ol_Chiki</code></td></tr><tr><td><code>Old_Hungarian</code></td></tr><tr><td><code>Old_Italic</code></td></tr><tr><td><code>Old_North_Arabian</code></td></tr><tr><td><code>Old_Permic</code></td></tr><tr><td><code>Old_Persian</code></td></tr><tr><td><code>Old_Sogdian</code></td></tr><tr><td><code>Old_South_Arabian</code></td></tr><tr><td><code>Old_Turkic</code></td></tr><tr><td><code>Old_Uyghur</code></td></tr><tr><td><code>Oriya</code></td></tr><tr><td><code>Osage</code></td></tr><tr><td><code>Osmanya</code></td></tr><tr><td><code>Pahawh_Hmong</code></td></tr><tr><td><code>Palmyrene</code></td></tr><tr><td><code>Pau_Cin_Hau</code></td></tr><tr><td><code>Phags_Pa</code></td></tr><tr><td><code>Phoenician</code></td></tr><tr><td><code>Psalter_Pahlavi</code></td></tr><tr><td><code>Rejang</code></td></tr><tr><td><code>Runic</code></td></tr><tr><td><code>Samaritan</code></td></tr><tr><td><code>Saurashtra</code></td></tr><tr><td><code>Sharada</code></td></tr><tr><td><code>Shavian</code></td></tr><tr><td><code>Siddham</code></td></tr><tr><td><code>SignWriting</code></td></tr><tr><td><code>Sinhala</code></td></tr><tr><td><code>Sogdian</code></td></tr><tr><td><code>Sora_Sompeng</code></td></tr><tr><td><code>Soyombo</code></td></tr><tr><td><code>Sundanese</code></td></tr><tr><td><code>Syloti_Nagri</code></td></tr><tr><td><code>Syriac</code></td></tr><tr><td><code>Tagalog</code></td></tr><tr><td><code>Tagbanwa</code></td></tr><tr><td><code>Tai_Le</code></td></tr><tr><td><code>Tai_Tham</code></td></tr><tr><td><code>Tai_Viet</code></td></tr><tr><td><code>Takri</code></td></tr><tr><td><code>Tamil</code></td></tr><tr><td><code>Tangsa</code></td></tr><tr><td><code>Tangut</code></td></tr><tr><td><code>Telugu</code></td></tr><tr><td><code>Thaana</code></td></tr><tr><td><code>Thai</code></td></tr><tr><td><code>Tibetan</code></td></tr><tr><td><code>Tifinagh</code></td></tr><tr><td><code>Tirhuta</code></td></tr><tr><td><code>Toto</code></td></tr><tr><td><code>Ugaritic</code></td></tr><tr><td><code>Vai</code></td></tr><tr><td><code>Vithkuqi</code></td></tr><tr><td><code>Wancho</code></td></tr><tr><td><code>Warang_Citi</code></td></tr><tr><td><code>Yezidi</code></td></tr><tr><td><code>Yi</code></td></tr><tr><td><code>Zanabazar_Square</code></td></tr></table><table><tr><th></th><th>Vim character classes</th></tr><tr><td><font color='#808080'><code>\i</code></font></td><td>identifier character <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\I</code></font></td><td><code>\i</code> except digits <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\k</code></font></td><td>keyword character <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\K</code></font></td><td><code>\k</code> except digits <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\f</code></font></td><td>file name character <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\F</code></font></td><td><code>\f</code> except digits <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\p</code></font></td><td>printable character <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\P</code></font></td><td><code>\p</code> except digits <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\s</code></font></td><td>whitespace character (≡ <code>[ \t]</code>) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\S</code></font></td><td>non-white space character (≡ <code>[^ \t]</code>) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><code>\d</code></td><td>digits (≡ <code>[0-9]</code>) <small>VIM</small></td></tr><tr><td><code>\D</code></td><td>not <code>\d</code> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\x</code></font></td><td>hex digits (≡ <code>[0-9A-Fa-f]</code>) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\X</code></font></td><td>not <code>\x</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\o</code></font></td><td>octal digits (≡ <code>[0-7]</code>) <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\O</code></font></td><td>not <code>\o</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><code>\w</code></td><td>word character <small>VIM</small></td></tr><tr><td><code>\W</code></td><td>not <code>\w</code> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\h</code></font></td><td>head of word character <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\H</code></font></td><td>not <code>\h</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\a</code></font></td><td>alphabetic <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\A</code></font></td><td>not <code>\a</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\l</code></font></td><td>lowercase <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\L</code></font></td><td>not lowercase <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\u</code></font></td><td>uppercase <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\U</code></font></td><td>not uppercase <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\_x</code></font></td><td><code>\x</code> plus newline, for any <code>x</code> <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\c</code></font></td><td>ignore case <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\C</code></font></td><td>match case <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\m</code></font></td><td>magic <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\M</code></font></td><td>nomagic <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\v</code></font></td><td>verymagic <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\V</code></font></td><td>verynomagic <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr><tr><td><font color='#808080'><code>\Z</code></font></td><td>ignore differences in Unicode combining characters <small>(NOT SUPPORTED)</small> <small>VIM</small></td></tr></table><table><tr><th></th><th>Magic</th></tr><tr><td><font color='#808080'><code>(?&#123;code&#125;)</code></font></td><td>arbitrary Perl code <small>(NOT SUPPORTED)</small> <small>PERL</small></td></tr><tr><td><font color='#808080'><code>(??&#123;code&#125;)</code></font></td><td>postponed arbitrary Perl code <small>(NOT SUPPORTED)</small> <small>PERL</small></td></tr><tr><td><font color='#808080'><code>(?n)</code></font></td><td>recursive call to regexp capturing group <code>n</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?+n)</code></font></td><td>recursive call to relative group <code>+n</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?-n)</code></font></td><td>recursive call to relative group <code>-n</code> <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?C)</code></font></td><td>PCRE callout <small>(NOT SUPPORTED)</small> <small>PCRE</small></td></tr><tr><td><font color='#808080'><code>(?R)</code></font></td><td>recursive call to entire regexp (≡ <code>(?0)</code>) <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?&amp;name)</code></font></td><td>recursive call to named group <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?P=name)</code></font></td><td>named backreference <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?P&gt;name)</code></font></td><td>recursive call to named group <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?(cond)true|false)</code></font></td><td>conditional branch <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(?(cond)true)</code></font></td><td>conditional branch <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*ACCEPT)</code></font></td><td>make regexps more like Prolog <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*COMMIT)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*F)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*FAIL)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*MARK)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*PRUNE)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*SKIP)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*THEN)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*ANY)</code></font></td><td>set newline convention <small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*ANYCRLF)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*CR)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*CRLF)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*LF)</code></font></td><td><small>(NOT SUPPORTED)</small></td></tr><tr><td><font color='#808080'><code>(*BSR_ANYCRLF)</code></font></td><td>set \R convention <small>(NOT SUPPORTED)</small> <small>PCRE</small></td></tr><tr><td><font color='#808080'><code>(*BSR_UNICODE)</code></font></td><td><small>(NOT SUPPORTED)</small> <small>PCRE</small></td></tr></table>          </div>]]></content>
    
    <summary type="html">
    
      Google RE2 Syntax&lt;br&gt;RE2 is a fast, safe, thread-friendly alternative to backtracking regular expression engines
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="REGEX" scheme="https://augists.top/tags/REGEX/"/>
    
  </entry>
  
  <entry>
    <title>Why My Devices Cannot Automatically Connect to Mbp</title>
    <link href="https://augists.top/SELF/SHARING/LIFE/Why-my-devices-cannot-automatically-connect-to-mbp/"/>
    <id>https://augists.top/SELF/SHARING/LIFE/Why-my-devices-cannot-automatically-connect-to-mbp/</id>
    <published>2022-01-10T12:27:43.000Z</published>
    <updated>2022-01-10T13:00:39.981Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>早先的无线设备大多使用的是 2.4G 无线接收器来进行传输，例如之前使用的罗技 M370 和 ikbc poker，并且耳机也一直用着 3.5mm 的音频线，可以说对蓝牙真无线一直没有接触很多<br>自从去年换用了 HHKB，经常需要使用蓝牙来进行连接。前几天又买了罗技的 mx master 2s 作为在家里使用的过渡品，耳机也改为了无线蓝牙来进行传输，蓝牙自动连接的问题就一直在困扰着我</p><div class="note danger">            <p>为什么我在唤醒电脑之后，只有耳机自动连接了电脑，另外两个都无法连接</p>          </div><p>我们知道，在点击系统 menu bar 上的蓝牙小图标时，如果按住 <code>option</code> 再点，会显示详细信息；旧版本的系统在按住 <code>shift + option</code> 点击时，可以重置蓝牙模块（现在好像没有了<br>恰巧我再查看的时候，注意到我的电脑蓝牙开关下有一行小字写着 <code>Discoverable: off</code><br>我就感觉不是很对劲</p><p>根据 ssh 心跳包的理解，我们可以猜测，耳机由于没有关机并且是音频设备，可能会一直用心跳包来维持蓝牙的连接<br>而键盘和鼠标都有长时间不用自动断电的功能<br>由于 mac 的蓝牙被设定为不可以被发现，所以当电脑不是主动去发现并连接设备时，设备的主动尝试连接失效</p><p>解决方案是：可以在 <code>系统偏好设置 - Sharing - Bluetooth Sharing</code> 将其勾选打开，这样电脑就允许被其他设备通过蓝牙进行扫描发现了</p>          </div>]]></content>
    
    <summary type="html">
    
      After getting more wireless connectivity devices, I have unfortunately found that my Bluetooth devices have a high probability of not connecting every time I wake up my Macbook Pro.&lt;br&gt; At first I thought it was the fault of HHKB, but now I am temporarily a fan of bluetooth wireless&lt;br&gt; I bought a Logi master 2s as my new mouse to cope with the use of scenarios at home&lt;br&gt; Also my Audio-Technica headphones also changed to wireless mode&lt;br&gt; Just now I wake up my mac and only headphones connected&lt;br&gt; It really bothered me for a long time
    
    </summary>
    
    
    
      <category term="MAC" scheme="https://augists.top/tags/MAC/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>AODV Analysis</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/AODV-Source-Code-Analysis/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/AODV-Source-Code-Analysis/</id>
    <published>2022-01-03T15:26:34.000Z</published>
    <updated>2022-01-03T15:31:07.219Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h1 id="AODV-协议基本原理及工作流程"><a href="#AODV-协议基本原理及工作流程" class="headerlink" title="AODV 协议基本原理及工作流程"></a>AODV 协议基本原理及工作流程</h1><h2 id="AODV-简介"><a href="#AODV-简介" class="headerlink" title="AODV 简介"></a>AODV 简介</h2><blockquote><p>The Ad hoc On-Demand Distance Vector (AODV) algorithm enables<br>dynamic, self-starting, multihop routing between participating mobile<br>nodes wishing to establish and maintain an ad hoc network.  AODV<br>allows mobile nodes to obtain routes quickly for new destinations,<br>and does not require nodes to maintain routes to destinations that<br>are not in active communication.  AODV allows mobile nodes to respond<br>to link breakages and changes in network topology in a timely manner.<br>The operation of AODV is loop-free, and by avoiding the Bellman-Ford<br>“counting to infinity” problem offers quick convergence when the ad<br>hoc network topology changes (typically, when a node moves in the<br>network).  When links break, AODV causes the affected set of nodes to<br>be notified so that they are able to invalidate the routes using the<br>lost link.</p></blockquote><p>One distinguishing feature of AODV is its use of a destination<br>sequence number for each route entry.  The destination sequence<br>number is created by the destination to be included along with any<br>route information it sends to requesting nodes.  Using destination<br>sequence numbers ensures loop freedom and is simple to program.<br>Given the choice between two routes to a destination, a requesting<br>node is required to select the one with the greatest sequence number.</p><p>AODV uses the following fields with each route table entry:</p><ul><li>Destination IP Address</li><li>Destination Sequence Number</li><li>Valid Destination Sequence Number flag</li><li>Other state and routing flags (e.g., valid, invalid, repairable, being repaired)</li><li>Network Interface</li><li>Hop Count (number of hops needed to reach destination)</li><li>Next Hop</li><li>List of Precursors (described in Section 6.2)</li><li>Lifetime (expiration or deletion time of the route)</li></ul><hr><h2 id="AODV-特点"><a href="#AODV-特点" class="headerlink" title="AODV 特点"></a>AODV 特点</h2><ul><li>接入速度快</li><li>计算量小</li><li>内存占用低</li><li>网络负载轻</li></ul><p>疑问🤔️：AODV 协议通过管理 sequence number 来在有多个有效路由的情况下进行决策，每使用过一次 sequence number+1，并以此来表示节点的新鲜程度，选择 sequence number 较大的有效路由。这样难道不会导致积压、增大负载吗？感觉并不是一个合理的方案</p><hr><h2 id="AODV-Message-Type"><a href="#AODV-Message-Type" class="headerlink" title="AODV Message Type"></a>AODV Message Type</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* AODV Message types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_HELLO 0 <span class="comment">/* Really never used as a separate type... */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_RREQ 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_RREP 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_RERR 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_RREP_ACK 4</span></span><br></pre></td></tr></table></figure><hr><h2 id="AODV-文件树分析"><a href="#AODV-文件树分析" class="headerlink" title="AODV 文件树分析"></a>AODV 文件树分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── ChangeLog</span><br><span class="line">├── GPL</span><br><span class="line">├── Makefile</span><br><span class="line">├── README</span><br><span class="line">├── README.ns</span><br><span class="line">├── TODO</span><br><span class="line">├── aodv_hello.c</span><br><span class="line">├── aodv_hello.h</span><br><span class="line">├── aodv_neighbor.c</span><br><span class="line">├── aodv_neighbor.h</span><br><span class="line">├── aodv_rerr.c</span><br><span class="line">├── aodv_rerr.h</span><br><span class="line">├── aodv_rrep.c</span><br><span class="line">├── aodv_rrep.h</span><br><span class="line">├── aodv_rreq.c</span><br><span class="line">├── aodv_rreq.h</span><br><span class="line">├── aodv_socket.c</span><br><span class="line">├── aodv_socket.h</span><br><span class="line">├── aodv_timeout.c</span><br><span class="line">├── aodv_timeout.h</span><br><span class="line">├── debug.c</span><br><span class="line">├── debug.h</span><br><span class="line">├── defs.h</span><br><span class="line">├── endian.c</span><br><span class="line">├── list.c</span><br><span class="line">├── list.h</span><br><span class="line">├── llf.c</span><br><span class="line">├── llf.h</span><br><span class="line">├── lnx</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── TAGS</span><br><span class="line">│   ├── kaodv-debug.c</span><br><span class="line">│   ├── kaodv-debug.h</span><br><span class="line">│   ├── kaodv-expl.c</span><br><span class="line">│   ├── kaodv-expl.h</span><br><span class="line">│   ├── kaodv-ipenc.c</span><br><span class="line">│   ├── kaodv-ipenc.h</span><br><span class="line">│   ├── kaodv-mod.c</span><br><span class="line">│   ├── kaodv-mod.h</span><br><span class="line">│   ├── kaodv-netlink.c</span><br><span class="line">│   ├── kaodv-netlink.h</span><br><span class="line">│   ├── kaodv-queue.c</span><br><span class="line">│   ├── kaodv-queue.h</span><br><span class="line">│   └── kaodv.h</span><br><span class="line">├── locality.c</span><br><span class="line">├── locality.h</span><br><span class="line">├── main.c</span><br><span class="line">├── nl.c</span><br><span class="line">├── nl.h</span><br><span class="line">├── params.h</span><br><span class="line">├── patches</span><br><span class="line">│   ├── ns-2.26-aodv-uu-0.8.patch</span><br><span class="line">│   ├── ns-2.27-aodv-uu-0.8.patch</span><br><span class="line">│   ├── ns-2.27-aodv-uu-0.9.1.patch</span><br><span class="line">│   ├── ns-2.27-aodv-uu-0.9.patch</span><br><span class="line">│   ├── ns-2.28-aodv-uu-0.9.1.patch</span><br><span class="line">│   ├── ns-2.29-aodv-uu-0.9.1-dsr-uu-0.2-oolsr-0.99.15.patch</span><br><span class="line">│   ├── ns-2.29.3-aodv-uu-0.9.2.patch</span><br><span class="line">│   └── ns-2.32-aodv-uu.patch</span><br><span class="line">├── rfc3561.txt</span><br><span class="line">├── routing_table.c</span><br><span class="line">├── routing_table.h</span><br><span class="line">├── seek_list.c</span><br><span class="line">├── seek_list.h</span><br><span class="line">├── tags</span><br><span class="line">├── timer_queue.c</span><br><span class="line">└── timer_queue.h</span><br><span class="line"></span><br><span class="line">2 directories, 65 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过在 AODV 项目根目录下运行 <code>tree</code> 可以得到如上面代码块中的结果。项目中共有65个文件，其中通过分析 Makefile 文件中的编译链接方式我们可以看到，AODV 项目共提供了两大方向，分别为 ns-2 模拟器运行和实际运行服务。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SRC =  main.c list.c debug.c timer_queue.c aodv_socket.c aodv_hello.c \</span><br><span class="line">  aodv_neighbor.c aodv_timeout.c routing_table.c seek_list.c \</span><br><span class="line">  aodv_rreq.c aodv_rrep.c aodv_rerr.c nl.c</span><br><span class="line"></span><br><span class="line">SRC_NS =   debug.c list.c timer_queue.c aodv_socket.c aodv_hello.c \</span><br><span class="line">    aodv_neighbor.c aodv_timeout.c routing_table.c seek_list.c \</span><br><span class="line">    aodv_rreq.c aodv_rrep.c aodv_rerr.c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里，SRC 是为实际运行使用的 c 文件，而 SRC_NS 是在 NS 模拟器中编译需要使用的文件。在这次对 AODV 源代码分析的过程中，我们只关注于它运用在实践中的代码部分。所以不仅是 SRC_NS 的文件，在 SRC 的文件中如果遇到例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NS_PORT</span></span><br><span class="line"><span class="comment">/* code */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>我们都可以将其化简。</p><p>这样，我们将所有需要查看的源代码文件根据我们定下的阅读顺序进行了分类，如下表所示：</p><ul><li>Preparation<ul><li>params.h: AODV 运行时的参数定义</li><li>defs.h: 包含了 AODV 代码中的主要宏定义，例如 <code>MINTTL</code>、AODV message type 等全局宏定义，以及对主机和网卡设备的信息结构体 <code>host_info</code> 和<code>dev_info</code></li><li>list.{c|h}: 对循环双链表结构 <code>list_t</code> 的定义及操作</li><li>timer_queue.{c|h}: 定时器 <code>timer</code> 的定义及操作，依托于 <code>list_t</code> 循环双链表进行串联</li><li>routing_table.{c|h}: 路由表的定义及操作</li><li>endian.c: 对于硬件和操作系统的大小端的定义，被应用于 aodv 结构体内变量顺序</li></ul></li><li>AODV Message<ul><li>aodv_hello.{c|h}: </li><li>aodv_neighbor.{c|h}:</li><li>aodv_rreq.{c|h}:</li><li>aodv_rrep.{c|h}:</li><li>aodv_rerr.{c|h}:</li><li>aodv_socket.{c|h}:</li><li>aodv_timeout.{c|h}:</li></ul></li><li>Main<ul><li>llf.{c|h}: 链路层反馈</li><li>locality.{c|h}: 寻找目的地的方位</li><li>nl.{c|h}: AODV 协议专用套接字</li><li>seek_list.{c|h}: RREQ寻找的目的地链表</li><li>main.c: 协议初始化和运行</li></ul></li></ul><hr><h2 id="define-do-while-0"><a href="#define-do-while-0" class="headerlink" title="#define do while (0)"></a><code>#define do while (0)</code></h2><p><a href="https://www.linuxidc.com/Linux/2014-10/108520.htm">C语言宏定语执行多条语句一般都会用 do { … } while (0)</a></p><hr><h2 id="list-c"><a href="#list-c" class="headerlink" title="list.c"></a><code>list.c</code></h2><ul><li><code>list.c</code> 文件是所有<strong>循环双链表</strong> 操作，有一个空的头节点 head<ul><li><code>listelm_detach</code>: 把两个参数的节点连接起来</li><li><code>listelm_add</code>: 第一个参数的节点添加到后两个节点中间</li><li><code>list_add</code>: 插入头节点之后的那个位置</li><li><code>list_add_tail</code>: 相当于插入tail位置</li><li><code>list_detach</code>: 把参数中的节点删除</li></ul></li></ul><blockquote><p>所有 <code>list_t *le</code> 都全名是 list element</p></blockquote><hr><h2 id="Log-Path"><a href="#Log-Path" class="headerlink" title="Log Path"></a>Log Path</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_LOG_PATH <span class="meta-string">&quot;/var/log/aodvd.log&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_RT_LOG_PATH <span class="meta-string">&quot;/var/log/aodvd.rtlog&quot;</span></span></span><br></pre></td></tr></table></figure><hr><h2 id="defs-h"><a href="#defs-h" class="headerlink" title="defs.h"></a><code>defs.h</code></h2><ul><li><p><code>defs.h</code></p><ul><li><p>host 主机, dev 网卡</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Data for a network device */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> enabled; <span class="comment">/* 1 if struct is used, else 0 */</span></span><br><span class="line">    <span class="keyword">int</span> sock;    <span class="comment">/* AODV socket associated with this device */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GATEWAY</span></span><br><span class="line">    <span class="keyword">int</span> psock; <span class="comment">/* Socket to send buffered data packets. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ifindex;</span><br><span class="line">    <span class="keyword">char</span> ifname[IFNAMSIZ];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ipaddr</span>;</span>  <span class="comment">/* The local IP address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">netmask</span>;</span> <span class="comment">/* The netmask we use */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">broadcast</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">host_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> seqno;           <span class="comment">/* Sequence number */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">bcast_time</span>;</span> <span class="comment">/* The time of the last broadcast msg sent */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">fwd_time</span>;</span>   <span class="comment">/* The time a data packet was last forwarded */</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> rreq_id;         <span class="comment">/* RREQ id */</span></span><br><span class="line">    <span class="keyword">int</span> nif;                   <span class="comment">/* Number of interfaces to broadcast on */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_info</span></span></span><br><span class="line"><span class="class">        <span class="title">devs</span>[<span class="title">MAX_NR_INTERFACES</span> +</span></span><br><span class="line"><span class="class">             1];</span> <span class="comment">/* Add +1 for returning as &quot;error&quot; in ifindex2devindex. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>host_info</code> 中存储 <code>def_info</code> 数组，多开了一个位置 <code>(MAX_NR_INTERFACES+1)</code>，让函数返回错误时使用，来代表 error</p></li><li><p><code>ifindex</code> 全称是 network interface index</p></li><li><p>对 <code>AODV_msg</code> 结构体进行简化后为</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">u_int8_t</span> type;</span><br><span class="line">&#125; AODV_msg;</span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* An generic AODV extensions header */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> type;</span><br><span class="line">    <span class="keyword">u_int8_t</span> length;</span><br><span class="line">    <span class="comment">/* Type specific data follows here */</span></span><br><span class="line">&#125; AODV_ext;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="对-list-t-和-timer-嵌套结构体的理解"><a href="#对-list-t-和-timer-嵌套结构体的理解" class="headerlink" title="对 list_t 和 timer 嵌套结构体的理解"></a>对 <code>list_t</code> 和 <code>timer</code> 嵌套结构体的理解</h2><p><img src="https://s2.loli.net/2021/12/12/ZitwIevknBAWyQ6.jpg" alt="timer通过list_t实现循环双链表"></p><hr><h2 id="timeval-结构体在不同系统中的不同定义"><a href="#timeval-结构体在不同系统中的不同定义" class="headerlink" title="timeval 结构体在不同系统中的不同定义"></a><code>timeval</code> 结构体在不同系统中的不同定义</h2><ul><li><p>在 Linux 中<code>time.h</code>库文件内</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">__time_t</span> tv_sec;        <span class="comment">/* Seconds. */</span></span><br><span class="line"><span class="keyword">__suseconds_t</span> tv_usec;  <span class="comment">/* Microseconds. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在 macOS 中</p><ul><li><p>util_ldap.h</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> timeval l_timeval</span></span><br></pre></td></tr></table></figure></li><li><p>time.h</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure used as a parameter by getitimer(2) and setitimer(2) system</span></span><br><span class="line"><span class="comment"> * calls.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">itimerval</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span>  <span class="title">timeval</span> <span class="title">it_interval</span>;</span>    <span class="comment">/* timer interval */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span>  <span class="title">timeval</span> <span class="title">it_value</span>;</span>       <span class="comment">/* current value */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>clock_types.h</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Normal time specification used by the kernel clock facility.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_timespec</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>    tv_sec;                 <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="keyword">clock_res_t</span>             tv_nsec;                <span class="comment">/* nanoseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_timespec</span>    <span class="title">mach_timespec_t</span>;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="timer-queue-c"><a href="#timer-queue-c" class="headerlink" title="timer_queue.c"></a><code>timer_queue.c</code></h2><ul><li><p><code>timer_queue.c</code></p><ul><li><p><code>timer_timeout</code> 函数</p><ul><li>对 <code>list_t</code> 串联起来的 <code>timer</code> 循环双链表 <code>TQ</code></li><li>循环判断其时间是否为当前时间，将 <code>timeout</code> 的 <code>timer</code> 放入 <code>expTQ</code> 中<ul><li>若是，则从 <code>TQ</code> 中移除，并加入到 <code>expTQ</code></li><li>若否，则终止循环判断</li></ul></li><li>循环执行并删除 <code>expTQ</code> 中 <code>timer</code> 的 handler function</li></ul></li><li><p><code>timer_remove</code></p><ul><li><code>t-&gt;used</code> 置 0</li></ul></li><li><p><code>timer_add</code></p><ul><li><p><code>t-&gt;used</code> 置 1</p></li><li><p>判断 <code>TQ</code> 是否为空</p><ul><li>若空，则直接添加</li><li>若非空，则遍历 <code>TQ</code>，将 t 按照时间顺序添加到 <code>TQ</code> 中</li></ul></li><li><p><code>timer_timeout_now</code></p><ul><li><p>判断 <code>timer</code> 是否在 <code>TQ</code> 中</p><ul><li>若是，则执行 <code>handler</code>，并 <code>t-&gt;used</code> 置 0，<code>timer</code> 依旧在 <code>TQ</code> 中等待执行</li><li>若否，则返回-1</li></ul></li><li><p><code>timer_set_timeout</code></p><ul><li><p><code>t-&gt;used</code> 置 0</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;timeout.tv_usec += msec * <span class="number">1000</span>;</span><br><span class="line">t-&gt;timeout.tv_sec += t-&gt;timeout.tv_usec / <span class="number">1000000</span>;</span><br><span class="line">t-&gt;timeout.tv_usec = t-&gt;timeout.tv_usec % <span class="number">1000000</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>timer_add(t)</code></p></li></ul></li></ul></li></ul></li></ul></li></ul><hr><h2 id="AODV-Socket"><a href="#AODV-Socket" class="headerlink" title="AODV Socket"></a>AODV Socket</h2><p>在对于 <code>aodv_socket.{c|h}</code> 文件的分析中，我们发现它大量依赖于系统 C 语言源代码中的 <code>struct cmsghdr</code>，于是我们查看了系统源代码 C 语言文件中的 <code>socket.h</code> 文件，并从中找到了对于 <code>msghdr</code> 和 <code>cmsghdr</code> 结构体的定义。</p><ul><li><p><code>msghdr</code>：用于调用 recvmsg 和 sendmsg 的消息头。在 recvmsg 中使用值与结果相对应，而在 sendmsg 中仅使用值。</p><ul><li>套接口地址成员 <code>msg_name</code> 与 <code>msg_namelen</code>，分别指向我们要发送或是接收信息的套接口地址及这个套接口地址的长度<ul><li>当调用 recvmsg 时，msg_name 会指向一个将要接收的地址的接收区域</li><li>当调用 sendmsg 时，它会指向一个数据报将要发送到的目的地址</li></ul></li><li>I/O 向量引用 <code>msg_iov</code> 与 <code>msg_iovlen</code></li><li>附属数据缓冲区成员 <code>msg_control</code> 与 <code>msg_controllen</code></li><li>接收信息标记位 <code>msg_flags</code>，其可以接收的标记如下</li></ul><table><thead><tr><th>标记位</th><th>描述</th></tr></thead><tbody><tr><td>MSG_EOR</td><td>当接收到记录结尾时会设置这一位。这通常对于SOCK_SEQPACKET套接口类型十分有用</td></tr><tr><td>MSG_TRUNC</td><td>这个标记位表明数据的结尾被截短，因为接收缓冲区太小不足以接收全部的数据</td></tr><tr><td>MSG_CTRUNC</td><td>这个标记位表明某些控制数据(附属数据)被截短，因为缓冲区太小</td></tr><tr><td>MSG_OOB</td><td>这个标记位表明接收了带外数据</td></tr><tr><td>MSG_ERRQUEUE</td><td>这个标记位表明没有接收到数据，但是返回一个扩展错误</td></tr></tbody></table></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>            *msg_name;      <span class="comment">/* [XSI] optional address */</span></span><br><span class="line">    <span class="keyword">socklen_t</span>       msg_namelen;    <span class="comment">/* [XSI] size of address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>          <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span> <span class="comment">/* [XSI] scatter/gather array */</span></span><br><span class="line">    <span class="keyword">int</span>             msg_iovlen;     <span class="comment">/* [XSI] # elements in msg_iov */</span></span><br><span class="line">    <span class="keyword">void</span>            *msg_control;   <span class="comment">/* [XSI] ancillary data, see below */</span></span><br><span class="line">    <span class="keyword">socklen_t</span>       msg_controllen; <span class="comment">/* [XSI] ancillary data buffer len */</span></span><br><span class="line">    <span class="keyword">int</span>             msg_flags;      <span class="comment">/* [XSI] flags on received message */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>cmsghdr</code>：msg_control 缓冲区中辅助数据对象的头。用于提供数据报的额外信息的附加信息。 格式是一串以 cmsghdr 结构为首的信息元素的序列。<ul><li><code>cmsg_len</code>:  附属数据的字节计数，这包含结构头的尺寸。这个值是由 <code>CMSG_LEN()</code> 宏计算的</li><li><code>cmsg_level</code>:  这个值表明了原始的协议级别(例如，<code>SOL_SOCKET</code>)</li><li><code>cmsg_type</code>:  这个值表明了控制信息类型(例如，<code>SCM_RIGHTS</code>)</li><li><code>cmsg_data</code>:  这个成员并不实际存在。他用来指明实际的额外附属数据所在的位置</li></ul></li></ul><p>对 <code>msg_level</code> 的描述如下：</p><table><thead><tr><th>cmsg_level</th><th>描述</th></tr></thead><tbody><tr><td>SCM_RIGHTS</td><td>附属数据对象是一个文件描述符</td></tr><tr><td>SCM_CREDENTIALS</td><td>附属数据对象是一个包含证书信息的结构</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">socklen_t</span>       cmsg_len;       <span class="comment">/* [XSI] data byte count, including hdr */</span></span><br><span class="line">    <span class="keyword">int</span>             cmsg_level;     <span class="comment">/* [XSI] originating protocol */</span></span><br><span class="line">    <span class="keyword">int</span>             cmsg_type;      <span class="comment">/* [XSI] protocol-specific type */</span></span><br><span class="line"><span class="comment">/* followed by    unsigned char  cmsg_data[]; */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AODV 协议认为系统提供的源代码的关于 routine 部分存在 bug，所以通过 <code>msghdr</code> 和 <code>cmsghdr</code> 结构并重写部分函数来解决这个问题。</p><ul><li><code>__cmsg_nxthdr_fix</code> </li><li><code>cmsg_nxthdr_fix</code></li></ul><p>其中 <code>cmsg_nxthdr_fix</code> 函数调用 <code>__cmsg_nxthdr_fix</code> 来完成</p><ul><li><code>aodv_socket.c</code><ul><li><code>aodv_socket_init</code><ul><li></li></ul></li></ul></li></ul><p>我们在处理 AODV 协议源代码中的 <code>socket</code> 函数时发现了对于 <code>PF_INET</code> 量，于我们在高级 C 语言课程中学习的 <code>AF_INET</code> 不同。经过在网上的查阅我们可以看到，对于 Windows 系统来说，它在 <code>Winsock2.h</code> 中将 <code>PF_INET</code> 与 <code>IF_INET</code> 等价</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INET 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_INET AF_INET</span></span><br></pre></td></tr></table></figure><p>而在 Unix/Linux 系统中，对于 BSD 是 AF，对于 POSIX 是 PF。在 《Unix 网络编程 卷1: 套接字联网 API》书中，我们找到了这一段解释</p><blockquote><p><code>AF_XXX</code> Versus <code>PF_XXX</code></p><p>The “<code>AF_</code>“ prefix stands for “address family” and the “<code>PF_</code>“ prefix stands for “protocol family”. Historically, the intent was that a single protocol family might support multiple address families and that the <code>PF_</code> value was used to create the socket and the <code>AF_</code> value was used in socket address structures. But in actuality, a protocol family supporting multiple address families has never been supported and the <code>&lt;sys/socket.h&gt;</code> header defines the <code>PF_</code> value for a given protocol to be equal to the <code>AF_</code> value for that protocol. While there is no guarantee that this equality between the two will always be true, should anyone change this for existing protocols, lots of existing code would break. To conform to existing coding practice, we use only the <code>AF_</code> constants in this text, although you may encounter the <code>PF_</code> value, mainly in calls to socket.</p></blockquote><ul><li><p><code>aodv_socket_init</code></p><ul><li><p>在函数中第一次使用了 ifreq 结构体，跳转得到其化简后的部分定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">ifreq</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>    ifr_name[IFNAMSIZ];             <span class="comment">/* if name, e.g. &quot;en0&quot; */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">sockaddr</span> <span class="title">ifru_addr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">sockaddr</span> <span class="title">ifru_dstaddr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">sockaddr</span> <span class="title">ifru_broadaddr</span>;</span></span><br><span class="line">        <span class="keyword">short</span>   ifru_flags;</span><br><span class="line">        <span class="keyword">int</span>     ifru_metric;</span><br><span class="line">        <span class="keyword">int</span>     ifru_mtu;</span><br><span class="line">        <span class="keyword">int</span>     ifru_phys;</span><br><span class="line">        <span class="keyword">int</span>     ifru_media;</span><br><span class="line">        <span class="keyword">int</span>     ifru_intval;</span><br><span class="line">        <span class="keyword">caddr_t</span> ifru_data;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">ifdevmtu</span> <span class="title">ifru_devmtu</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">ifkpi</span>   <span class="title">ifru_kpi</span>;</span></span><br><span class="line">        <span class="keyword">u_int32_t</span> ifru_wake_flags;</span><br><span class="line">        <span class="keyword">u_int32_t</span> ifru_route_refcnt;</span><br><span class="line">        <span class="keyword">int</span>     ifru_cap[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">u_int32_t</span> ifru_functional_type;</span><br><span class="line">    &#125; ifr_ifru;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体中包含了两部分，包括接口 interface 的名称和一个 union 类型的定义。ifreq 为接口请求结构，用于套接字 ioctl 的接口请求结构。 所有的接口 IOctl 必须有参数定义，该定义以 ifr_name 开头。 其余的其余的可以是特定的接口。</p></li><li><p>socket 初始化 udp 数据包时，会查看 <code>this_host.nif</code> 即 number of interface to boardcast on。若为 0 则异常退出。</p></li><li><p>在 socket 部分有非常多的内容在高级 C 语言课程 Unix 网络编程中学到过，如 <code>socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)</code> 来创建 UDP 包，但在 aodv 协议中，均使用了 <code>PF_INET</code> 来替换原始的 <code>AF_INET</code></p></li><li><p>在 Unix Network Programming 中，作者提到他建议使用 <code>bzero</code> 来替换 <code>memset(&amp;aodv_addr, 0, sizeof(aodv_addr))</code>，我们组成员也查阅了这两种在内存层面上对其赋值为 0 的区别。<code>bcopy</code>、<code>bzero</code> 和 <code>bcmp</code> 是传统 BSD 的函数，属于 POSIX 标准；<code>mem*</code> 是 C90 (以及 C99)标准的 C 函数。区别在于，如果你打算把程序弄到一个符合 C90/C99，但是不符合 POSIX 标准的平台时，后者会更有优势。但是 <code>memset</code> 函数的第二和第三个参数需要单独记忆</p><blockquote><p>C has memset(), the Berkeley UNIX C library has <strong>bzero</strong>(). They are not<br>identical, and <strong>bzero</strong>() pre dates memset() but is not widely available (since<br>it’s not part of standard C</p></blockquote></li><li><p>函数中通过 <code>setsockopt</code> 给 socket 设置了以下的字段选项：</p><ul><li><code>SOL_SOCKET</code> - <code>SO_BROADCAST</code>：允许发送广播数据包</li><li><code>SOL_SOCKET</code> - <code>SO_BINDTODEVICE</code>：将套接字绑定到指定接口</li><li><code>SOL_SOCKET</code> - <code>SO_PRIORITY</code>：设置在套接字发送的所有包的协议定义优先权</li><li><code>SOL_SOCKET</code> - <code>SO_RCVBUF</code>：接受缓冲区大小</li><li><code>SOL_IP</code> - <code>IP_RECVTTL</code>：传送一条带有用一个字节表示的接收包生存时间字段的 IP_RECVTTL 控制信息</li><li><code>SOL_IP</code> - <code>IP_PKTINFO</code>：获取接收报文的相关信息，也可在发送报文时指定报文的相关控制信息</li></ul></li><li><p>aodv 将 receive buffer size 设定为了 1024 并且不允许修改（没有通过 <code>#define</code> 或其他形式提供便于修改的方法）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (setsockopt(DEV_NR(i).sock, SOL_SOCKET, SO_RCVBUF,</span><br><span class="line">               (<span class="keyword">char</span> *)&amp;bufsize, optlen) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    alog(LOG_NOTICE, <span class="number">0</span>, __FUNCTION__,</span><br><span class="line">         <span class="string">&quot;Receive buffer size set to %d&quot;</span>, bufsize);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bufsize &lt; RECV_BUF_SIZE)</span><br><span class="line">&#123;</span><br><span class="line">    alog(LOG_ERR, <span class="number">0</span>, __FUNCTION__,</span><br><span class="line">         <span class="string">&quot;Could not set receive buffer size&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>aodv_socket_process_packet</code></p><ul><li>确保邻居节点已经被添加或更新</li><li>判断消息报文类型<ul><li>通过 <code>type == RREP &amp; ttl == 1 &amp; dst.s_addr == AODV_BROADCAST</code> 判断是否为 Hello 包，并调用 hello_process 来对 Hello 包进行处理</li><li><code>AODV_RREQ</code>: <code>rreq_process((RREQ *)aodv_msg, len, src, dst, ttl, ifindex)</code></li><li><code>AODV_RREP</code>: <code>rrep_process((RREP *)aodv_msg, len, src, dst, ttl, ifindex)</code></li><li><code>AODV_RERR</code>: <code>rerr_process((RERR *)aodv_msg, len, src, dst)</code></li><li><code>AODV_RREP_ACK</code>: <code>rrep_ack_process((RREP_ack *)aodv_msg, len, src, dst)</code></li></ul></li></ul></li><li><p><code>aodv_socket_read</code></p><ul><li>本函数负责读取并调用 <code>aodv_socket_process_packet</code> 处理 AODV socket 包，在 NS-2 系统中，函数为 <code>recvAODVUUPacket</code></li><li>通过 <code>recvmsg(fd, &amp;msgh, 0)</code>  读取 socket，并从控制信息中获取 ttl 和目标地址。通过判断 <code>cmsg-&gt;cmsg_type</code><ul><li><code>IP_TTL</code>: <code>ttl = *(CMSG_DATA(cmsg));</code></li><li><code>IP_PKTINFO</code>: <code>struct in_pktinfo *pi = (struct in_pktinfo *)CMSG_DATA(cmsg); dst.s_addr = pi-&gt;ipi_addr.s_addr;</code></li></ul></li><li>若 TTL 为负值，则异常，并进行空返回</li><li>通过 <code>devfromsock</code> 尝试将 <code>sockf</code> 转换为 <code>dev_info</code>，对转换错误即空指针的返回同样按照异常处理并进行空返回</li></ul></li><li><p><code>aodv_socket_send</code></p><ul><li><p>本函数负责发送 AODV socket 数据包</p></li><li><p>不处理 AODV_RREP 数据包，并且当 <code>wait_on_reboot</code> 被设置为真时也不再发送数据包</p></li><li><p>设置 socket 的 TTL 值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(dev-&gt;sock, SOL_IP, IP_TTL, &amp;ttl, <span class="keyword">sizeof</span>(ttl))</span><br></pre></td></tr></table></figure></li><li><p>如果速率限制被启用，检查我们是否正在发送一个 RREQ 或 RERR。在这种情况下，丢弃传出的控制数据包。如果距离上次发送该类型的数据包的时间少于或小于允许的 RATE LIMIT 时间</p></li></ul></li><li><p><code>aodv_socket_new_msg</code></p><ul><li>为新产生的数据包发送缓冲空间</li></ul></li><li><p><code>aodv_socket_queue_msg</code></p><ul><li>把一个AODV消息存储在发送缓冲区中</li></ul></li><li><p><code>aodv_socket_clean</code></p><ul><li>清空套接字信息并关闭</li></ul></li></ul><p>对部分 Socket 函数的详细解释将放在内容中</p><hr><h2 id="RREQ"><a href="#RREQ" class="headerlink" title="RREQ"></a><code>RREQ</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |J|R|G|D|U|      Reserved       |   Hop Count   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                            RREQ ID                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Destination IP Address                     |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                  Destination Sequence Number                  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Originator IP Address                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                  Originator Sequence Number                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>疑问🤔️：代码实际没有 U 标志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> type;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__LITTLE_ENDIAN)</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> res1:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">u_int8_t</span> d:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int8_t</span> g:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int8_t</span> r:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int8_t</span> j:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__BIG_ENDIAN)</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> j:<span class="number">1</span>;    <span class="comment">/* Join flag (multicast) */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> r:<span class="number">1</span>;    <span class="comment">/* Repair flag */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> g:<span class="number">1</span>;    <span class="comment">/* Gratuitous RREP flag */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> d:<span class="number">1</span>;    <span class="comment">/* Destination only respond */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> res1:<span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">&quot;Adjust your &lt;bits/endian.h&gt; defines&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">u_int8_t</span> res2;</span><br><span class="line">    <span class="keyword">u_int8_t</span> hcnt;</span><br><span class="line">    <span class="keyword">u_int32_t</span> rreq_id;</span><br><span class="line">    <span class="keyword">u_int32_t</span> dest_addr;</span><br><span class="line">    <span class="keyword">u_int32_t</span> dest_seqno;</span><br><span class="line">    <span class="keyword">u_int32_t</span> orig_addr;</span><br><span class="line">    <span class="keyword">u_int32_t</span> orig_seqno;</span><br><span class="line">&#125; RREQ;</span><br></pre></td></tr></table></figure><ul><li><p><code>aodv_rreq.c</code></p><ul><li><p><code>rare_create</code></p><ul><li><p>创建 <code>RREQ</code> 并初始化</p></li><li><p>seq number increase（0 仍为 0，最大值时变为 1，其他正常 +1）</p><ul><li>当某一节点要产生 RREQ 洪泛，必须先增大自身序列号</li></ul></li><li><p><code>flag</code> 匹配并给对应的值赋 1</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* RREQ Flags: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RREQ_JOIN          0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RREQ_REPAIR        0x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RREQ_GRATUITOUS    0x4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RREQ_DEST_ONLY     0x8</span></span><br></pre></td></tr></table></figure><ul><li><p>疑问🤔️：为什么不直接用数组记录，或直接使用 <code>flag</code> 记录？目前用于匹配的代码如下</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags &amp; RREQ_JOIN)</span><br><span class="line">    rreq-&gt;j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; RREQ_REPAIR)</span><br><span class="line">    rreq-&gt;r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; RREQ_GRATUITOUS)</span><br><span class="line">    rreq-&gt;g = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; RREQ_DEST_ONLY)</span><br><span class="line">    rreq-&gt;d = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>解释：可以同时有多个 <code>flag</code></li></ul></li><li><p><code>rreq_add_ext</code></p><ul><li><p>用于对 RREQ 进行补充</p></li><li><p>存放于 <code>(AODV_ext *)((char *)rreq + offset)</code></p><ul><li><code>offset</code> 应大于或等于 <code>RREQ_SIZE</code></li></ul></li><li><p><code>AODV_ext</code> 存储信息</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* An generic AODV extensions header */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> type;</span><br><span class="line">    <span class="keyword">u_int8_t</span> length;</span><br><span class="line">    <span class="comment">/* Type specific data follows here */</span></span><br><span class="line">&#125; AODV_ext;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>type</code></li><li><code>length</code></li></ul></li><li><p>将 data 复制到 <code>((char *)((char *)ext + sizeof(AODV_ext))</code></p></li></ul></li><li><p><code>rreq_send</code></p><ul><li><p><code>struct in_addr</code></p></li><li><p><code>apr_uint32_t</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">apr_uint32_t</span>  s_addr; <span class="comment">/**&lt; storage to hold the IP# */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>unsigned int</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dest.s_addr = AODV_BROADCAST;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Broadcast on all interfaces */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_NR_INTERFACES; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!DEV_NR(i).enabled)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    rreq = rreq_create(flags, dest_addr, dest_seqno, DEV_NR(i).ipaddr);</span><br><span class="line">    aodv_socket_send((AODV_msg *)rreq, dest, RREQ_SIZE, ttl, &amp;DEV_NR(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>广播 <code>dest.s_addr = AODV_BROADCAST;</code></p></li><li><p>创建 RREQ 并发送报文</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rreq = rreq_create(flags, dest_addr, dest_seqno, DEV_NR(i).ipaddr);</span><br><span class="line">aodv_socket_send((AODV_msg *)rreq, dest, RREQ_SIZE, ttl, &amp;DEV_NR(i));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>rreq_forward</code></p><ul><li><p>记录目的和源</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dest.s_addr = AODV_BROADCAST;</span><br><span class="line">orig.s_addr = rreq-&gt;orig_addr;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>若 TTL 仍然大于 0 时继续转发</p></li><li><p>报文进入队列 <code>send_buf</code>，等待发送</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rreq = (RREQ *)aodv_socket_queue_msg((AODV_msg *)rreq, size);</span><br></pre></td></tr></table></figure></li><li><p>增加跳数 hcnt <code>rreq-&gt;hcnt++;</code></p></li><li><p>转发发送缓冲区 <code>send_buf</code> 中的报文</p></li><li><p>疑问🤔️：转发时 TTL-1 操作没有找到</p><ul><li><p>回答：forward 中只转发，在 process 中找到如下的对 TTL 的处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ip_ttl &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Update the sequence number in case the maintained one is</span></span><br><span class="line"><span class="comment">     * larger */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd_rt &amp;&amp; !(fwd_rt-&gt;flags &amp; RT_INET_DEST) &amp;&amp;</span><br><span class="line">        (<span class="keyword">int32_t</span>)fwd_rt-&gt;dest_seqno &gt; (<span class="keyword">int32_t</span>)rreq_dest_seqno)</span><br><span class="line">        rreq-&gt;dest_seqno = htonl(fwd_rt-&gt;dest_seqno);</span><br><span class="line">                                                                </span><br><span class="line">    rreq_forward(rreq, rreqlen, --ip_ttl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    DEBUG(LOG_DEBUG, <span class="number">0</span>, <span class="string">&quot;RREQ not forwarded - ttl=0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>当 TTL 大于 1 时，判断并转发 <code>—-ip_ttl</code> 的包</p></li></ul></li><li><p><code>rreq_process</code></p><ul><li><p>目的和源的初始化</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rreq_dest.s_addr = rreq-&gt;dest_addr;</span><br><span class="line">rreq_orig.s_addr = rreq-&gt;orig_addr;</span><br><span class="line">rreq_id = ntohl(rreq-&gt;rreq_id);</span><br><span class="line">rreq_dest_seqno = ntohl(rreq-&gt;dest_seqno);</span><br><span class="line">rreq_orig_seqno = ntohl(rreq-&gt;orig_seqno);</span><br><span class="line">rreq_new_hcnt = rreq-&gt;hcnt + <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>忽略由本节点开始发送的包</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rreq_orig.s_addr == DEV_IFINDEX(ifindex).ipaddr.s_addr)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>检查接收到的 RREQ 包的上一跳是否在黑名单中，若在则忽略该包</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rreq_blacklist_find(ip_src))</span><br><span class="line">&#123;</span><br><span class="line">    DEBUG(LOG_DEBUG, <span class="number">0</span>, <span class="string">&quot;prev hop of RREQ blacklisted, ignoring!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>忽略已经处理过的 RREQ 包，防止发生网络风暴</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rreq_record_find(rreq_orig, rreq_id))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>疑问🤔️：是否可以通过将检查操作前置到函数内初始化之前，小幅度提升运算速度</p></li><li><p>缓存接收到的 RREQ 包，下次接收到相同包时可以忽略不进行处理</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rreq_record_insert(rreq_orig, rreq_id);</span><br></pre></td></tr></table></figure></li><li><p>通过 rreqlen 和 extlen 处理分割 RREQ 包</p></li><li><p>路由发现 <code>rt_table_find</code></p><ul><li><p>若路由表中没有存储过目的节点，则添加到路由表中 <code>rt_table_insert</code></p></li><li><p>若发现已经存储过的记录，则尝试计算出开销最小的路径并更新</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">life = PATH_DISCOVERY_TIME - <span class="number">2</span> * rreq_new_hcnt * NODE_TRAVERSAL_TIME;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rev_rt-&gt;dest_seqno == <span class="number">0</span> ||</span><br><span class="line">    (<span class="keyword">int32_t</span>)rreq_orig_seqno &gt; (<span class="keyword">int32_t</span>)rev_rt-&gt;dest_seqno ||</span><br><span class="line">    (rreq_orig_seqno == rev_rt-&gt;dest_seqno &amp;&amp;</span><br><span class="line">     (rev_rt-&gt;state == INVALID || rreq_new_hcnt &lt; rev_rt-&gt;hcnt)))</span><br><span class="line">&#123;</span><br><span class="line">    rev_rt =</span><br><span class="line">        rt_table_update(rev_rt, ip_src, rreq_new_hcnt, rreq_orig_seqno,</span><br><span class="line">                        life, VALID, rev_rt-&gt;flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>判断自己是否为目的节点</p><ul><li><p>若是目的节点，终止 RREQ，开始 RREQ 过程，更新最大序列号</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rreq_dest.s_addr == DEV_IFINDEX(ifindex).ipaddr.s_addr)</span><br><span class="line">&#123;</span><br><span class="line">                                                                           </span><br><span class="line">    <span class="comment">/* WE are the RREQ DESTINATION. Update the node&#x27;s own</span></span><br><span class="line"><span class="comment">       sequence number to the maximum of the current seqno and the</span></span><br><span class="line"><span class="comment">       one in the RREQ. */</span></span><br><span class="line">    <span class="keyword">if</span> (rreq_dest_seqno != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int32_t</span>)this_host.seqno &lt; (<span class="keyword">int32_t</span>)rreq_dest_seqno)</span><br><span class="line">            this_host.seqno = rreq_dest_seqno;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (this_host.seqno == rreq_dest_seqno)</span><br><span class="line">            seqno_incr(this_host.seqno);</span><br><span class="line">    &#125;</span><br><span class="line">    rrep =</span><br><span class="line">        rrep_create(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, DEV_IFINDEX(rev_rt-&gt;ifindex).ipaddr,</span><br><span class="line">                    this_host.seqno, rev_rt-&gt;dest_addr, MY_ROUTE_TIMEOUT);</span><br><span class="line">                                                                           </span><br><span class="line">    rrep_send(rrep, rev_rt, <span class="literal">NULL</span>, RREP_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>若不是目的节点，则查看是否包含目的节点的路由信息</p><ul><li>若有则回复 RREP</li><li>若没有则继续广播 RREQ<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* We are an INTERMEDIATE node. - check if we have an active</span></span><br><span class="line"><span class="comment">     * route entry */</span></span><br><span class="line">                                                                          </span><br><span class="line">    fwd_rt = rt_table_find(rreq_dest);</span><br><span class="line">                                                                          </span><br><span class="line">    <span class="keyword">if</span> (fwd_rt &amp;&amp; fwd_rt-&gt;state == VALID &amp;&amp; !rreq-&gt;d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">        <span class="keyword">u_int32_t</span> lifetime;</span><br><span class="line">                                                                          </span><br><span class="line">        <span class="comment">/* GENERATE RREP, i.e we have an ACTIVE route entry that is fresh</span></span><br><span class="line"><span class="comment">           enough (our destination sequence number for that route is</span></span><br><span class="line"><span class="comment">           larger than the one in the RREQ). */</span></span><br><span class="line">                                                                          </span><br><span class="line">        gettimeofday(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">                                                                          </span><br><span class="line">        <span class="comment">/* Respond only if the sequence number is fresh enough... */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd_rt-&gt;dest_seqno != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (<span class="keyword">int32_t</span>)fwd_rt-&gt;dest_seqno &gt;= (<span class="keyword">int32_t</span>)rreq_dest_seqno)</span><br><span class="line">        &#123;</span><br><span class="line">            lifetime = timeval_diff(&amp;fwd_rt-&gt;rt_timer.timeout, &amp;now);</span><br><span class="line">            rrep = rrep_create(<span class="number">0</span>, <span class="number">0</span>, fwd_rt-&gt;hcnt, fwd_rt-&gt;dest_addr,</span><br><span class="line">                               fwd_rt-&gt;dest_seqno, rev_rt-&gt;dest_addr,</span><br><span class="line">                               lifetime);</span><br><span class="line">            rrep_send(rrep, rev_rt, fwd_rt, rrep_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* If the GRATUITOUS flag is set, we must also unicast a</span></span><br><span class="line"><span class="comment">           gratuitous RREP to the destination. */</span></span><br><span class="line">        <span class="keyword">if</span> (rreq-&gt;g)</span><br><span class="line">        &#123;</span><br><span class="line">            rrep = rrep_create(<span class="number">0</span>, <span class="number">0</span>, rev_rt-&gt;hcnt, rev_rt-&gt;dest_addr,</span><br><span class="line">                               rev_rt-&gt;dest_seqno, fwd_rt-&gt;dest_addr,</span><br><span class="line">                               lifetime);</span><br><span class="line">                                                                          </span><br><span class="line">            rrep_send(rrep, fwd_rt, rev_rt, RREP_SIZE);</span><br><span class="line">                                                                          </span><br><span class="line">            DEBUG(LOG_INFO, <span class="number">0</span>, <span class="string">&quot;Sending G-RREP to %s with rte to %s&quot;</span>,</span><br><span class="line">                  ip_to_str(rreq_dest), ip_to_str(rreq_orig));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">forward:</span><br><span class="line">    <span class="keyword">if</span> (ip_ttl &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Update the sequence number in case the maintained one is</span></span><br><span class="line"><span class="comment">         * larger */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd_rt &amp;&amp; !(fwd_rt-&gt;flags &amp; RT_INET_DEST) &amp;&amp;</span><br><span class="line">            (<span class="keyword">int32_t</span>)fwd_rt-&gt;dest_seqno &gt; (<span class="keyword">int32_t</span>)rreq_dest_seqno)</span><br><span class="line">            rreq-&gt;dest_seqno = htonl(fwd_rt-&gt;dest_seqno);</span><br><span class="line">                                                                          </span><br><span class="line">        rreq_forward(rreq, rreqlen, --ip_ttl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        DEBUG(LOG_DEBUG, <span class="number">0</span>, <span class="string">&quot;RREQ not forwarded - ttl=0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><hr><h2 id="RREP"><a href="#RREP" class="headerlink" title="RREP"></a><code>RREP</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |R|A|    Reserved     |Prefix Sz|   Hop Count   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                     Destination IP address                    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                  Destination Sequence Number                  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Originator IP address                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           Lifetime                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><ul><li><p><code>rrep_create</code></p><ul><li><p>通过 <code>aodv_socket_new_msg</code> 创建 socket message，并进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rrep-&gt;type = AODV_RREP;</span><br><span class="line">rrep-&gt;res1 = <span class="number">0</span>;</span><br><span class="line">rrep-&gt;res2 = <span class="number">0</span>;</span><br><span class="line">rrep-&gt;prefix = prefix;</span><br><span class="line">rrep-&gt;hcnt = hcnt;</span><br><span class="line">rrep-&gt;dest_addr = dest_addr.s_addr;</span><br><span class="line">rrep-&gt;dest_seqno = htonl(dest_seqno);</span><br><span class="line">rrep-&gt;orig_addr = orig_addr.s_addr;</span><br><span class="line">rrep-&gt;lifetime = htonl(life);</span><br></pre></td></tr></table></figure></li><li><p>对 flag 进行位判断，并将对应在 message 中的位置 1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags &amp; RREP_REPAIR)</span><br><span class="line">    rrep-&gt;r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; RREP_ACK)</span><br><span class="line">    rrep-&gt;a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>rrep_ack_create</code></p><ul><li><p>创建 socket message，初始化仅需要将其类型设置为 ACK 包</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rrep_ack-&gt;type = AODV_RREP_ACK;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>rrep_ack_process</code></p><ul><li><p>处理 ACK 包时，先在路由表中查找其源 ip，然后删除这个 RREP_ACK 包还未到期的计时器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_remove(&amp;rt-&gt;ack_timer);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>rrep_add_ext</code></p><ul><li>通 RREQ 时的处理，在 <code>(AODV_ext *)((char *)rrep + offset)</code> 位置添加 extension 信息。存储类型和长度信息</li></ul></li><li><p><code>rrep_send</code></p><ul><li><p>检查我们是否应该请求 <code>RREP_ACK</code>。如果收到 RREQ 的节点是邻居，则可能面临单向链路，最好请求一个<code>RREP_ACK</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (neighbor &amp;&amp; neighbor-&gt;state == VALID &amp;&amp; !neighbor-&gt;ack_timer.used)</span><br><span class="line">&#123;</span><br><span class="line">    rrep_flags |= RREP_ACK;</span><br><span class="line">    neighbor-&gt;flags |= RT_UNIDIR;</span><br><span class="line">                                                                       </span><br><span class="line">    <span class="comment">/* Must remove any pending hello timeouts when we set the</span></span><br><span class="line"><span class="comment">       RT_UNIDIR flag, else the route may expire after we begin to</span></span><br><span class="line"><span class="comment">       ignore hellos... */</span></span><br><span class="line">    timer_remove(&amp;neighbor-&gt;hello_timer);</span><br><span class="line">    neighbor_link_break(neighbor);</span><br><span class="line">                                                                       </span><br><span class="line">    DEBUG(LOG_DEBUG, <span class="number">0</span>, <span class="string">&quot;Link to %s is unidirectional!&quot;</span>,</span><br><span class="line">          ip_to_str(neighbor-&gt;dest_addr));</span><br><span class="line">                                                                       </span><br><span class="line">    timer_set_timeout(&amp;neighbor-&gt;ack_timer, NEXT_HOP_WAIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置 <code>RT_UNIDIR</code> 标志时，必须删除所有待处理的 Hello 超时，否则路由可能会在开始忽略 Hello 之后终止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fwd_rt)</span><br><span class="line">&#123;</span><br><span class="line">    precursor_add(fwd_rt, rev_rt-&gt;next_hop);</span><br><span class="line">    precursor_add(rev_rt, fwd_rt-&gt;next_hop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>rrep_forward</code></p><ul><li><p>检查是否应该请求 <code>RREP_ACK</code>，如果RREP的来源不是一个邻居，我们必须找到邻居条目，它是通往 RREP 源的下一跳。如果我们接收到 RREQ 的节点是邻居，则我们可能正面临单向链路，最好请求一个 <code>RREP_ACK</code></p></li><li><p>疑问🤔️：AODV 源码的作者在这里也没有弄明白，他们认为这里存在一个单向的连接，于是作者暂且使用了 <code>if(0)</code> 让这段代码仅仅存在于程序中但是不会被执行</p><blockquote><p>we suspect a unidirectional link</p></blockquote></li></ul></li><li><p><code>rrep_process</code></p><ul><li><p>在 RREP 的处理中，将 RREP 包中的地址信息提取出来放入四元组中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rrep_dest.s_addr = rrep-&gt;dest_addr;</span><br><span class="line">rrep_orig.s_addr = rrep-&gt;orig_addr;</span><br><span class="line">rrep_seqno = ntohl(rrep-&gt;dest_seqno);</span><br><span class="line">rrep_lifetime = ntohl(rrep-&gt;lifetime);</span><br></pre></td></tr></table></figure></li><li><p>考虑到中间节点的情况，增加RREP跳数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rrep_new_hcnt = rrep-&gt;hcnt + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>在 RREQ 的处理时，会忽略那些旨在建立一条通往自我的路线的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rrep_dest.s_addr == DEV_IFINDEX(ifindex).ipaddr.s_addr)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></li><li><p>对 RREQ 包是否还有 extension 进行判断，并将其放入 ext 变量中</p></li><li><p>检查是否应该进行前进的路线。若没有现有条目，则插入一个新条目。若有，则更新条目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">fwd_rt = rt_table_find(rrep_dest);</span><br><span class="line">rev_rt = rt_table_find(rrep_orig);</span><br><span class="line">                                                                           </span><br><span class="line"><span class="keyword">if</span> (!fwd_rt)</span><br><span class="line">&#123;</span><br><span class="line">    fwd_rt = rt_table_insert(rrep_dest, ip_src, rrep_new_hcnt, rrep_seqno,</span><br><span class="line">                             rrep_lifetime, VALID, rt_flags, ifindex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fwd_rt-&gt;dest_seqno == <span class="number">0</span> ||</span><br><span class="line">         (<span class="keyword">int32_t</span>)rrep_seqno &gt; (<span class="keyword">int32_t</span>)fwd_rt-&gt;dest_seqno ||</span><br><span class="line">         (rrep_seqno == fwd_rt-&gt;dest_seqno &amp;&amp;</span><br><span class="line">          (fwd_rt-&gt;state == INVALID || fwd_rt-&gt;flags &amp; RT_UNIDIR ||</span><br><span class="line">           rrep_new_hcnt &lt; fwd_rt-&gt;hcnt)))</span><br><span class="line">&#123;</span><br><span class="line">    pre_repair_hcnt = fwd_rt-&gt;hcnt;</span><br><span class="line">    pre_repair_flags = fwd_rt-&gt;flags;</span><br><span class="line">                                                                           </span><br><span class="line">    fwd_rt =</span><br><span class="line">        rt_table_update(fwd_rt, ip_src, rrep_new_hcnt, rrep_seqno,</span><br><span class="line">                        rrep_lifetime, VALID, rt_flags | fwd_rt-&gt;flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fwd_rt-&gt;hcnt &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DEBUG(LOG_DEBUG, <span class="number">0</span>,</span><br><span class="line">              <span class="string">&quot;Dropping RREP, fwd_rt-&gt;hcnt=%d fwd_rt-&gt;seqno=%ld&quot;</span>,</span><br><span class="line">              fwd_rt-&gt;hcnt, fwd_rt-&gt;dest_seqno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果设置了 <code>RREP_ACK</code> 标志，将 RREP 确认发送到所答复的目的地，并移除 <code>RREP_ACK</code> 标志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rrep-&gt;a)</span><br><span class="line">&#123;</span><br><span class="line">    RREP_ack *rrep_ack;</span><br><span class="line">                                                                            </span><br><span class="line">    rrep_ack = rrep_ack_create();</span><br><span class="line">    aodv_socket_send((AODV_msg *)rrep_ack, fwd_rt-&gt;next_hop, NEXT_HOP_WAIT,</span><br><span class="line">                     MAXTTL, &amp;DEV_IFINDEX(fwd_rt-&gt;ifindex));</span><br><span class="line">    <span class="comment">/* Remove RREP_ACK flag... */</span></span><br><span class="line">    rrep-&gt;a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果路由以前处于修复状态，应该向路由源发送 <code>NO DELETE RERR</code>，这样它就可以选择为目的地重新启动路由发现。通过这样的方式可以修正一个导致修复标志未被设置和 <code>RERR</code> 从未被发送的错误。</p></li></ul></li></ul><hr><h2 id="RERR"><a href="#RERR" class="headerlink" title="RERR"></a><code>RERR</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |N|          Reserved           |   DestCount   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|            Unreachable Destination IP Address (1)             |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|         Unreachable Destination Sequence Number (1)           |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|</span><br><span class="line">|  Additional Unreachable Destination IP Addresses (if needed)  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Additional Unreachable Destination Sequence Numbers (if needed)|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><ul><li><code>rerr_create</code><ul><li>RERR 的创建和初始化与 RREQ 和 RREP 类似，故这里不再赘述</li></ul></li><li><code>rerr_add_udest</code><ul><li>添加 RERR 信息，与 RREQ 和 RREP 中的 ext 类似，均为在内存中结构体后面添加附加信息</li></ul></li><li><code>rerr_process</code><ul><li>在处理 RERR 消息时，会检查哪些目的节点时不可达的。根据作者的描述，这些内容仍然只是草案</li><li>使用数据包中的目标序列号更新相应的目标序列号。检查前驱列表是否为空。如果不为空，则将该目标作为 RERR 中的不可访问目标。确定是否有新的前驱使它成为非单播 RERR 并删除所有无法到达的目的地的先驱列表</li><li>如果创建了 RERR 消息，则立即发送，同样需要经过路由发现等过程。仅在具有中断路由的先驱节点的那些接口上发送 RERR</li></ul></li></ul><hr><h2 id="HELLO"><a href="#HELLO" class="headerlink" title="HELLO"></a><code>HELLO</code></h2><ul><li><p><code>hello_start</code></p><ul><li><p>若计时器 used 则消息已经发送</p></li><li><p>设定计时器，与 Hello 进行绑定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timer_init(&amp;hello_timer, &amp;NS_CLASS hello_send, <span class="literal">NULL</span>);</span><br><span class="line">hello_send(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>hello_stop</code></p><ul><li><p>移除计时器即为停止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_remove(&amp;hello_timer);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>hello_send</code></p><ul><li>检测发送 Hello 消息是否有必要，通过判断 <code>time_diff &gt;= HELLO_INTERVAL</code> 以防我们已经在HELLO_INTERVAL内发送了其他广播信息</li></ul></li><li><p><code>hello_process</code></p><ul><li><p>处理 Hello 消息时，仅需要存储目的节点的信息，不需要完整的四元组。同样经过路由发现过程，并检测是否有补充信息</p></li><li><p>邻居节点应该只在收到3个连续的 Hello 消息后才有效</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (receive_n_hellos)</span><br><span class="line">    state = INVALID;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    state = VALID;</span><br></pre></td></tr></table></figure></li><li><p>在对时间的判断上，Hello 消息的处理为允许的时延与发送包的数量相乘后加入路由的时延</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout = ALLOWED_HELLO_LOSS * hello_interval + ROUTE_TIMEOUT_SLACK;</span><br></pre></td></tr></table></figure></li><li><p>最后通过 <code>hello_update_timeout</code> 更新 timeout 信息，而 <code>hello_update_timeout</code> 函数调用计时器的更新方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_set_timeout(&amp;rt-&gt;hello_timer, time + HELLO_DELAY);</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="RREP-ACK"><a href="#RREP-ACK" class="headerlink" title="RREP_ACK"></a><code>RREP_ACK</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |   Reserved    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><hr><h2 id="关于-t后缀"><a href="#关于-t后缀" class="headerlink" title="关于_t后缀"></a>关于<code>_t</code>后缀</h2><blockquote><p>but most often you will use &lt;inttypes.h&gt; which (unusually for standard C headers) includes &lt;stdint.h&gt;. It (&lt;inttypes.h&gt;) also defines macros for use with the printf() and scanf().</p><p>As Matt Curtis noted, there is no significance to the compiler in the suffix; it is a human-oriented convention.</p><p>However, you should also note that POSIX defines a lot of extra type names ending in ‘_t’, and reserves the suffix for the implementation. That means that if you are working on POSIX-related systems, defining your own type names with the convention is ill-advised. The system I work on has done it (for more than 20 years); we regularly get tripped up by systems defining types with the same name as we define.</p><p>CesarB:</p><p>I use _type instead of _t on my typedefs precisely to avoid that.</p><p><a href="https://stackoverflow.com/questions/231760/what-does-a-type-followed-by-t-underscore-t-represent">Reference</a></p></blockquote><p>推测 AODV 作者意为对本身 <code>struct struct_name</code> 的替换，使得所有 <code>struct_name_t</code> 都为对应 <code>struct struct_name</code> 的 <code>typedef</code>，但是根据网上所查阅的资料，除非对系统内核等有深入了解，对于非内核级别代码并不推荐这样命名，可能会与 POSIX 相关的代码起冲突</p><hr>          </div>]]></content>
    
    <summary type="html">
    
      Analysis of AODV protocol based on its source code
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>How to Choose Your Own Courses in SSDUT</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/How-to-choose-your-own-courses-in-SSDUT/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/How-to-choose-your-own-courses-in-SSDUT/</id>
    <published>2022-01-03T06:25:24.000Z</published>
    <updated>2022-01-12T02:12:54.937Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h1 id="究极无敌选课攻略"><a href="#究极无敌选课攻略" class="headerlink" title="究极无敌选课攻略"></a>究极无敌选课攻略</h1><blockquote><p>鉴于教务对于培养方案的各种模糊，在这里写一个面向于大一新生以及其他对于选课的操作有疑问的同学。希望大家都能抢到自己心仪的课程</p></blockquote><div class="note danger">            <ul><li>首先最重要的一点是，找到自己学院自己这一届的培养方案，拿出来好好看看。注意不要太相信教务写的文字解释，一定要以表格中写明的为准</li></ul><p>比如在软件学院会在大二上快结束的时候进行专业划分，分为软件工程和网络工程。所以在还没有分专业的时候两个都需要看看。当然，在没分专业之前两边的课程理应没有任何差别</p>          </div><ul><li>开发区的培养方案是从主校区的方案基础上进行修改的，所以会看到有很多课其实开发区不安排。例如：通识课程中的艺术类</li></ul><p><img src="https://s2.loli.net/2022/01/03/4HlezmgIncwr1NQ.jpg" alt=""></p><p>虽然看起来有这么多课可以选择，但是实际上开发区一般只会开设《艺术与审美》课程和《音乐鉴赏》课程，而《艺术与审美》课程同时是作为核心课程和艺术类课程的</p><ul><li>每学期的开设课程（推荐课表）可以提前从 <code>教务系统 - 我的班级课表 - 选择对应的学年和学期</code> 看到需要上的课程，如果这里没有显示可以通过点 <code>学期全部课程</code> 看到文字说明版本的课程</li></ul><p>需要注意，这里的课程并不意味着你必须按照这样来进行选择。对于选修课来说，他一般是教务给你安排错开所有选修课的最大集，你可以按照培养方案中的学分要求自己进行选择<br>同时，这也不意味着你只能选择这个老师或这个时间段。在选课系统中只会进行时间冲突限制，也就是说如果课程 A 与课程 B 时间发生冲突，而你已经选了课程 A，那么课程 B 的选课按钮将变为灰色<br>通常的建议是可以拿别的班级相同专业的同学的推荐课表进行比较，你可以完全按照别的班的推荐课表来进行选课，只要你能保证你的学分修满培养方案的要求并且本学期没有冲突即可</p><blockquote><p>若课程有冲突且必须这么选，可以通过 <code>冲突选课申请</code> 或直接联系你们年纪的教务老师。通常建议直接去办公室等线下联系方式，也可以通过电话、QQ 等方式。教务的上班时间大致为工作日的上午 9 点到下午 5 点，中午可能有两个小时的休息。如果教务不在或在非教务工作时间，请尝试别的方法或多尝试几次</p></blockquote><ul><li>2020 年选课方案进行了修改，预选课阶段只能选择自己推荐课表中的课程和老师（也可能开放选择别的年级的课程，正常情况下不要管他），通过意愿值分配并抽签的方式进行预选课。每个人每学期选课有 100 的意愿值，选课时可以分配 0 - 100 意愿值。教务系统在确定预选结果时通常会先按照意愿值进行排序，并从高到低选择。如果课容量满时的允许的意愿值有多位学生相同，则由这些同学进行随机安排</li></ul><p>对于意愿值分配，通常来说如果课程可选的人员固定，例如推荐课表中已经分配好的英语课程，可以考虑意愿值是否给 0，因为按照现在的选课方案，只有同样推荐课表分到了这个课序号的同学和重修或提前修的同学可以选择这门课程，掉课的可能性不大（不过最好也忽悠你同学跟你一起给 0，一起赌）<br>对于知道大家都给多少的课，比如以前的社会学，一般人都会给整十或者整五，比如别人都给 10，你就给 11 就行<br>其实也就只有一些热门的老师需要在意愿值上多考虑一下，因为预选课的限制，意愿值其实作用不大了现在</p><p>另外，不要对意愿值抱有太大的期待，因为 2021 年小学期出现过网络的课程所有网安专业的同学全部掉课的情况。</p><div class="note danger">            <p>从 2022 年春季选课的预选课结果统计上来看，意愿值系统进行了很大的修改，不再完全按照意愿值进行排序选取，但是大体上仍然是这样的<br>音乐鉴赏给到 84 及以上的基本都选上了，也出现偶尔有给 50 多或给 70 选上的情况</p>          </div><ul><li><p>一般你去问学长学姐的时候，都更多的是会告诉你需要避开哪些老师，而不是哪些老师一定一定要抢到。一般课程要水的时候大家一起水，偶尔会有那种人美心善的可以多注意一下。并且开发区不限制同学们蹭课。例如软件学院的计算机网络，一般除了孙wf大师，其他老师都会在第一次上课时告诉你，上谁的课都可以。并且这门课以自学为主，我的推荐是选一个例如万良田之类的老师，然后去蹭孙wf大师的课，因为他的课只讲拓展，不推荐直接选择</p></li><li><p>选课的时候要从校园门户或者从网站上直接登陆进行选课，不要使用 webvpn。选课系统没有 ip 限制，不必使用校园网。现在教务系统好像可以直接登陆了，之前有过一段时间没导入数据</p></li><li><p>一般来讲，预选课先选和后选是没有区别的，排名只会按照给出的意愿值，所以预选课可以不用着急，着重看自己想要上哪门课</p></li><li><p>正选课就是抢课，根据你的网络情况等会出现各种问题。系统开放时间每次都不一定，可能提前半小时也可能延后一小时，建议是直接 brunch，然后乖乖等好。正选课中退课释放的课容量不会立刻更新，而是会放到第二天，一般为中午的某一时间集中释放退掉的课容量，如果有想抢的课程请每天关注课容量的释放情况，因为你选不上课教务会怪你为什么正选的后面几天不看释放的课容量</p></li><li><p>正选的时候每天下午都有一个时间段是不开放选课的，请关注教务发放的选课通知</p></li><li><p>当前自己的课程选择情况可以在选课系统中点 <code>我的课表</code> 进行查看（也可以直接在校园门户页面的课表里看）。抢课时间很紧张，建议提前规划好课程，不要到时候再点开看自己是不是还有什么时间可以选，系统很慢，很浪费时间</p></li><li><p>遇到选课系统无法进入或出现各种故障请不要惊慌，是每次必有的常规操作，请告知学委，让学委来问教务，不要所有人都一窝蜂的找教务。会让教务不耐烦，也会让有价值的信息被淹没掉</p></li><li><p>建议学委在正选课开始之后制作一个班级没有选上课的同学的信息单，以班级或级队为单位找教务进行处理而尽量不要单独每个人都去找教务处理。虽然我每次都对教务很生气，但是选课这几天他们确实会很忙来不及一个一个回复。希望各位班级和级队学委能干一点活发挥一下自己的作用，也是为你自己好</p></li><li><p>选课期间的课程情况可以在 <code>教务系统 - 全校开课查询</code> 中找到你所想要查看的课。通常可以查看到的信息是课容量和当前已经选择的人数。一般在预选课和正选每一天过了中午选课高峰期之后进行，查看你想要选择的课程是否还有空余的名额留给你抢</p></li><li><p>预选课结束后，正选开始之前，可以通过 <code>我的课表</code> 来查看自己预选的课程是否已经被选中了</p></li><li><p><code>培养方案完成情况</code> 里会有一部分学分因为与当前大四的培养方案不同而被放入计划外完成情况。这部分的学分会在你上大四的时候由教务添加进系统</p></li><li><p>查看成绩的时候，需要先评教才能查看成绩，可以通过培养方案完成情况来避开</p></li><li><p>关于重修刷分后成绩单的显示情况目前仍然没有定论，希望能有一个官方的说法。目前有听说出国用的英文成绩单在主校区的校史馆打印时可以选择将思修类课程去掉，但是所有这方面的消息都为传言，如有需要请自行询问教务</p></li><li><p>退课最晚大概是在补退选的时间，学期中间非身体原因教务不会给你退课的一般</p></li><li><p>大一的体育都是体能课，大二开始教技能，但是教的很浅</p></li></ul>          </div>]]></content>
    
    <summary type="html">
    
      Help you select your favorite courses in SSDUT&lt;br&gt;For freshman
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
</feed>

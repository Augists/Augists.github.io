<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Augists-ZDCZ</title>
  
  <subtitle>LESS is MORE</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://augists.top/"/>
  <updated>2021-12-24T11:23:02.717Z</updated>
  <id>https://augists.top/</id>
  
  <author>
    <name>Augists</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Software Engineering Review 2</title>
    <link href="https://augists.top/NOTES/COURSES/Software_Engineering/Software-Engineering-Review-2/"/>
    <id>https://augists.top/NOTES/COURSES/Software_Engineering/Software-Engineering-Review-2/</id>
    <published>2021-12-22T15:55:11.000Z</published>
    <updated>2021-12-24T11:23:02.717Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h2 id="软件工程学概述"><a href="#软件工程学概述" class="headerlink" title="软件工程学概述"></a>软件工程学概述</h2><h3 id="何谓软件危机"><a href="#何谓软件危机" class="headerlink" title="何谓软件危机"></a>何谓软件危机</h3><p>软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题</p><h3 id="产生软件危机的原因及解决途径"><a href="#产生软件危机的原因及解决途径" class="headerlink" title="产生软件危机的原因及解决途径"></a>产生软件危机的原因及解决途径</h3><ul><li><p>技术原因</p><ul><li>软件规模越来越大</li><li>软件复杂度越来越高</li></ul></li><li><p>管理原因</p><ul><li>软件开发缺乏正确的理论指导，过分依靠个人技巧和创造性</li><li>对用户需求没有完整准确的认识</li></ul></li><li><p>解决途径：软件工程</p><ul><li>对计算机软件正确认识</li><li>推广使用开发软件成功的技术和方法，研究探索更好更有效的技术和方法，消除错误概念和做法</li><li>开发和使用更好的软件工具</li><li>对于时间、人员、资源等需要引入更加合理的管理措施</li></ul></li></ul><h3 id="软件工程定义及基本原理"><a href="#软件工程定义及基本原理" class="headerlink" title="软件工程定义及基本原理"></a>软件工程定义及基本原理</h3><ul><li>软件工程<ul><li>将系统化、规范化、可量化的工程原则和方法，应用于软件的开发、运行和维护</li><li>对其中方法的理论研究</li></ul></li><li>主要目标<ul><li>高效开发高质量软件，降低开发成本</li></ul></li><li>基本原理<ul><li>用分阶段的生命周期计划严格管理</li><li>坚持进行阶段评审</li><li>实行严格的产品控制</li><li>采用现代程序设计技术</li><li>结果应能清楚的审查</li><li>开发小组的人员应该少而精</li><li>承认不断改进软件工程实践的必要性</li></ul></li></ul><h3 id="软件工程方法学包含哪三个要素"><a href="#软件工程方法学包含哪三个要素" class="headerlink" title="软件工程方法学包含哪三个要素"></a>软件工程方法学包含哪三个要素</h3><ul><li>方法</li><li>工具</li><li>过程</li></ul><h3 id="软件生命周期阶段划分及各阶段的任务"><a href="#软件生命周期阶段划分及各阶段的任务" class="headerlink" title="软件生命周期阶段划分及各阶段的任务"></a>软件生命周期阶段划分及各阶段的任务</h3><ul><li>可行性分析与开发计划<ul><li>约束和限制</li><li>简要需求分析，建立逻辑模型</li><li>对可供选择的解决方法进行研究<ul><li>技术可行性</li><li>经济可行性</li><li>社会可行性</li></ul></li></ul></li><li>需求分析<ul><li>功能需求</li><li>非功能性需求</li></ul></li><li>软件设计<ul><li>概要设计</li><li>详细设计</li></ul></li><li>程序编码</li><li>软件测试<ul><li>单元测试</li><li>集成测试</li><li>系统测试</li></ul></li><li>软件维护<ul><li>改正性维护</li><li>适应性维护</li><li>完善性维护</li><li>预防性维护</li></ul></li></ul><h3 id="各种生命周期模型的概念和特点"><a href="#各种生命周期模型的概念和特点" class="headerlink" title="各种生命周期模型的概念和特点"></a>各种生命周期模型的概念和特点</h3><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><ul><li>阶段间具有顺序性和依赖性，文档驱动</li><li>推迟实现，不急于编写代码<ul><li>尽可能的理解和掌握系统需求</li><li>清楚区分逻辑设计与物理设计，尽可能推迟程序的物理实现</li></ul></li><li>质量保证的观点<ul><li>每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务</li><li>每个阶段结束前都要对所完成的文档进行评审，以便尽早发现问题，改正错误</li></ul></li></ul><p>问题</p><ul><li>不希望有变化</li><li>变化来的越晚，付出的代价越高</li><li>设计阶段过多的假设，导致理想化、一厢情愿的东西过多（用户只参与需求）</li><li>文档驱动，静态</li></ul><p>适合规模较大的系统或分布式开发模式</p><h4 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h4><ul><li>对系统进行简单和快速的分析，快速构造一个软件原型</li><li>用户和开发者在试用或演示过程中加强沟通和反馈，获取到用户真正的需求</li></ul><p>问题</p><ul><li>所选用的开发技术和工具不一定是实际项目的需要</li><li>快速建立起来的模型可能由于不符合各种开发规范，加上不断修改，质量较差，被抛弃</li></ul><p>适合一个全新的系统开发</p><h4 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h4><ul><li>逐步增加系统功能</li><li>第一个增量构件往往实现软件的基本需求，提供最核心的功能</li></ul><p>问题：</p><ul><li>加入构件必须不破坏已构造好的系统部分</li><li>容易退化为“边做边改”模型，从而使软件过程的控制失去整体性</li></ul><h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><ul><li>在每个阶段之前都增加了风险分析过程（瀑布模型）的快速原型模型</li></ul><p>适合大型复杂的系统</p><h4 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h4><ul><li>典型的面向对象生命周期模型</li><li>迭代：逐步求精</li><li>阶段间没有明显的界限</li></ul><h4 id="敏捷软件开发"><a href="#敏捷软件开发" class="headerlink" title="敏捷软件开发"></a>敏捷软件开发</h4><ul><li>迭代式开发</li><li>增量交付</li><li>开发团队和用户反馈推动产品开发</li><li>持续集成</li><li>开发团队自我管理</li></ul><p>敏捷宣言：</p><ul><li>个体和互动胜过流程和工具</li><li>工作的软件胜过详尽的文档</li><li>客户合作胜过合同谈判</li><li>相应变化胜过遵循计划</li></ul><p>优势</p><ul><li>精确</li><li>质量</li><li>速度</li><li>丰厚的投资回报率</li><li>高效的自我管理团队</li></ul><p>适合规模中小、需求变化频繁的系统开发，并且强调团队的作用，适合集中式的开发模式</p><h4 id="极限编程"><a href="#极限编程" class="headerlink" title="极限编程"></a>极限编程</h4><ul><li>e<strong>X</strong>treme <strong>P</strong>rogramming</li><li>目的是降低需求变化的成本</li><li>开发方法<ul><li>客户代表与开发团队紧密融合</li><li>结对编程 pair-programming</li></ul></li><li>开发流程<ul><li>编写用户故事</li><li>架构规范</li><li>实施规划</li><li>迭代计划</li><li>代码开发</li><li>单元测试</li><li>验收测试</li></ul></li><li>核心做法<ul><li>小规模，频繁的版本发布，短迭代周期</li><li>测试驱动开发 Test-driven development</li><li>结对编程 Pair programming</li><li>持续集成 Continuous integration</li><li>每日站立会议 Daily stand-up meeting</li><li>共同拥有代码 Collative code ownership</li><li>系统隐喻 System metaphor</li></ul></li></ul><h3 id="了解敏捷过程和极限编程的基本思想"><a href="#了解敏捷过程和极限编程的基本思想" class="headerlink" title="了解敏捷过程和极限编程的基本思想"></a>了解敏捷过程和极限编程的基本思想</h3><ul><li>Scrum 注重过程，XP 注重实践</li><li>需求被定义为产品需求积压 product backlogs</li><li>开发过程氛围多个冲刺周期 sprint</li><li>燃尽图 burn down 显示当前冲刺中未完成的数目</li></ul><p>Scrum 角色</p><ul><li>产品拥有者 Product Owner</li><li>利益相关者 Stakeholder</li><li>专家 Scrum Master</li><li>团队成员 Team Member</li></ul><p>DevOps 过程</p><ul><li>核心目标是自动化和可持续交付</li></ul><h2 id="软件架构的构件"><a href="#软件架构的构件" class="headerlink" title="软件架构的构件"></a>软件架构的构件</h2><h3 id="4-1-视图"><a href="#4-1-视图" class="headerlink" title="4+1 视图"></a>4+1 视图</h3><ul><li>逻辑视图 Logic View<ul><li>主要支持系统的功能性需求，即系统提供给最终用户的服务</li><li>功能描述</li><li>类模型</li></ul></li><li>开发视图 Development View （模块视图 Module View）<ul><li>软件模块的组织和管理</li><li>软件可通过程序库或子系统进行组织</li><li>子系统</li><li>接口</li></ul></li><li>进程视图 Process View （并发视图）<ul><li>系统的运行特性，主要关注非功能性需求</li><li>处理流程</li><li>并行性</li><li>同步</li></ul></li><li>物理视图 Physical View<ul><li>把软件映射到硬件上</li><li>考虑系统性能、规模、可靠性</li><li>目标硬件</li><li>网络</li></ul></li><li>场景视图 Scenarios View<ul><li>重要系统活动的抽象</li></ul></li></ul><h3 id="软件架构风格"><a href="#软件架构风格" class="headerlink" title="软件架构风格"></a>软件架构风格</h3><h4 id="管道与过滤器"><a href="#管道与过滤器" class="headerlink" title="管道与过滤器"></a>管道与过滤器</h4><h4 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h4><h4 id="仓库-黑板系统"><a href="#仓库-黑板系统" class="headerlink" title="仓库/黑板系统"></a>仓库/黑板系统</h4><ul><li>中央数据结构：说明当前状态</li><li>独立构件：在中央数据存储上执行</li></ul><p>若输入流中某类时间触发进程执行的选择，则仓库是一个传统型数据库<br>若中央数据结构的当前状态触发进程执行的选择，则仓库是一个黑板系统</p><h4 id="正交软件结构"><a href="#正交软件结构" class="headerlink" title="正交软件结构"></a>正交软件结构</h4><ul><li>组织层</li><li>线索</li></ul><h4 id="客户机-服务器结构"><a href="#客户机-服务器结构" class="headerlink" title="客户机/服务器结构"></a>客户机/服务器结构</h4><ul><li>服务器：管理系统的资源，服务器访问与并发性控制、服务器安全性、服务器的备份与恢复和全局数据完整性规则</li><li>客户应用程序：提供用户与服务器交互的界面、向服务器提交用户请求并接收来自服务器的信息、利用客户应用程序对存在于客户端的数据执行应用逻辑要求</li><li>网络：完成服务器和客户应用程序之间的数据传输</li></ul><h4 id="浏览器-服务器结构"><a href="#浏览器-服务器结构" class="headerlink" title="浏览器/服务器结构"></a>浏览器/服务器结构</h4><p>与 C/S 结构相比，B/S 结构增加了一个应用服务器，可以将整个应用逻辑保存在应用服务器上，客户端的压力大大减轻，负荷被均衡的分配给了服务器</p><h4 id="MVC-结构"><a href="#MVC-结构" class="headerlink" title="MVC 结构"></a>MVC 结构</h4><p>Model View Controller</p>          </div>]]></content>
    
    <summary type="html">
    
      Software Engineering Review
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Software Engineering Review</title>
    <link href="https://augists.top/NOTES/COURSES/Software_Engineering/Software-Engineering-Review/"/>
    <id>https://augists.top/NOTES/COURSES/Software_Engineering/Software-Engineering-Review/</id>
    <published>2021-12-19T07:06:30.000Z</published>
    <updated>2021-12-20T06:00:41.480Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <h1 id="软件工程复习"><a href="#软件工程复习" class="headerlink" title="软件工程复习"></a>软件工程复习</h1><p>软件工程三要素： 方法 工具 和 过程</p><h2 id="软件开发方法"><a href="#软件开发方法" class="headerlink" title="软件开发方法*"></a>软件开发方法*</h2><h3 id="传统开发方法"><a href="#传统开发方法" class="headerlink" title="传统开发方法"></a>传统开发方法</h3><p>结构化方法：分阶段的，顺序的，依赖性</p><p>缺点：缺少灵活性，静态，缺少应对变化的能力</p><h3 id="面向对象方法"><a href="#面向对象方法" class="headerlink" title="面向对象方法"></a>面向对象方法</h3><p>将软件构件划分为<strong>类</strong>，并定义一组静态的<strong>变量</strong>和动态的<strong>方法</strong></p><p>利用父子类和<strong>继承</strong>的关系形成<strong>层次结构</strong>，</p><p><strong>封装性</strong>：对象间仅能通过发送消息互相联系</p><p>通过<strong>反复迭代</strong>开发软件，降低<strong>复杂性</strong>，提高<strong>可理解性</strong>，支持<strong>软件重用</strong></p><p>更好的应对变化</p><h2 id="软件开发各阶段活动及任务"><a href="#软件开发各阶段活动及任务" class="headerlink" title="软件开发各阶段活动及任务*"></a>软件开发各阶段活动及任务*</h2><ul><li>可行性分析：高层次需求分析 - 技术，经济，社会</li><li>需求分析：进行<strong>变更管理</strong>适应变化，分为功能性和非功能性，输出需求规格说明书</li><li>软件设计：概要+详细</li><li>程序编码</li><li>软件测试：单元-&gt;集成-&gt;系统，分为黑盒和白盒</li><li>软件维护：改正性，适应性，完善性，预防性</li></ul><h2 id="生命周期模型"><a href="#生命周期模型" class="headerlink" title="生命周期模型"></a>生命周期模型</h2><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型*"></a>瀑布模型*</h3><p>传统开发方法 <strong>最广泛</strong>，顺序性，依赖性</p><p>推迟写代码，每个阶段都写文档</p><p>缺点：用户参与少，静态</p><h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型*"></a>快速原型模型*</h3><p>看名</p><p>优点： 用户参与多了</p><p>缺点： 原型大概率抛弃</p><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><p>分为功能模块，逐步实现（开放架构）</p><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>瀑布+快速原型+风险分析</p><p>每阶段增加风险分析，降低风险</p><h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型*"></a>喷泉模型*</h3><p>迭代和无缝</p><p>总目标：线性过程</p><p><strong>迭代</strong> 逐步求精，面向对象</p><h2 id="敏捷"><a href="#敏捷" class="headerlink" title="敏捷"></a>敏捷</h2><h3 id="敏捷宣言"><a href="#敏捷宣言" class="headerlink" title="敏捷宣言"></a>敏捷宣言</h3><ul><li>个体 + 互动 &gt; 流程 + 工具</li><li>软件 &gt; 文档</li><li>客户合作 &gt; 合同谈判</li><li>相应变化 &gt; 遵循计划</li></ul><h3 id="增量和迭代"><a href="#增量和迭代" class="headerlink" title="增量和迭代"></a>增量和迭代</h3><p>系统由三个模块构成</p><ul><li><p>增量：一个个实现</p></li><li><p>迭代：实现三个垃圾模块，再一步步求精</p></li></ul><h3 id="SCRUM"><a href="#SCRUM" class="headerlink" title="SCRUM*"></a>SCRUM*</h3><p><strong>冲刺 Sprint</strong>：一个工作周期</p><ul><li>产品订单：项目的概要文档，以天为单位</li><li>冲刺订单：小文档，以 16 小时为单位</li><li>燃尽图：to-do list</li></ul><p>角色</p><ul><li>产品拥有者：甲方领导</li><li>利益相关者：客户</li><li>专家：技术总监</li><li>团队成员：程序员</li></ul><p>活动</p><ul><li>计划会：冲刺初制定计划</li><li>每日立会：每天15分钟</li><li>评审会：冲刺结束前</li><li>反思会/回顾会：冲刺结束后</li></ul><p>XP(极限编程) 于 SCRUM 区别</p><table><thead><tr><th></th><th>XP</th><th>SCRUM</th></tr></thead><tbody><tr><td>迭代长度</td><td>1-2周</td><td>3-4周</td></tr><tr><td>迭代中是否允许修改需求</td><td>yes</td><td>no</td></tr><tr><td>迭代中是否按优先级实现</td><td>yes</td><td>no</td></tr><tr><td>是否采用严格工程方法，保证进度质量</td><td>yes</td><td>no</td></tr></tbody></table><h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3><p>自动化，高度依赖工具</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="用户-amp-系统"><a href="#用户-amp-系统" class="headerlink" title="用户 &amp; 系统"></a>用户 &amp; 系统</h3><ul><li>系统需求是对用户需求的细化和完善</li><li>系统需求的阅读对象是开发者，用户需求是客户</li><li>系统需求是用户需求的开始</li><li>目标 &amp; 涉众</li></ul><h3 id="涉众"><a href="#涉众" class="headerlink" title="涉众"></a>涉众</h3><p>与目标系统相关的一切人和物</p><h3 id="系统功能的确定"><a href="#系统功能的确定" class="headerlink" title="系统功能的确定"></a>系统功能的确定</h3><p>正式和非正式的访谈</p><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>用例-&gt;规约用例并生成文档-&gt;活动图-&gt;文字功能性需求</p><h4 id="三种功能性需求"><a href="#三种功能性需求" class="headerlink" title="三种功能性需求"></a>三种功能性需求</h4><p>系统功能需求 + 交互需求 + 外部接口需求</p><h4 id="需求说明书"><a href="#需求说明书" class="headerlink" title="需求说明书"></a>需求说明书</h4><p>文档+涉众+目标+功能，非功能+交付物+验收标准+附件</p><h4 id="需求跟踪"><a href="#需求跟踪" class="headerlink" title="需求跟踪"></a>需求跟踪</h4><p>业务，需求，类模型 三者递归确定，互有对应</p><p>活动图，需求文档，类图</p><p>提高完备性，同时检查是否有冗余（有没有缺的，多的）</p><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><h3 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h3><p>构件 + 连接件 + 配置</p><h3 id="数据流风格"><a href="#数据流风格" class="headerlink" title="数据流风格"></a>数据流风格</h3><p><strong>管道与过滤器</strong>：信息隐藏，高内聚低耦合，可以灵活组合</p><p><strong>层次系统</strong>：计算机网络</p><p><strong>正交软件架构</strong>：</p><ul><li><p>层：一组具有相同抽象级别的构件</p></li><li><p>线索：用例形成的调用关系</p></li><li><p>好处：每个需求变动仅影响某一条线索</p></li></ul><p><strong>客户机服务器架构</strong>：</p><ul><li>一个服务器服务多个客户端</li><li>适应变化，灵活</li><li>易于对系统进行扩充和缩小</li><li>功能构建隔离</li></ul><p><strong>浏览器/服务器架构</strong>：基本同上+抽取client的function形成的web服务器</p><h3 id="独立构建风格"><a href="#独立构建风格" class="headerlink" title="独立构建风格"></a>独立构建风格</h3><h4 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构*"></a>MVC架构*</h4><ul><li><p>Model: 企业数据和业务规则</p></li><li><p>View: 用户看到并与之交互的界面</p></li><li><p>Controller: 根据输入调用模型和视图去完成用户的需求，不输出结果，不做任何处理</p></li></ul><h3 id="数据中心风格-仓库系统"><a href="#数据中心风格-仓库系统" class="headerlink" title="数据中心风格 - 仓库系统"></a>数据中心风格 - 仓库系统</h3><p>星型结构，中央数据库和周边client</p><p>黑板系统：中央数据库将状态通知client，由client决定选择</p><h2 id="类的分析与设计"><a href="#类的分析与设计" class="headerlink" title="类的分析与设计"></a>类的分析与设计</h2><p>迭代逐级细化</p><h3 id="类的种类"><a href="#类的种类" class="headerlink" title="类的种类"></a>类的种类</h3><ul><li>实体类：存储，传递数据的类，名词</li><li>控制类：管理类，体现执行逻辑，动宾</li><li>边界类：外部用户交互，界面类，数据交换类</li></ul><h4 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h4><p>初始类图-实体类</p><p><strong>实体类</strong> <code>&lt;&lt;entity&gt;&gt;</code></p><ul><li>类名：构造性</li><li>变量：<ul><li>可见性 (private, public ..) - (<code>-+_~</code>)</li><li>依赖（计算）属性，(<code>/</code>)</li><li>名字</li><li>类型：UML定义的，int String…</li><li>下划线：表示静态</li></ul></li></ul><p>没有方法</p><h4 id="类的关系"><a href="#类的关系" class="headerlink" title="类的关系*"></a>类的关系*</h4><ul><li>关联关系：静态，拥有，长期持久</li><li>导航方向：箭头，包含关系</li><li>依赖关系：动态，临时 - 避免双向依赖</li><li>依赖 包含 关联</li></ul><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul><li>对象名：类的类型</li><li>实例变量 = 初始值</li><li>对象名为空代表匿名对象，类名为空代表有上下文</li></ul><h4 id="管理类-amp-控制类"><a href="#管理类-amp-控制类" class="headerlink" title="管理类 &amp; 控制类"></a>管理类 &amp; 控制类</h4><table><thead><tr><th></th><th>管理类</th><th>控制类</th></tr></thead><tbody><tr><td></td><td>不考虑get，set方法</td><td>隔离边界与实体</td></tr><tr><td>对象</td><td>对于同类对象的协调和管理</td><td>不同类</td></tr><tr><td>层</td><td>Domain层</td><td>业务控制层</td></tr><tr><td>作用</td><td>创建对象，代理访问其他对象</td><td>一个用例一个</td></tr></tbody></table><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>利用抽象类隔离变化</p><p>空三角箭头表示继承</p><h4 id="枚举类-lt-lt-enumeration-gt-gt"><a href="#枚举类-lt-lt-enumeration-gt-gt" class="headerlink" title="枚举类 &lt;&lt;enumeration&gt;&gt;"></a>枚举类 <code>&lt;&lt;enumeration&gt;&gt;</code></h4><h4 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h4><p>对实体，生成 <code>ProjectMask</code> 代理类</p><h4 id="CASE工具"><a href="#CASE工具" class="headerlink" title="CASE工具"></a>CASE工具</h4><p>软件开发环境，计算机辅助软件工程</p><h2 id="类的关系-1"><a href="#类的关系-1" class="headerlink" title="类的关系"></a>类的关系</h2><h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><table><thead><tr><th>是否要求顺序</th><th>是否要求唯一性</th><th></th></tr></thead><tbody><tr><td>no</td><td>yes</td><td>Set</td></tr><tr><td>no</td><td>no</td><td>Bag/Multiset</td></tr><tr><td>yes</td><td>yes</td><td>OrderedSet</td></tr><tr><td>yes</td><td>no</td><td>List/Sequence</td></tr></tbody></table><p>适用模板类而非具体类</p><h4 id="聚合-聚集"><a href="#聚合-聚集" class="headerlink" title="聚合 - 聚集"></a>聚合 - 聚集</h4><p>部分与整体，共享</p><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>存在依赖性 - 同生共死</p><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>访问的瞬时性 - 用参数</p><h2 id="类的详细设计"><a href="#类的详细设计" class="headerlink" title="类的详细设计"></a>类的详细设计</h2><p>算法+数据结构+物理结构</p><p>其他设计+详细设计说明书+评审</p><p>什么是结构化的程序</p><h3 id="盒图"><a href="#盒图" class="headerlink" title="盒图"></a>盒图</h3><p>图例：不允许随意跳转 - 向里嵌套</p><h3 id="PAD图"><a href="#PAD图" class="headerlink" title="PAD图"></a>PAD图</h3><p>问题分析图 - 向右嵌套</p><h3 id="判定表"><a href="#判定表" class="headerlink" title="判定表"></a>判定表</h3><p>使用<code>—</code>来表 示对此条件的不关心或不适用</p><p>判定树：结点-选择，叶子-结果</p><h3 id="PDL"><a href="#PDL" class="headerlink" title="PDL"></a>PDL</h3><p>人话版的C语言</p><h3 id="OCL"><a href="#OCL" class="headerlink" title="OCL"></a>OCL</h3><h2 id="设计优化"><a href="#设计优化" class="headerlink" title="设计优化"></a>设计优化</h2><h3 id="smell"><a href="#smell" class="headerlink" title="smell"></a>smell</h3><p>僵化性，脆弱性，顽固性，粘滞性，复杂，重复，晦涩</p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><ul><li>与父类方法有相似的行为，细节调整</li><li>相同条件工作，子类不应具有比其父类更严格的条件限制 - <strong>Liskov 替换原则</strong></li><li>重写的方法最高不能超出父类方法的状态。</li></ul><p>循环依赖：提取接口</p><p>狎昵关系：两个类过分亲密，高耦合</p><p>接口隔离原则：接口的稳定，适应变化，同一个类提取不同的接口</p><p>依赖倒置原则：依赖于抽象</p><p>开放封闭原则：扩展开放，修改封闭</p><p>单一职责原则：单一功能</p><p>合成/聚合复用原则：尽量使用合成/聚合形式的委托重用，尽量不使用继承重用</p><blockquote><p>子类是父类的特殊类型</p></blockquote><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li>架构模式：MVC，层次等</li><li>设计模式：抽象工程之类的</li><li>实现模式：具体到写代码，类名，变量名，函数名</li></ul><table><thead><tr><th></th><th>创建模式</th><th>结构模式</th><th>行为模式</th></tr></thead><tbody><tr><td>类</td><td>抽象工厂</td><td>适配器</td><td>观察者模式</td></tr><tr><td>类</td><td>单例</td><td>桥 - 装饰</td><td>策略模式</td></tr><tr><td>类</td><td></td><td>代理</td><td>状态</td></tr><tr><td>类</td><td></td><td>门面</td><td></td></tr></tbody></table><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>工厂表示一组产品的打包，不同的工厂对应不同的组合</p><p>抽象工厂是一个接口，用于生成一组对象，实际对象根据类别又有自己的接口</p><p>低耦合，且添加新的更容易</p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>管理类或控制类系统中只需要一个实例，该实例在程序中被创建</p><p>要求类的构造方法是私有的，有公有的方法获取该类的实例，实例变量为私有或受保护的。</p><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>利用适配器进行接口的转换</p><h4 id="桥模式"><a href="#桥模式" class="headerlink" title="桥模式"></a>桥模式</h4><p>先将不同的变化维度（单一职责原则）分离，每个维度都有独立的抽象和继承结构，建立抽象耦合</p><h4 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h4><p>对于负数功能，若将其归入不同的变化维度太多了，归入装饰器</p><p>将 Bridge 中的抽象和实现合二为一了，是其特殊形式</p><h4 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h4><p>外部与一个子系统的通信必须通过一个统一的门面对象，且单例</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>中介，负责资源的中间处理，节省主体的时间</p><p>用来对有价值稀缺资源的管理，比如数据库的连接等，提高资源的利用率或系统性能</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>MVC 适用了观察者</p><p>当主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己</p><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>将每一个算法封装到具有共同接口的独立的类中</p><p>灵活可以相互替换</p><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p>使用一个具有多个子类的类，提前创建所有对应的子类，状态变化时换类</p><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p>测试的通过并不能用来证明整个系统是正确的</p><h3 id="测试V模型-测试"><a href="#测试V模型-测试" class="headerlink" title="测试V模型 + 测试*"></a>测试V模型 + 测试*</h3><table><thead><tr><th>测试名称</th><th>开发阶段</th><th>测试对象</th><th>测试方法</th></tr></thead><tbody><tr><td>单元测试</td><td>实现</td><td>类测试</td><td>白盒测试</td></tr><tr><td>集成测试</td><td>系统设计</td><td>包或系统测试-交互</td><td>灰盒测试</td></tr><tr><td>系统测试</td><td>系统需求</td><td>构件和接口测试</td><td>黑盒测试</td></tr><tr><td>验收测试</td><td>客户需求</td><td>现场复现</td><td>黑盒测试</td></tr></tbody></table><p>为什么要早修正</p><ul><li>涉及的范围越来越广泛</li><li>曾经付出的成本越来越高</li></ul><p>看一眼 P9 左下图</p><h5 id="非功能测试"><a href="#非功能测试" class="headerlink" title="非功能测试"></a>非功能测试</h5><p>峰值，尖峰，压力，浸泡</p><h4 id="软件度量"><a href="#软件度量" class="headerlink" title="软件度量"></a>软件度量</h4><h5 id="McCabe-控制流图"><a href="#McCabe-控制流图" class="headerlink" title="McCabe + 控制流图"></a>McCabe + 控制流图</h5><p>边数 - 点数 + 2 = 分支结点+1</p><h5 id="LCOM"><a href="#LCOM" class="headerlink" title="LCOM"></a>LCOM</h5><p><img src="https://s2.loli.net/2021/12/20/3BY8Z46qzw5btSX.png" alt=""></p><p>m为方法数，a为所含的实例变量数，为访问每个实例变量的方法数。</p><h4 id="等价类测试-黑盒"><a href="#等价类测试-黑盒" class="headerlink" title="等价类测试 - 黑盒"></a>等价类测试 - 黑盒</h4><ul><li>数值：一般，一个有效，两个无效</li><li>其他：一个有效，一个无效</li><li>传统 + 强等价类方法</li><li>边界值分析：对数值边界创建有效或无效等价类</li></ul><h4 id="控制流的覆盖测试-白盒"><a href="#控制流的覆盖测试-白盒" class="headerlink" title="控制流的覆盖测试 - 白盒"></a>控制流的覆盖测试 - 白盒</h4><ul><li>语句覆盖 - 结点</li><li>分支覆盖 - 边</li><li>条件覆盖 - 原子谓词真假</li></ul><p>满足分支覆盖要求一定会满足语句覆盖要求</p><ul><li><p>分支覆盖不能覆盖条件，因为条件是原子谓词判断，但对于组合条件可能会有诸如短路的情况</p></li><li><p>条件不能覆盖分支，因为是原子谓词，可能有没覆盖到的情况</p></li></ul><p>分支，条件并不完全覆盖，综合一下</p><ul><li><p>多条件组合覆盖 - 原子谓词及其组合覆盖</p></li><li><p>基本路径测试 - 独立路径 （ 独立路径要求在路径中至少含有一条未曾使用过的边）</p><ul><li><code>&lt;= V(G)</code></li></ul></li></ul><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><h4 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h4><p>可测试性 - 彼此依赖而需要模拟程序或桩</p><p>设计简单方法</p><p>避免私有方法</p><p>优先使用通用方法</p><p>组合优于继承</p><p>避免隐藏的依赖关系与全局状态</p><h4 id="人工测试"><a href="#人工测试" class="headerlink" title="人工测试"></a>人工测试</h4><p>审查 - 评审 - 走查</p><h2 id="CMMI"><a href="#CMMI" class="headerlink" title="CMMI"></a>CMMI</h2><p>统一的，明确定义的组织级软件工程</p><p>初始级 - 已管理 - 已定义 - 已量化管理 - 优化</p><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><p>注意同一个图中的用例在同一个抽象级别</p><h4 id="角色-Actor"><a href="#角色-Actor" class="headerlink" title="角色 Actor"></a>角色 Actor</h4><p>人或软件系统，使用系统，与系统有关系</p><h4 id="寻找用例"><a href="#寻找用例" class="headerlink" title="寻找用例"></a>寻找用例</h4><h4 id="包含关系-lt-lt-include-gt-gt"><a href="#包含关系-lt-lt-include-gt-gt" class="headerlink" title="包含关系 &lt;&lt;include&gt;&gt;"></a>包含关系 <code>&lt;&lt;include&gt;&gt;</code></h4><p>一些通用，共同基础过程的功能，避免重复实现 - 非逻辑分解</p><p>关键词：依赖，包含</p><h4 id="扩展关系-lt-lt-extend-gt-gt"><a href="#扩展关系-lt-lt-extend-gt-gt" class="headerlink" title="扩展关系 &lt;&lt;extend&gt;&gt;"></a>扩展关系 <code>&lt;&lt;extend&gt;&gt;</code></h4><p>特殊情况，需要有条件</p><p>关键词：错误，特殊情况</p><h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3><p>跨用例</p><h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><ul><li><strong>开始点</strong>：实心圆点</li><li><strong>结束点</strong>：实心加一圈</li><li><strong>动作</strong>：圆角矩形</li><li><strong>条件</strong>：菱形 - 可省略</li><li><strong>分支，汇聚</strong>：粗横线，{and}，{or}</li><li><strong>对象</strong>：直角矩形</li><li><strong>集合</strong>：多个动作（三叉戟）</li></ul><p>如果动作具有多个汇聚的箭头，需要等待所有分支都完成</p><h4 id="泳道"><a href="#泳道" class="headerlink" title="泳道"></a>泳道</h4><p>按角色划分</p><h4 id="基本事件流和备选"><a href="#基本事件流和备选" class="headerlink" title="基本事件流和备选"></a>基本事件流和备选</h4><p>利用中括号<code>[]</code>围绕子活动或者进入备选事件流的条件，可以另用活动图描述</p><h3 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h3><h4 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a>基本符号</h4><p>实体，处理，存储，流</p><h4 id="画法"><a href="#画法" class="headerlink" title="画法"></a>画法</h4><p>看课件</p><h3 id="包图"><a href="#包图" class="headerlink" title="包图"></a>包图</h3><p>大包嵌套小包，小包嵌套类</p><p>⊕：嵌套关系</p><p>虚线：层间的使用(依赖)关系</p><p>实线：包间的使用(依赖)关系</p><p>空心三角：继承</p><p>避免循环依赖</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><h4 id="领域模型-1"><a href="#领域模型-1" class="headerlink" title="领域模型"></a>领域模型</h4><h5 id="实体类-lt-lt-entity-gt-gt"><a href="#实体类-lt-lt-entity-gt-gt" class="headerlink" title="实体类 &lt;&lt;entity&gt;&gt;"></a>实体类 <code>&lt;&lt;entity&gt;&gt;</code></h5><ul><li>类名：构造性</li><li>变量：<ul><li>可见性 (private, public ..) - (<code>-+_~</code>)</li><li>依赖（计算）属性，(<code>/</code>)</li><li>名字：</li><li>类型：UML定义的，int String…</li><li>下划线：表示静态</li></ul></li><li>方法：<ul><li>同上</li><li>参数三种类型：in, out, inout</li></ul></li></ul><p>没有方法</p><h4 id="关联类"><a href="#关联类" class="headerlink" title="关联类"></a>关联类</h4><p>描述两个对象之间的联系</p><h3 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h3><p>表示一个用例，同步调用的方式（阻塞）</p><ul><li>控制焦点：长方形</li><li>生命线：竖虚线</li><li>同步消息：实心三角箭头（左右都可以）</li><li>返回消息：虚线左箭头</li><li>异步消息：创建对象，虚线右箭头</li></ul><p>结构：</p><ul><li>方括号 condition</li><li>可选：opt - 有条件执行的动作，不满足条件就不执行</li><li>多分支 alt - 不同的条件执行不同</li><li>循环 loop (start,end,condition)</li></ul><h3 id="通信图"><a href="#通信图" class="headerlink" title="通信图"></a>通信图</h3><p>可嵌套，或用编号 编号表示嵌套级别</p><p>其他与顺序图类似</p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p>唯一的开始状态，可以有多个结束状态，针对确定性行为</p><p>转台框中的三个状态：Entry - Do - Exit</p><h4 id="状态转换-过渡"><a href="#状态转换-过渡" class="headerlink" title="状态转换 - 过渡"></a>状态转换 - 过渡</h4><p>事件+[条件]+动作</p><p>在事件被触发并且满足某个特定条件的情况下才会进行</p><p>动作：entry 执行前，未进入状态时做的动作</p><p>层次化组织：框起来</p><p>分解：分解为互不依赖的子状态 - 子状态离开</p><p>并行：有两个输入，则都完成才会被触发</p><h2 id="体系结构风格"><a href="#体系结构风格" class="headerlink" title="体系结构风格"></a>体系结构风格</h2><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>从低到高排序</p><p>内聚程度：内部各个元素彼此结合的紧密程度 - 越高，模块独立性越强</p><ul><li>偶然内聚</li><li>逻辑内聚</li><li>时间内聚</li><li>通信内聚</li><li>顺序内聚</li><li>功能内聚</li></ul><p>耦合程度：模块之间互相连接的紧密程度 - 越低，模块独立性越强</p><p>非直接 &lt; 数据 &lt; 标记 &lt; 控制 &lt; 外部 &lt; 公共 &lt; 内容</p><h3 id="4-1-视图模型"><a href="#4-1-视图模型" class="headerlink" title="4+1 视图模型"></a>4+1 视图模型</h3><p>用例在中间，四周是逻辑视图（功能需求），开发试图（软件模块），进程视图（并发），物理视图（硬件）</p>          </div>]]></content>
    
    <summary type="html">
    
      Copyright (c) Dingsoul&lt;br&gt;Link: https://dingiso.github.io/2021/03/11/软件工程复习/
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Unix Network Programming Review</title>
    <link href="https://augists.top/NOTES/COURSES/Advanced_C/Unix-Network-Programming-Review/"/>
    <id>https://augists.top/NOTES/COURSES/Advanced_C/Unix-Network-Programming-Review/</id>
    <published>2021-12-16T07:52:12.000Z</published>
    <updated>2021-12-25T15:00:50.777Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>大小端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">union</span> un</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">short</span> a;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">  &#125;u;</span><br><span class="line"></span><br><span class="line">  u.a = <span class="number">0x0102</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(u.b[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; u.b[<span class="number">1</span>] == <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;big endian&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(u.b[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; u.b[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;small endian&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>intro/daytimetcpcli.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd, n;</span><br><span class="line">  <span class="keyword">char</span> recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;usage: a.out &lt;IPaddress&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = htons(<span class="number">13</span>);</span><br><span class="line">  <span class="keyword">if</span> (inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;inet_pton error for %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (connect(sockfd, (SA *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( (n = read(sockfd, recvline, MAXLINE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    recvline[n] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>) == EOF)</span><br><span class="line">      err_sys(<span class="string">&quot;fputs error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>intro/daytimetcpsrv.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">  <span class="keyword">char</span> buff[MAXLINE];</span><br><span class="line">  <span class="keyword">time_t</span> ticks;</span><br><span class="line"></span><br><span class="line">  listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  bzeros(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  servaddr.sin_port = htons(<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">  Bind(listenfd, (SA *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">  Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">    connfd = Accept(listenfd, (SA *) <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    ticks = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(buff, <span class="keyword">sizeof</span>(buff), <span class="string">&quot;%.24s\r\n&quot;</span>, ctime(&amp;ticks));</span><br><span class="line">    Write(connfd, buff, <span class="built_in">strlen</span>(buff));</span><br><span class="line"></span><br><span class="line">    Close(connfd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Concurrent Server</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> listenfd, connfd;</span><br><span class="line"></span><br><span class="line">listenfd = Socket ( ... );</span><br><span class="line"></span><br><span class="line">Bind(listenfd, ... );</span><br><span class="line">Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">  connfd = Accept(listenfd, ... );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (pid = Fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">    Close(listenfd);  <span class="comment">/* child closes listening socket */</span></span><br><span class="line">    doit(connfd);     <span class="comment">/* process the request */</span></span><br><span class="line">    Close(connfd);    <span class="comment">/* done with this client */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);          <span class="comment">/* child terminates */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   Close(connfd);     <span class="comment">/* parent close connected socket */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TCP echo server<br><code>tcpdiserv/tcpserv01.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_echo</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> n;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">  <span class="keyword">while</span> ( (n = read(sockfd, buf, MAXLINE)) &gt; <span class="number">0</span>)</span><br><span class="line">    Writen(sockfd, buf, n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">    <span class="keyword">goto</span> again;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;str_echo: read error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">  <span class="keyword">pid_t</span> childpid;</span><br><span class="line">  <span class="keyword">socklen_t</span> clilen;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  listenfd = Socket (AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  servaddr.sin_port(SERV_PORT);</span><br><span class="line"></span><br><span class="line">  Bind(listenfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; ; )</span><br><span class="line">  &#123;</span><br><span class="line">    clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (childpid = fork()) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      Close(listenfd);</span><br><span class="line">      str_echo(connfd);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(connfd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tcpcliserv/tcpcli01.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    Writen(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Readline(sockfd, recvline, MAXLINE) == <span class="number">0</span>)</span><br><span class="line">      err_quit(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;usage: tcpcli &lt;IPaddress&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  sockfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">  Inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">  Connect(sockfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">  str_cli(<span class="built_in">stdin</span>, sockfd);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UDP echo server<br><code>udpcliserv/udpserv01.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dg_echo</span><span class="params">(<span class="keyword">int</span> sockfd, SA *pcliaddr, <span class="keyword">socklen_t</span> clilen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">socklen_t</span> len;</span><br><span class="line">  <span class="keyword">char</span> mesg[MAXLINE];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; ; )</span><br><span class="line">  &#123;</span><br><span class="line">    len = clilen;</span><br><span class="line">    n = Recvfrom(sockfd, mesg, MAXLINE, <span class="number">0</span>, pcliaddr, &amp;len);</span><br><span class="line">    Sendto(sockfd, mesg, n, <span class="number">0</span>, pcliaddr, len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  sockfd = Socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">  Bind(sockfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">  dg_echo(sockfd, (SA *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UDP echo client<br><code>udpcliserv/udpcli01.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&quot;unp.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dg_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd, <span class="keyword">const</span> SA *pservaddr, <span class="keyword">socklen_t</span> servlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    Sendto(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>, pservaddr, servlen);</span><br><span class="line"></span><br><span class="line">    n = Recvfrom(sockfd, recvline, MAXLINE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    recvline[n] = <span class="number">0</span>;</span><br><span class="line">    Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;usage: udpcli &lt;IPaddress&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servadr.sin_port = htons(SERV_PORT);</span><br><span class="line">  Inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">  sockfd = Socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  dg_cli(<span class="built_in">stdin</span>, sockfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>信号处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用:Signal(SIGCHID,sig_chld);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_chld</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> stat;   <span class="comment">//value-result para</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>解释datalink access，写出一个datalink access的实现</p><ul><li>操作系统为应用程序提供访问数据链路层的功能，这种功能可提供如下能力:<ul><li>能够监视由数据链路层接收的分组</li><li>能够作为普通应用进程而不是内核的一部分运行某些程序，例如: RARP<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL));</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>写出重启被中断的accept函数程序片段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">  clilen= <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">  <span class="keyword">if</span>(connfd=accept(listenfd,(struct sockaddr *)&amp;cliaddr, &amp;clilen) &lt;<span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      err_sys(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>TCP echo 程序如何区分服务器进程终止和服务器崩溃</p><ul><li>进程终止: 客户端收到一个 FIN 并返回一个 ACK，但客户进程此时处于 fgets 调用的阻塞中，等待从客户端接收到一行文本。(此时客户端并不知道服务器子进程已经终止，只是单纯的接收到了一个 FIN) 而后，我们在客户上再键入一行文本。<code>str_cli</code> 调用 writen 发送数据给服务子进程，但由于服务子进程已经关闭，于是发送一个RST。我们客户端 readline 时若先收到第二步中的 FIN，则立即返回 0，如果先接收到 RST，则返回一个 <code>ECONNRESET</code> (对方复位连接错误)</li><li>服务器崩溃: 在客户端上键入一行文本，由 writen 写入内核。writen 成功返回后，客户随后阻塞于 readline 调用，客户端持续重传数据分节，试图从服务器上接收一个 ACK。然而服务器已崩坏，没有任何响应，最终 readline 调用上返回一个错误。如果是主机崩溃，则返回超时 <code>ETIMEOUT</code></li><li>进程终止: 服务器发送 FIN</li><li>崩溃: 服务器不会在已有网络上发送任何信号</li></ul></li></ul><h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><p>考著名的人物：</p><ul><li>c语言作者，unix 作者：Ken Thompson (Dennis M. Ritchie)</li><li>GNU 创建者/Emacs 作者 Richard Matthew Stallman </li><li>linux 作者：Linus Benedict Torvalds</li><li>vim 作者：Bram Moolenaar</li><li>Tex 作者：Donald Knuth 高德纳</li></ul><h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><p>TCP 状态转换图 ， 2.9 常用的Port Number ，2.10 Concurrent Server ， 2.12 services</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">21端口：FTP 文件传输服务</span><br><span class="line">22端口：SSH 端口</span><br><span class="line">23端口：TELNET 终端仿真服务</span><br><span class="line">25端口：SMTP 简单邮件传输服务</span><br><span class="line">53端口：DNS 域名解析服务</span><br><span class="line">80端口：HTTP 超文本传输服务</span><br><span class="line">110端口：POP3 “邮局协议版本3”使用的端口</span><br><span class="line">443端口：HTTPS 加密的超文本传输服务</span><br><span class="line">**********************************</span><br><span class="line">1433端口：MS SQL*SERVER数据库 默认端口号</span><br><span class="line">1521端口：Oracle数据库服务</span><br><span class="line">1863端口：MSN Messenger的文件传输功能所使用的端口</span><br><span class="line">3306端口：MYSQL 默认端口号</span><br><span class="line">3389端口：Microsoft RDP 微软远程桌面使用的端口</span><br><span class="line">5631端口：Symantec pcAnywhere 远程控制数据传输时使用的端口</span><br><span class="line">5632端口：Symantec pcAnywhere 主控端扫描被控端时使用的端口</span><br><span class="line">5000端口：MS SQL Server使用的端口</span><br><span class="line">8000端口：腾讯QQ</span><br></pre></td></tr></table></figure><h2 id="Chapter-3，4，5，6"><a href="#Chapter-3，4，5，6" class="headerlink" title="Chapter 3，4，5，6"></a>Chapter 3，4，5，6</h2><h3 id="Socket-Address-Structures"><a href="#Socket-Address-Structures" class="headerlink" title="Socket Address Structures"></a>Socket Address Structures</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span>         s_addr;           <span class="comment">/* 32-bit IPv4 address */</span></span><br><span class="line">                                <span class="comment">/* network byte ordered */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         sin_len;         <span class="comment">/* length of structure (16) */</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>       sin_family;   <span class="comment">/* AF_INET */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>            sin_port;       <span class="comment">/* 16-bit TCP or UDP port number */</span></span><br><span class="line">                                                <span class="comment">/* network byte ordered */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>        <span class="comment">/* 32-bit IPv4 address */</span></span><br><span class="line">                                                <span class="comment">/* network byte ordered */</span></span><br><span class="line">    <span class="keyword">char</span>                   sin_zero[<span class="number">8</span>];  <span class="comment">/* unused */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IPV4</span></span><br><span class="line">inet_addr inet_ntoa</span><br><span class="line"><span class="comment">// IPV4/6</span></span><br><span class="line">inet_pton inet_ntop</span><br></pre></td></tr></table></figure><ul><li>in_addr 是结构的原因是早期将其定义为 union 方便A，B，C类地址的访问</li><li>sin_zero 置0</li></ul><h3 id="Generic-socket-address-structure"><a href="#Generic-socket-address-structure" class="headerlink" title="Generic socket address structure"></a>Generic socket address structure</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>       sa_len;</span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;      <span class="comment">/* address family: AF_xxx value */</span></span><br><span class="line">    <span class="keyword">char</span>             sa_data[<span class="number">14</span>]; <span class="comment">/* protocol-specific address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span>, struct sockaddr *, <span class="keyword">socklen_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span>    <span class="comment">/* IPv4 socket address structure */</span></span><br><span class="line"><span class="comment">/* fill in serv&#123;&#125; */</span></span><br><span class="line">bind(sockfd, (struct sockaddr *) &amp;serv, <span class="keyword">sizeof</span>(serv));</span><br></pre></td></tr></table></figure><p>用于定义函数时适配各种不同类型的地址结构，</p><p>若不转换，编译器报 <code>warning: passing arg 2 of &#39;bind&#39; from incompatible pointer type</code></p><h3 id="Sockaddr-in6"><a href="#Sockaddr-in6" class="headerlink" title="Sockaddr_in6"></a>Sockaddr_in6</h3><p>128-bits ipv6 地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>     s6_addr[<span class="number">16</span>];  <span class="comment">/* 128-bit IPv6 address */</span></span><br><span class="line">                                        <span class="comment">/* network byte ordered */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIN6_LEN                 <span class="comment">/* required for compile-time tests */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>             sin6_len;           <span class="comment">/* length of this struct (28) */</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>       sin6_family;       <span class="comment">/* AF_INET6 */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>           sin6_port;           <span class="comment">/* transport layer port# */</span></span><br><span class="line">                                                    <span class="comment">/* network byte ordered */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>             sin6_flowinfo;  <span class="comment">/* flow information, undefined */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>           <span class="comment">/* IPv6 address */</span></span><br><span class="line">                                                    <span class="comment">/* network byte ordered */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>             sin6_scope_id;  <span class="comment">/* set of interfaces for a scope */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>The <code>sin6_flowinfo</code> member is divided into two fields:<ul><li>The low-order 20 bits are the flow label</li><li>The high-order 12 bits are reserved</li></ul></li></ul><h3 id="Value-Result"><a href="#Value-Result" class="headerlink" title="Value-Result"></a>Value-Result</h3><p>当我们把 <code>SA*</code> 从用户进程传入内核时长度作为值 value ，内核处理完返回时结构的大小可能会改变，因此长度作为一个结果 result 传回 , 引用是因为需要函数内部去赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户进程 =&gt; 内核</span></span><br><span class="line"><span class="comment">// bind connect sendto </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* fill in serv&#123;&#125; */</span></span><br><span class="line">connect(sockfd, (SA *) &amp;serv, <span class="keyword">sizeof</span>(serv));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核 =&gt; 用户进程</span></span><br><span class="line"><span class="comment">// accept recvfrom getsockname getpeername </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cli</span>;</span> <span class="comment">/* Unix domain */</span></span><br><span class="line"><span class="keyword">socklen_t</span> len;</span><br><span class="line"></span><br><span class="line">len = <span class="keyword">sizeof</span>(cli);           <span class="comment">/* len is a value */</span></span><br><span class="line">getpeername(unixfd, (SA *) &amp;cli, &amp;len);</span><br><span class="line"><span class="comment">/* len may have changed */</span></span><br></pre></td></tr></table></figure><h3 id="字节序-Byte-Ordering"><a href="#字节序-Byte-Ordering" class="headerlink" title="字节序 Byte Ordering"></a>字节序 Byte Ordering</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字节序转换函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> host16bitvalue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> host32bitvalue)</span></span>;</span><br><span class="line">                                     Both <span class="keyword">return</span>: value in network byte order</span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> net16bitvalue);</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> net32bitvalue)</span></span>;</span><br><span class="line">                                    Both <span class="keyword">return</span>: value in host byte order</span><br></pre></td></tr></table></figure><p>n - network , h - host , s - short 16 位, l - long 32 位</p><h3 id="Byte-Manipulation"><a href="#Byte-Manipulation" class="headerlink" title="Byte Manipulation"></a>Byte Manipulation</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bcopy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">void</span> *dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">bcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1, <span class="keyword">const</span> <span class="keyword">void</span> *ptr2, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line">                                    Returns: <span class="number">0</span> <span class="keyword">if</span> equal, nonzero <span class="keyword">if</span> unequal</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">int</span> c, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1, <span class="keyword">const</span> <span class="keyword">void</span> *ptr2, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line">                        Returns: <span class="number">0</span> <span class="keyword">if</span> equal, &lt;<span class="number">0</span> <span class="keyword">or</span> &gt;<span class="number">0</span> <span class="function"><span class="keyword">if</span> <span class="title">unequal</span> <span class="params">(see text)</span></span></span><br></pre></td></tr></table></figure><h3 id="地址转换函数"><a href="#地址转换函数" class="headerlink" title="地址转换函数"></a>地址转换函数</h3><h4 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// converts the C character string pointed to by strptr into</span></span><br><span class="line"><span class="comment">// its 32-bit binary network byte ordered value, </span></span><br><span class="line"><span class="comment">// which is stored through the pointer addrptr </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *strptr, struct in_addr *addrptr)</span></span>;</span><br><span class="line">                    Returns: <span class="number">1</span> <span class="keyword">if</span> <span class="built_in">string</span> was valid, <span class="number">0</span> on error</span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *strptr)</span></span>;</span><br><span class="line">                    Returns: <span class="number">32</span>-bit binary network byte ordered IPv4 address; INADDR_NONE <span class="keyword">if</span> error</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr inaddr)</span></span>;</span><br><span class="line">                    Returns: pointer to dotted-decimal <span class="built_in">string</span></span><br></pre></td></tr></table></figure><ul><li><p><code>inet_aton</code> 将字符串 <code>strptr</code> 转换为 32 比特二进制网络字节序地址 <code>addrptr</code></p></li><li><p><code>inet_addr</code> 作用同上，出错返回 <code>INADDR_NONE</code> 255.255.255.255, 所以不能处理该地址（被废弃）</p></li><li><p><code>inet_ntoa</code> 32bit 网络字节序到点分十进制 IPV4 字符串，储存在静态内存，不可重入</p></li></ul><h4 id="IPV4-6"><a href="#IPV4-6" class="headerlink" title="IPV4/6"></a>IPV4/6</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> *strptr, <span class="keyword">void</span> *addrptr)</span></span>;</span><br><span class="line">                                Returns: <span class="number">1</span> <span class="keyword">if</span> OK, <span class="number">0</span> <span class="keyword">if</span> input <span class="keyword">not</span> a valid presentation format, −<span class="number">1</span> on error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">void</span> *addrptr, <span class="keyword">char</span> *strptr, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line">                                Returns: pointer to result <span class="keyword">if</span> OK, <span class="literal">NULL</span> on error</span><br></pre></td></tr></table></figure><p>p - presentation , n - numeric</p><ul><li><code>family</code>: <code>AF_INET</code> / <code>AF_INET6</code> 不支持 errno= <code>EAFNOSUPPORT</code></li><li><code>inet_pton</code>: 字符串 strptr 转换为 addrptr 二进制地址结果</li><li><code>inet_ntop</code>: 相反，len 位 strptr 大小，防止溢出 - len太小，返回空指针 errno= <code>ENOSPC</code></li></ul><h3 id="读写函数"><a href="#读写函数" class="headerlink" title="读写函数"></a>读写函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writen</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readline</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> maxlen)</span></span>;</span><br><span class="line">                    All <span class="keyword">return</span>: number of bytes read <span class="keyword">or</span> written, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>readline 每次读一个字符，极端地慢</p><h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><p>基本 TCP 套接字编程</p><h3 id="Socket-函数"><a href="#Socket-函数" class="headerlink" title="Socket 函数"></a>Socket 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">                Returns: non-negative descriptor <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>AF_INET</th><th>AF_INET6</th><th>AF_LOCAL</th><th>AF_ROUTE</th><th>AF_KEY</th></tr></thead><tbody><tr><td>SOCK_STREAM</td><td>TCP SCTP</td><td>TCP SCTP</td><td>YES</td><td></td><td></td></tr><tr><td>SOCK_DGRAM</td><td>UDP</td><td>UDP</td><td>YES</td><td></td><td></td></tr><tr><td>SOCK_SEQPACKET</td><td>SCTP</td><td>SCTP</td><td>YES</td><td></td><td></td></tr><tr><td>SOCK_RAW</td><td>IPV4</td><td>IPV6</td><td></td><td>YES</td><td>YES</td></tr></tbody></table><h3 id="Connect-函数"><a href="#Connect-函数" class="headerlink" title="Connect 函数"></a>Connect 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">                                    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>client 用于与 server 连接，内核会自己选择临时端口</p><ul><li>75 s 无响应后返回 <code>ETIMEDOUT</code></li><li>若相应 RST 则马上返回 <code>ECONNREFUSED</code> - 指定端口没有等待连接</li><li>目的不可达，返回 <code>EHOSTUNREACH</code>, <code>ENETUNREACH</code></li></ul><p>错误</p><ul><li>如果给不存在的机器发送，因为没有 ARP reply , <code>ETIMEOUT</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect error: Connection timed out</span><br></pre></td></tr></table></figure><ul><li>如果给未运行 server 的机器发送，收到 RST ，<code>ECONNREFUSED</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect error: Connection refused</span><br></pre></td></tr></table></figure><ul><li>给不可达发送， 收到 ICMP 不可达错误，<code>EHOSTUNREACH</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect error: No route to host</span><br></pre></td></tr></table></figure><p>每次 connect 失败后，都需要关闭 sockfd 重新调用 socket 函数</p><h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind 函数"></a>bind 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">                                    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>32b ipv4 / 128b ipv6 + 16b TCP/UDP port number</p><p>Servers 会在启动时调用 bind 端口（程序定义） ，若没有则当调用 connect 或 listen 时，内核会选择一个临时端口 或 根据 SYN 的目的地址</p><p>Client 通常不会 bind 而是 connect 时由内核根据路径选择</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>wildcard 通配符</p><p>ipv4 : <code>INADDR_ANY</code> 0.0.0.0，内核等到TCP连接，UDP报文发送后选择ip地址</p><p>ipv6 : <code>in6addr_any</code> 由系统预先分配并置为 <code>IN6ADDR_ANY_INIT</code></p><p>RPC 例外，会通过 端口映射器注册</p><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p><code>EADDRINUSE</code> : <code>Address already in use</code> 地址已使用</p><h3 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen 函数"></a>listen 函数</h3><p>Server : convert unconnected socket into a passive socket</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line">                    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p><code>backlog</code> : 内核队列中排队的最大连接数</p><p>调用时间： socket bind 后， accept 前</p><p>为 listening socket 保持两个队列</p><ul><li><code>incomplete connection queue</code> 未完成连接队列，未完成握手，<code>SYN_RCVD</code> 态</li><li><code>completed connection queue</code> 已完成连接队列，完成握手，<code>ESTABLISHED</code> 态</li></ul><p>两队之和不超过 backlog</p><h3 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept 函数"></a>accept 函数</h3><p>返回已完成连接队列队头，如果为空，进程睡眠</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *cliaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">                        Returns: non-negative descriptor <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><ul><li><code>sockfd</code> : listening socket 监听</li><li><code>return</code> : connected socket 已连接</li><li><code>cliaddr</code> &amp; <code>addrlen</code> ：对端的地址和长度</li><li>一对多的关系，监听socket 保持打开，连接socket完成对一个客户的服务就关闭</li></ul><h4 id="bind-错误"><a href="#bind-错误" class="headerlink" title="bind 错误"></a>bind 错误</h4><ul><li>非超级用户：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> error: Permission denied</span><br></pre></td></tr></table></figure><h3 id="fork-和-exec-函数"><a href="#fork-和-exec-函数" class="headerlink" title="fork 和 exec 函数"></a>fork 和 exec 函数</h3><p>fork 是唯一生成新进程的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">            Returns: <span class="number">0</span> in child, process ID of child in parent, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><h3 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h3><p>父进程 listenfd 监听，子进程 connfd 负责接收数据和实际操作</p><h3 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line">                        Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>为了方便多个进程使用套接字，它是引用计数的。</p><p>内核会发完所有等待发送的数据，然后 TCP 连接终止过程</p><p>如果只想发送FIN，改用 <code>shutdown</code> 函数</p><h3 id="地址函数"><a href="#地址函数" class="headerlink" title="地址函数"></a>地址函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *localaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *peeraddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">                            Both <span class="keyword">return</span>: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>sock 本地，peer 连接对端</p><p>重点基本都要求掌握、5.13不要求掌握</p><p>6.9，6.20 不要求掌握</p><h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><h3 id="TCP-Echo-Server"><a href="#TCP-Echo-Server" class="headerlink" title="TCP Echo Server"></a>TCP Echo Server</h3><p>Port : 5000 - 49152</p><h3 id="Normal-Startup"><a href="#Normal-Startup" class="headerlink" title="Normal Startup"></a>Normal Startup</h3><p>server 阻塞在 accept （还未启动用户）</p><p>client 阻塞在 fgets 调用</p><p>连接</p><p>服务器阻塞在 read ，父进程阻塞在 accept</p><p>此时 三个进程 STAT 都是 S- sleeping - （已阻塞）</p><p>WCHAN 父进程 wait_for_connect , server tcp_data_wait , client - read_chan</p><h3 id="Normal-Termination"><a href="#Normal-Termination" class="headerlink" title="Normal Termination"></a>Normal Termination</h3><p>Client ： EOF 字符（Control+D) 终止服务器</p><p>客户端进入 <code>TIME_WAIT</code> 状态</p><h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><p><code>SIGKILL</code> &amp; <code>SIGSTOP</code> 不能被捕获</p><p>信号处理函数是一个仅有一个整数参数且不返回值的函数</p><h4 id="wait-amp-waitpid"><a href="#wait-amp-waitpid" class="headerlink" title="wait &amp; waitpid"></a>wait &amp; waitpid</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *statloc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line">                        Both <span class="keyword">return</span>: process ID <span class="keyword">if</span> OK, <span class="number">0</span> <span class="keyword">or</span> −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>处理已终止的子进程</p><ul><li>返回值： 已终止子进程的进程 ID 号，通过 statloc 指针返回的子进程终止状态（一个整数）</li><li>对于同种类型的信号，主机只会执行一次信号处理函数</li></ul><h4 id="accept-返回前连接中止"><a href="#accept-返回前连接中止" class="headerlink" title="accept 返回前连接中止"></a>accept 返回前连接中止</h4><p>connect 后，accept 前，客户端发送 RST 报文</p><p>POSIX : <code>ECONNABORTED</code> - <code>software caused connection abort</code></p><h4 id="服务器进程终止"><a href="#服务器进程终止" class="headerlink" title="服务器进程终止"></a>服务器进程终止</h4><p>服务器进程崩溃后，如果 client 不操作，会阻塞在 fgets，输入字符后，readline 因接收到 FIN 返回 0（EOF），client 返回 : <code>str_cli: server terminated prematurely</code> - 程序定义的并结束</p><p>如果先收到了 RST，会返回 <code>ECONNRESET</code> - <code>connection reset by peer</code></p><p>RST 会因为并没有与该客户端连接但是接收到该客户端发送的内容而被服务器发送</p><h4 id="服务器主机崩溃"><a href="#服务器主机崩溃" class="headerlink" title="服务器主机崩溃"></a>服务器主机崩溃</h4><p>同上面不同的是，服务器并不会有任何反应，会有以下两种情况：</p><ul><li>一直没有响应 <code>ETIMEOUT</code></li><li>中间路由器判断不可达，响应一个 <code>destination unreachable</code> 的 ICMP，返回的错误是 <code>EHOSTUNREACH</code> 或 <code>ENETUNREACH</code></li></ul><h4 id="服务器主机崩溃后重启"><a href="#服务器主机崩溃后重启" class="headerlink" title="服务器主机崩溃后重启"></a>服务器主机崩溃后重启</h4><p>当服务器主机崩溃后重启时，它的 TCP 丢失了崩溃前的所有连接信息，因此服务器 TCP 对于所收到的来自客户的数据分节响应以一个RST</p><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>服务器读入换行符，所搜索的只是换行符</p><p>二进制 : <code>sscanf</code> 转换到结构体 binary ，发送后，对方也用同样的结构体接收。</p><p>大小端不同 ， 同样 int 型长度不同，结构体的打包方式不同 都会导致负数不行，</p><p>解决方法： 发送 string ， 用 XDR（external data representation) 发送</p><h2 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h2><h3 id="I-O-Model"><a href="#I-O-Model" class="headerlink" title="I/O Model"></a>I/O Model</h3><p>分为两个部分：等待对端发送数据 ，将数据从内核拷贝到用户</p><ul><li>blocking: 调用接收函数后就一直等到两步都完成再返回</li></ul><p><img src="https://s2.loli.net/2021/12/24/k7NsibMYlA4BnCG.jpg" alt=""></p><ul><li>Nonblocking: 第一阶段不断循环 call，知道收到完整包</li></ul><p><img src="https://s2.loli.net/2021/12/24/1Qs5ucmSPpXRVaD.jpg" alt=""></p><ul><li>Multiplexing: 第一步调用 select，直到返回 readable，然后调用 recvfrom 完成第二步<ul><li>好处: 可以等待多个描述符</li></ul></li></ul><p><img src="https://s2.loli.net/2021/12/24/gFw2hGWOmPx1Mas.jpg" alt=""></p><ul><li>Signal-Driven: 调用后立即返回，signal handler 会在 data 准备好后发出信号，调用 recvfrom 完成第二步</li></ul><p><img src="https://s2.loli.net/2021/12/24/xACoPEYT3g4prwD.jpg" alt=""></p><ul><li>Asynchronous: 告知内核启动某个操作，并让内核在两步操作完成后通知我们</li></ul><p><img src="https://s2.loli.net/2021/12/24/NBrtk7uoz5AKxlc.jpg" alt=""></p><h3 id="select-函数"><a href="#select-函数" class="headerlink" title="select 函数"></a>select 函数</h3><p>告诉内核等待多个事件，有事件发生或 Timeout 后唤醒他</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br><span class="line">    Returns: positive count of ready descriptors, <span class="number">0</span> on timeout, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><ul><li><code>maxfdp1</code>: 待测试的最大描述符值 +1</li><li><code>set</code>: 告诉内核 what descriptors we are interested in ，不关心设为空，三个参数都是 value-result 类型的，调用时为关心的描述符的值，返回时指示哪些描述符已就绪<ul><li><code>readset</code>: Any of the descriptors in the readset are ready for reading</li><li><code>writeset</code>: Any of the descriptors in the writeset are ready for reading</li><li><code>exceptset</code>: Any of the descriptors in the exceptset have an exception condition pending</li></ul></li><li><code>timeout</code>: how long to wait - 信号中断 - 不准<ul><li>设置为空: 永远等待</li><li>值: 固定时间</li><li>0: 根本不等待- 轮询（polling）</li></ul></li><li><code>Returns</code>: 就绪的数目，timeout=0，error=-1</li><li>这是系统函数，descriptor 和 socket 无关，socket 可以 select 任意 descriptor</li><li>错误处理 - 不考</li></ul><h4 id="fd-set-数据结构"><a href="#fd-set-数据结构" class="headerlink" title="fd_set 数据结构"></a>fd_set 数据结构</h4><p>每一位代表一个描述符，每一bit为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;          <span class="comment">/* clear all bits in fdset */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">/* turn on the bit for fd in fdset */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">/* turn off the bit for fd in fdset */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">/* is the bit for fd on in fdset ? */</span></span><br></pre></td></tr></table></figure><ul><li>利用 <code>FD_ZERO</code> 进行初始化十分重要，因为是 value-result 值会变化</li><li><code>FD_SETSIZE</code>: 1024</li></ul><h4 id="读-ready-的条件"><a href="#读-ready-的条件" class="headerlink" title="读 ready 的条件"></a>读 ready 的条件</h4><ul><li>收到的数据高于 low-water 低水位了</li><li>连接关闭了，read 返回 0 （EOF）</li><li>是监听套接字，且有已完成的连接 ？</li><li>套接字有错误待处理，返回 -1 ， errno 设置成确切的错误条件</li></ul><h4 id="写-ready-的条件"><a href="#写-ready-的条件" class="headerlink" title="写 ready 的条件"></a>写 ready 的条件</h4><ul><li>已连接（udp不需要），可写空间超过 low-water</li><li>写半边关闭了 （有未完成发送的数据，要发送出去）</li><li>non-blocking connect 建立了连接或失败了</li><li>套接字有错误待处理，返回 -1 ， errno 设置成确切的错误条件</li></ul><h4 id="exceptiong-ready"><a href="#exceptiong-ready" class="headerlink" title="exceptiong ready"></a>exceptiong ready</h4><p>如果一个套接字存在带外数据或者仍处于带外标记，那么它有异常条件待处理</p><h3 id="str-cli"><a href="#str-cli" class="headerlink" title="str_cli"></a>str_cli</h3><p>阻塞在 select，将原本的待前后顺序的阻塞，变成同时的阻塞</p><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>给服务器发送一个FIN，告诉它我们已经完成了数据发送，但是 仍然保持套接字描述符打开以便读取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br><span class="line">                    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><ul><li>不动引用计数就激发 TCP 的正常连接终止序列</li><li>close 终止读和写两个方向的数据传送，shutdown 还可以继续读</li><li>三种可选项<ul><li><code>SHUT_RD</code>: 关闭连接的读这一半</li><li><code>SHUT_WR</code>: 关闭连接的写这一半</li><li><code>SHUT_RDWR</code>: 连接的读半部和写半部都关闭</li></ul></li></ul><h3 id="str-cli-pipeline版"><a href="#str-cli-pipeline版" class="headerlink" title="str_cli pipeline版"></a>str_cli pipeline版</h3><p>加入 shutdown，模拟先连续发送数据，关闭写半部，然后再连续接收返回数据的 pipeline 操作</p><h3 id="TCP-echo-程序-select-版"><a href="#TCP-echo-程序-select-版" class="headerlink" title="TCP echo 程序- select 版"></a>TCP echo 程序- select 版</h3><p>client 数组存储已连接 accept 描述符的值</p><p>省去了 fork 新进程的开销</p><p>rset 数组保存 0-stdin，1-stdout，2-stderr ，3–都是已连接描述符</p><ul><li>客户发送 FIN，4 变为可读 read 将返回 0。关闭该套接字并把 <code>client[0]</code> 的值置为 -1，把描述符集中描述符 4 的位设置为 0。注意，<strong>maxfd 的值没有改变</strong></li></ul><h2 id="Chapter-7"><a href="#Chapter-7" class="headerlink" title="Chapter 7"></a>Chapter 7</h2><h3 id="sockopt-函数"><a href="#sockopt-函数" class="headerlink" title="_sockopt 函数"></a>_sockopt 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line">                                    Both <span class="keyword">return</span>: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><ul><li>sockfd ： 打开的套接字描述符</li><li>level ：指代系统中解释该选项的代码</li><li>optval ：存储 option 的数据结构 - 是标志 0 为不启用，值为启用</li><li>optlen ：长度 - value-result</li></ul><p>sockopt :掌握 7.2 原理 - SO_LINGER / SO_KEEPALIVE / SO_DONTROUTE</p><h3 id="SO-KEEPALIVE"><a href="#SO-KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h3><p>保活</p><h3 id="SO-LINGER-？"><a href="#SO-LINGER-？" class="headerlink" title="SO_LINGER ？"></a>SO_LINGER ？</h3><p>关闭 close 时是否丢弃保留在套接字发送缓冲区中的任何数据，</p><p>设置正的延滞时间</p><h3 id="SO-DONTROUTE"><a href="#SO-DONTROUTE" class="headerlink" title="SO_DONTROUTE"></a>SO_DONTROUTE</h3><p>是否绕过下层协议的路由机制</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP : IP_HDRINCL / IP_TTL </span><br></pre></td></tr></table></figure><h3 id="IP-HDRINCL"><a href="#IP-HDRINCL" class="headerlink" title="IP_HDRINCL"></a>IP_HDRINCL</h3><p>设置了就需要自己构建IP头</p><h3 id="IP-TTL"><a href="#IP-TTL" class="headerlink" title="IP_TTL"></a>IP_TTL</h3><p>设置和获取系统用在从某个给定套接字的默认 TTL 值</p><h3 id="TCP-TCP-MAXSEG"><a href="#TCP-TCP-MAXSEG" class="headerlink" title="TCP : TCP_MAXSEG"></a>TCP : TCP_MAXSEG</h3><p>允许我们获取或设置TCP连接的最大分节大小</p><p>SYN中通告的MSS</p><h2 id="Chapter-8"><a href="#Chapter-8" class="headerlink" title="Chapter 8"></a>Chapter 8</h2><p>8.1 图，并发程序设计 - 重点注意区别</p><p><code>sendto()</code> <code>recvfrom()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct sockaddr *from, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> struct sockaddr *to, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">            Both <span class="keyword">return</span>: number of bytes read <span class="keyword">or</span> written <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>echo 程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="服务器进程未运行"><a href="#服务器进程未运行" class="headerlink" title="服务器进程未运行"></a>服务器进程未运行</h3><p>返回 ICMP 异步错误</p><p>sendto 成功返回仅表示接口输出队列中有存放数据报的空间</p><p>仅在进程已将其 UDP 套接字连接到一个对端后，这些异步错误才返回给进程</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><ul><li>不需要再指定目的 IP 和端口号</li><li>不用 recvfrom 用 read 就行</li><li>返回异步错误</li></ul><h2 id="Chapter-11"><a href="#Chapter-11" class="headerlink" title="Chapter 11"></a>Chapter 11</h2><p>简单前面部分 DNS 操作 11.3、11.4、11.5</p><p>使用 UDP 查询，如果答案太长，超出了 UDP 承载能力，换成 TCP</p><h3 id="gethostbyname"><a href="#gethostbyname" class="headerlink" title="gethostbyname"></a>gethostbyname</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *hostname)</span></span>;</span><br><span class="line">            Returns: non-null pointer <span class="keyword">if</span> OK, <span class="literal">NULL</span> on error with h_errno <span class="built_in">set</span></span><br></pre></td></tr></table></figure><p>只能返回 ipv4，getaddrinfo 能够处理 4 和 6</p><h3 id="gethostbyaddr"><a href="#gethostbyaddr" class="headerlink" title="gethostbyaddr"></a>gethostbyaddr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">socklen_t</span> len, <span class="keyword">int</span> family)</span></span>;</span><br><span class="line">            Returns: non-null pointer <span class="keyword">if</span> OK, <span class="literal">NULL</span> on error with h_errno <span class="built_in">set</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct servent *<span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *servname, <span class="keyword">const</span> <span class="keyword">char</span> *protoname)</span></span>;</span><br><span class="line">Returns: non-null pointer <span class="keyword">if</span> OK, <span class="literal">NULL</span> on erro</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct servent *<span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *protoname)</span></span>;</span><br><span class="line">Returns: non-null pointer <span class="keyword">if</span> OK, <span class="literal">NULL</span> on error</span><br></pre></td></tr></table></figure><h2 id="Part-3-Advanced-Sockets"><a href="#Part-3-Advanced-Sockets" class="headerlink" title="Part 3 Advanced Sockets"></a>Part 3 Advanced Sockets</h2><p>12，13，14，15 ，17，18.5,20,21,22,23,24，30，31不考 Daemon Process 了解一下</p><p>19 Introduction</p><p>特权 SA ， SADB</p><p>25 掌握，结合第 5 章看</p><p>26 掌握 基本概念，线程和进程区别</p><p>27 结合前面的 Options 一起看，简单看看。</p><p>28 重点掌握</p><p>读写ICMP，读写非内核处理的协议段的数据报，构建ip首部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sockfd = socket(AF_INET, SOCK_RAW, protocol)</span><br><span class="line"><span class="comment">// 例 ： protocol IPPROTO_ICMP</span></span><br><span class="line"><span class="comment">// 开启 IP_HDRINCL</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &amp;on, <span class="keyword">sizeof</span>(on)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 出错处理</span></span><br></pre></td></tr></table></figure><p>29 掌握 基本概念，如何抓包</p><p>libpcap 公开分组捕获函数库</p><p>A.3 C.1 netstat tcpdump</p><p>简答题（解释名词） ， 编程题（补充小的片段）上机+上课 ， 实验分析题（分析实验的结果）例如： 服务端没起来 报什么错误</p><p>最开始 那个 带函数的函数</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>P180，P165，LINGER 的意思是什么</p><p>ioctl 实现 sockopt 进行读写操作 - 了解功能</p><p>函数原型 ： 名字 + 参数</p><p>ping ， recvmsg 如果被中断 <code>EINTR</code>，continue 重新执行，函数重启</p><p>5.10 wait / waitpid 要求</p><p>server ， server host 情况</p><p>raw socket 适用于什么情况 routing 、key</p><p>29 introduction</p><p>信号处理函数 5 章 signal handler</p><p>signal driven 不要求</p><p>tcp函数的顺序图</p>          </div>]]></content>
    
    <summary type="html">
    
      Base on Copyright (c) Dingsoul&lt;br&gt;Link: https://dingiso.github.io/2021/03/13/UNIX%20%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%A4%8D%E4%B9%A0/
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Slice Growth in Golang</title>
    <link href="https://augists.top/NOTES/CODE_LANGUAGE/GOLANG/Slice-Growth-in-Golang/"/>
    <id>https://augists.top/NOTES/CODE_LANGUAGE/GOLANG/Slice-Growth-in-Golang/</id>
    <published>2021-11-21T15:45:42.000Z</published>
    <updated>2021-11-21T16:09:23.543Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>前两天在看《GO程序设计语言》的关于 Slice 的代码的时候产生了一个疑问，书里的代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gopl.io/ch4/append</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendInt</span><span class="params">(x []<span class="keyword">int</span>, y <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> z []<span class="keyword">int</span></span><br><span class="line">  zlen := <span class="built_in">len</span>(x) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> zlen &lt;= <span class="built_in">cap</span>(x) &#123;</span><br><span class="line">    z = x[:zlen]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    zcap := zlen</span><br><span class="line">    <span class="keyword">if</span> zcap &lt; <span class="number">2</span>*<span class="built_in">len</span>(x) &#123;</span><br><span class="line">      zcap = <span class="number">2</span> * <span class="built_in">len</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">    z = <span class="built_in">make</span>([]<span class="keyword">int</span>, zlen, zcap)</span><br><span class="line">    <span class="built_in">copy</span>(z, x)</span><br><span class="line">  &#125;</span><br><span class="line">  z[<span class="built_in">len</span>(x)] = y</span><br><span class="line">  <span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个当对切片使用 append 添加时进行判断是否需要扩容的操作，尽管这是书中的代码，但是它可能和源码稍有差别<br>我从网上查询到的源码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">        newcap = <span class="built_in">cap</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">            newcap = doublecap</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">                newcap += newcap / <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    <span class="comment">//内存对齐操作</span></span><br><span class="line">    capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">    newcap = <span class="keyword">int</span>(capmem / ptrSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始我在想，为什么它需要去判断一下 <code>zcap &lt; 2*len(x)</code>，而不是直接赋值呢<br>其实当时想的时候漏掉了 <code>len(x) == 0</code> 的情况<br>如果 <code>len(x)</code> 为大于等于 1 的正整数时，无论如何 <code>zcap &lt;= 2*len(x)</code><br>如果 <code>len(x)</code> 为 0 时，就需要让新的容量等于 <code>zcap == zlen == len(x) + 1 == 1</code></p><p>那么此时就会产生两个问题：</p><ol><li>为什么不直接采用 <code>zcap = 2*len(x) + 1</code>，如此省去判断步骤</li><li>为什么不直接判断是否 <code>len(x) == 0</code>，而是判断 <code>zcap &lt; 2*len(x)</code></li></ol><p>对于第一个问题，这涉及到内存对齐操作。尽管在以前的 C Family 语言学习和计算机组成原理课程中学习过，但是并没有迁移到 Go 这里来思考问题<br>这里推荐我看到的一篇<a href="https://www.jianshu.com/p/f035a22e094d">文章</a>，我通过这篇重新学习了 Go 语言中的内存对齐</p><p>对于第二个问题，我到现在也没有 get 到原因。按理说这本书是由创始人编写的，依照在《C程序设计语言》中的严谨程度，这里应该会有什么特别的用意。但是我想如果只判断 <code>len(x) == 0</code> 在操作及时间上都要好于书中的示例代码。此处仍然留有疑问</p>          </div>]]></content>
    
    <summary type="html">
    
      A Question while reading the book *Go Programming Language*
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="GOLANG" scheme="https://augists.top/tags/GOLANG/"/>
    
  </entry>
  
  <entry>
    <title>Get Root Privilege in Linux by Docker or Dirty COW</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/Get-Root-Privilege-in-Linux-by-Docker-or-Dirty-COW/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/Get-Root-Privilege-in-Linux-by-Docker-or-Dirty-COW/</id>
    <published>2021-11-15T08:41:59.000Z</published>
    <updated>2021-11-15T08:44:30.944Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <div class="note info">            <p>计算机病毒入侵与检测课程大作业</p>          </div><h1 id="Docker-和-DirtyCow-两种方式的-Linux-提权"><a href="#Docker-和-DirtyCow-两种方式的-Linux-提权" class="headerlink" title="Docker 和 DirtyCow 两种方式的 Linux 提权"></a>Docker 和 DirtyCow 两种方式的 Linux 提权</h1><h2 id="Docker-用户组及本地映射"><a href="#Docker-用户组及本地映射" class="headerlink" title="Docker 用户组及本地映射"></a>Docker 用户组及本地映射</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Docker 作为近年来兴起的技术经常被极客们热议。作为容器化思想的典型代表，它与虚拟机类似，但在原理上不尽相同。Docker 是将操作系统底层进行虚拟化，而虚拟机是对计算机硬件进行虚拟，如通过软件虚拟出一套硬件设备提供给虚拟机程序进行使用。可以说，在实现思路上，两者就有天然的差异性。由于 Docker 可以只构造单一软件所需要的环境，或是直接使用操作系统本地进行文件映射，所以相比于虚拟机来说，Docker 更便携、高效。它允许用户将基础设施中的应用单独分割出来，形成更小的颗粒（容器），从而提高交付软件的速度。</p><p>Docker 利用 Linux 核心中的资源分离机制，例如 cgroups，以及 Linux 核心 namespace，来创建独立的容器。这可以在单一 Linux 实体下运作，避免启动一个虚拟机造成的额外负担。Linux 核心对名字空间的支持完全隔离了工作环境中应用程序的视野，包括行程树、网络、用户 ID 与挂载文件系统，而核心的 cgroup 提供资源隔离，包括 CPU、存储器、block I/O 与网络。从 0.9 版本起，Docker 在使用抽象虚拟是经由 <code>libvirt</code> 的 <code>LXC</code> 与 <code>systemd - nspawn</code> 提供界面的基础上，开始包括 <code>libcontainer</code> 库做为以自己的方式开始直接使用由 Linux 核心提供的虚拟化的设施。</p><p>在这里，我们可以对比使用 Docker 与使用安装包。当想要发布一款软件时，我们假设软件是在 python 3.7 版本进行了测试，而开发者并不确定它是否在其他诸如最新的 3.10 或是较老的版本中是否也可以像自己在 python 3.7 版本中运行一样稳定。如果是一个较为激进的开发者，可能会选择优先检测用户电脑中的环境变量里是否已经安装了 python 3，如果有则直接安装打包后的软件部分。如果是一个稳妥的开发者，更可能选择将 python 3.7 与软件一同打包给用户进行使用，这样可以保证软件基本能够正常稳定的与开发者相同环境下运行，但不是绝对，每个人的操作系统也大不相同，系统的版本，打的补丁都可能不一样，这样多复杂的因素都可能导致软件在运行过程中崩溃，与开发者的测试环境不一致，这就会导致各种环境问题。又或者，当团队在开发自己的软件时，每个人的编写环境不同，安装的依赖也可能不一样。为了方便软件在开发者与用户之间能有相同或相似的运行环境，解决团队在开发过程中的依赖问题，Docker 将他们融入 Dockerfile 进行管理，使开发者能够确保用户使用时 <code>pull</code> 了开发者选择或者相同的 <code>image</code>，从而保证或避免一些因为环境和依赖导致的问题。</p><p>在 Docker 的官网上，Docker 团队提出了自己的 slogan: Accelerate how you build, share, and run modern applications。Docker 可以让开发变得更加高效，并能对一些问题提前预知。通过将开发工作转移到 Docker 上，开发者可以更为方便的搭建环境、在不同设备之间进行分享、更少的性能损失来运行服务。也正是这一点让我非常着迷。</p><blockquote><p>Docker takes away repetitive, mundane configuration tasks and is used throughout the development lifecycle for fast, easy and portable application development - desktop and cloud. Docker’s comprehensive end to end platform includes UIs, CLIs, APIs and security that are engineered to work together across the entire application delivery lifecycle.</p></blockquote><h3 id="Docker-隔离性与安全性"><a href="#Docker-隔离性与安全性" class="headerlink" title="Docker 隔离性与安全性"></a>Docker 隔离性与安全性</h3><p>就 Docker 来说，安全性主要为两点：</p><ol><li>不会对主机造成影响</li><li>不会对其他容器造成影响</li></ol><p>从这里也可以看出，安全性更大程度上依赖的是 Docker 的隔离性。在这里又会想到与虚拟机进行对比。</p><p>传统的虚拟机其实并非 100% 安全，只需攻破 Hypervisor 便足以令整个虚拟机毁于一旦，问题是有谁能随随便便就攻破吗？Docker 的隔离性主要运用 Namespace 技术。传统上 Linux 中的 <code>PID</code> 是唯一且独立的，在正常情况下，用户不会看见重复的 <code>PID</code>。然而在 Docker 采用了 Namespace，从而令相同的 <code>PID</code> 可于不同的 Namespace 中独立存在。举个例子，A Container 之中 PID=1 是 A 程序，而 B Container 之中的 PID=1 同样可以是 A 程序。虽然 Docker 可透过 Namespace 的方式分隔出看似是独立的空间，然而 Linux 内核却不能 Namespace，所以即使有多个 Container，所有的 system call 其实都是通过主机的内核处理，这便为 Docker 留下了不可否认的安全问题。传统的虚拟机同样地很多操作都需要通过内核处理，但这只是虚拟机的内核，并非宿主主机内核。因此万一出现问题时，最多只影响到虚拟系统本身。</p><p>有一点是 Docker 非常有意思的特点，也是本次实验对 Docker 漏洞的利用之处。Docker 在主机与容器的映射上，有非常多的文件没有进行隔离：</p><ul><li><p><code>/proc</code>、<code>/sys</code> 等</p></li><li><p><code>top</code>, <code>free</code>, <code>iostat</code> 等命令展示的信息</p></li><li><p><code>root</code> 用户</p></li><li><p><code>/dev</code> 设备</p></li><li><p>内核模块</p></li><li><p>SELinux、time、syslog 等所有现有 Namespace 之外的信息</p></li></ul><p>这也使得 Docker 的安全性一直备受热议。即便本次实验中的 Docker 提权漏洞已经被 Docker 官方所了解，但是他们似乎并不打算对这个漏洞进行修复，因为这也属于他们对主机与容器建立本地映射的一部分。</p><p>Docker 的另一个好处就是，它是由 Docker 团队打造并且积极拥抱开源。开源社区甚至是 Red Hat 都在给 Docker 贡献代码，连同 Docker 一起改进安全性，改进项主要包括保护宿主不受容器内部运行进程的入侵、防止容器之间相互破坏。开源社区在解决 Docker 安全性问题上的努力包括：</p><ul><li><p>Audit namespace</p><ul><li>作用：隔离审计功能</li><li>未合入原因：意义不大，而且会增加 audit 的复杂度，难以维护。</li></ul></li><li><p>Syslog namespace</p><ul><li>作用：隔离系统日志</li><li>未合入原因：很难完美的区分哪些 log 应该属于某个 container。</li></ul></li><li><p>Device namespace</p><ul><li>作用：隔离设备（支持设备同时在多个容器中使用）</li><li>未合入原因：几乎要修改所有驱动，改动太大。</li></ul></li><li><p>Time namespace</p><ul><li>作用：使每个容器有自己的系统时间</li><li>未合入原因：一些设计细节上未达成一致，而且感觉应用场景不多。</li></ul></li><li><p>Task count cgroup</p><ul><li>作用：限制 cgroup 中的进程数，可以解决 fork bomb 的问题</li><li>未合入原因：不太必要，增加了复杂性，<code>kmemlimit</code> 可以实现类似的效果。(最近可能会被合入)</li></ul></li><li><p>隔离 <code>/proc/meminfo</code> 的信息显示</p><ul><li>作用：在容器中看到属于自己的 <code>meminfo</code> 信息</li><li>未合入原因：cgroupfs 已经导出了所有信息，<code>/proc</code> 展现的工作可以由用户态实现，比如 fuse。</li></ul></li></ul><p>不过，从 08 年 cgroup/ns 基本成型后，至今还没有新的 namespace 加入内核，cgroup 在子系统上做了简单的补充，多数工作都是对原有 subsystem 的完善。内核社区对容器技术要求的隔离性，本的原则是够用就好，不能把内核搞的太复杂。</p><p>一些企业也做了很多工作，比如一些项目团队采用了层叠式的安全机制，这些可选的安全机制具体如下：</p><ol><li><p>文件系统级防护</p><p>文件系统只读：有些 Linux 系统的内核文件系统必须要 <code>mount</code> 到容器环境里，否则容器里的进程就会罢工。这给恶意进程非常大的便利，但是大部分运行在容器里的 App 其实并不需要向文件系统写入数据。基于这种情况，开发者可以在 <code>mount</code> 时使用只读模式。比如下面几个： <code>/sys</code> 、<code>/proc/sys</code> 、<code>/proc/sysrq-trigger</code> 、<code>/proc/irq</code>、<code>/proc/bus</code></p><p>写入时复制（Copy-On-Write）：Docker 采用的就是这样的文件系统。所有运行的容器可以先共享一个基本文件系统镜像，一旦需要向文件系统写数据，就引导它写到与该容器相关的另一个特定文件系统中。这样的机制避免了一个容器看到另一个容器的数据，而且容器也无法通过修改文件系统的内容来影响其他容器。在第二个 DirtyCow 实验中，就是利用的 Copy-On-Write。</p></li><li><p>Capability 机制</p><p>Linux 对 Capability 机制阐述的还是比较清楚的，即为了进行权限检查，传统的 UNIX 对进程实现了两种不同的归类，高权限进程（用户 ID 为 0，超级用户或者 <code>root</code>），以及低权限进程（<code>UID</code> 不为 0 的）。高权限进程完全避免了各种权限检查，而低权限进程则要接受所有权限检查，会被检查如 <code>UID</code>、<code>GID</code> 和组清单是否有效。从 2.2 内核开始，Linux 把原来和超级用户相关的高级权限划分成为不同的单元，称为 Capability，这样就可以独立对特定的 Capability 进行使能或禁止。通常来讲，不合理的禁止 Capability，会导致应用崩溃，因此对于 Docker 这样的容器，既要安全，又要保证其可用性。开发者需要从功能性、可用性以及安全性多方面综合权衡 Capability 的设置。目前 Docker 安装时默认开启的 Capability 列表一直是开发社区争议的焦点，作为普通开发者，可以通过命令行来改变其默认设置。</p></li><li><p>NameSpace 机制</p><p>Docker 提供的一些命名空间也从某种程度上提供了安全保护，比如 <code>PID</code> 命名空间，它会将全部未运行在开发者当前容器里的进程隐藏。如果恶意程序看都看不见这些进程，攻击起来应该也会麻烦一些。另外，如果开发者终止 <code>pid</code> 是 1 的进程命名空间，容器里面所有的进程就会被全部自动终止，这意味着管理员可以非常容易地关掉容器。此外还有网络命名空间，方便管理员通过路由规则和 iptable 来构建容器的网络环境，这样容器内部的进程就只能使用管理员许可的特定网络。如只能访问公网的、只能访问本地的和两个容器之间用于过滤内容的容器。</p></li><li><p>Cgroups 机制</p><p>主要是针对拒绝服务攻击。恶意进程会通过占有系统全部资源来进行系统攻击。Cgroups 机制可以避免这种情况的发生，如 CPU 的 cgroups 可以在一个 Docker 容器试图破坏 CPU 的时候登录并制止恶意进程。管理员需要设计更多的 cgroups，用于控制那些打开过多文件或者过多子进程等资源的进程。</p></li><li><p>SELinux</p><p>SELinux 是一个标签系统，进程有标签，每个文件、目录、系统对象都有标签。SELinux 通过撰写标签进程和标签对象之间访问规则来进行安全保护。它实现的是一种叫做 MAC（Mandatory Access Control）的系统，即对象的所有者不能控制别人访问对象。</p></li></ol><h3 id="Docker-用户组"><a href="#Docker-用户组" class="headerlink" title="Docker 用户组"></a>Docker 用户组</h3><p>本次实验中使用 Docker 本地映射进行提权的一个必要的前提条件就是 Docker 用户组会在 Docker 内获得 root 权限。</p><blockquote><p>The Docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user <code>root</code> and other users can only access it using <code>sudo</code>. The Docker daemon always runs as the <code>root</code> user.</p><p>If you don’t want to preface the <code>docker</code> command with <code>sudo</code>, create a Unix group called <code>docker</code> and add users to it. When the Docker daemon starts, it creates a Unix socket accessible by members of the <code>docker</code> group.</p><blockquote><p>Warning</p><p>The <code>docker</code> group grants privileges equivalent to the <code>root</code> user. For details on how this impacts security in your system, see <a href="https://docs.docker.com/engine/security/#docker-daemon-attack-surface"><em>Docker Daemon Attack Surface</em></a>.</p></blockquote></blockquote><p>大概解释一下，就是本身 Docker 由于要和端口进行绑定，会默认使用 <code>root</code> 用户对 Docker 进行管理。所以 Docker 允许宿主机 <code>root</code> 将需要使用 Docker 服务的用户添加进 Docker 用户组，以便于该用户可以在 Docker 中获得 <code>root</code> 权限，使用所有需要在 Docker 中使用的诸如映射本地文件、开放端口等服务。</p><p>可以说，Docker 为了避开让用户必须使用 <code>root</code> 用户权限才能使用，增加了对 Docker 用户组的权限认证。解决了 <code>sudo</code> 的麻烦，但是也使得本次实验中利用的漏洞暴露出来。</p><h3 id="提权方式：Docker-本地映射"><a href="#提权方式：Docker-本地映射" class="headerlink" title="提权方式：Docker 本地映射"></a>提权方式：Docker 本地映射</h3><h4 id="提权过程演示"><a href="#提权过程演示" class="headerlink" title="提权过程演示"></a>提权过程演示</h4><p>在上文中提到，Docker 一方面使用 Docker 用户组来让普通用户不通过 <code>sudo</code> 也可以在 Docker 中获得最高权限，从而方便普通用户的使用。另一方面，它使用的内核进行了本地与容器内文件的映射，同时也允许用户自己添加本地文件映射。也就是说，一个在 Docker 用户组的普通用户，可以直接映射本地 <code>root</code> 权限的文件进入容器内，并作为容器内的 <code>root</code> 用户对宿主机的高权限文件进行修改。</p><p>自然，我们就可以想到，作为被添加进 Docker 用户组的普通用户，可以通过使用 Docker，将本地对用户权限进行管理的 <code>/etc/sudoers</code> 文件映射进容器内，然后作为 <code>root</code> 用户对其进行一定的修改。在实际操作时，我们可以直接将整个 <code>/etc</code> 映射入容器内。</p><p>下面将演示使用 Docker 用户组及本地映射为普通用户提权。本次实验运行于 Azure Hong Kong 云服务器上，配置为单核 CPU，1G 内存，Ubuntu 20.04。</p><p>首先，我们使用 <code>root</code> 添加 Docker 用户组。通常在安装 Docker 时，Docker 用户组已经被创建好并且分配好权限。</p><p><img src="https://i.loli.net/2021/11/15/VHlTxg3WkXYhyOq.png" alt="Screen Shot 2021-10-28 at 10.23.53 PM"></p><p>查看到 <code>/etc/sudoers</code> 文件的权限为只读，即便是作为 <code>root</code> 用户也没有可写权限，并且并没有为任何用户添加申请 <code>root</code> 的权限。</p><p><img src="https://i.loli.net/2021/11/15/yEe4LBV5QGJOrut.png" alt="Screen Shot 2021-10-28 at 10.27.05 PM"></p><p><img src="https://i.loli.net/2021/11/15/Hdlgn1UA7GtFExs.png" alt="Screen Shot 2021-10-28 at 10.30.24 PM"></p><p>我们添加一个用于本次实验的 test 用户，可以看到其权限为最低。将它加入到 docker 用户组。</p><p><img src="https://i.loli.net/2021/11/15/ecmDuHbwfM5OlBv.png" alt="Screen Shot 2021-10-28 at 10.54.38 PM"></p><p>重启 Docker 后，test 用户生效，被 Docker 赋予容器内的 <code>root</code> 权限。</p><p><img src="https://i.loli.net/2021/11/15/WZ3TQHdE4iDKlNr.png" alt="Screen Shot 2021-10-28 at 11.57.39 PM"></p><p>首先可以通过 <code>usermod -aG root test</code> 命令将 test 用户添加进 <code>root</code> 用户组。此时如果退出 Docker 就会看到 test 用户已经被添加了管理员权限。</p><p><img src="https://i.loli.net/2021/11/15/UlbS4nGZj2em6ip.png" alt="Screen Shot 2021-10-29 at 12.00.41 AM"></p><p>但是此时 test 用户并不能登陆 <code>root</code> 用户。其实也就是 <code>/etc/sudoers</code> 文件内并没有添加对 test 用户的许可，而只是赋予了权限的可能。所以我们可以在容器内对 <code>/etc/sudoers</code> 文件进行修改，将 test 用户部分 <code>test ALL=(ALL) ALL</code> 写入文件末尾。普通 Docker 用户组用户到这里已经提权成功。</p><p><img src="https://i.loli.net/2021/11/15/QaWXHxBbwI2Vvij.png" alt="Screen Shot 2021-10-29 at 12.06.19 AM"></p><p><img src="https://i.loli.net/2021/11/15/ef1PTvZCXWjp5Y8.png" alt="Screen Shot 2021-10-29 at 12.08.06 AM"></p><h4 id="rootplease"><a href="#rootplease" class="headerlink" title="rootplease"></a>rootplease</h4><p>在 Docker Hub 上已经有人通过这个漏洞制作好了专门用于将普通用户提权为 <code>root</code> 用户的容器，可以通过运行镜像一键提权。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /:/hostOS -i -t chrisfosterelli/rootplease</span><br></pre></td></tr></table></figure><p>它是通过将宿主机根目录直接映射到容器内的 <code>/hostOS</code> 目录，然后在容器中 <code>chroot /hostOS /bin/sh</code> 将根目录改到 <code>/chroot</code> 目录。获得宿主机的 <code>root</code> 权限并启动 shell。</p><h3 id="Docker-涉及到的其他安全风险及解决方案举例"><a href="#Docker-涉及到的其他安全风险及解决方案举例" class="headerlink" title="Docker 涉及到的其他安全风险及解决方案举例"></a>Docker 涉及到的其他安全风险及解决方案举例</h3><p><img src="https://s.secrss.com/anquanneican/8d894075fbc696d1402f5bb6b9eae223.png" alt=""></p><h4 id="镜像安全风险"><a href="#镜像安全风险" class="headerlink" title="镜像安全风险"></a>镜像安全风险</h4><h5 id="Dockerfile-安全问题"><a href="#Dockerfile-安全问题" class="headerlink" title="Dockerfile 安全问题"></a>Dockerfile 安全问题</h5><p>Docker 容器使用的 Docker Hub 中镜像不仅由官方上传，个人开发者也可以自由上传。其数量丰富、版本多样，但质量参差不齐，甚至存在包含恶意漏洞的恶意镜像，因而可能存在较大的安全风险。具体而言，Docker 镜像的安全风险分布在创建过程、获取来源、获取途径等方方面面。</p><p>Docker 镜像的生成主要包括两种方式，一种是对运行中的动态容器通过 <code>docker commit</code> 命令进行打包，另一种是通过 <code>docker build</code> 命令执行 Dockerfile 文件进行创建。为了确保最小安装原则，同时考虑容器的易维护性，一般推荐采用 Dockerfile 文件构建容器镜像，即在基础镜像上进行逐层应用添加操作。</p><p>Dockerfile 文件内容在一定程度上决定了Docker镜像的安全性，其安全风险具体包括但不限于以下情况：</p><ul><li>如果 Dockerfile 存在漏洞或被插入恶意脚本，那么生成的容器也可能产生漏洞或被恶意利用。例如，攻击者可构造特殊的 Dockerfile 压缩文件，在编译时触发漏洞获取执行任意代码的权限。</li><li>如果在 Dockerfile 中没有指定 USER，Docker 将默认以 root 用户的身份运行该 Dockerfile 创建的容器，如果该容器遭到攻击，那么宿主机的 root 访问权限也可能会被获取。</li><li>如果在 Dockerfile 文件中存储了固定密码等敏感信息并对外进行发布，则可能导致数据泄露的风险。</li><li>如果在 Dockerfile 的编写中添加了不必要的应用，如 SSH、Telnet 等，则会产生攻击面扩大的风险。</li></ul><h5 id="镜像漏洞"><a href="#镜像漏洞" class="headerlink" title="镜像漏洞"></a>镜像漏洞</h5><p>镜像漏洞安全风险具体包括镜像中的软件含有 CVE(Common Vulnerabilities &amp; Exposures) 漏洞、攻击者上传含有恶意漏洞的镜像等情况。</p><ul><li><p>CVE 漏洞</p><ul><li>由于镜像通常由基础操作系统与各类应用软件构成，因此，含有 CVE 漏洞的应用软件同样也会向 Docker 镜像中引入 CVE 漏洞。</li></ul></li><li><p>恶意漏洞</p><ul><li>恶意用户可能将含有后门、病毒等恶意漏洞的镜像上传至官方镜像库。</li><li>2018年6月，安全厂商 Fortinet 和 Kromtech 在 Docker Hub 上发现 17 个包含用于数字货币挖矿恶意程序的 Docker 镜像，而这些恶意镜像当时已有 500 万次的下载量。</li></ul></li></ul><h5 id="镜像仓库安全"><a href="#镜像仓库安全" class="headerlink" title="镜像仓库安全"></a>镜像仓库安全</h5><p>作为搭建私有镜像存储仓库的工具，Docker Registry 的应用安全性也必须得到保证。镜像仓库的安全风险主要包括仓库本身的安全风险和镜像拉取过程中的传输安全风险。</p><ul><li>仓库自身安全<ul><li>如果镜像仓库特别是私有镜像仓库被恶意攻击者所控制，那么其中所有镜像的安全性将无法得到保证。</li><li>例如，如果私有镜像仓库由于配置不当而开启了 2357 端口，将会导致私有仓库暴露在公网中，攻击者可直接访问私有仓库并篡改镜像内容，造成仓库内镜像的安全隐患。</li></ul></li><li>镜像拉取安全<ul><li>由于 Docker 以明文形式拉取镜像，如果用户在与镜像仓库交互的过程中遭遇了中间人攻击，导致拉取的镜像在传输过程中被篡改或被冒名发布恶意镜像，会造成镜像仓库和用户双方的安全风险。</li><li>Docker 已在其 1.8 版本后采用内容校验机制解决中间人攻击的问题。</li></ul></li></ul><h4 id="容器虚拟化安全风险"><a href="#容器虚拟化安全风险" class="headerlink" title="容器虚拟化安全风险"></a>容器虚拟化安全风险</h4><p>与传统虚拟机相比，Docker容器不拥有独立的资源配置，且没有做到操作系统内核层面的隔离，因此可能存在资源隔离不彻底与资源限制不到位所导致的安全风险。</p><h5 id="容器隔离问题"><a href="#容器隔离问题" class="headerlink" title="容器隔离问题"></a>容器隔离问题</h5><p>对于 Docker 容器而言，由于容器与宿主机共享操作系统内核，因此存在容器与宿主机之间、容器与容器之间隔离方面的安全风险，具体包括进程隔离、文件系统隔离、进程间通信隔离等。隔离问题已经在安全性与隔离性中讨论，在此不再赘述。</p><p>针对容器隔离安全风险问题，主要存在以下两种隔离失效的情况：</p><ul><li>攻击者可能通过对宿主机内核进行攻击达到攻击其中某个容器的目的。</li><li>由于容器所在主机文件系统存在联合挂载的情况，恶意用户控制的容器也可能通过共同挂载的文件系统访问其他容器或宿主机，造成数据安全问题。</li></ul><h5 id="容器逃逸攻击"><a href="#容器逃逸攻击" class="headerlink" title="容器逃逸攻击"></a>容器逃逸攻击</h5><p>容器逃逸攻击指的是容器利用系统漏洞，“逃逸”出了其自身所拥有的权限，实现了对宿主机和宿主机上其他容器的访问。由于容器与宿主机共享操作系统内核，为了避免容器获取宿主机的 root 权限，通常不允许采用特权模式运行 Docker 容器。容器逃逸攻击在本次病毒学大作业开题前曾被作为组队的最主要课题内容。</p><p>在容器逃逸案例中，最为著名的是 <code>shocker.c</code> 程序，其通过调用 <code>open_by_handle_at</code> 函数对宿主机文件系统进行暴力扫描，以获取宿主机的目标文件内容。由于 Docker 1.0 之前版本对容器能力使用黑名单策略进行管理，并没有限制 <code>CAP_DAC_READ_SEARCH</code> 能力，所以 <code>shocker.c</code> 可以调用 <code>open_by_handle_at</code> 函数，导致容器逃逸的发生。因此，对容器能力的限制不当是可能造成容器逃逸等安全问题的风险成因之一。所幸的是，Docker 在后续版本中对容器能力采用白名单管理，避免了默认创建的容器通过 <code>shocker.c</code> 案例实现容器逃逸的情况。</p><p>后来在 Black Hat USA 2019 会议中，来自 Capsule8 的研究员也给出了若干 Docker 容器引擎漏洞与容器逃逸攻击方法，包括 <strong>CVE-2019-5736</strong>、<strong>CVE-2018-18955</strong>、<strong>CVE-2016-5195</strong> 等可能造成容器逃逸的漏洞。</p><ul><li>CVE-2019-5736 是 <code>runC</code> 的一个安全漏洞，导致 18.09.2 版本前的 Docker 允许恶意容器覆盖宿主机上的 <code>runC</code> 二进制文件。<code>runC</code> 是用于创建和运行 Docker 容器的 CLI 工具，该漏洞使攻击者能够以 <code>root</code> 身份在宿主机上执行任意命令。</li><li>CVE-2018-18955 漏洞涉及到 User 命名空间中的嵌套用户命名空间，用户命名空间中针对 <code>uid</code> 和 <code>gid</code> 的 ID 映射机制保证了进程拥有的权限不会逾越其父命名空间的范畴。该漏洞利用创建用户命名空间的子命名空间时损坏的ID映射实现提权。</li><li>CVE-2016-5195 脏牛（Dirty COW）Linux内核提权漏洞可以使低权限用户在多版本 Linux 系统上实现本地提权，进而可能导致容器逃逸的发生。本次病毒学大作业也将 Dirty COW 作为第二个研究的内容。</li></ul><h5 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h5><p>由于容器与宿主机共享 CPU、内存、磁盘空间等硬件资源，且 Docker 本身对容器使用的资源并没有默认限制，如果单个容器耗尽宿主机的计算资源或存储资源（例如进程数量、存储空间等）可能导致宿主机或其他容器的拒绝服务。</p><p>针对 Docker 的 Dos 攻击主要有两种：</p><ol><li><p>计算型 DoS 攻击</p><p>Fork Bomb 是一类典型的针对计算资源的拒绝服务攻击手段，其可通过递归方式无限循环调用 <code>fork()</code> 系统函数快速创建大量进程。由于宿主机操作系统内核支持的进程总数有限，如果某个容器遭到了 Fork Bomb 攻击，那么就有可能存在由于短时间内在该容器内创建过多进程而耗尽宿主机进程资源的情况，宿主机及其他容器就无法再创建新的进程。</p></li><li><p>存储型 DoS 攻击</p><p>针对存储资源，虽然 Docker 通过 <code>Mount</code> 命名空间实现了文件系统的隔离，但 CGroups 并没有针对 AUFS 文件系统进行单个容器的存储资源限制，因此采用 AUFS 作为存储驱动具有一定的安全风险。如果宿主机上的某个容器向 AUFS 文件系统中不断地进行写文件操作，则可能会导致宿主机存储设备空间不足，无法再满足其自身及其他容器的数据存储需求。</p></li></ol><h4 id="网络安全风险"><a href="#网络安全风险" class="headerlink" title="网络安全风险"></a>网络安全风险</h4><p>网络安全风险是互联网中所有信息系统所面临的重要风险，不论是物理设备还是虚拟机，都存在难以完全规避的网络安全风险问题。而在轻量级虚拟化的容器网络环境中，其网络安全风险较传统网络而言更为复杂严峻。</p><h5 id="容器网络攻击"><a href="#容器网络攻击" class="headerlink" title="容器网络攻击"></a>容器网络攻击</h5><p>Docker提供桥接网络、MacVLAN、覆盖网络（Overlay）等多种组网模式，可分别实现同一宿主机内容器互联、跨宿主机容器互联、容器集群网络等功能。</p><ol><li><p>网桥模式</p><p>Docker 默认采用网桥模式，利用 iptables 进行 NAT 转换和端口映射。Docker 将所有容器都通过虚拟网络接口对连接在一个名为 <code>docker0</code> 的虚拟网桥上，作为容器的默认网关，而该网桥与宿主机直接相连。由于容器网络直接与 <code>docker0</code> 相连，不同容器间可以通过网桥直接通信，而宿主机外部无法访问容器。</p><p>由于缺乏容器间的网络安全管理机制，无法对同一宿主机内各容器之间的网络访问权限进行限制。如果容器间没有防火墙等保护机制，则攻击者可通过某个容器对宿主机内的其他容器进行 ARP 欺骗、嗅探、广播风暴等攻击，导致信息泄露、影响网络正常运行等安全后果。</p></li><li><p>MacVLAN</p><p>MacVLAN 是一种轻量级网络虚拟化技术，通过与主机的网络接口连接实现了与实体网络的隔离性。它允许为同一个物理网卡配置多个拥有独立 MAC 地址的网络接口并可分别配置 IP 地址，实现了网卡的虚拟化。但是它仍然没有解决在同一 VLAN 内部的容器之间进行网络攻击的风险。</p></li><li><p>Overlay 网络</p><p>Overlay 网络架构主要用于构建分布式容器集群，通过 VxLAN 技术在不同主机之间的 Underlay 网络上建立虚拟网络，以搭建跨主机容器集群，实现不同物理主机中同一 Overlay 网络下的容器间通信。与其他组网模式一样，Overlay 网络也没有对同一网络内各容器间的连接进行访问控制。此外，由于 VxLAN 网络流量没有加密，需要在设定 IPSec 隧道参数时选择加密以保证容器网络传输内容安全。</p></li></ol><h5 id="网络-DoS-攻击"><a href="#网络-DoS-攻击" class="headerlink" title="网络 DoS 攻击"></a>网络 DoS 攻击</h5><p>Docker 容器网络的 DoS 攻击分为内部威胁和外部威胁两种主要形式。</p><ul><li><p>内部威胁</p><ul><li>基于容器网络攻击，DoS 攻击可直接在容器之间进行，攻击者通过某个容器向其他容器发起 DoS 攻击可能降低其他容器的网络数据处理能力。</li></ul></li><li><p>外部威胁</p><ul><li>由于同一台宿主机上的所有容器共享宿主机的物理网卡资源，若外部攻击者使用包含大量受控主机的僵尸网络向某一个目标容器发送大量数据包进行 DDoS 攻击，将可能占满宿主机的网络带宽资源，造成宿主机和其他容器的拒绝服务。</li></ul></li></ul><h2 id="Dirty-COW-漏洞"><a href="#Dirty-COW-漏洞" class="headerlink" title="Dirty COW 漏洞"></a>Dirty COW 漏洞</h2><blockquote><p>The Dirty COW vulnerability (CVE-2016-5195) is a recent (and interesting) privilege escalation vulnerability in the Linux kernel.  By exploiting this vulnerability, an ordinary, non-privileged user already on a machine can take complete control. Dirty COW works by taking advantage of a flaw in how the Linux kernel manages memory – more specifically, an optimization technique in how memory pages are utilized.</p></blockquote><p>相比于上一个 Docker 设计的漏洞，Dirty COW 是利用的了内存读写的编程漏洞，强行通过刷写内存达到写入只读文件的目的。</p><h3 id="Dirty-COW-漏洞分析及代码解释"><a href="#Dirty-COW-漏洞分析及代码解释" class="headerlink" title="Dirty COW 漏洞分析及代码解释"></a>Dirty COW 漏洞分析及代码解释</h3><h4 id="Copy-on-Write"><a href="#Copy-on-Write" class="headerlink" title="Copy on Write"></a>Copy on Write</h4><p>在微软的官方文档里，详细的解释了 Copy on Write 优化。它允许多个进程映射到同一个物理页面进行共享，直到某一进程想要修改页面。通过 Copy on Write 技术，操作系统可以将内存合理安排，在非必要的情况下不执行操作，以达到节省物理内存和时间的目的。</p><p>例如我们有两个进程被映射到了同物理页面内（如图）</p><p><img src="https://docs.microsoft.com/en-us/windows/win32/memory/images/mem1.png" alt=""></p><p>如果程序不需要对内容进行修改，则可以最大化利用物理内存页面。如果 Process 1 想要对 Page 2 进行修改，操作系统会先将 Page B 复制到一个新的物理页面 Page D，并为 Process 1 更新虚拟内存映射。按照我的想法，此后操作系统会寻找合适的时机，即两进程可能长期不会再进行修改时再将其进行合并操作。（如图）</p><p><img src="https://docs.microsoft.com/en-us/windows/win32/memory/images/mem2.png" alt=""></p><p>在 Windows 系统上，文档中提到，在加载应用程序时，每个实例都在自己的受保护虚拟地址空间中运行。然而，他们的实例句柄（<em>hInstance</em>）通常具有相同的值。此值表示应用程序虚拟地址空间中的基本地址。如果每个实例都可以加载到默认基地址，它可以通过 Copy on Write 保护映射到其他实例并与他们共享相同的物理页面。系统允许这些实例共享相同的物理页面，直到其中一个实例修改页面。如果由于某种原因无法将其中一个实例加载到所需的基地址中，它将接收自己的物理页面。</p><p>也就是说，只要进程只从这些内存页面读取，它们就会被共享，优化就会生效。如果其中一个进程在任何时候写入这些共享页面之一，则数据将被复制到一个新的物理页面，并更新虚拟到物理内存映射以反映更改。这种技术用于许多不同的场景，如加载的dll、分叉进程、文件系统数据块等。</p><h4 id="并发多线程"><a href="#并发多线程" class="headerlink" title="并发多线程"></a>并发多线程</h4><p>操作系统通常对并发的多线程访问共享数据时添加锁。通过互斥条件使对同一变量的不同访问分开，或使用其他的方式，如 Windows 上的 InterlockedIncrement()，使它们成为原子。当发生 Race Condition 时，就会产生一些小的时间窗口，时间窗口内一些预期之外的操作就可以被执行。</p><blockquote><p>A race condition is when the end result of an operation or sequence of operations is dependent on the order or timing of the operation(s). </p></blockquote><p>通常来说，时间窗口的大小决定了这个漏洞可以被利用的难易程度。比如 VMware 博客的作者提到他在调试一个文件系统时，可以利用的时间窗口只有 3μs，这也导致他很难对这个漏洞进行复现，从而使得它难以修复。</p><p>在 Dirty COW 漏洞中，病毒进程通过循环尝试 100,000,000 次来加大漏洞可以被利用的概率，提高 Copy on Write 的成功率。</p><h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><p>Dirty COW 的伪代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Main:</span><br><span class="line">    fd = open(filename, O_RDONLY)</span><br><span class="line">    fstat(fd, &amp;st)</span><br><span class="line">    <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, st.st_size , PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>)</span><br><span class="line">    start Thread1</span><br><span class="line">    start Thread2</span><br><span class="line">    </span><br><span class="line">Thread1：</span><br><span class="line">    f = open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR)</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">        lseek(f, <span class="built_in">map</span>, SEEK_SET)</span><br><span class="line">        write(f, shellcode, <span class="built_in">strlen</span>(shellcode))</span><br><span class="line">        </span><br><span class="line">Thread2：</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">        madvise(<span class="built_in">map</span>, <span class="number">100</span>, MADV_DONTNEED)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作为只有读文件权限的普通用户，在打开文件时必须先使用 Read Only，然后使用 MAP_PRIVATE 标记映射文件到内存区域。完成后就可以启动两个线程开始竞争了。Thread 1 以读写权限打开 <code>/proc/self/mem</code>。由于在内核中使用的 OOP 思想，其通用的抽象类结构源自于 <code>/proc/&#123;pid&#125;/men</code>，它包含了以下结构体内变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">proc_mem_operations</span> = &#123;</span></span><br><span class="line">    .llseek  = mem_lseek,</span><br><span class="line">    .read    = mem_read,</span><br><span class="line">    .write   = mem_write,</span><br><span class="line">    .open    = mem_open,</span><br><span class="line">    .release = mem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也就是说，当我们需要写入一个虚拟文件时，内核将调用 <code>mem_write</code> 函数，它本质上也是对 <code>mem_rw</code> 函数的封装。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">mem_rw</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos, <span class="keyword">int</span> write)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> addr = *ppos;</span><br><span class="line">    <span class="keyword">ssize_t</span> copied;</span><br><span class="line">    <span class="keyword">char</span> *page;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mm)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate an exchange buffer */</span></span><br><span class="line">    page = (<span class="keyword">char</span> *)__get_free_page(GFP_TEMPORARY);</span><br><span class="line">    <span class="keyword">if</span> (!page)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    copied = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!atomic_inc_not_zero(&amp;mm-&gt;mm_users))</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> this_len = <span class="keyword">min_t</span>(<span class="keyword">int</span>, count, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* copy user content to the exchange buffer */</span></span><br><span class="line">        <span class="keyword">if</span> (write &amp;&amp; copy_from_user(page, buf, this_len)) &#123;</span><br><span class="line">            copied = -EFAULT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this_len = access_remote_vm(mm, addr, page, this_len, write);</span><br><span class="line">        <span class="keyword">if</span> (!this_len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!copied)</span><br><span class="line">                copied = -EIO;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!write &amp;&amp; copy_to_user(buf, page, this_len)) &#123;</span><br><span class="line">            copied = -EFAULT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buf += this_len;</span><br><span class="line">        addr += this_len;</span><br><span class="line">        copied += this_len;</span><br><span class="line">        count -= this_len;</span><br><span class="line">    &#125;</span><br><span class="line">    *ppos = addr;</span><br><span class="line"></span><br><span class="line">    mmput(mm);<span class="built_in">free</span>:</span><br><span class="line">    free_page((<span class="keyword">unsigned</span> <span class="keyword">long</span>) page);</span><br><span class="line">    <span class="keyword">return</span> copied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会在开始时分配一个临时内存 buffer，用来在源进程（要写的只读文件）和目的进程（<code>/proc/self/mem</code>）之间进行内存交换。因为 Copy on Write 的两个进程的虚拟地址空间不能直接互相访问，所以它将拷贝源进程的 buffer 到新物理页面。<code>access_remote_vm</code> 函数允许内核读写另一个进程的虚拟地址空间，它是所有 out-of-band 访问内存方式的核心实现。<code>madvise</code> 系统调用的作用是给系统对于内存使用的一些建议，<code>MADV_DONTNEED</code> 参数告诉系统未来不访问该内存了，内核可以释放内存页了。内核函数 <code>madvise_dontneed</code> 中会移除指定范围内的用户空间 page。可以看到，写操作由两步完成： 将应用层传进的数据写到目标page中 以及将page设置为脏页。<code>madvise(MADV_DONTNEED)</code> 基本功能是清除被管理的内存映射的物理页。就当前情况而言， 在调用完该函数后，提到的这些页将被clear。当下一次用户尝试访问这些内存区域时，原始的内容会重新从磁盘或者页缓存中导入，而对于匿名的堆内存，则会填充零。 </p><p>如果我们直接访问一个基于文件的只读映射，一个段错误将会产生。但是，为什么我们使用写 <code>/proc/self/mem</code> 确返回了一个 Dirty COW 页呢？这个原因取决于当在一个进程内发生内存访问和当采用 out-of-band, <code>/proc/&#123;pid&#125;/mem</code> 内存访问时，内核如何处理页错误的情况。这两种情况最终都会调 <code>handle_mm_fault</code> 来处理页错误。但是后者使用 <code>faultin_page</code> 来模拟页错误，页错误直接导致触发 MMU，将直接进入中断处理器，之后所有的路径都进入到平台独立的内核处理函数 <code>__do_page_fault</code> 中。而在直接写只读内存区域时，hanler 将检测到访问违例在函数 <code>access_error</code> 中，同时在 <code>handle_mm_fault</code> 处理之前，直接触发信号 <code>SIGEGV</code> 在函数 <code>bad_aea_access_error</code> 中。</p><h3 id="Dirty-COW-漏洞复现中的困难"><a href="#Dirty-COW-漏洞复现中的困难" class="headerlink" title="Dirty COW 漏洞复现中的困难"></a>Dirty COW 漏洞复现中的困难</h3><p>在尝试复现 DirtyCow 内核漏洞代码的过程中，遇到了非常多的困难和挫折。我先后在日常使用的 macOS、Docker Ubuntu 20.04、Docker Ubuntu 14.04 上简单试运行了 dirtyc0w 病毒程序，均未能成功。</p><p>macOS 本身使用 XNU 内核，其前身 NeXT 系统是基于 Mach 内核和 BSD 代码库创建，与后来的 Linux 内核尽管功能性上有很多相似想通之处，但是在底层上相去甚远。macOS 内嵌 Mach 微内核和 BSD 宏内核，而 Linux 仅有一个负责对 CPU、内存、进程间通信、设备驱动、文件系统和系统服务调用进行管理的宏内核。并且 macOS 本身为闭源，无从将其与 Linux 内核代码进行比较。</p><p>由于使用及前半部分选题的原因，我首先尝试使用 Docker 的 Ubuntu 来对 DirtyCow 漏洞进行复现。在 Docker 本地映射提权中使用的 Ubuntu 20.04 中运行时，病毒文件只对进程本身做出相应，即 <code>main</code> 中进行的 <code>mmap</code>，而无法进入两个运行的线程中并正常执行。例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmap 7f03ac372000</span><br></pre></td></tr></table></figure><p>第一个想到的是，是否是由于目前版本已经对 Dirty COW 漏洞进行了修复。所以我查看了 Linux 在 GitHub 上的源代码仓库，发现并没有有关 DirtyCow 的提交或 issue。查阅到 <code>linux/mm/madvise.c</code> 和 <code>linux/tools/perf/trace/beauty/mmap.c</code> 与本病毒项目可能存在相关性。（后续查阅到 Dirty COW 的影响范围为影响范围：Linux 内核 &gt;= 2.6.22（2007 年发行）开始就受影响了，直到 2016 年 10 月 18 日才修复</p><p>于是改用了旧版本的 Ubuntu 14.04，但是其系统内核为 4.4，应该也是 Ubuntu LTS 长期支持，从 Docker Hub 拉取的 Ubuntu 14.04 使用的是更新后的系统内核版本，推理应该是作为安全性更新得到了修补。但是当时并没有意识到可能有这个问题。由于 Docker 在本地与容器的映射问题，我当时怀疑的对象是 Docker 在默认映射部分将我系统中修补后的内容映射到了容器里，没有意识到尽管使用了旧版本的 Ubuntu 发行版，内核版本可能已经不是当时使用的内核版本了。在运行 Dirty COW 核心代码时，出现了 Docker 占用率拉高，致使风扇狂转的现象。我在程序假死半个小时后才强制结束运行。</p><p>其实我们可以以 Ubuntu 为例，查询发行版年代以及对应的内核版本。可以看到 Ubuntu 14.04 LTS 开发代号 Trusty Tahr，于 2014 年 4 月发行，使用 3.13 版本的 Linux 内核，原计划于 2019 年停止对系统的维护，但是开发团队将维护时间延长到了 2022 年。这也就是我为什么能从官方途径直接找到仍然在维护支持的 Ubuntu 14.04 版本的原因。</p><p>在放弃在 Docker Ubuntu 中直接复现 DirtyCow 漏洞后，我转而使用 Windows 下的虚拟机重新搭建了一个 Ubuntu Server 14.04 实验环境。虽然后来发现系统版本为 4.4（其为 Ubuntu 16.04 LTS 版本在发布时使用的内核版本，发布于 2016 年 4 月，仍早于该漏洞被修复的时间）。在虚拟机环境中，我也“成功”运行了 DirtyCow 程序，但是可能仅有一次在刷写 <code>/etc/passwd</code> 文件时成功将 <code>test</code>（权限为 1001）用户的密码写入了文件，而在对只读测试文件（权限为 0404 或 704）的写入中失败。但是程序正常结束了运行。例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line">1234567890</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./dirtyc0w test.txt 00000</span><br><span class="line">mmap 7f8b6aaae000</span><br><span class="line"></span><br><span class="line">madvise 0</span><br><span class="line"></span><br><span class="line">procselfmem 500000000</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line">1234567890</span><br></pre></td></tr></table></figure><p>在复现添加用户进入 <code>sudoers</code> 时同样无法生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./dirtyc0w /etc/group <span class="string">&quot;<span class="subst">$(sed &#x27;s/\(sudo:x:.*:\)/\1test1/g&#x27; /etc/group)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>在与老师讨论后，选择尝试将系统的 Linux 内核进行降级。前后共尝试了 3 个 ubuntu 发行版，为 14.04 及 ubuntu 12，其中 14 内核降级为 3.14 版本时出现了在常规情况下正常，但启动病毒程序进行刷写内存时出现系统崩溃以及引导故障的问题。</p><p><img src="https://i.loli.net/2021/11/15/blFgufXzAsK4OLW.jpg" alt="IMG_4034"></p><p><img src="https://i.loli.net/2021/11/15/qgdoIxN7Ty9BL2M.jpg" alt="IMG_4035"></p><p><img src="https://i.loli.net/2021/11/15/1wvXYKjCycHab4U.png" alt="6383A801DE9D67BB2E9F892B2AAE963D"></p><p>如图所示，我在尝试了将 Linux 内核进行降级后仍然无法复现病毒样本。现在网络上能找到的 Ubuntu 14.04 发行版均采用了 4.4 版本的内核，Ubuntu 12 采用 3.1x 版本内核。在第一次给 Ubuntu 14 降级内核版本至 3.14 后，系统维持正常运行，但是每当长时间运行高负载的进程时，系统引导就会崩溃并在提示引导错误后直接死机。这也是在本次复现 Dirty COW 病毒的过程中遇到的最无法解释的错误。事实上，可能是早期的 Ubuntu 发行版的问题，我每次安装都可能有不一样的问题，通常一个 iso 需要安装很多次，找到运行最稳定的一次。例如经常会有安装完系统后报 dpkg error 等，再重新安装就可以解决。</p><p>在 Linux 内核降级时，无论是指定 Advanced Option 还是直接设定启动运行的内核版本，系统都会将 4.4 作为启动的优先选项。在多次尝试无果后，我选择了降级后删除原 4.4 版本的内核，从而迫使系统使用旧版本的内核来启动。</p><p>我的三次系统内核降级的尝试分别选择了 3.14，3.13-100（后也尝试了72），2.6 版本。后两次在现在看来是理论上是应该可以成功的。我们可以查询 Dirty COW 的 wiki 上对于补丁版本的说明。对于每个发行版的补丁时间，在其他人对漏洞分析里都没有提到，所有提到漏洞可以利用的版本时都说的是“对Linux内核2.6.22以上的版本都有效果“，可事实上漏洞修复的很快，在 2021 年能找到的系统镜像都早以修复了它。网络上的复现实例都是写于 2016 年。</p><p><img src="https://i.loli.net/2021/11/15/PqWQpE7xTX9hl1A.png" alt="Screen Shot 2021-11-05 at 2.08.16 PM"></p><p>基本上每次尝试运行病毒样本的花销都是在半个小时左右。从前期的正常运行但无法得出结果，到中期运行后崩溃报错，再到最后降级到理论可复现的系统内核版本后每次运行都死机。前后大概花了一个月时间用于 Dirty COW 病毒，但实质上仍然没有成功复现出来。</p><h3 id="Dirty-COW-总结"><a href="#Dirty-COW-总结" class="headerlink" title="Dirty COW 总结"></a>Dirty COW 总结</h3><ol><li>Dirty COW 漏洞究其原因是 Copy on Write 这种对于内存利用的尝试的技术漏洞。尽管它非常有效的提升了内存的利用，但是在当时对于这部分内容的编写者来说可能并没有注意到它可能存在的问题并进行修补，导致最终暴露出问题。Dirty COW 漏洞最后由 Linus 本人亲自对其进行修复。</li><li><code>MADV_DONTNEED</code> 在 Linux 上的行为一直都是有争议的，它并没有完全服从 POSIX 的标准。事实上，正式它非标准的行为导致 Dirty COW 的攻击变为可能。 </li><li>漏洞可以体现出在对于并发处理上旧版本仍有瑕疵。一直以来，并发处理都被认为是很难处理的事情，这也是 Golang 自推出以来就一直很受欢迎的原因之一。</li><li>一开始我对于网络上别人对于漏洞的说明有些盲目信任，这也导致了我在尝试复现的初期踩了很多坑。</li></ol><h2 id="Preference-List"><a href="#Preference-List" class="headerlink" title="Preference List"></a>Preference List</h2><ol><li><a href="https://cve.mitre.org/index.html">CVE List</a></li><li><a href="https://www.dell.com/community/数据存储和保护-资料文档/浅谈Docker隔离性和安全性/ta-p/7181817A">浅谈Docker隔离性和安全性</a></li><li><a href="https://www.freebuf.com/articles/network/226210.html">针对Docker的恶意行为分析</a></li><li><a href="https://www.secrss.com/articles/16228">Docker容器安全性分析</a></li><li><a href="http://blog.lujun9972.win/blog/2019/05/13/为什么说创建docker用户组不是个好选择/">为什么说创建docker用户组不是个好选择</a></li><li><a href="https://docs.docker.com/engine/install/linux-postinstall/">Post-installation steps for Linux</a></li><li><a href="https://szukevin.site/2020/05/31/利用docker提权的一次尝试/">利用Docker进行提权的一次尝试</a></li><li><a href="https://github.com/zeroby0/virus/blob/master/virus.sh">copy to all script</a></li><li><a href="https://blogs.vmware.com/security/2016/12/dirty-truth-dirty-cow-cve-2016-5195.html">The Dirty Truth About “Dirty COW” (CVE-2016-5195)</a></li><li><a href="https://dirtycow.ninja">CVE-2016-5195 homepage</a></li><li><a href="https://github.com/dirtycow/dirtycow.github.io">Dirty COW source code</a></li><li><a href="https://zhuanlan.zhihu.com/p/27604276">从内核角度分析Dirty Cow原理</a></li><li><a href="https://blog.csdn.net/wanzt123/article/details/81879680">DirtyCow（脏牛）漏洞复现</a></li><li><a href="https://blog.jenisec.org/security/dirtycow.html">DirtyCow 漏洞利用</a></li><li><a href="https://blog.lovetecnet.xyz/2018/04/5ed11002857793053427715c/">脏牛（CVE-2016-5195）漏洞分析</a></li><li><a href="https://www.cnblogs.com/xiaozi/p/14264210.html">Linux提权的几种常用姿势</a></li><li><a href="https://linux.cn/article-9850-1.html">macOS 和 Linux 的内核有什么区别</a></li><li><a href="https://hub.docker.com/_/ubuntu">Docker Hub</a></li><li><a href="https://zh.wikipedia.org/wiki/Ubuntu">Ubuntu发行版列表</a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection?redirectedfrom=MSDN">内存保护</a></li><li><a href="https://www.bbsmax.com/A/n2d9a7vdDv/">dirtycow不死机exploit</a></li><li><a href="https://github.com/torvalds/linux/blob/7cca308cfdc0725363ac5943dca9dcd49cc1d2d5/mm/madvise.c">linux kernel madvise</a></li><li><a href="https://github.com/torvalds/linux/blob/5bfc75d92efd494db37f5c4c173d3639d4772966/tools/perf/trace/beauty/mmap.c">linux kernel mmap</a></li><li><a href="http://www.cnblogs.com/bonelee/p/6900243.html">LMDB中的mmap、copy on write深入理解</a></li><li><a href="https://www.anquanke.com/post/id/84851">深入解读脏牛Linux本地提权漏洞（CVE-2016-5195）</a></li><li><a href="http://pwn4.fun/2017/07/14/Dirty-COW（CVE-2016-5195）漏洞分析/">Dirty COW（CVE-2016-5195）漏洞分析</a></li></ol>          </div>]]></content>
    
    <summary type="html">
    
      Homework for Computer Virus Detect Course
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
      <category term="VIRUS" scheme="https://augists.top/tags/VIRUS/"/>
    
  </entry>
  
  <entry>
    <title>Bit Operation: Average of Two Integer</title>
    <link href="https://augists.top/NOTES/COURSES/Network_Protocol_Stack/bit-operation-average-of-two-integer/"/>
    <id>https://augists.top/NOTES/COURSES/Network_Protocol_Stack/bit-operation-average-of-two-integer/</id>
    <published>2021-11-12T04:59:34.000Z</published>
    <updated>2021-11-12T05:15:00.196Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>如何求两个整数的平均值？</p><p>问题看起来简单，如果用代码实现起来却有很多值得研究的地方。</p><p>下面我们使用Java代码来实现。</p><h2 id="普通实现1"><a href="#普通实现1" class="headerlink" title="普通实现1"></a>普通实现1</h2><p>求两个整数的平均值，最简单的实现方法就是两个数相加再除以二。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mean</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x + y) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是, 如果传入的是两个整数都是<code>Integer.MAX_VALUE</code>， 下面的断言就过不了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertEquals(Integer.MAX_VALUE, </span><br><span class="line">    mean(Integer.MAX_VALUE, Integer.MAX_VALUE));</span><br></pre></td></tr></table></figure><p>我们期望的结果是<code>Integer.MAX_VALUE</code>，但是实际上返回的结果却是-1。因为 <code>Integer.MAX_VALUE + Integer.MAX_VALUE = -2</code>， 结果已经溢出了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.AssertionError</span>: </span><br><span class="line"><span class="selector-tag">Expected</span> <span class="selector-pseudo">:2147483647</span></span><br><span class="line"><span class="selector-tag">Actual</span>   <span class="selector-pseudo">:-1</span></span><br></pre></td></tr></table></figure><h2 id="普通实现2"><a href="#普通实现2" class="headerlink" title="普通实现2"></a>普通实现2</h2><p>如果我们使用无符号的右移运算符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mean1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x + y) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样虽然可以得到我们想要的结果<code>Integer.MAX_VALUE</code>, 但是却是不支持负数。</p><p>比如我们求-9和-3的平均值,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertEquals(-<span class="number">6</span>, mean1(-<span class="number">9</span>, -<span class="number">34</span>));</span><br></pre></td></tr></table></figure><p>期望返回的结果是-6,但是实际上却返回了2147483642</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.AssertionError: </span><br><span class="line">Expected :-<span class="number">6</span></span><br><span class="line">Actual   :<span class="number">2147483642</span></span><br></pre></td></tr></table></figure><h2 id="普通实现3"><a href="#普通实现3" class="headerlink" title="普通实现3"></a>普通实现3</h2><p>那么如果我们不把两个整数直接相加, 而是分别除以2再相加, 是不是就不会溢出了呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mean3</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &gt;&gt; <span class="number">1</span>) + (y &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现的话, 确实是不会溢出了，但是精度也丢失了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.AssertionError: </span><br><span class="line">Expected :<span class="number">2147483647</span></span><br><span class="line">Actual   :<span class="number">2147483646</span></span><br></pre></td></tr></table></figure><p>那么有没有一种实现方式, 既不会溢出,又可以同时支持正负整数呢?</p><p>答案是不止一种!</p><h2 id="位运算实现1"><a href="#位运算实现1" class="headerlink" title="位运算实现1"></a>位运算实现1</h2><p>我们来看看Google的guava工具类是怎么实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IntMath#mean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@link</span> https://github.com/google/guava/blob/master/guava/src/com/google/common/math/IntMath.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 小数 向下取整</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">meanRoundDown</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &amp; y) + ((x ^ y) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过集合来理解上面的代码。</p><p>比如我们求整数9和3的平均值。</p><p>9的二进制是1001, 3的二进制是0011,</p><p>那么这两个数的交集就是<code>9&amp;3=0001</code>,</p><p>差集就是1010。<code>0001+(1010&gt;&gt;1)</code>结果就是6。</p><p>我们都知道二进制数字都是一串0和1，那么可以把整数x和y都看作是一个有很多不同的0和1组成的集合。</p><p>那么<code>x &amp; y</code>就表示两个集合的交集, 因为<code>1&amp;1=1</code>；</p><p><code>x ^ y</code>得到的就是两个集合的差集, 因为<code>1^1=0</code>,<code>1^0=1</code>；</p><p>交集加上差集的一半, 就得到了两个数的二进制平均值。</p><h2 id="位运算实现2"><a href="#位运算实现2" class="headerlink" title="位运算实现2"></a>位运算实现2</h2><p>下面我们来看看用位运算的第二种实现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小数 向上取整</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">meanRoundUp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x | y) - ((x ^ y) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码怎么理解呢？</p><p><code>x | y</code> 得到的就是两个集合的去重并集。</p><p>并集减去差集的一半，就得到了两个数的二进制平均值。</p><h2 id="两种方式的区别"><a href="#两种方式的区别" class="headerlink" title="两种方式的区别"></a>两种方式的区别</h2><p>如果两个整数的平均值是小数时，</p><p>第一种方式是向下取整；</p><p>第二种方式是向上取整。</p><p>比如我们求整数9和4的平均值，这两个数的平均值应该是6.5，向上取整就是7，向下取值就是6。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertEquals(<span class="number">6</span>, meanRoundDown(<span class="number">9</span>, <span class="number">4</span>)); <span class="comment">// 6</span></span><br><span class="line">Assert.assertEquals(<span class="number">7</span>, meanRoundUp(<span class="number">9</span>, <span class="number">4</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>上面探讨的只是求两个整数的平均值, 那么求多个整数的平均值又有哪些值得参考的实现方式呢?</p><p>同样我们来看看Google的guava工具类是怎么实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Stats#meanOf</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@link</span> https://github.com/google/guava/blob/master/guava/src/com/google/common/math/Stats.java</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * Returns the &lt;a href=&quot;http://en.wikipedia.org/wiki/Arithmetic_mean&quot;&gt;arithmetic mean&lt;/a&gt; of the</span></span><br><span class="line"><span class="comment">   * values. The count must be non-zero.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;The definition of the mean is the same as &#123;<span class="doctag">@link</span> Stats#mean&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> values a series of values</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalArgumentException if the dataset is empty</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">meanOf</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">  checkArgument(values.length &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">double</span> mean = values[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">1</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    <span class="keyword">double</span> value = values[index];</span><br><span class="line">    <span class="keyword">if</span> (isFinite(value) &amp;&amp; isFinite(mean)) &#123;</span><br><span class="line">      <span class="comment">// Art of Computer Programming vol. 2, Knuth, 4.2.2, (15)</span></span><br><span class="line">      mean += (value - mean) / (index + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mean = calculateNewMeanNonFinite(mean, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意这句注释:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Art of Computer Programming vol. <span class="number">2</span>, Knuth, <span class="number">4.2</span>.<span class="number">2</span>, (<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p>Guava的实现是参考了高德纳老爷子的经典之作《计算机编程的艺术》, 这套书规划有 7 卷, 目前已经出版了 4 卷。</p><p>比尔盖茨给出的评价是：“如果你能读完此书，你绝对得给我发份简历。”</p><blockquote><p>速记卡</p><p>求两个整数的平均值<br><code>(x &amp; y) + ((x ^ y) &gt;&gt; 1)</code>向下取整；<br><code>(x | y) - ((x ^ y) &gt;&gt; 1)</code>向上取整；</p></blockquote>          </div>]]></content>
    
    <summary type="html">
    
      Network Protocol Stack Notes
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="C/C++" scheme="https://augists.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Why Su &amp; Why Sudo</title>
    <link href="https://augists.top/NOTES/TERMINAL/Why-su-Why-sudo/"/>
    <id>https://augists.top/NOTES/TERMINAL/Why-su-Why-sudo/</id>
    <published>2021-11-10T04:13:15.000Z</published>
    <updated>2021-11-10T04:21:09.809Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <div class="note info">            <p>作者 | Jun Tao<br>来源 | <a href="https://tanjuntao.github.io/">https://tanjuntao.github.io/</a><br>转自 | <a href="https://mp.weixin.qq.com/s/iMF-3NXgWk5yEfLlQp1MqQ">https://mp.weixin.qq.com/s/iMF-3NXgWk5yEfLlQp1MqQ</a></p>          </div><p>之前一直对 su 和 sudo 这两个命令犯迷糊，最近专门搜了这方面的资料，总算是把两者的关系以及用法搞清楚了，这篇文章来系统总结一下。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>因为本篇博客中涉及到用户切换，所以我需要提前准备好几个测试用户，方便后续切换。</p><p>Linux 中新建用户的命令是 useradd ，一般系统中这个命令对应的路径都在 PATH 环境变量里，如果直接输入 useradd 不管用的话，就用绝对路径名的方式：/usr/sbin/useradd 。</p><p>useradd 新建用户命令只有 root 用户才能执行，我们先从普通用户 ubuntu 切换到 root 用户（如何切换后文会介绍）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ su -</span><br><span class="line">Password:                                         <span class="comment"># 输入 root 用户登录密码</span></span><br><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># useradd -m test_user       # 带上 -m 参数</span></span><br><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># ls /home</span></span><br><span class="line">test_user  ubuntu                                 <span class="comment"># 可以看到 /home 目录下面有两个用户了</span></span><br></pre></td></tr></table></figure><p>因为还没有给新建的用户 test_user 设置登录密码，这就导致我们无法从普通用户 ubuntu 切换到 test_user，所以接下来，我们需要用 root 来设置 test_user 的登录密码。需要用到 passwd 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># passwd test_user</span></span><br><span class="line">Enter new UNIX password:                          <span class="comment"># 输出 test_user 的密码</span></span><br><span class="line">Retype new UNIX password:       </span><br><span class="line">passwd: password updated successfully</span><br><span class="line">root@VM-0-14-ubuntu:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>接着我们输入 exit 退出 root 用户到 普通用户 ubuntu：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">logout</span></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$</span><br></pre></td></tr></table></figure><p>可以看到，命令提示符前面已经由 root 变成 ubuntu，说明我们现在的身份是 ubuntu 用户。</p><h2 id="su-命令介绍及主要用法"><a href="#su-命令介绍及主要用法" class="headerlink" title="su 命令介绍及主要用法"></a>su 命令介绍及主要用法</h2><p>首先需要解释下 su 代表什么意思。</p><p>之前一直以为 su 是 super user，查阅资料之后才知道原来表示 switch user。</p><p>知道 su 是由什么缩写来的之后，那么它提供的功能就显而易见了，就是切换用户。</p><h3 id="参数"><a href="#参数" class="headerlink" title="- 参数"></a><code>-</code> 参数</h3><p>su 的一般使用方法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su  &lt;user_name&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - &lt;user_name&gt;</span><br></pre></td></tr></table></figure><p>两种方法只差了一个字符 -，会有比较大的差异：</p><p>如果加入了 - 参数，那么是一种 login-shell 的方式，意思是说切换到另一个用户 <user_name> 之后，当前的 shell 会加载 <user_name> 对应的环境变量和各种设置；<br>如果没有加入 - 参数，那么是一种 non-login-shell 的方式，意思是说我现在切换到了 <user_name>，但是当前的 shell 还是加载切换之前的那个用户的环境变量以及各种设置。<br>光解释会比较抽象，我们看一个例子就比较容易理解了。</p><p>我们首先从 ubuntu 用户以 non-login-shell 的方式切换到 root 用户，比较两种用户状态下环境变量中 PWD 的值（su 命令不跟任何 <user_name> ，默认切换到 root 用户）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ env | grep ubuntu</span><br><span class="line">USER=ubuntu</span><br><span class="line">PWD=/home/ubuntu                                         <span class="comment"># 是 /home/ubuntu</span></span><br><span class="line">HOME=/home/ubuntu</span><br><span class="line"><span class="comment"># 省略......</span></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$ su                              <span class="comment"># non-login-shell 方式</span></span><br><span class="line">Password:                                                <span class="comment"># 输入 root 用户登录密码</span></span><br><span class="line">root@VM-0-14-ubuntu:/home/ubuntu<span class="comment"># env | grep ubuntu</span></span><br><span class="line">PWD=/home/ubuntu                                         <span class="comment"># 可以发现还是 /home/ubuntu</span></span><br><span class="line">root@VM-0-14-ubuntu:/home/ubuntu<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>我们的确是切换到 root 用户了，但是 shell 环境中的变量并没有改变，还是用之前 ubuntu 用户的环境变量。</p><p>接着我们从 ubuntu 用户以 login-shell 的方式切换到 root 用户，同样比较两种用户转台下环境变量中 PWD 的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ env | grep ubuntu</span><br><span class="line">USER=ubuntu</span><br><span class="line">PWD=/home/ubuntu                               <span class="comment"># 是 /home/ubuntu</span></span><br><span class="line">HOME=/home/ubuntu</span><br><span class="line"><span class="comment"># 省略.......</span></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$ su -                  <span class="comment"># 是 login-shell 方式</span></span><br><span class="line">Password:</span><br><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># env | grep root</span></span><br><span class="line">USER=root</span><br><span class="line">PWD=/root                                      <span class="comment"># 已经变成 /root 了</span></span><br><span class="line">HOME=/root</span><br><span class="line">MAIL=/var/mail/root</span><br><span class="line">LOGNAME=root</span><br><span class="line">root@VM-0-14-ubuntu:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>可以看到用 login-shell 的方式切换用户的话，shell 中的环境变量也跟着改变了。</p><p>总结：具体使用哪种方式切换用户看个人需求：</p><p>如果不想因为切换到另一个用户导致自己在当前用户下的设置不可用，那么用 non-login-shell 的方式；<br>如果切换用户后，需要用到该用户的各种环境变量（不同用户的环境变量设置一般是不同的），那么使用 login-shell 的方式。</p><h3 id="切换到指定用户"><a href="#切换到指定用户" class="headerlink" title="切换到指定用户"></a>切换到指定用户</h3><p>前面已经介绍了，如果 su 命令后面不跟任何 <user_name>，那么默认是切换到 root 用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ su -</span><br><span class="line">Password:                                       <span class="comment"># root 用户的密码</span></span><br><span class="line">root@VM-0-14-ubuntu:/home/ubuntu<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>因为我们在 1. 准备工作 部分已经新建了一个 test_user 用户，并且我们也知道 test_user 用户的登录密码（root 用户设置的），我们就能从 ubuntu 用户切换到 test_user 用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ su - test_user</span><br><span class="line">Password:                                       <span class="comment"># test_user 用户的密码</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="c-参数"><a href="#c-参数" class="headerlink" title="-c 参数"></a>-c 参数</h3><p>前面的方法中，我们都是先切换到另一个用户（root 或者 test_user），在哪个用户的状态下执行命令，最后输入 exit 返回当前 ubuntu 用户。</p><p>还有一种方式是：不需要先切换用户再执行命令，可以直接在当前用户下，以另一个用户的方式执行命令，执行结束后就返回当前用户。这就得用到 -c 参数。</p><p>具体使用方法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - -c <span class="string">&quot;指令串&quot;</span>                                  <span class="comment"># 以 root 的方式执行 &quot;指令串&quot;</span></span><br></pre></td></tr></table></figure><p>我么看个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ cat /etc/shadow</span><br><span class="line">cat: /etc/shadow: Permission denied                <span class="comment"># ubuntu 用户不能直接查看 /etc/shadow 文件内容</span></span><br><span class="line"></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$ su - -c <span class="string">&quot;tail -n 4 /etc/shadow&quot;</span></span><br><span class="line">Password:                                          <span class="comment"># 输入 root 用户密码</span></span><br><span class="line">ubuntu:<span class="variable">$1</span><span class="variable">$fZKcWEDI</span><span class="variable">$uwZ64uFvVbwpHTbCSgim0</span>/:18352:0:99999:7:::</span><br><span class="line">ntp:*:17752:0:99999:7:::</span><br><span class="line">mysql:!:18376:0:99999:7:::</span><br><span class="line">test_user:<span class="variable">$6</span>$.ZY1lj4m<span class="variable">$ii0x9CG8h</span>.JHlh6zKbfBXRuolJmIDBHAd5eqhvW7lbUQXTRS//89jcuTzRilKqRkP8YbYW4VPxmTVHWRLYNGS/:18406:0:99999:7:::</span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$                            <span class="comment"># 执行完马上返回 ubuntu 用户而不是 root 用户</span></span><br></pre></td></tr></table></figure><p>这种执行方式和后面要介绍的 sudo 很像，都是临时申请一下 root 用户的权限。但还是有差异，我们接着往后看。</p><h2 id="sudo-命令介绍及主要用法"><a href="#sudo-命令介绍及主要用法" class="headerlink" title="sudo 命令介绍及主要用法"></a>sudo 命令介绍及主要用法</h2><p>首先还是解释下 sudo 命令是什么意思。</p><p>sudo 的英文全称是 super user do，即以超级用户（root 用户）的方式执行命令。这里的 sudo 和之前 su 表示的 switch user 是不同的，这点需要注意，很容易搞混。</p><p>我们先介绍 sudo 命令能做什么事情，然后说明为何能做到这些，以及如何做到这些。</p><p>我们开始。</p><h3 id="主要用法"><a href="#主要用法" class="headerlink" title="主要用法"></a>主要用法</h3><p>我们在 Linux 中经常会碰到 Permission denied 这种情况，比如以 ubuntu 用户的身份查看 /etc/shadow 的内容。因为这个文件的内容是只有 root 用户能查看的。</p><p>那如果我们想要查看怎么办呢？这时候就可以使用 sudo :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ tail -n 3 /etc/shadow</span><br><span class="line">tail: cannot open <span class="string">&#x27;/etc/shadow&#x27;</span> <span class="keyword">for</span> reading: Permission denied      <span class="comment"># 没有权限</span></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$ sudo !!                                    <span class="comment"># 跟两个惊叹号</span></span><br><span class="line">sudo tail -n 3 /etc/shadow</span><br><span class="line">ntp:*:17752:0:99999:7:::</span><br><span class="line">mysql:!:18376:0:99999:7:::</span><br><span class="line">test_user:<span class="variable">$6</span>$.ZY1lj4m<span class="variable">$ii0x9CG8h</span>.JHlh6zKbfBXRuolJmIDBHAd5eqhvW7lbUQXTRS//89jcuTzRilKqRkP8YbYW4VPxmTVHWRLYNGS/:18406:0:99999:7:::</span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$</span><br></pre></td></tr></table></figure><p>实例中，我们使用了 sudo !! 这个小技巧，表示重复上面输入的命令，只不过在命令最前面加上 sudo 。</p><p>因为我已经设置了 sudo 命令不需要输入密码，所以这里 sudo !! 就能直接输出内容。如果没有设置的话，需要输入当前这个用户的密码，例如本例中，我就应该输入 ubuntu 用户的登录密码。</p><p>两次相邻的 sudo 操作，如果间隔在 5min 之内，第二次输入 sudo 不需要重新输入密码；如果超过 5min，那么再输入 sudo 时，又需要输入密码。所以一个比较省事的方法是设置 sudo 操作不需要密码。后面介绍如何设置。</p><p>sudo 除了以 root 用户的权限执行命令外，还有其它几个用法，这里做简单介绍。</p><p>切换到 root 用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su -</span><br></pre></td></tr></table></figure><p>这种方式也能以 login-shell 的方式切换到 root 用户，但是它和 su - 方法是由区别的：</p><p>前者输入 sudo su - 后，需要提供当前用户的登录密码，也就是 ubuntu 用户的密码；<br>后者输入 su - 后，需要提供 root 用户的登录密码。<br>还有一个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -i</span><br></pre></td></tr></table></figure><p>这个命令和 sudo su - 效果一致，也是切换到 root 用户，也是需要提供当前用户（ubuntu 用户）的登录密码。</p><p>我们现在切换到 test_user 用户，尝试显示 /etc/shadow 文件的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-14-ubuntu:~$ su - test_user</span><br><span class="line">Password:                                       <span class="comment"># test_user 的密码</span></span><br><span class="line">$ sudo cat /etc/shadow</span><br><span class="line">[sudo] password <span class="keyword">for</span> test_user:                  <span class="comment"># test_user 的密码</span></span><br><span class="line">test_user is not <span class="keyword">in</span> the sudoers file.  This incident will be reported.</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>我们会看到倒数第二行中的错误提示信息，我们无法查看 /etc/shadow 的内容，这是为什么？为什么 ubuntu 可以使用 sudo 但是 test_user 不行呢？</p><p>这就涉及到 sudo 的工作原理了。</p><h3 id="sudo-工作原理"><a href="#sudo-工作原理" class="headerlink" title="sudo 工作原理"></a>sudo 工作原理</h3><p>一个用户能否使用 sudo 命令，取决于 /etc/sudoers 文件的设置。</p><p>从 3.1 节中我们已经看到，ubuntu 用户可以正常使用 sudo ，但是 test_user 用户却无法使用，这是因为 /etc/sudoers 文件里没有配置 test_user。</p><p>/etc/sudoers 也是一个文本文件，但是因其有特定的语法，我们不要直接用 vim 或者 vi 来编辑它，需要用 visudo 这个命令。输入这个命令之后就能直接编辑 /etc/sudoers 这个文件了。</p><p>需要说明的是，只有 root 用户有权限使用 visudo 命令。</p><p>我们先来看下输入 visudo 命令后显示的内容。</p><p>输入（root 用户）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-14-ubuntu:~<span class="comment"># visudo</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># User privilege specification</span></span><br><span class="line">root    ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment"># Members of the admin group may gain root privileges</span></span><br><span class="line">%admin ALL=(ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment"># Allow members of group sudo to execute any command</span></span><br><span class="line">%sudo   ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment"># See sudoers(5) for more information on &quot;#include&quot; directives:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#includedir /etc/sudoers.d</span></span><br><span class="line">ubuntu  ALL=(ALL:ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure><p>解释下每一行的格式：</p><p>第一个表示用户名，如 root 、ubuntu 等；<br>接下来等号左边的 ALL 表示允许从任何主机登录当前的用户账户；<br>等号右边的 ALL 表示：这一行行首对一个的用户可以切换到系统中任何一个其它用户；<br>行尾的 ALL 表示：当前行首的用户，能以 root 用户的身份下达什么命令，ALL 表示可以下达任何命令。<br>我们还注意到 ubuntu 对应的那一行有个 NOPASSWD 关键字，这就是表明 ubuntu 这个用户在请求 sudo 时不需要输入密码，到这里就解释了前面的问题。</p><p>同时我们注意到，这个文件里并没有 test_user 对应的行，这也就解释了为什么 test_user 无法使用 sudo 命令。</p><p>接下来，我们尝试将 test_user 添加到 /etc/sudoers 文件中，使 test_user 也能使用 sudo 命令。我们在最后一行添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">test_user  ALL=(ALL:ALL)  ALL       <span class="comment"># test_user 使用 sudo 需要提供 test_user 的密码</span></span><br><span class="line">接下来我们再在 test_user 账户下执行 sudo ：</span><br><span class="line"></span><br><span class="line">ubuntu@VM-0-14-ubuntu:~$ su - test_user</span><br><span class="line">Password:</span><br><span class="line">$ tail -n 3 /etc/shadow</span><br><span class="line">tail: cannot open <span class="string">&#x27;/etc/shadow&#x27;</span> <span class="keyword">for</span> reading: Permission denied</span><br><span class="line">$ sudo tail -n 3 /etc/shadow                   <span class="comment"># 加上 sudo</span></span><br><span class="line">ntp:*:17752:0:99999:7:::</span><br><span class="line">mysql:!:18376:0:99999:7:::</span><br><span class="line">test_user:<span class="variable">$6</span>$.ZY1lj4m<span class="variable">$ii0x9CG8h</span>.JHlh6zKbfBXRuolJmIDBHAd5eqhvW7lbUQXTRS//89jcuTzRilKqRkP8YbYW4VPxmTVHWRLYNGS/:18406:0:99999:7:::</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>可以看到，现在已经可以使用 sudo 了。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>我们已经看到了，如果一个用户在 /etc/sudoers 文件中，那么它就具有 sudo 权限，就能通过 sudo su - 或者 sudo -i 等命令切换到 root 用户了，那这时这个用户就变成 root 用户了，那这不对系统造成很大的威胁吗？</p><p>实际上的确是这样的。所以如果在编辑 /etc/sudoers 文件赋予某种用户 sudo 权限时，必须要确定该用户是可信任的，不会对系统造成恶意破坏，否则将所有 root 权限都赋予该用户将会有非常大的危险。</p><p>当然，root 用户也可以编辑 /etc/sudoers 使用户只具备一部分权限，即只能执行一小部分命令。有兴趣的读者可以参考 Reference 部分第二条，这篇文章不再赘述。</p><h2 id="二者的差异对比"><a href="#二者的差异对比" class="headerlink" title="二者的差异对比"></a>二者的差异对比</h2><p>我们已经看到：</p><p>使用 su - ，提供 root 账户的密码，可以切换到 root 用户；<br>使用 sudo su - ，提供当前用户的密码，也可以切换到 root 用户<br>两种方式的差异也显而易见：如果我们的 Linux 系统有很多用户需要使用的话，前者要求所有用户都知道 root 用户的密码，这显然是非常危险的；后者是不需要暴露 root 账户密码的，用户只需要输入自己的账户密码就可以，而且哪些用户可以切换到 root，这完全是受 root 控制的（root 通过设置 /etc/sudoers 实现的），这样系统就安全很多了。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.rootusers.com/the-difference-between-su-and-sudo-commands-in-linux/">https://www.rootusers.com/the-difference-between-su-and-sudo-commands-in-linux/</a></li><li>《鸟哥的 Linux 私房菜》13.4 节：使用者身份切换</li><li><a href="https://github.com/ustclug/Linux101-docs/blob/master/docs/Ch05/index.md">https://github.com/ustclug/Linux101-docs/blob/master/docs/Ch05/index.md</a></li><li><a href="https://www.maketecheasier.com/differences-between-su-sudo-su-sudo-s-sudo-i/">https://www.maketecheasier.com/differences-between-su-sudo-su-sudo-s-sudo-i/</a></li><li><a href="https://stackoverflow.com/questions/35999671/whats-the-difference-between-sudo-i-and-sudo-su?r=SearchResults">https://stackoverflow.com/questions/35999671/whats-the-difference-between-sudo-i-and-sudo-su?r=SearchResults</a></li><li><a href="https://www.zhihu.com/question/51746286">https://www.zhihu.com/question/51746286</a></li><li><a href="https://www.linuxidc.com/Linux/2017-06/144916.htm">https://www.linuxidc.com/Linux/2017-06/144916.htm</a></li></ul>          </div>]]></content>
    
    <summary type="html">
    
      Copyright@Jun Tao&lt;br&gt;From https://tanjuntao.github.io
    
    </summary>
    
    
    
      <category term="TERMINAL" scheme="https://augists.top/tags/TERMINAL/"/>
    
  </entry>
  
  <entry>
    <title>Squid Game</title>
    <link href="https://augists.top/SELF/THINKING/Squid-Game/"/>
    <id>https://augists.top/SELF/THINKING/Squid-Game/</id>
    <published>2021-11-08T15:04:40.000Z</published>
    <updated>2021-11-09T15:34:02.614Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>最近鱿鱼游戏属实是挺火，不管是国内还是国外，到处都在说鱿鱼游戏，这一个 Netflix 原生 ip 直接给东家带来了成吨的新用户，是目前 Netflix 热度最高的 ip</p><p>本身这个电视剧拍的是挺好的，并且韩国在近几年产出的电影质量都在上乘，所以电影能在国外火起来并不让人意外。但是偏偏国内也非常火爆，这就很奇怪了。本身国内能有能力访问外网的就不多，基本上可以排除非计算机行业的人员；有能力访问 Netflix 的就更少了，尤其是在 Netflix 对访问 ip 限制一直在加大的情况下；有买 Netflix 会员的那简直是少之又少。所以，初步又一个小结论是，很多人是通过第三方网站（即盗版网站）观看的，或是很大一部分人仅仅是跟风，并不了解电视剧的内容</p><p>实际上，在我的观看体验中，对为什么 Squid Game 能火起来一直抱有疑惑。本身电视剧所探讨的主题是在极端情况下对人性的探讨，这种题材的电影电视剧其实已经非常多了，比如《蝇王》等，都是在探讨将一群人放入一个无领导空间下，所暴露出来的人性问题，只不过这一次把目标换成了钱，“更俗气了”</p><p>简单介绍一下剧情，可能涉及剧透，谨慎观看</p><div class="note info">            <p>男主是双门洞的成奇勋，生活穷困潦倒，靠年迈的母亲卖菜挣钱养活，自己平日喜欢去赌赛马，手气不佳经常赌输，也在外面欠了高利贷。和妻子已经离婚多年，有一个7岁的小女儿。男主虽然各方面都不太行，但是确实是打心里喜欢自己女儿。但是由于自己太穷，赌赛马赢得钱也被别人偷走，十分对不起女儿。恰好此时，有人找上来，问他想不想玩游戏，赢了就有钱拿。男主最终没有经得住诱惑选择加入，这个组织也就是故事的主线——鱿鱼游戏（Squid Game）</p><p>游戏一共有七关，每一关都是在年幼时会玩的游戏，如：一二三木头人，弹球，以及第七关鱿鱼游戏。在这个密闭的空间内，所有人通过其他竞争对手的死亡累计奖池里的奖金，每个人相当于 1 亿韩元。只有通过最后一关的一个人可以拿到奖池里的奖金。在整个游戏过程中，不限制每位竞争者的获胜手段，即便是直接杀死别的竞争者也是被默许的</p>          </div><p>可以说，“Squid Game” 只是最后一关，但它同时也象征着不择手段、甚至通过暴力的方式来获取胜利。这本身是在现在社会看来非常荒谬的，所以电视剧把游戏的组织方的位置摆的很荒谬，让它处处充满荒谬之处。主办方的动机很荒谬，富人们取乐的方式很荒谬，参加者同意参加的方式很荒谬，工作人员的穿着和行为很荒谬，比赛场地的布置很荒谬等等。</p><p>电视剧中还有一个值得注意的点是，15 年最终的获胜者，也就是警察的哥哥，在多年后成为了主办方的黑衣人。而最后，成奇勋也没有登上去往美国的飞机，转头拿起了新一轮的鱿鱼游戏名片。他是否会成为下一个黑衣人，还是继承警察的遗志继续探查下去。显然老人的死并没有组织 Squid Game 的继续举办，剧中富豪意指是谁，谁又会成为新一轮的观看者</p><p>有一个事情剧里一直没有交代，即工作人员的动机。这里不展开叙述，如果你也看了《Squid Game》，那你可能也会对这个登记森严的群体产生兴趣</p><p>尽管黑衣人一直在阐述 Squid Game 的目的是让他们能有最后一次机会翻盘，在这其中每个人都是平等的，但是这个平等与我们常规理解中的平等并不完全相等。他是抛弃了先天条件下的平等，仅仅是对于肉体上的平等，而不是对每个人综合（大致为我们平时在日常生活中的平等观）情况下的平等。当然，这也是让整部剧显得荒谬的一点</p><p>非常高兴的能看到在最后与老人的实验中，人性与爱战胜了老人的冷漠世界观，但是他可能并没有看到就离开了。最后，成奇勋心中的正义和人性，也让他做出了在我们角度更为合理的选择。</p><p>总结来看，《Squid Game》是一部中上游的电视剧，它以荒诞的形式作为表层，核心一直围绕在人性与金钱的探讨。因为本身在对于这个话题的探讨上有非常多的优秀作品，其中也有很大一部分是出自韩国，所以本身电视剧是有一个非常优秀的基调的。再加上它用荒诞不经、博人眼球的方式呈现出来，也让它成为 2021 年下爆品级的存在。这部电视剧在最早放出预告片的时候我就有在乌鸦上关注到，它一经推出也常常占据 Netflix 的首页推荐位，但是我一直没有打开它看，即便在它热度最高的时候，我也依然不认为它会是一部好作品。直到自己看完，我能理解它为什么能成为这样火爆全球的存在，但是我并不能承认它可以超过前辈们对这个话题的探讨，它的火爆很大程度上归咎于外表更适应这个时代的节奏罢了。如果 Netflix 成功制作出了第二部，我依然不会立刻就看，但不能否认，它是一部优秀的电视剧，它也配得上让 Netflix 这一季度新用户数据达到新高。</p>          </div>]]></content>
    
    <summary type="html">
    
      Squid Game is Hot&lt;br&gt;But why?
    
    </summary>
    
    
    
      <category term="THINKING" scheme="https://augists.top/tags/THINKING/"/>
    
      <category term="NETFLIX" scheme="https://augists.top/tags/NETFLIX/"/>
    
  </entry>
  
  <entry>
    <title>Record an Experience of Computer Fixing</title>
    <link href="https://augists.top/SELF/THINKING/Record-an-experience-of-computer-fixing/"/>
    <id>https://augists.top/SELF/THINKING/Record-an-experience-of-computer-fixing/</id>
    <published>2021-10-25T12:28:05.000Z</published>
    <updated>2021-11-08T15:07:08.286Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>昨天朋友的 windows 在更新系统的时候，突然蓝屏了，叫我过去帮忙。</p><p>蓝屏代码 0xc0000001，网上查询其错误原因特别乱，最终确定可能是因为系统引导故障。</p><p>电脑是 ROG 的笔记本，每次开机时间都超级长。出现蓝屏问题后，无法正常进入系统。F8通过安全模式启动，无论是否带命令行的安全模式（我应该没记错，也可能叫恢复模式）还是是否禁用一些启动设置再启动系统，都无法进入系统。尝试了自带的修复工具、恢复到还原点（3个）、UEFI固件设置等所有可以尝试的操作（除了直接重置系统），都没有任何反应。</p><p>其实修电脑并不是我想说的，最终的修复方法是用其他电脑做了一个windows的启动盘然后将系统装在D盘，并且成功进入了新做好的系统，并将C盘里需要的文件拷贝回来。我是在想。。。</p><p>当你使用一套别人制作好并且闭源的系统，当它出现这种故障时，你只能使用开发者提供的修复工具尝试进行修复，而无法了解为什么出现这个问题，如何复现，怎么才能避免出现这种状况。我一直提倡的理念是，简约、但将其他复杂的功能作为备选项提供给用户，让它的决定权还给用户自己。我可以不用，但你不能没有。以手机系统为例，我可以将屏幕刷新率默认设置到一个用户能接受并且对系统影响不大的数值，比如系统默认设置为60Hz的刷新率，同时提供90Hz、120Hz甚至ProMotion这种可变刷新率的选项。依照它的实用程度、用户的使用频率甚至说计算出的用户使用的可能性，将它放在一定的系统设置的层级深度。比如刚才提到的屏幕刷新率设置放在 设置-显示-屏幕刷新率 层级里，或是 设置-显示-屏幕-刷新率，因为屏幕刷新率是用户有可能与默认设置意见不同而进行修改的选项。如果提供了如ProMotion这种动态可变刷新率的设置，当用户将刷新率修改为ProMotion后，屏幕刷新率的选项设置层级会进行下移，将它放入 设置-其他-屏幕（显示）-屏幕刷新率 这种角落里。本身系统提供了最基础最大众最优化（甚至可以说是让用户感知的结果最好）的方案，将方案的修改细节同样提供给用户可以进行任意的修改。</p><p>说完我自己的想法，那就可以来说说现在市场上的产品了。windows作为一个完全闭源，基本软件也闭源的操作系统，可以说是和我相去甚远的。当我遇到这种情况，仅仅使用它提供的工具和手段无法方便快捷的解决问题时，我会非常无能为力。macOS只能说达标了一部分。本身系统也闭源，但是它很好的提供了对开源的Linux的兼容性，同时开放的去接受了大量开源软件和开源思想。所以当你在macOS上遇到了问题，如果你有能力，是可以一定程度上自己尝试解决的。但是在开放系统本身上，它做的只是提供了一套非常优秀的配置方案，而并没有给用户开放更多的权限了。在Linux的众多发行版里，arch就比较极端，ubuntu系中规中矩。arch（甚至gentoo）将所有都开放给了用户， 甚至可以说连最基本的都完全交给用户自己定义。ubuntu系本身提供了一套还不错的路子，但是似乎在可自定义性上稍微会差一点。介于中间的像Manjaro同时兼具了提供配套服务、提供用户最大化的选择权，同时拥有类arch的自定义性，所以我一直把Manjaro当作我心目中最佳的选择了。</p>          </div>]]></content>
    
    <summary type="html">
    
      Export My Thought
    
    </summary>
    
    
    
      <category term="THINKING" scheme="https://augists.top/tags/THINKING/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu Server on Raspberry Pi</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/Ubuntu-Server-on-Raspberry-Pi/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/Ubuntu-Server-on-Raspberry-Pi/</id>
    <published>2021-10-05T14:51:08.000Z</published>
    <updated>2021-11-08T15:10:24.736Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>又在树莓派上折腾了一顿，简单整理一下一开始遇到的问题</p><hr><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p>现在拿到 ubuntu 每次第一件事就要先去网上找镜像源。比较习惯用清华源和中科大源<br>按照惯例写了几个镜像源，一更新发现坏了，根本不行<br>之前一直是在服务器上做配置，树莓派最大的区别在于改用了 arm 架构<br>镜像源对 arm 架构要使用 ports 源</p><p><img src="https://mirrors.ustc.edu.cn/help/ubuntu-ports.html" alt="UTSC ubuntu ports"><br><img src="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" alt="TUNA ubuntu ports"></p><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>换完源之后更新，还是不行，报错大概是这个</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update failed because certificate verification failed because handshake failed on nodesource</span><br></pre></td></tr></table></figure><p>一开始是用 ca 证书解决的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ca-certificates</span><br></pre></td></tr></table></figure><p>但是想了想，应该不是这个问题。<code>date -R</code> 查看系统时间，时区默认被设置成了格林尼治</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tzselect</span><br></pre></td></tr></table></figure><p>不知道这有啥用，它加在 <code>.profile</code> 文件里 <code>TZ=</code>，不是很优雅</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><p>大概用软链接更合理</p><h2 id="静态ip"><a href="#静态ip" class="headerlink" title="静态ip"></a>静态ip</h2><p>ubuntu server 配置静态 ip 和之前树莓派自己的 raspbianOS 上不太一样，要复杂一些<br>因为本身我们是为了搭建 ss 服务器，并且有一些特殊需求，就没有配好</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/netplan/00-installer-config.yaml</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">network:</span><br><span class="line">  ethernets:</span><br><span class="line">    ens160:     #配置的网卡的名称</span><br><span class="line">      addresses: [192.168.0.105/24]    #配置的静态ip地址和掩码</span><br><span class="line">      dhcp4: no    #关闭DHCP，如果需要打开DHCP则写yes</span><br><span class="line">      optional: true</span><br><span class="line">      gateway4: 192.168.0.1    #网关地址</span><br><span class="line">      nameservers:</span><br><span class="line">         addresses: [114.114.114.114,180.76.76.76]    #DNS服务器地址，多个DNS服务器地址需要用英文逗号分隔开</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: networkd    #指定后端采用systemd-networkd或者Network Manager，可不填写则默认使用systemd-workd</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>          </div>]]></content>
    
    <summary type="html">
    
      There is not much executable and helpful manual page for Ubuntu Server on a Raspberry Pi
    
    </summary>
    
    
    
      <category term="DEVICE" scheme="https://augists.top/tags/DEVICE/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>MAC With External Display</title>
    <link href="https://augists.top/APPLE/MAC-with-external-display/"/>
    <id>https://augists.top/APPLE/MAC-with-external-display/</id>
    <published>2021-09-13T15:12:29.000Z</published>
    <updated>2021-09-13T15:37:44.965Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <p>刚开学的时候买了台显示器，确实是我看到过的最便宜的给 mac 用的显示器了</p>          </div><div class="note warning">            <p>给 mac 配显示器，稍微有点要求的话，大概这些是必须的吧</p><ul><li>3.5k 以上的分辨率</li><li>支持 HiDPI</li><li>反向充电 65W 以上的 C 口</li><li>色域达标为支持 P3 色域</li></ul><p>这只是一个非常笼统的配置要求，例如 P3 色域在实际显示的时候也会有非常多的讲究<br>可以在先看评测的对 4k 以下显示器的横评中看到非常多的评价标准，同时即便是相同的标准也可能有一些消费者无法感知的差异</p><p>我购买的是 WE （小厂）的显示器，据说采用的是京东方的面板<br>最终花费 1.5k 的价格就拿下这款显示器了<br>但是毕竟价钱摆在这里，色域上只能达到 99-100% sRGB<br>但是其实实际观感不会差什么，整体色调相比与 mac build-in 显示器会偏暖的比较多，目前也没有改调色方案</p><hr><p>前面说的感觉真的挺好的，但是有一点是我自己遇到的问题<br>mac 自带的电源线是没有视频传输能力的<br>这一点，不得不承认，有道理，但是用的时候很烦人<br>确实，不是所有人都有把 mac 接到外置显示器的需求<br>但是像我这种一开始不知道的人，买了显示器之后发现原装的线不能用，被迫只能使用 HDMI</p><p>买了根便宜的雷电 3 数据线，便宜的我有点不是很能相信<br>常规的雷电 3 数据线价格一般在 2-3 百上下<br>现在只能等便宜的这根到了试试好不好用了<br>希望到时候能让桌面更清爽一点，只使用一根雷电数据线接出来</p>          </div>]]></content>
    
    <summary type="html">
    
      Here comes an external display I bought&lt;br&gt;An 27 inches 4k display with full functional type c&lt;br&gt;BUT!!! only 1.5k RMB
    
    </summary>
    
    
    
      <category term="APPLE" scheme="https://augists.top/tags/APPLE/"/>
    
      <category term="MAC" scheme="https://augists.top/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>Backspace Does Not Work on VPS?</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/Backspace-does-not-work-on-VPS/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/Backspace-does-not-work-on-VPS/</id>
    <published>2021-08-27T08:36:56.000Z</published>
    <updated>2021-11-08T15:09:39.614Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>在我用我的新终端 kitty 登陆 VPS 的时候发现，很多快捷键都失效了。比如退格键就会变成空格，<code>&lt;C-u&gt;</code> 会没有反应，<code>clear</code> 会提示我的终端模拟器不支持等</p><p><img src="https://i.loli.net/2021/08/27/7DTkwj6LFPIdxRq.png" alt=""></p><p>我们也可以通过 <code>echo $TERM</code> 查看到终端的情况</p><p><img src="https://i.loli.net/2021/08/27/oFkeaPMsTdhQJXy.png" alt=""></p><p>大概就可以看到，应该是当前的 VPS 不支持 xterm-kitty</p><p>可以通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stty -a</span><br></pre></td></tr></table></figure><p>进行查看服务器支持的终端通信参数</p><p>我们尝试使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stty sane</span><br></pre></td></tr></table></figure><p>命令 sane 最常出现在大多数终端的 stty 选项的集合中。它并不改变通信信道的速率，但当终端发生混乱时，通常能够产生有益的效果。</p><p>不过很可惜，没啥效果</p><p>最终经过尝试，使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TERM=linux</span><br></pre></td></tr></table></figure><p>有效</p><div class="note info">            <p>TERM 环境变量用于终端处理。它允许 DB-Access（及其他基于字符的应用程序）识别您正在使用的终端并与其通信。</p>          </div><p>可以推测，我们将终端类型设置成 VPS 自己，从而使对于 VPS 本身是正常的</p><p>后来查到</p><div class="note info">            <ul><li><code>putty</code>，<code>konsole</code>，<code>Eterm</code>，<code>rxvt</code>，<code>gnome</code>等, 如果你正在运行的 XTerm 模拟器和一些功能键，退格键，删除，Home 和 End 不能正常工作</li><li><code>linux</code> 通过 Linux 控制台登录时</li><li><code>dumb</code> 当其他都不能用时</li></ul>          </div><p>可以通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toe /usr/share/terminfo</span><br></pre></td></tr></table></figure><p>查看可选信息</p><p><img src="https://i.loli.net/2021/08/27/QEJsUv8z72SGrbn.png" alt=""></p><p><img src="https://i.loli.net/2021/08/27/zW5tGqPfeVyj3i6.png" alt=""></p>          </div>]]></content>
    
    <summary type="html">
    
      This is the first time that I use my VPS on kitty&lt;br&gt;It goes wrong with my expect&lt;br&gt;Plenty of shortcuts fail such as *Backspace*, *clear*, and so on
    
    </summary>
    
    
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Applications &amp; Command Line Tools</title>
    <link href="https://augists.top/APPLE/Applications-and-Command-Line-Tools/"/>
    <id>https://augists.top/APPLE/Applications-and-Command-Line-Tools/</id>
    <published>2021-08-20T08:27:19.000Z</published>
    <updated>2021-08-20T10:20:07.659Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>There is the overview of my recommends. 不全，但是是我在重装系统之后经过重新考虑之后保留下来的推荐</p><div class="note info">            <center><b>System</b></center><ul><li>Caffeinated: 保持系统常量不休眠的小工具</li><li>AppCleaner: 软件清理</li><li>Hidden Bar: Menu Bar 隐藏</li><li>IINA: 视频播放器</li><li>Karabiner: 修改键盘映射</li><li>OnlyX: 系统垃圾清理</li><li>Paste: 剪贴板历史</li><li>The Unarchiver: 解压</li><li>uPic: 图片上传图床</li><li>Vimari: safari 的 vim-like 快捷键</li><li>V2rayU: VPN</li><li>rectangle: 窗口管理器</li><li>yabai: 窗口管理器</li><li>shkd: 快捷键工具</li><li>spacebar: Menu Bar 定制</li><li>htop: 活动监视器</li></ul><center><b>Code</b></center><ul><li>Dash: 查看文档</li><li>Kitty: 终端模拟器</li><li>Typora: markdown</li><li>Docker: 虚拟容器</li><li>homebrew: 包管理器</li><li>tmux: 终端复用</li><li>neovim: 编辑器</li><li>fzf: fuzzy file finder</li><li>nnn: 文件管理器</li><li>autojump: 快速跳转</li><li>zsh<ul><li>oh-my-zsh: 终端美化</li><li>zsh-autosuggestions: 终端补全</li><li>zsh-syntax-highlighting: 终端高亮</li></ul></li><li>clang-format: c language formatter</li></ul>          </div><p>简单说明是啥之后，就可以挑主要的说了</p><h2 id="Caffeinated"><a href="#Caffeinated" class="headerlink" title="Caffeinated"></a>Caffeinated</h2><p>这是一个比较简单，图标也好看一点的禁止休眠工具，直接显示在 Menu Bar 上<br>比其他同类软件更简单，不提供一些有的没的工具，与终端指令 Caffeinate 相同效果</p><h2 id="AppCleaner-amp-OnlyX-amp-fzf"><a href="#AppCleaner-amp-OnlyX-amp-fzf" class="headerlink" title="AppCleaner &amp; OnlyX &amp; fzf"></a>AppCleaner &amp; OnlyX &amp; fzf</h2><p>卸载软件其实一直都是一件很头疼的事情，即便有了这两个工具<br>首先，一定不推荐任何打着清理名头的软件，如 CleanMyMacX、腾讯柠檬清理等<br>AppCleaner 在卸载软件时查找它在系统中存储的一些配置信息文件，但是并不是所有都能找到<br>它主要检索 <code>$HOME/Library</code> 下的文件，但是即便是这样，也并不是能发现全部可以删除的垃圾文件<br>而 OnlyX 是更为深度的清理系统缓存等垃圾，需要对一些名词有一定了解<br>众所周知，macOS 采用了沙盒机制<br>我第一次对沙盒机制感慨是在看了飞蚊话的<a href="https://www.bilibili.com/video/BV1WA411V7r8">分析视频</a><br>即便有这样优秀的思想，也不能防止软件忽悠你获取权限然后把文件放在不该放的地方<br>所以我一般会在删除完软件或者我想要清理系统垃圾的时候手动去两个 Library 里看看<br>心情好就去根目录用 fzf 开个全盘扫描，经常会发现几个漏网之鱼<br>举个例子，前几天下载了 Parallel Desktop 试用了几下，一看空间，好家伙，占了我 50G 的空间<br>在 AppCleaner 找完一部分，手动去 Library 里删了一些之后，我又去根目录用 fzf 扫了一下，果然发现在 <code>/etc</code> 和 <code>/var</code> 下都还有配置文件</p><h2 id="Karabiner"><a href="#Karabiner" class="headerlink" title="Karabiner"></a>Karabiner</h2><p>这个是在键盘与系统之间虚拟出一层来，对键盘的键位映射进行修改<br>由于我现在开始用 HHKB，一些键位我就需要重新改一下（最主要还是因为 QQ<br>我的 Karabiner 配置文件已经放在 GitHub 上的 dotfiles 里了<br>通过 json 文件简单修改就可以用了</p><h2 id="uPic"><a href="#uPic" class="headerlink" title="uPic"></a>uPic</h2><p>uPic 的作者挺好玩的，之前加了 tg 群，正好碰到他说要上架 app store了<br>app store 里的版本是收费的，同时因为软件开源，免费版可以直接从 GitHub 上下载</p><h2 id="yabai-amp-shkd-amp-spacebar"><a href="#yabai-amp-shkd-amp-spacebar" class="headerlink" title="yabai &amp; shkd &amp; spacebar"></a>yabai &amp; shkd &amp; spacebar</h2><p>最近新换的窗口管理器，配置也比较简单，实现效果就和 Linux 下的如 dwm、i3 等类似<br>经过一番操作，我的 mac 它更像 Linux 了<br>但是 yabai 需要关闭 SIP<br>不推荐了解不够深入的关闭 SIP</p><h2 id="Kitty"><a href="#Kitty" class="headerlink" title="Kitty"></a>Kitty</h2><p>Kitty 是一个更符合 Unix 哲学的终端模拟器，基于 GPU，更快速<br>我用 Kitty 替换了 iTerm2，主要是 iTerm2 太过于庞杂，提供的功能基本都用不上<br>而 Kitty 只需要修改它的配置文件就可以啦 <code>~/.config/kitty/kitty.conf</code><br>在换用 Kitty 之后，我把我的配置文件重新整理了一遍，按照模块进行加载</p><h2 id="nnn"><a href="#nnn" class="headerlink" title="nnn"></a>nnn</h2><p>nnn 我用来替换了 ranger<br>其实论实用，ranger 更好用一点，但是在我电脑上，一旦开启了一些功能就会变卡<br>如果打开了 git，直接就卡到怀疑人生<br>我之前的 ranger 经常在预览上卡住。一开始我以为是预览大文件会卡，后来发现啥都可能卡<br>ranger 的好处是它可以直接调用 iTerm2 在终端显示图片预览<br>而 nnn 虽然也采用 vim-like 快捷键，但是它没有了三栏的设计，操作也都尽可能的用一个键完成<br>总的来说，应该算是 ranger 的下位替代吧<br>另外有一点，如果想让 nnn 显示图标，需要自己手动编译，修改编译参数，这在无形中提高了门槛</p><h2 id="neovim"><a href="#neovim" class="headerlink" title="neovim"></a>neovim</h2><p>vim 作为我一直在使用的编辑器，一直就仅限于想要的那一部分就再没往下探索新的东西了<br>重装系统之前改用 neovim 重新进行了配置，新的 neovim 配置基于 coc，并且终于我开始用提示了<br>LSP 让它的配置变得非常好用<br>最近也在想改用 lua 重写配置，放弃 coc，直接转用新配置<br>目前只是学会了 lua，还没有换新 <em>init.lua</em> 的动力</p><h2 id="autojump"><a href="#autojump" class="headerlink" title="autojump"></a>autojump</h2><p>autojump 算是比较推荐的一个终端工具，它可以记住我的 <code>cd</code> 路径，并在后面直接 <code>j</code> 过去<br>在从 ranger 改用 nnn 之后我把 autojump 卸载了，但是最近又重新安装回来了<br>我一直把它作为文件管理器的辅助，比如要写博客的时候 <code>j augists</code> 就会跳到博客目录</p><hr><div class="note info">            <p>最近的最后一次大改是因为在学习 python<br>在 macOS 里，系统自带了 python2.7<br>如果你使用 <code>xcode-select --install</code> 安装了 Command Line Tools<br>它就会给你安装上 python3（目前是 python3.8)<br>但是因为路径和权限的原因经常会出现一些问题<br>所以我现在电脑上同时存在了 3 个 python</p><ul><li>系统自带的 python2</li><li>Command Line Tools 安装的 python3.8</li><li>homebrew 安装的 python3.9</li></ul><p>2 为系统提供服务<br>3.8 为 neovim 服务，在 <code>$PATH</code> 中存放在后面<br>3.9 是我平常用的，因为 homebrew 很鸡贼的让安装的路径是环境变量的第一个</p>          </div>          </div>]]></content>
    
    <summary type="html">
    
      !!!NOW!!! These applications and command line tools are on my mac&lt;br&gt;which I strongly recommend
    
    </summary>
    
    
    
      <category term="APPLE" scheme="https://augists.top/tags/APPLE/"/>
    
      <category term="MAC" scheme="https://augists.top/tags/MAC/"/>
    
      <category term="TERMINAL" scheme="https://augists.top/tags/TERMINAL/"/>
    
  </entry>
  
  <entry>
    <title>Reinstall macOS</title>
    <link href="https://augists.top/APPLE/Reinstall-macOS/"/>
    <id>https://augists.top/APPLE/Reinstall-macOS/</id>
    <published>2021-08-13T04:25:54.000Z</published>
    <updated>2021-08-14T10:46:09.596Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>花了一天多的时间，把 mac 抹盘重装了，收获了一个全新的 mac</p><p>之前使用的是 macOS 12 public beta 4。本身使用并没有什么问题，问题出在了软件的兼容性上。很多软件如 <em>OnlyX</em> 都无法在新系统里正常打开运行（这里还是再点一下 <em>OnlyX</em>，每个系统版本出一个软件版本，导致兼容性非常差。但是也不是说这样做不好，只是我觉得应该又一个更鲜明的提示，当检测为更新的系统版本时提示一下）</p><p>导致我重装系统的直接原因是下载了 <em>CrossOver</em>，我不记得它有要我的系统权限，但是它直接修改了系统默认显示 <code>.exe</code> 文件的图标，而我比较菜（lan）。权衡了一下啊，干脆直接抹盘重装一次系统</p><hr><p>在这次重装过程中也发现了很多好玩的事情，也对很多东西有了新的理解。比如：</p><ul><li>切换输入法的快捷键应该设置给 <em>select the previous input source*，而不是 *select next input source</em></li><li><em>screen saver</em> 文件一般为 <code>.saver</code> 文件，而 <em>fliqlo</em> 是 <code>dmg</code> 安装器</li><li>由于更换了 <code>neovim</code>，很多东西都和以前不太一样，同时 <code>vim</code> 作为被我抛弃掉的被替代品，没有再使用任何插件，当作一个单纯的编辑器来使用了</li><li>对电脑的容量非常诧异。本来以为会清理出非常多的东西，能让 256G 的容量剩出很多，但是现在看其实和之前差别不大，只是少装了很多软件，大概节省了 20G 的空间，甚至 <em>Chrome</em> 我都还没有安装（也是在尝试一个单 <em>Safari</em> 能否承担重任，尤其是在下个版本中将要加回 <em>Group Tab</em>，这个在测试版中我爱不释手的功能</li><li>在抹盘之后，可以将 Data 和 数据 两个盘直接删掉，只保留 <em>Macintosh HD</em> 就可以，之前被这个奇怪的保护机制烦了很久</li><li>mac 启动器下载完成之后打开就会报错，但是事实上是正常的，这一点在网上查阅的时候都没有指出来。使用官方的制作启动器的指令之后报错了一次，有点莫名其妙，第二次就好了</li><li>mac 在使用制作好的外置磁盘启动器进行安装时，仍然需要关闭一些安全性设置（由于 T2 芯片的缘故）。我目前没有把这些安全性设置修改回来，但是我现在也不是很想折腾 <em>yabai</em></li></ul>          </div>]]></content>
    
    <summary type="html">
    
      Spend A day for reinstalling my macOS&lt;br&gt;Downgrade the system from the beta version to official version Big Sur
    
    </summary>
    
    
    
      <category term="APPLE" scheme="https://augists.top/tags/APPLE/"/>
    
      <category term="MAC" scheme="https://augists.top/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>A Comfortable Way for Coding</title>
    <link href="https://augists.top/SELF/SHARING/STUDY/A-better-way-for-coding/"/>
    <id>https://augists.top/SELF/SHARING/STUDY/A-better-way-for-coding/</id>
    <published>2021-08-08T01:44:25.000Z</published>
    <updated>2021-11-08T15:09:16.093Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>这几天一直在尝试从头重新配置一个更适合我使用的 coding platform，用这篇博客简单记录一下我的配置过程<br>是探索，也是从上一个舒适区里走出来，划定一个更大范围的舒适区</p><div class="note info">            <p>我一直使用终端作为我的 coding platform，所以我也将基本围绕终端展开</p>          </div><hr><h2 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h2><p>既然是要走出舒适区，那肯定就要大胆尝试一下新东西。<a href="https://iterm2.com">iTerm2</a> 一直是我不知道需不需要尝试的一个新玩意。一直以来看所有的 mac 装机推荐文章或视频里很多都会告诉你，当你拿到一个新 mac 的时候，要先下载 iTerm2，然后安装 <code>oh-my-zsh</code>。这就和让装 Alfred 一样，完全不知道它好在哪，但是就是所有人都推荐装</p><p>目前就在使用 iTerm2。尽管在换用 iTerm2 之后我仍然没有很明显的感知它有多少特别的功能并提升了我的终端使用体验，但是通过设置让它变得比原生 Terminal<br>更好看了是真的。我取消了顶部的 title bar，并且添加了彩虹 🌈 色小组件，这就是我现在改用 iTerm2 的主要原因了</p><p><img src="https://i.loli.net/2021/08/08/6ngbcAlLQBmtUrx.png" alt="iTerm2"></p><p>当然，每个东西肯定有好有不好。iTerm2 最让我无法忍受的是每次粘贴都会刷新屏幕，就一个非常明显的闪屏。虽然可以理解，但是对它的好感度大打折扣。除此之外，之前说的打开 vim 再退出时终端会自动变到最后一行的问题在改用终端模拟器之后并没有解决，反而是换成 neovim 之后解决掉了</p><h2 id="neovim"><a href="#neovim" class="headerlink" title="neovim"></a>neovim</h2><p>相比 iTerm2，<a href="https://neovim.io">neovim</a> 带给我的体验提升就非常大了，甚至可以说是飞跃。Neovim 相比于 vim，进行了非常多体验上的优化，比如便捷的添加如 python 支持，通过命令直接查看 provider 的状态等等。同时 neovim 下也提供了一些插件的支持，提供了新的 api。现在我甚至可以不用分屏就能打开终端或者 fzf 了</p><p><img src="https://i.loli.net/2021/08/08/wYOWZb7krNFag5q.png" alt="fzf"></p><h2 id="coc-nvim"><a href="#coc-nvim" class="headerlink" title="coc.nvim"></a>coc.nvim</h2><p>更换了 neovim 之后，我也对我的 <a href="https://github.com/Augists/ZDCZ-vimrc">vimrc</a> 进行了重写。新的 <code>init.vim</code> 改为基于赵启明大佬的 <a href="https://github.com/neoclide/coc.nvim">coc.nvim</a> 进行配置，尽可能多的使用 LSP 插件体系</p><p>在以前我认为，刚学习敲代码，就应该去掉代码提示，像在记事本写代码一样减少机器辅助。现在我已经到了日常需要查文档才能写代码的时候了（其实就是不会写了），尽管装了 Dash 但是从来不用……Code Completion &amp; Document 显得非常重要了。我屈服了</p><h2 id="glow"><a href="#glow" class="headerlink" title="glow"></a>glow</h2><p><code>glow</code> 是一个似乎不是很轻量的 markdown 终端渲染程序<br>很明显我并不会去使用它，我已经有太多的 markdown 渲染了，但是这不妨碍我把它放在推荐列表，因为确实很好看</p><h2 id="brew-rmtree"><a href="#brew-rmtree" class="headerlink" title="brew rmtree"></a>brew rmtree</h2><p><code>homebrew</code> 的 <code>formula &amp; cask</code> 的卸载一直是一个大问题，因为它没有像 <code>apt</code> 那样的 <code>autoremove</code> 来自动清理不需要的依赖。后果就是我在以前使用的时候每次安装软件都会把终端的内容打印到一个文件里进行存储，然后在卸载的时候对照着一个一个删掉</p><p><code>retree</code> 是一个辅助清理不需要的依赖的工具，但是在我的使用中它似乎对新系统的兼容性有待提升，就像我每次使用 <code>homebrew</code> 都会收到一个新系统的警告一样烦人</p><blockquote><p>我在尝试 <code>pip-autoremove</code> 的过程中遇到了更加恶心的问题。简单来说就是 mac 系统中的 python 太多太乱导致的，这导致我直接放弃了对 <code>pip-autoremove</code> 的研究</p></blockquote>          </div>]]></content>
    
    <summary type="html">
    
      After &lt;i&gt;remake&lt;/i&gt; my coding tools, I find my comfortable zone
    
    </summary>
    
    
    
      <category term="CODE" scheme="https://augists.top/tags/CODE/"/>
    
      <category term="SHARING" scheme="https://augists.top/tags/SHARING/"/>
    
  </entry>
  
  <entry>
    <title>Command Ps | Grep Then Find Itself</title>
    <link href="https://augists.top/SELF/ERROR/Command-ps-grep-then-find-itself/"/>
    <id>https://augists.top/SELF/ERROR/Command-ps-grep-then-find-itself/</id>
    <published>2021-07-24T16:50:07.000Z</published>
    <updated>2021-11-08T15:11:39.231Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>分享今日份蠢事</p><p>事情要从下载学校的 VPN 客户端开始说起 …</p><hr><p>学校的 VPN 客户端使用的是 GlobalProtect，应该是一个提供成熟的 VPN 服务的软件，可以自己根据需求定制。这个软件有一个很奇怪的地方，它自动设置为开机自启动，而且进程不允许关闭<br>要知道，当你打开它之后，你会发现它连个 quit 都没有<br>我也尝试过在任务管理器里终止，或是直接 <code>kill</code> 掉它，但都会发现每次它都会立刻重启并开始尝试连接。总之让人看的非常想卸载<br>除此之外，它一直在不断的弹窗让我同意它监控我的所有网络活动…当时我就来气。我看的东西是你不花钱能跟着看的？<br>所以，在发现它并不能帮助我登录 IEEE 之后，我毅然决然的准备卸载掉它 😒</p><p><img src="https://i.loli.net/2021/07/25/GCTESI5Fo4NAPat.jpg" alt=""></p><hr><p>在我使用它提供的 pkg 里卸载时，它就莫名其妙的卡住了。于是我直接强制关闭了 installer（对，它的卸载是在安装器里的），然后准备重新卸载</p><p><img src="https://i.loli.net/2021/07/25/RdigjZxuhy1I4An.jpg" alt=""></p><p>这时候就发现，第二个 installer 会等待第一个运行完，而第一个尽管被我强制退出了，不过很明显它并没有“实质性”的退出 installer<br>它就这么莫名其妙的锁住了！！！<br>当时我就有点懵，尽管这可能是 macOS 系统限制，但是它的卸载强行卡死，导致我连关机都不能执行<br>在我长按关机执行强制重启后，它在启动界面再一次卡死了…</p><p><img src="https://i.loli.net/2021/07/25/tBzuefaORyUcgb9.jpg" alt=""></p><p>最后，上网查到这个软件会在 <code>Contents/Resources</code> 里面放一个卸载 shell 脚本，终于算是卸载掉了</p><hr><p>但是还是很慌，毕竟它能干出要监控我这种事情。我就怀疑他是不是背地里还有卸载残留<br>于是我一通 <code>ps -ef | grep GlobalProtect</code>，好家伙！还真有<br>当场又懵了，这啥进程啊怎么卸载完了还在运行，而且居然每次查看 pid 都不一样<br>又是一通骚操作，甚至已经入魔了，开始每次把获取到的 pid 提出来扔给 <code>kill</code>，然后就发现这个“病毒”非常的顽固呀，每秒都会换一个进程 id，还变成小强了</p><p><img src="https://i.loli.net/2021/07/25/1UQyAg2D5BrWfJ8.png" alt=""></p><p>过了很久才反应过来，这不就是我 <code>grep</code> 进程嘛…<br>也就是说，<code>grep GlobalProtect</code> 就是一个 <code>grep</code> 查找进程，然后它每次都会查找到自己…害得我在这折腾一晚上</p>          </div>]]></content>
    
    <summary type="html">
    
      While running command ps -ef | grep xxx, I came up with a stupid circle
    
    </summary>
    
    
    
      <category term="ERROR" scheme="https://augists.top/tags/ERROR/"/>
    
  </entry>
  
  <entry>
    <title>Merge Tab Bar in Safari</title>
    <link href="https://augists.top/APPLE/Merge-Tab-Bar-in-Safari/"/>
    <id>https://augists.top/APPLE/Merge-Tab-Bar-in-Safari/</id>
    <published>2021-07-17T15:22:50.000Z</published>
    <updated>2021-07-31T02:56:09.582Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>英文表述明白这意思太麻烦了<br>简单来说，就是我的 mac 更新了新的公测版本之后发现，safari 在上个版本添加的新功能：把 tab bar 合并到上面行程一栏，可以节省 title bar 的空间。这个功能不见了<br>😭 我那个急啊，这么好的功能，苹果官方怎么就想不开了<br>把偏好设置翻了个遍都没找到有关于这个的设置，最后在上面找到了<br>截两张图，省的下次再犯傻</p><p><img src="https://i.loli.net/2021/07/17/EC4JfaoDshVkvGO.png" alt=""></p><p><img src="https://i.loli.net/2021/07/17/Zwx1OfkuidEtXgC.png" alt=""></p><p><img src="https://i.loli.net/2021/07/17/eEzm4GfRNicL2jZ.png" alt=""></p><hr><p>更新到 public beta 4 之后，safari 的偏好设置中改用更为明显的方式进行修改了</p><p><img src="https://i.loli.net/2021/07/31/eOpZgKhmSGUE2nI.png" alt=""></p>          </div>]]></content>
    
    <summary type="html">
    
      You may find surprisingly that there will be a separate tab bar in Safari after updating to macOS Monterey beta 12.0&lt;br&gt;I like what it looks like in the last beta version&lt;br&gt;Then...How to roll back Safari
    
    </summary>
    
    
    
      <category term="APPLE" scheme="https://augists.top/tags/APPLE/"/>
    
      <category term="MAC" scheme="https://augists.top/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>Pac Proxy for Github</title>
    <link href="https://augists.top/NOTES/GIT/Pac-Proxy-for-Github/"/>
    <id>https://augists.top/NOTES/GIT/Pac-Proxy-for-Github/</id>
    <published>2021-06-14T02:34:15.000Z</published>
    <updated>2021-06-14T02:47:20.007Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>为了能好好上 GitHub，真是招数用尽<br>之前转了一篇通过添加 Hosts 的方式正常使用 GitHub 并让图片正常加载的，没过多久就不好用了。当时也有提到，需要通过查询 hosts 的网站经常更新才可以。俗话说，懒是第一生产力，所以还是通过 pac 规则添加才是正道</p><p>如何自定义 PAC 列表规则</p><p>规则大概描述如下</p><p>通配符支持，如 <code>*.example.com/</code> 实际书写时可省略如 <code>.example.com/</code> 意即 <code>*.example.com/*</code><br>正则表达式支持，以 <code>\</code> 开始和结束，如 <code>[\w]+://example.com\</code><br>例外规则 <code>@@</code>，如 <code>@@_.example.com/_</code> 满足 <code>@@</code> 后规则的地址不使用代理<br>匹配地址开始和结尾<code>|</code>，如<code>|http://example.com</code>, <code>example.com|</code> 分别表示以 <code>http://example.com</code> 开始和以 <code>example.com</code> 结束的地址<br><code>||</code> 标记，如 <code>||example.com</code> 则 <code>http://example.com</code>，<code>https://example.com</code>，<code>FTP：//example.com</code> 等地址均满足条件，只用于匹配地址开头<br>注释 <code>!</code><br>分隔符 <code>^</code>，表示除了字母，数字或者<code>_ - 。％</code>之外的任何字符。如 <code>http://example.com^</code>，则 <code>http://example.com/</code>, <code>http://example.com:8000/:</code> 均满足条件，而 <code>http://example.com.ar/</code> 不满足条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">! Put user rules line by line in this file.</span><br><span class="line">! See https:&#x2F;&#x2F;adblockplus.org&#x2F;en&#x2F;filter-cheatsheet</span><br><span class="line">||amazonaws.com</span><br><span class="line">||atom.io</span><br><span class="line">||github.com^</span><br></pre></td></tr></table></figure>          </div>]]></content>
    
    <summary type="html">
    
      How to write your pac configuration for surfing on GitHub
    
    </summary>
    
    
    
      <category term="NOTE" scheme="https://augists.top/tags/NOTE/"/>
    
      <category term="GIT" scheme="https://augists.top/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title>Way of HarmonyOS</title>
    <link href="https://augists.top/NOTES/DEVICE/way-of-HarmonyOS/"/>
    <id>https://augists.top/NOTES/DEVICE/way-of-HarmonyOS/</id>
    <published>2021-06-06T15:55:28.000Z</published>
    <updated>2021-06-06T16:05:18.178Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <blockquote><p>Copyright@Linux中国<br><a href="https://linux.cn/article-13457-1.html">link</a></p></blockquote><p><img src="https://img.linux.net.cn/data/attachment/album/202106/04/224803x7fppnqf77yyjfzb.jpg" alt=""><br>6 月 2 日晚上八点，鸿蒙召开了 2.0 的发布会，发布了鸿蒙 OS，以及一大批的新品。这两天想必大家也都看到了不少。这篇文章不想讨论鸿蒙系统本身的体验层面的变化，而是将会将精力更多的投放在鸿蒙的生态发展中。</p><h2 id="鸿蒙想要的是什么？"><a href="#鸿蒙想要的是什么？" class="headerlink" title="鸿蒙想要的是什么？"></a>鸿蒙想要的是什么？</h2><p>从 2019<br>年鸿蒙发布，有几个关键词就是核心，分布式、全场景、自主研发，其中自主研发比较好理解，而分布式、全场景一直是我无法理解的，直到看了发布会，我才意识到鸿蒙真正想要的是什么。由于我近几年来，使用的都是苹果的生态，使用<br>Macbook Pro 办公，使用 Homepod 听歌，出门会使用 Airpods Pro 来降噪。所以，在看鸿蒙发布会的时候，我时常有一个想法：这个功能苹果生态里已经有了啊？<br>或者是这个功能的 UI 交互确实是新的，但核心的体验我在苹果生态中也已经体验了啊？<br>也正是这一刻，我悟了，鸿蒙想要的分布式、全场景，其实就是过去我在苹果生态一直体验的那些东西，不同的是，鸿蒙的分布式、全场景，是超出了苹果生态所给予我的东西。</p><p><img src="https://img.linux.net.cn/data/attachment/album/202106/04/224147uqxu94xvvlf19482.png" alt=""></p><p>鸿蒙的产品架构是 1+8+N，1 指的是手机，8 指的是 PC、平板、智慧屏、手表、智能音箱、车机、耳机、AR/VR，N 则是更多的生态。对比着我们来看苹果的生态，1 指的是 iPhone，8 指的是 Macbook Pro、iPad、Apple TV、Apple Watch、Homepod、Apple Car、AirPods 以及不知道有没有的 VR/AR 产品。到这一步，鸿蒙和苹果看起来都很像，那为什么我又说华为超越了苹果生态？原因在于 8 加的 N。在蒙的描述中，N 是指更多的 IoT 设备，他们可以通过鸿蒙系统借助 4G/5G/HiLink 等方式，和核心的 8 个产品进行连接，沟通，从而提升产品的智能性，让用户真正感受到产品的智能特性。而在苹果生态中，苹果是不做 IoT 设备的操作系统的。鸿蒙既做了手机、核心设备的操作系统，还做了嵌入式的操作系统，确实可以让 IoT 设备的操作体验，如同 8 个核心设备的体验，这一点是只制定标准，不下场做事的苹果所无法达到的。可以说，鸿蒙生态假设真的铺设起来了，体验、易用性，可能都要超过苹果生态目前能够提供给我们的。</p><h2 id="鸿蒙生态之乱象"><a href="#鸿蒙生态之乱象" class="headerlink" title="鸿蒙生态之乱象"></a>鸿蒙生态之乱象</h2><p>鸿蒙作为一个看起来还不错的产品，为何近几年来饱受争议？我觉得主要是在宣传策略上的混乱。</p><p><img src="https://img.linux.net.cn/data/attachment/album/202106/04/224305nao3xua1o2jg3xa9.png" alt=""></p><p>提起鸿蒙，数码圈的人往往说的是鸿蒙 OS；而互联网/科技圈的人说的往往是 OpenHarmony 操作系统。二者在宣传的过程中，往往都是被人称作是鸿蒙系统。但实际上，鸿 OS 是真正的鸿蒙 OS，OpenHarmony 仅仅是鸿蒙生态的一个基座，如果你将之与 Android 对比，便是 Android 与 AOSP 的区别。</p><p><img src="https://img.linux.net.cn/data/attachment/album/202106/04/224336t72gddgygyq1jeg3.png" alt=""></p><p>我们真正在使用的鸿蒙系统，是一个完整的、加入了各项系统设定的操作系统，而我们所看到的源码的部分，只是一个操作系统的基座，你真正在使用的过程中，还需要做大量的修改和剪裁的版本。不过，这样的区分是一件好事。Android 当年之所以能够盛行，AOSP 功不可没。OpenHarmony 同样承载了鸿蒙系统发扬光大的路线。不过，OpenHarmony 本身也在宣传上有硬伤。一直以来，OpenHarmony 都被称之为 Android 套壳，在我看来，是不完全准确的。OpenHarmony 在手机/平板/智慧屏部分，使用的是兼容 Android 的机制，而且兼容 Android 的路线也是没有问题的；但在覆盖面更广的嵌入式设备中，产生的价值的是 2012 年就开发的 LiteOS；对于一些特定的场景下，OpenHarmony 可能会使用 Linux Kernel 来完成自己的工作。OpenHarmony 不是 Android 套壳，而是基于 Android/LiteOS/Linux Kernel 的土壤所诞生出的操作系统。操作系统的研发一直以来都不是技术问题而是生态问题，用户不太会裸用操作系统提供的基础功能，能够留下用户的，必然是操作系统之上的应用生态，对于 OpenHarmony 这样的一个后来者，一个最为简单高效获得生态的方式，就是与原有生态的兼容，所以 OpenHarmony 兼容 Android 生态是在我意料之中的事情，倘若鸿蒙真的将整个系统完全重写，那我反而不看好 OpenHarmony。相比于è¯´ OpenHarmony 套壳 Android，我更倾向于 OpenHarmony 编写了一个抽象层，磨平了 LiteOS 和 Android 的系统 API，从而使得一些功能特性可以更加容易的在两种系统之上来实现。而这些，也正是鸿蒙所宣传的 1 + 8 + N战略下的核心体验的由来。但不得不说，在宣传上，OpenHarmony 做的很一般，至可能没有起到好的作用，而是一个坏的作用。</p><h2 id="鸿蒙生态的未来"><a href="#鸿蒙生态的未来" class="headerlink" title="鸿蒙生态的未来"></a>鸿蒙生态的未来</h2><p>说完了鸿蒙想要的东西和鸿蒙生态的乱象，最后，我想聊一聊关于鸿蒙的未来。鸿蒙生态看起来非常的不错，但，能否达到所预想的水平，又是另外一个问题，对于鸿蒙来说，前路依然坎坷。在国内方面，鸿蒙如果希进行推广，就必须要考虑合作伙伴的问题，鸿蒙生态的建设不仅仅是华为的事情，华为可以完成 1+8 的建设，可后面的 N，是需要无数的中小 IoT 设备生产厂商共同建设而来的。但，国内的厂商可能要面临的问题就是，面对曾经的对手，是否还要继续合作？如果合作了，未来是否会被华为卡脖子？华为又是否会在 OpenHarmony 中为自家系统添加单独的优化？这些问题都会让国内的厂商在面临选择时产生困惑。此外，国内的厂商在完成了接入后， 鸿蒙想要扩大生态范围，就必然需要进行出海，出海时就要正面与 Android、iOS 所构建的生态进行竞争，在海外生态不足的情况下，如何取得竞争的胜利，也是一个需要研究和探讨的话题。不过，说了这么多困难，我还是想说，鸿蒙看起来真的很好，或许，有朝一日我会面临这样的选择“花 15000 元，获得完整的苹果生态体验；花 10000 元，获得完整的鸿蒙生态体验，可以实现苹果生态 80% 甚至是 120% 的体验”，你会怎么选？<br>鸿蒙之路，道阻且长。</p>          </div>]]></content>
    
    <summary type="html">
    
      鸿蒙之路，道阻且长&lt;br&gt;Copyright@Linux中国
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Login in 163 in Mail App on Apple Device</title>
    <link href="https://augists.top/APPLE/Login-in-163-in-Mail-app-on-apple-device/"/>
    <id>https://augists.top/APPLE/Login-in-163-in-Mail-app-on-apple-device/</id>
    <published>2021-06-03T10:39:59.000Z</published>
    <updated>2021-06-05T02:39:04.288Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>一直以来，我都很嫌弃苹果设备自带的邮箱。附件稍微大一点就无法正常发送，而且感觉使用逻辑也不是很清晰，一些我需要的小功能也没有提供<br>尝试了 Spark，网易邮箱大师。Spark 的配置上似乎不支持网易邮箱，但网易邮箱又在我的使用中占了大头，所以忍痛割爱，选择了网易邮箱大师<br>但这只是电脑端啊，我还有 pad 和手机端的邮箱需要使用。碰到问题，就要解决问题 😏<br>首先，分析自己的需求：</p><ol><li>发送较大附件 📎 仅在电脑上进行，通常为传输视频或软件一些有较高存储占用的</li><li>移动端主要为接收验证码和一些通知类邮件使用，几乎没有重度使用的要求。但是要求稳定、便捷</li><li>常用邮箱为网易 163 邮箱，并且对 outlook 和 edu 邮箱有一定的使用需求，Gmail 几乎不打开</li></ol><p>根据我自己的要求分析</p><ul><li>电脑端使用网易自己的邮箱软件进行接收更合适，并且似乎不要求必须开启 imap/smtp 功能</li><li>电脑端同时登陆 163, outlook, edu 及一些特殊邮箱，提供必要时的接收和较大附件的发送。有自动签名、自动回复和一些别的功能</li><li>移动端登陆 iCloud、outlook、163 邮箱，仅作为查看邮件的使用和一些小文件的发送</li></ul><hr><p>在配置苹果上的 163 邮箱的时候遇到了无法验证账号和密码的情况，下面是解决方法（或者说配置 163 邮箱的正确步骤）</p><ol><li>网页上登陆 163 邮箱，进入邮箱的设置界面<br><img src="https://i.loli.net/2021/06/05/mvDK4FfhSQtyA2n.png" alt=""></li><li>选择 <code>POP3/SMTP/IMAP</code>，开启 <code>IMAP/SMTP</code> 服务（也可以选择 <code>POP3/SMTP</code> 服务，自行配置 <img src="https://i.loli.net/2021/06/05/oeUDQmVlWhtITMO.png" alt=""></li><li>记录弹出的授权码，授权码是用于登陆第三方设备的专用密码</li><li>在要登陆的位置填写好邮箱的信息，密码使用刚才得到的授权码，不要写自己邮箱的密码</li></ol>          </div>]]></content>
    
    <summary type="html">
    
      The mailbox in system event was suddenly invalid&lt;br&gt;Cannot login and receive emails as normal
    
    </summary>
    
    
    
      <category term="APPLE" scheme="https://augists.top/tags/APPLE/"/>
    
  </entry>
  
</feed>

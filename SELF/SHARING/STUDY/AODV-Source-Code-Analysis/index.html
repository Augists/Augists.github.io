<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/32.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16.ico">
  <link rel="mask-icon" href="/images/32.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"augists.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

<script>
  (function() {
    if ('') {
      if (prompt('Please input password') !== '') {
        alert('Wrong password! ');
        history.back();
      }
    }
  })();
</script>

  <meta name="description" content="Analysis of AODV protocol based on its source code">
<meta property="og:type" content="article">
<meta property="og:title" content="AODV Analysis">
<meta property="og:url" content="https://augists.top/SELF/SHARING/STUDY/AODV-Source-Code-Analysis/index.html">
<meta property="og:site_name" content="Augists-ZDCZ">
<meta property="og:description" content="Analysis of AODV protocol based on its source code">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2021/12/12/ZitwIevknBAWyQ6.jpg">
<meta property="article:published_time" content="2022-01-03T15:26:34.000Z">
<meta property="article:modified_time" content="2022-01-03T15:31:07.219Z">
<meta property="article:author" content="Augists">
<meta property="article:tag" content="SHARING">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2021/12/12/ZitwIevknBAWyQ6.jpg">

<link rel="canonical" href="https://augists.top/SELF/SHARING/STUDY/AODV-Source-Code-Analysis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>AODV Analysis | Augists-ZDCZ</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Augists-ZDCZ" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

	<!-- github icon -->
	<a target="_blank" rel="noopener" href="https://github.com/Augists" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Augists-ZDCZ</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">LESS is MORE</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-gallery">

    <a href="/gallery/" rel="section"><i class="fas fa-images fa-fw"></i>Gallery</a>

  </li>
        <li class="menu-item menu-item-f-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>F-links</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://augists.top/SELF/SHARING/STUDY/AODV-Source-Code-Analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/2CCC8E38-15C8-4A70-A836-2DC4D988DD4E_1_105_c.jpeg">
      <meta itemprop="name" content="Augists">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Augists-ZDCZ">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AODV Analysis
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-03 23:26:34 / Modified: 23:31:07" itemprop="dateCreated datePublished" datetime="2022-01-03T23:26:34+08:00">2022-01-03</time>
            </span>

          
            <div class="post-description">Analysis of AODV protocol based on its source code</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <div class="note warning">
            <h1 id="AODV-协议基本原理及工作流程"><a href="#AODV-协议基本原理及工作流程" class="headerlink" title="AODV 协议基本原理及工作流程"></a>AODV 协议基本原理及工作流程</h1><h2 id="AODV-简介"><a href="#AODV-简介" class="headerlink" title="AODV 简介"></a>AODV 简介</h2><blockquote><p>The Ad hoc On-Demand Distance Vector (AODV) algorithm enables<br>dynamic, self-starting, multihop routing between participating mobile<br>nodes wishing to establish and maintain an ad hoc network.  AODV<br>allows mobile nodes to obtain routes quickly for new destinations,<br>and does not require nodes to maintain routes to destinations that<br>are not in active communication.  AODV allows mobile nodes to respond<br>to link breakages and changes in network topology in a timely manner.<br>The operation of AODV is loop-free, and by avoiding the Bellman-Ford<br>“counting to infinity” problem offers quick convergence when the ad<br>hoc network topology changes (typically, when a node moves in the<br>network).  When links break, AODV causes the affected set of nodes to<br>be notified so that they are able to invalidate the routes using the<br>lost link.</p></blockquote><p>One distinguishing feature of AODV is its use of a destination<br>sequence number for each route entry.  The destination sequence<br>number is created by the destination to be included along with any<br>route information it sends to requesting nodes.  Using destination<br>sequence numbers ensures loop freedom and is simple to program.<br>Given the choice between two routes to a destination, a requesting<br>node is required to select the one with the greatest sequence number.</p><p>AODV uses the following fields with each route table entry:</p><ul><li>Destination IP Address</li><li>Destination Sequence Number</li><li>Valid Destination Sequence Number flag</li><li>Other state and routing flags (e.g., valid, invalid, repairable, being repaired)</li><li>Network Interface</li><li>Hop Count (number of hops needed to reach destination)</li><li>Next Hop</li><li>List of Precursors (described in Section 6.2)</li><li>Lifetime (expiration or deletion time of the route)</li></ul><hr><h2 id="AODV-特点"><a href="#AODV-特点" class="headerlink" title="AODV 特点"></a>AODV 特点</h2><ul><li>接入速度快</li><li>计算量小</li><li>内存占用低</li><li>网络负载轻</li></ul><p>疑问🤔️：AODV 协议通过管理 sequence number 来在有多个有效路由的情况下进行决策，每使用过一次 sequence number+1，并以此来表示节点的新鲜程度，选择 sequence number 较大的有效路由。这样难道不会导致积压、增大负载吗？感觉并不是一个合理的方案</p><hr><h2 id="AODV-Message-Type"><a href="#AODV-Message-Type" class="headerlink" title="AODV Message Type"></a>AODV Message Type</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* AODV Message types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_HELLO 0 <span class="comment">/* Really never used as a separate type... */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_RREQ 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_RREP 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_RERR 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_RREP_ACK 4</span></span><br></pre></td></tr></table></figure><hr><h2 id="AODV-文件树分析"><a href="#AODV-文件树分析" class="headerlink" title="AODV 文件树分析"></a>AODV 文件树分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── ChangeLog</span><br><span class="line">├── GPL</span><br><span class="line">├── Makefile</span><br><span class="line">├── README</span><br><span class="line">├── README.ns</span><br><span class="line">├── TODO</span><br><span class="line">├── aodv_hello.c</span><br><span class="line">├── aodv_hello.h</span><br><span class="line">├── aodv_neighbor.c</span><br><span class="line">├── aodv_neighbor.h</span><br><span class="line">├── aodv_rerr.c</span><br><span class="line">├── aodv_rerr.h</span><br><span class="line">├── aodv_rrep.c</span><br><span class="line">├── aodv_rrep.h</span><br><span class="line">├── aodv_rreq.c</span><br><span class="line">├── aodv_rreq.h</span><br><span class="line">├── aodv_socket.c</span><br><span class="line">├── aodv_socket.h</span><br><span class="line">├── aodv_timeout.c</span><br><span class="line">├── aodv_timeout.h</span><br><span class="line">├── debug.c</span><br><span class="line">├── debug.h</span><br><span class="line">├── defs.h</span><br><span class="line">├── endian.c</span><br><span class="line">├── list.c</span><br><span class="line">├── list.h</span><br><span class="line">├── llf.c</span><br><span class="line">├── llf.h</span><br><span class="line">├── lnx</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── TAGS</span><br><span class="line">│   ├── kaodv-debug.c</span><br><span class="line">│   ├── kaodv-debug.h</span><br><span class="line">│   ├── kaodv-expl.c</span><br><span class="line">│   ├── kaodv-expl.h</span><br><span class="line">│   ├── kaodv-ipenc.c</span><br><span class="line">│   ├── kaodv-ipenc.h</span><br><span class="line">│   ├── kaodv-mod.c</span><br><span class="line">│   ├── kaodv-mod.h</span><br><span class="line">│   ├── kaodv-netlink.c</span><br><span class="line">│   ├── kaodv-netlink.h</span><br><span class="line">│   ├── kaodv-queue.c</span><br><span class="line">│   ├── kaodv-queue.h</span><br><span class="line">│   └── kaodv.h</span><br><span class="line">├── locality.c</span><br><span class="line">├── locality.h</span><br><span class="line">├── main.c</span><br><span class="line">├── nl.c</span><br><span class="line">├── nl.h</span><br><span class="line">├── params.h</span><br><span class="line">├── patches</span><br><span class="line">│   ├── ns-2.26-aodv-uu-0.8.patch</span><br><span class="line">│   ├── ns-2.27-aodv-uu-0.8.patch</span><br><span class="line">│   ├── ns-2.27-aodv-uu-0.9.1.patch</span><br><span class="line">│   ├── ns-2.27-aodv-uu-0.9.patch</span><br><span class="line">│   ├── ns-2.28-aodv-uu-0.9.1.patch</span><br><span class="line">│   ├── ns-2.29-aodv-uu-0.9.1-dsr-uu-0.2-oolsr-0.99.15.patch</span><br><span class="line">│   ├── ns-2.29.3-aodv-uu-0.9.2.patch</span><br><span class="line">│   └── ns-2.32-aodv-uu.patch</span><br><span class="line">├── rfc3561.txt</span><br><span class="line">├── routing_table.c</span><br><span class="line">├── routing_table.h</span><br><span class="line">├── seek_list.c</span><br><span class="line">├── seek_list.h</span><br><span class="line">├── tags</span><br><span class="line">├── timer_queue.c</span><br><span class="line">└── timer_queue.h</span><br><span class="line"></span><br><span class="line">2 directories, 65 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过在 AODV 项目根目录下运行 <code>tree</code> 可以得到如上面代码块中的结果。项目中共有65个文件，其中通过分析 Makefile 文件中的编译链接方式我们可以看到，AODV 项目共提供了两大方向，分别为 ns-2 模拟器运行和实际运行服务。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SRC =  main.c list.c debug.c timer_queue.c aodv_socket.c aodv_hello.c \</span><br><span class="line">  aodv_neighbor.c aodv_timeout.c routing_table.c seek_list.c \</span><br><span class="line">  aodv_rreq.c aodv_rrep.c aodv_rerr.c nl.c</span><br><span class="line"></span><br><span class="line">SRC_NS =   debug.c list.c timer_queue.c aodv_socket.c aodv_hello.c \</span><br><span class="line">    aodv_neighbor.c aodv_timeout.c routing_table.c seek_list.c \</span><br><span class="line">    aodv_rreq.c aodv_rrep.c aodv_rerr.c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里，SRC 是为实际运行使用的 c 文件，而 SRC_NS 是在 NS 模拟器中编译需要使用的文件。在这次对 AODV 源代码分析的过程中，我们只关注于它运用在实践中的代码部分。所以不仅是 SRC_NS 的文件，在 SRC 的文件中如果遇到例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NS_PORT</span></span><br><span class="line"><span class="comment">/* code */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>我们都可以将其化简。</p><p>这样，我们将所有需要查看的源代码文件根据我们定下的阅读顺序进行了分类，如下表所示：</p><ul><li>Preparation<ul><li>params.h: AODV 运行时的参数定义</li><li>defs.h: 包含了 AODV 代码中的主要宏定义，例如 <code>MINTTL</code>、AODV message type 等全局宏定义，以及对主机和网卡设备的信息结构体 <code>host_info</code> 和<code>dev_info</code></li><li>list.{c|h}: 对循环双链表结构 <code>list_t</code> 的定义及操作</li><li>timer_queue.{c|h}: 定时器 <code>timer</code> 的定义及操作，依托于 <code>list_t</code> 循环双链表进行串联</li><li>routing_table.{c|h}: 路由表的定义及操作</li><li>endian.c: 对于硬件和操作系统的大小端的定义，被应用于 aodv 结构体内变量顺序</li></ul></li><li>AODV Message<ul><li>aodv_hello.{c|h}: </li><li>aodv_neighbor.{c|h}:</li><li>aodv_rreq.{c|h}:</li><li>aodv_rrep.{c|h}:</li><li>aodv_rerr.{c|h}:</li><li>aodv_socket.{c|h}:</li><li>aodv_timeout.{c|h}:</li></ul></li><li>Main<ul><li>llf.{c|h}: 链路层反馈</li><li>locality.{c|h}: 寻找目的地的方位</li><li>nl.{c|h}: AODV 协议专用套接字</li><li>seek_list.{c|h}: RREQ寻找的目的地链表</li><li>main.c: 协议初始化和运行</li></ul></li></ul><hr><h2 id="define-do-while-0"><a href="#define-do-while-0" class="headerlink" title="#define do while (0)"></a><code>#define do while (0)</code></h2><p><a target="_blank" rel="noopener" href="https://www.linuxidc.com/Linux/2014-10/108520.htm">C语言宏定语执行多条语句一般都会用 do { … } while (0)</a></p><hr><h2 id="list-c"><a href="#list-c" class="headerlink" title="list.c"></a><code>list.c</code></h2><ul><li><code>list.c</code> 文件是所有<strong>循环双链表</strong> 操作，有一个空的头节点 head<ul><li><code>listelm_detach</code>: 把两个参数的节点连接起来</li><li><code>listelm_add</code>: 第一个参数的节点添加到后两个节点中间</li><li><code>list_add</code>: 插入头节点之后的那个位置</li><li><code>list_add_tail</code>: 相当于插入tail位置</li><li><code>list_detach</code>: 把参数中的节点删除</li></ul></li></ul><blockquote><p>所有 <code>list_t *le</code> 都全名是 list element</p></blockquote><hr><h2 id="Log-Path"><a href="#Log-Path" class="headerlink" title="Log Path"></a>Log Path</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_LOG_PATH <span class="meta-string">&quot;/var/log/aodvd.log&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AODV_RT_LOG_PATH <span class="meta-string">&quot;/var/log/aodvd.rtlog&quot;</span></span></span><br></pre></td></tr></table></figure><hr><h2 id="defs-h"><a href="#defs-h" class="headerlink" title="defs.h"></a><code>defs.h</code></h2><ul><li><p><code>defs.h</code></p><ul><li><p>host 主机, dev 网卡</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Data for a network device */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> enabled; <span class="comment">/* 1 if struct is used, else 0 */</span></span><br><span class="line">    <span class="keyword">int</span> sock;    <span class="comment">/* AODV socket associated with this device */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GATEWAY</span></span><br><span class="line">    <span class="keyword">int</span> psock; <span class="comment">/* Socket to send buffered data packets. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ifindex;</span><br><span class="line">    <span class="keyword">char</span> ifname[IFNAMSIZ];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ipaddr</span>;</span>  <span class="comment">/* The local IP address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">netmask</span>;</span> <span class="comment">/* The netmask we use */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">broadcast</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">host_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> seqno;           <span class="comment">/* Sequence number */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">bcast_time</span>;</span> <span class="comment">/* The time of the last broadcast msg sent */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">fwd_time</span>;</span>   <span class="comment">/* The time a data packet was last forwarded */</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> rreq_id;         <span class="comment">/* RREQ id */</span></span><br><span class="line">    <span class="keyword">int</span> nif;                   <span class="comment">/* Number of interfaces to broadcast on */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_info</span></span></span><br><span class="line"><span class="class">        <span class="title">devs</span>[<span class="title">MAX_NR_INTERFACES</span> +</span></span><br><span class="line"><span class="class">             1];</span> <span class="comment">/* Add +1 for returning as &quot;error&quot; in ifindex2devindex. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>host_info</code> 中存储 <code>def_info</code> 数组，多开了一个位置 <code>(MAX_NR_INTERFACES+1)</code>，让函数返回错误时使用，来代表 error</p></li><li><p><code>ifindex</code> 全称是 network interface index</p></li><li><p>对 <code>AODV_msg</code> 结构体进行简化后为</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">u_int8_t</span> type;</span><br><span class="line">&#125; AODV_msg;</span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* An generic AODV extensions header */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> type;</span><br><span class="line">    <span class="keyword">u_int8_t</span> length;</span><br><span class="line">    <span class="comment">/* Type specific data follows here */</span></span><br><span class="line">&#125; AODV_ext;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="对-list-t-和-timer-嵌套结构体的理解"><a href="#对-list-t-和-timer-嵌套结构体的理解" class="headerlink" title="对 list_t 和 timer 嵌套结构体的理解"></a>对 <code>list_t</code> 和 <code>timer</code> 嵌套结构体的理解</h2><p><img src="https://s2.loli.net/2021/12/12/ZitwIevknBAWyQ6.jpg" alt="timer通过list_t实现循环双链表"></p><hr><h2 id="timeval-结构体在不同系统中的不同定义"><a href="#timeval-结构体在不同系统中的不同定义" class="headerlink" title="timeval 结构体在不同系统中的不同定义"></a><code>timeval</code> 结构体在不同系统中的不同定义</h2><ul><li><p>在 Linux 中<code>time.h</code>库文件内</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">__time_t</span> tv_sec;        <span class="comment">/* Seconds. */</span></span><br><span class="line"><span class="keyword">__suseconds_t</span> tv_usec;  <span class="comment">/* Microseconds. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在 macOS 中</p><ul><li><p>util_ldap.h</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> timeval l_timeval</span></span><br></pre></td></tr></table></figure></li><li><p>time.h</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure used as a parameter by getitimer(2) and setitimer(2) system</span></span><br><span class="line"><span class="comment"> * calls.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">itimerval</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span>  <span class="title">timeval</span> <span class="title">it_interval</span>;</span>    <span class="comment">/* timer interval */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span>  <span class="title">timeval</span> <span class="title">it_value</span>;</span>       <span class="comment">/* current value */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>clock_types.h</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Normal time specification used by the kernel clock facility.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_timespec</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>    tv_sec;                 <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="keyword">clock_res_t</span>             tv_nsec;                <span class="comment">/* nanoseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_timespec</span>    <span class="title">mach_timespec_t</span>;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="timer-queue-c"><a href="#timer-queue-c" class="headerlink" title="timer_queue.c"></a><code>timer_queue.c</code></h2><ul><li><p><code>timer_queue.c</code></p><ul><li><p><code>timer_timeout</code> 函数</p><ul><li>对 <code>list_t</code> 串联起来的 <code>timer</code> 循环双链表 <code>TQ</code></li><li>循环判断其时间是否为当前时间，将 <code>timeout</code> 的 <code>timer</code> 放入 <code>expTQ</code> 中<ul><li>若是，则从 <code>TQ</code> 中移除，并加入到 <code>expTQ</code></li><li>若否，则终止循环判断</li></ul></li><li>循环执行并删除 <code>expTQ</code> 中 <code>timer</code> 的 handler function</li></ul></li><li><p><code>timer_remove</code></p><ul><li><code>t-&gt;used</code> 置 0</li></ul></li><li><p><code>timer_add</code></p><ul><li><p><code>t-&gt;used</code> 置 1</p></li><li><p>判断 <code>TQ</code> 是否为空</p><ul><li>若空，则直接添加</li><li>若非空，则遍历 <code>TQ</code>，将 t 按照时间顺序添加到 <code>TQ</code> 中</li></ul></li><li><p><code>timer_timeout_now</code></p><ul><li><p>判断 <code>timer</code> 是否在 <code>TQ</code> 中</p><ul><li>若是，则执行 <code>handler</code>，并 <code>t-&gt;used</code> 置 0，<code>timer</code> 依旧在 <code>TQ</code> 中等待执行</li><li>若否，则返回-1</li></ul></li><li><p><code>timer_set_timeout</code></p><ul><li><p><code>t-&gt;used</code> 置 0</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;timeout.tv_usec += msec * <span class="number">1000</span>;</span><br><span class="line">t-&gt;timeout.tv_sec += t-&gt;timeout.tv_usec / <span class="number">1000000</span>;</span><br><span class="line">t-&gt;timeout.tv_usec = t-&gt;timeout.tv_usec % <span class="number">1000000</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>timer_add(t)</code></p></li></ul></li></ul></li></ul></li></ul></li></ul><hr><h2 id="AODV-Socket"><a href="#AODV-Socket" class="headerlink" title="AODV Socket"></a>AODV Socket</h2><p>在对于 <code>aodv_socket.{c|h}</code> 文件的分析中，我们发现它大量依赖于系统 C 语言源代码中的 <code>struct cmsghdr</code>，于是我们查看了系统源代码 C 语言文件中的 <code>socket.h</code> 文件，并从中找到了对于 <code>msghdr</code> 和 <code>cmsghdr</code> 结构体的定义。</p><ul><li><p><code>msghdr</code>：用于调用 recvmsg 和 sendmsg 的消息头。在 recvmsg 中使用值与结果相对应，而在 sendmsg 中仅使用值。</p><ul><li>套接口地址成员 <code>msg_name</code> 与 <code>msg_namelen</code>，分别指向我们要发送或是接收信息的套接口地址及这个套接口地址的长度<ul><li>当调用 recvmsg 时，msg_name 会指向一个将要接收的地址的接收区域</li><li>当调用 sendmsg 时，它会指向一个数据报将要发送到的目的地址</li></ul></li><li>I/O 向量引用 <code>msg_iov</code> 与 <code>msg_iovlen</code></li><li>附属数据缓冲区成员 <code>msg_control</code> 与 <code>msg_controllen</code></li><li>接收信息标记位 <code>msg_flags</code>，其可以接收的标记如下</li></ul><table><thead><tr><th>标记位</th><th>描述</th></tr></thead><tbody><tr><td>MSG_EOR</td><td>当接收到记录结尾时会设置这一位。这通常对于SOCK_SEQPACKET套接口类型十分有用</td></tr><tr><td>MSG_TRUNC</td><td>这个标记位表明数据的结尾被截短，因为接收缓冲区太小不足以接收全部的数据</td></tr><tr><td>MSG_CTRUNC</td><td>这个标记位表明某些控制数据(附属数据)被截短，因为缓冲区太小</td></tr><tr><td>MSG_OOB</td><td>这个标记位表明接收了带外数据</td></tr><tr><td>MSG_ERRQUEUE</td><td>这个标记位表明没有接收到数据，但是返回一个扩展错误</td></tr></tbody></table></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>            *msg_name;      <span class="comment">/* [XSI] optional address */</span></span><br><span class="line">    <span class="keyword">socklen_t</span>       msg_namelen;    <span class="comment">/* [XSI] size of address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>          <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span> <span class="comment">/* [XSI] scatter/gather array */</span></span><br><span class="line">    <span class="keyword">int</span>             msg_iovlen;     <span class="comment">/* [XSI] # elements in msg_iov */</span></span><br><span class="line">    <span class="keyword">void</span>            *msg_control;   <span class="comment">/* [XSI] ancillary data, see below */</span></span><br><span class="line">    <span class="keyword">socklen_t</span>       msg_controllen; <span class="comment">/* [XSI] ancillary data buffer len */</span></span><br><span class="line">    <span class="keyword">int</span>             msg_flags;      <span class="comment">/* [XSI] flags on received message */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>cmsghdr</code>：msg_control 缓冲区中辅助数据对象的头。用于提供数据报的额外信息的附加信息。 格式是一串以 cmsghdr 结构为首的信息元素的序列。<ul><li><code>cmsg_len</code>:  附属数据的字节计数，这包含结构头的尺寸。这个值是由 <code>CMSG_LEN()</code> 宏计算的</li><li><code>cmsg_level</code>:  这个值表明了原始的协议级别(例如，<code>SOL_SOCKET</code>)</li><li><code>cmsg_type</code>:  这个值表明了控制信息类型(例如，<code>SCM_RIGHTS</code>)</li><li><code>cmsg_data</code>:  这个成员并不实际存在。他用来指明实际的额外附属数据所在的位置</li></ul></li></ul><p>对 <code>msg_level</code> 的描述如下：</p><table><thead><tr><th>cmsg_level</th><th>描述</th></tr></thead><tbody><tr><td>SCM_RIGHTS</td><td>附属数据对象是一个文件描述符</td></tr><tr><td>SCM_CREDENTIALS</td><td>附属数据对象是一个包含证书信息的结构</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">socklen_t</span>       cmsg_len;       <span class="comment">/* [XSI] data byte count, including hdr */</span></span><br><span class="line">    <span class="keyword">int</span>             cmsg_level;     <span class="comment">/* [XSI] originating protocol */</span></span><br><span class="line">    <span class="keyword">int</span>             cmsg_type;      <span class="comment">/* [XSI] protocol-specific type */</span></span><br><span class="line"><span class="comment">/* followed by    unsigned char  cmsg_data[]; */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AODV 协议认为系统提供的源代码的关于 routine 部分存在 bug，所以通过 <code>msghdr</code> 和 <code>cmsghdr</code> 结构并重写部分函数来解决这个问题。</p><ul><li><code>__cmsg_nxthdr_fix</code> </li><li><code>cmsg_nxthdr_fix</code></li></ul><p>其中 <code>cmsg_nxthdr_fix</code> 函数调用 <code>__cmsg_nxthdr_fix</code> 来完成</p><ul><li><code>aodv_socket.c</code><ul><li><code>aodv_socket_init</code><ul><li></li></ul></li></ul></li></ul><p>我们在处理 AODV 协议源代码中的 <code>socket</code> 函数时发现了对于 <code>PF_INET</code> 量，于我们在高级 C 语言课程中学习的 <code>AF_INET</code> 不同。经过在网上的查阅我们可以看到，对于 Windows 系统来说，它在 <code>Winsock2.h</code> 中将 <code>PF_INET</code> 与 <code>IF_INET</code> 等价</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INET 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_INET AF_INET</span></span><br></pre></td></tr></table></figure><p>而在 Unix/Linux 系统中，对于 BSD 是 AF，对于 POSIX 是 PF。在 《Unix 网络编程 卷1: 套接字联网 API》书中，我们找到了这一段解释</p><blockquote><p><code>AF_XXX</code> Versus <code>PF_XXX</code></p><p>The “<code>AF_</code>“ prefix stands for “address family” and the “<code>PF_</code>“ prefix stands for “protocol family”. Historically, the intent was that a single protocol family might support multiple address families and that the <code>PF_</code> value was used to create the socket and the <code>AF_</code> value was used in socket address structures. But in actuality, a protocol family supporting multiple address families has never been supported and the <code>&lt;sys/socket.h&gt;</code> header defines the <code>PF_</code> value for a given protocol to be equal to the <code>AF_</code> value for that protocol. While there is no guarantee that this equality between the two will always be true, should anyone change this for existing protocols, lots of existing code would break. To conform to existing coding practice, we use only the <code>AF_</code> constants in this text, although you may encounter the <code>PF_</code> value, mainly in calls to socket.</p></blockquote><ul><li><p><code>aodv_socket_init</code></p><ul><li><p>在函数中第一次使用了 ifreq 结构体，跳转得到其化简后的部分定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">ifreq</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>    ifr_name[IFNAMSIZ];             <span class="comment">/* if name, e.g. &quot;en0&quot; */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">sockaddr</span> <span class="title">ifru_addr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">sockaddr</span> <span class="title">ifru_dstaddr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">sockaddr</span> <span class="title">ifru_broadaddr</span>;</span></span><br><span class="line">        <span class="keyword">short</span>   ifru_flags;</span><br><span class="line">        <span class="keyword">int</span>     ifru_metric;</span><br><span class="line">        <span class="keyword">int</span>     ifru_mtu;</span><br><span class="line">        <span class="keyword">int</span>     ifru_phys;</span><br><span class="line">        <span class="keyword">int</span>     ifru_media;</span><br><span class="line">        <span class="keyword">int</span>     ifru_intval;</span><br><span class="line">        <span class="keyword">caddr_t</span> ifru_data;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">ifdevmtu</span> <span class="title">ifru_devmtu</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">ifkpi</span>   <span class="title">ifru_kpi</span>;</span></span><br><span class="line">        <span class="keyword">u_int32_t</span> ifru_wake_flags;</span><br><span class="line">        <span class="keyword">u_int32_t</span> ifru_route_refcnt;</span><br><span class="line">        <span class="keyword">int</span>     ifru_cap[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">u_int32_t</span> ifru_functional_type;</span><br><span class="line">    &#125; ifr_ifru;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体中包含了两部分，包括接口 interface 的名称和一个 union 类型的定义。ifreq 为接口请求结构，用于套接字 ioctl 的接口请求结构。 所有的接口 IOctl 必须有参数定义，该定义以 ifr_name 开头。 其余的其余的可以是特定的接口。</p></li><li><p>socket 初始化 udp 数据包时，会查看 <code>this_host.nif</code> 即 number of interface to boardcast on。若为 0 则异常退出。</p></li><li><p>在 socket 部分有非常多的内容在高级 C 语言课程 Unix 网络编程中学到过，如 <code>socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)</code> 来创建 UDP 包，但在 aodv 协议中，均使用了 <code>PF_INET</code> 来替换原始的 <code>AF_INET</code></p></li><li><p>在 Unix Network Programming 中，作者提到他建议使用 <code>bzero</code> 来替换 <code>memset(&amp;aodv_addr, 0, sizeof(aodv_addr))</code>，我们组成员也查阅了这两种在内存层面上对其赋值为 0 的区别。<code>bcopy</code>、<code>bzero</code> 和 <code>bcmp</code> 是传统 BSD 的函数，属于 POSIX 标准；<code>mem*</code> 是 C90 (以及 C99)标准的 C 函数。区别在于，如果你打算把程序弄到一个符合 C90/C99，但是不符合 POSIX 标准的平台时，后者会更有优势。但是 <code>memset</code> 函数的第二和第三个参数需要单独记忆</p><blockquote><p>C has memset(), the Berkeley UNIX C library has <strong>bzero</strong>(). They are not<br>identical, and <strong>bzero</strong>() pre dates memset() but is not widely available (since<br>it’s not part of standard C</p></blockquote></li><li><p>函数中通过 <code>setsockopt</code> 给 socket 设置了以下的字段选项：</p><ul><li><code>SOL_SOCKET</code> - <code>SO_BROADCAST</code>：允许发送广播数据包</li><li><code>SOL_SOCKET</code> - <code>SO_BINDTODEVICE</code>：将套接字绑定到指定接口</li><li><code>SOL_SOCKET</code> - <code>SO_PRIORITY</code>：设置在套接字发送的所有包的协议定义优先权</li><li><code>SOL_SOCKET</code> - <code>SO_RCVBUF</code>：接受缓冲区大小</li><li><code>SOL_IP</code> - <code>IP_RECVTTL</code>：传送一条带有用一个字节表示的接收包生存时间字段的 IP_RECVTTL 控制信息</li><li><code>SOL_IP</code> - <code>IP_PKTINFO</code>：获取接收报文的相关信息，也可在发送报文时指定报文的相关控制信息</li></ul></li><li><p>aodv 将 receive buffer size 设定为了 1024 并且不允许修改（没有通过 <code>#define</code> 或其他形式提供便于修改的方法）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (setsockopt(DEV_NR(i).sock, SOL_SOCKET, SO_RCVBUF,</span><br><span class="line">               (<span class="keyword">char</span> *)&amp;bufsize, optlen) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    alog(LOG_NOTICE, <span class="number">0</span>, __FUNCTION__,</span><br><span class="line">         <span class="string">&quot;Receive buffer size set to %d&quot;</span>, bufsize);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bufsize &lt; RECV_BUF_SIZE)</span><br><span class="line">&#123;</span><br><span class="line">    alog(LOG_ERR, <span class="number">0</span>, __FUNCTION__,</span><br><span class="line">         <span class="string">&quot;Could not set receive buffer size&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>aodv_socket_process_packet</code></p><ul><li>确保邻居节点已经被添加或更新</li><li>判断消息报文类型<ul><li>通过 <code>type == RREP &amp; ttl == 1 &amp; dst.s_addr == AODV_BROADCAST</code> 判断是否为 Hello 包，并调用 hello_process 来对 Hello 包进行处理</li><li><code>AODV_RREQ</code>: <code>rreq_process((RREQ *)aodv_msg, len, src, dst, ttl, ifindex)</code></li><li><code>AODV_RREP</code>: <code>rrep_process((RREP *)aodv_msg, len, src, dst, ttl, ifindex)</code></li><li><code>AODV_RERR</code>: <code>rerr_process((RERR *)aodv_msg, len, src, dst)</code></li><li><code>AODV_RREP_ACK</code>: <code>rrep_ack_process((RREP_ack *)aodv_msg, len, src, dst)</code></li></ul></li></ul></li><li><p><code>aodv_socket_read</code></p><ul><li>本函数负责读取并调用 <code>aodv_socket_process_packet</code> 处理 AODV socket 包，在 NS-2 系统中，函数为 <code>recvAODVUUPacket</code></li><li>通过 <code>recvmsg(fd, &amp;msgh, 0)</code>  读取 socket，并从控制信息中获取 ttl 和目标地址。通过判断 <code>cmsg-&gt;cmsg_type</code><ul><li><code>IP_TTL</code>: <code>ttl = *(CMSG_DATA(cmsg));</code></li><li><code>IP_PKTINFO</code>: <code>struct in_pktinfo *pi = (struct in_pktinfo *)CMSG_DATA(cmsg); dst.s_addr = pi-&gt;ipi_addr.s_addr;</code></li></ul></li><li>若 TTL 为负值，则异常，并进行空返回</li><li>通过 <code>devfromsock</code> 尝试将 <code>sockf</code> 转换为 <code>dev_info</code>，对转换错误即空指针的返回同样按照异常处理并进行空返回</li></ul></li><li><p><code>aodv_socket_send</code></p><ul><li><p>本函数负责发送 AODV socket 数据包</p></li><li><p>不处理 AODV_RREP 数据包，并且当 <code>wait_on_reboot</code> 被设置为真时也不再发送数据包</p></li><li><p>设置 socket 的 TTL 值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(dev-&gt;sock, SOL_IP, IP_TTL, &amp;ttl, <span class="keyword">sizeof</span>(ttl))</span><br></pre></td></tr></table></figure></li><li><p>如果速率限制被启用，检查我们是否正在发送一个 RREQ 或 RERR。在这种情况下，丢弃传出的控制数据包。如果距离上次发送该类型的数据包的时间少于或小于允许的 RATE LIMIT 时间</p></li></ul></li><li><p><code>aodv_socket_new_msg</code></p><ul><li>为新产生的数据包发送缓冲空间</li></ul></li><li><p><code>aodv_socket_queue_msg</code></p><ul><li>把一个AODV消息存储在发送缓冲区中</li></ul></li><li><p><code>aodv_socket_clean</code></p><ul><li>清空套接字信息并关闭</li></ul></li></ul><p>对部分 Socket 函数的详细解释将放在内容中</p><hr><h2 id="RREQ"><a href="#RREQ" class="headerlink" title="RREQ"></a><code>RREQ</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |J|R|G|D|U|      Reserved       |   Hop Count   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                            RREQ ID                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Destination IP Address                     |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                  Destination Sequence Number                  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Originator IP Address                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                  Originator Sequence Number                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>疑问🤔️：代码实际没有 U 标志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> type;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__LITTLE_ENDIAN)</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> res1:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">u_int8_t</span> d:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int8_t</span> g:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int8_t</span> r:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int8_t</span> j:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__BIG_ENDIAN)</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> j:<span class="number">1</span>;    <span class="comment">/* Join flag (multicast) */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> r:<span class="number">1</span>;    <span class="comment">/* Repair flag */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> g:<span class="number">1</span>;    <span class="comment">/* Gratuitous RREP flag */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> d:<span class="number">1</span>;    <span class="comment">/* Destination only respond */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> res1:<span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">&quot;Adjust your &lt;bits/endian.h&gt; defines&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">u_int8_t</span> res2;</span><br><span class="line">    <span class="keyword">u_int8_t</span> hcnt;</span><br><span class="line">    <span class="keyword">u_int32_t</span> rreq_id;</span><br><span class="line">    <span class="keyword">u_int32_t</span> dest_addr;</span><br><span class="line">    <span class="keyword">u_int32_t</span> dest_seqno;</span><br><span class="line">    <span class="keyword">u_int32_t</span> orig_addr;</span><br><span class="line">    <span class="keyword">u_int32_t</span> orig_seqno;</span><br><span class="line">&#125; RREQ;</span><br></pre></td></tr></table></figure><ul><li><p><code>aodv_rreq.c</code></p><ul><li><p><code>rare_create</code></p><ul><li><p>创建 <code>RREQ</code> 并初始化</p></li><li><p>seq number increase（0 仍为 0，最大值时变为 1，其他正常 +1）</p><ul><li>当某一节点要产生 RREQ 洪泛，必须先增大自身序列号</li></ul></li><li><p><code>flag</code> 匹配并给对应的值赋 1</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* RREQ Flags: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RREQ_JOIN          0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RREQ_REPAIR        0x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RREQ_GRATUITOUS    0x4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RREQ_DEST_ONLY     0x8</span></span><br></pre></td></tr></table></figure><ul><li><p>疑问🤔️：为什么不直接用数组记录，或直接使用 <code>flag</code> 记录？目前用于匹配的代码如下</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags &amp; RREQ_JOIN)</span><br><span class="line">    rreq-&gt;j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; RREQ_REPAIR)</span><br><span class="line">    rreq-&gt;r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; RREQ_GRATUITOUS)</span><br><span class="line">    rreq-&gt;g = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; RREQ_DEST_ONLY)</span><br><span class="line">    rreq-&gt;d = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>解释：可以同时有多个 <code>flag</code></li></ul></li><li><p><code>rreq_add_ext</code></p><ul><li><p>用于对 RREQ 进行补充</p></li><li><p>存放于 <code>(AODV_ext *)((char *)rreq + offset)</code></p><ul><li><code>offset</code> 应大于或等于 <code>RREQ_SIZE</code></li></ul></li><li><p><code>AODV_ext</code> 存储信息</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* An generic AODV extensions header */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> type;</span><br><span class="line">    <span class="keyword">u_int8_t</span> length;</span><br><span class="line">    <span class="comment">/* Type specific data follows here */</span></span><br><span class="line">&#125; AODV_ext;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>type</code></li><li><code>length</code></li></ul></li><li><p>将 data 复制到 <code>((char *)((char *)ext + sizeof(AODV_ext))</code></p></li></ul></li><li><p><code>rreq_send</code></p><ul><li><p><code>struct in_addr</code></p></li><li><p><code>apr_uint32_t</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">apr_uint32_t</span>  s_addr; <span class="comment">/**&lt; storage to hold the IP# */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>unsigned int</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dest.s_addr = AODV_BROADCAST;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Broadcast on all interfaces */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_NR_INTERFACES; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!DEV_NR(i).enabled)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    rreq = rreq_create(flags, dest_addr, dest_seqno, DEV_NR(i).ipaddr);</span><br><span class="line">    aodv_socket_send((AODV_msg *)rreq, dest, RREQ_SIZE, ttl, &amp;DEV_NR(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>广播 <code>dest.s_addr = AODV_BROADCAST;</code></p></li><li><p>创建 RREQ 并发送报文</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rreq = rreq_create(flags, dest_addr, dest_seqno, DEV_NR(i).ipaddr);</span><br><span class="line">aodv_socket_send((AODV_msg *)rreq, dest, RREQ_SIZE, ttl, &amp;DEV_NR(i));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>rreq_forward</code></p><ul><li><p>记录目的和源</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dest.s_addr = AODV_BROADCAST;</span><br><span class="line">orig.s_addr = rreq-&gt;orig_addr;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>若 TTL 仍然大于 0 时继续转发</p></li><li><p>报文进入队列 <code>send_buf</code>，等待发送</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rreq = (RREQ *)aodv_socket_queue_msg((AODV_msg *)rreq, size);</span><br></pre></td></tr></table></figure></li><li><p>增加跳数 hcnt <code>rreq-&gt;hcnt++;</code></p></li><li><p>转发发送缓冲区 <code>send_buf</code> 中的报文</p></li><li><p>疑问🤔️：转发时 TTL-1 操作没有找到</p><ul><li><p>回答：forward 中只转发，在 process 中找到如下的对 TTL 的处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ip_ttl &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Update the sequence number in case the maintained one is</span></span><br><span class="line"><span class="comment">     * larger */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd_rt &amp;&amp; !(fwd_rt-&gt;flags &amp; RT_INET_DEST) &amp;&amp;</span><br><span class="line">        (<span class="keyword">int32_t</span>)fwd_rt-&gt;dest_seqno &gt; (<span class="keyword">int32_t</span>)rreq_dest_seqno)</span><br><span class="line">        rreq-&gt;dest_seqno = htonl(fwd_rt-&gt;dest_seqno);</span><br><span class="line">                                                                </span><br><span class="line">    rreq_forward(rreq, rreqlen, --ip_ttl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    DEBUG(LOG_DEBUG, <span class="number">0</span>, <span class="string">&quot;RREQ not forwarded - ttl=0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>当 TTL 大于 1 时，判断并转发 <code>—-ip_ttl</code> 的包</p></li></ul></li><li><p><code>rreq_process</code></p><ul><li><p>目的和源的初始化</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rreq_dest.s_addr = rreq-&gt;dest_addr;</span><br><span class="line">rreq_orig.s_addr = rreq-&gt;orig_addr;</span><br><span class="line">rreq_id = ntohl(rreq-&gt;rreq_id);</span><br><span class="line">rreq_dest_seqno = ntohl(rreq-&gt;dest_seqno);</span><br><span class="line">rreq_orig_seqno = ntohl(rreq-&gt;orig_seqno);</span><br><span class="line">rreq_new_hcnt = rreq-&gt;hcnt + <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>忽略由本节点开始发送的包</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rreq_orig.s_addr == DEV_IFINDEX(ifindex).ipaddr.s_addr)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>检查接收到的 RREQ 包的上一跳是否在黑名单中，若在则忽略该包</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rreq_blacklist_find(ip_src))</span><br><span class="line">&#123;</span><br><span class="line">    DEBUG(LOG_DEBUG, <span class="number">0</span>, <span class="string">&quot;prev hop of RREQ blacklisted, ignoring!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>忽略已经处理过的 RREQ 包，防止发生网络风暴</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rreq_record_find(rreq_orig, rreq_id))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>疑问🤔️：是否可以通过将检查操作前置到函数内初始化之前，小幅度提升运算速度</p></li><li><p>缓存接收到的 RREQ 包，下次接收到相同包时可以忽略不进行处理</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rreq_record_insert(rreq_orig, rreq_id);</span><br></pre></td></tr></table></figure></li><li><p>通过 rreqlen 和 extlen 处理分割 RREQ 包</p></li><li><p>路由发现 <code>rt_table_find</code></p><ul><li><p>若路由表中没有存储过目的节点，则添加到路由表中 <code>rt_table_insert</code></p></li><li><p>若发现已经存储过的记录，则尝试计算出开销最小的路径并更新</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">life = PATH_DISCOVERY_TIME - <span class="number">2</span> * rreq_new_hcnt * NODE_TRAVERSAL_TIME;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rev_rt-&gt;dest_seqno == <span class="number">0</span> ||</span><br><span class="line">    (<span class="keyword">int32_t</span>)rreq_orig_seqno &gt; (<span class="keyword">int32_t</span>)rev_rt-&gt;dest_seqno ||</span><br><span class="line">    (rreq_orig_seqno == rev_rt-&gt;dest_seqno &amp;&amp;</span><br><span class="line">     (rev_rt-&gt;state == INVALID || rreq_new_hcnt &lt; rev_rt-&gt;hcnt)))</span><br><span class="line">&#123;</span><br><span class="line">    rev_rt =</span><br><span class="line">        rt_table_update(rev_rt, ip_src, rreq_new_hcnt, rreq_orig_seqno,</span><br><span class="line">                        life, VALID, rev_rt-&gt;flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>判断自己是否为目的节点</p><ul><li><p>若是目的节点，终止 RREQ，开始 RREQ 过程，更新最大序列号</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rreq_dest.s_addr == DEV_IFINDEX(ifindex).ipaddr.s_addr)</span><br><span class="line">&#123;</span><br><span class="line">                                                                           </span><br><span class="line">    <span class="comment">/* WE are the RREQ DESTINATION. Update the node&#x27;s own</span></span><br><span class="line"><span class="comment">       sequence number to the maximum of the current seqno and the</span></span><br><span class="line"><span class="comment">       one in the RREQ. */</span></span><br><span class="line">    <span class="keyword">if</span> (rreq_dest_seqno != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int32_t</span>)this_host.seqno &lt; (<span class="keyword">int32_t</span>)rreq_dest_seqno)</span><br><span class="line">            this_host.seqno = rreq_dest_seqno;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (this_host.seqno == rreq_dest_seqno)</span><br><span class="line">            seqno_incr(this_host.seqno);</span><br><span class="line">    &#125;</span><br><span class="line">    rrep =</span><br><span class="line">        rrep_create(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, DEV_IFINDEX(rev_rt-&gt;ifindex).ipaddr,</span><br><span class="line">                    this_host.seqno, rev_rt-&gt;dest_addr, MY_ROUTE_TIMEOUT);</span><br><span class="line">                                                                           </span><br><span class="line">    rrep_send(rrep, rev_rt, <span class="literal">NULL</span>, RREP_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>若不是目的节点，则查看是否包含目的节点的路由信息</p><ul><li>若有则回复 RREP</li><li>若没有则继续广播 RREQ<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* We are an INTERMEDIATE node. - check if we have an active</span></span><br><span class="line"><span class="comment">     * route entry */</span></span><br><span class="line">                                                                          </span><br><span class="line">    fwd_rt = rt_table_find(rreq_dest);</span><br><span class="line">                                                                          </span><br><span class="line">    <span class="keyword">if</span> (fwd_rt &amp;&amp; fwd_rt-&gt;state == VALID &amp;&amp; !rreq-&gt;d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">        <span class="keyword">u_int32_t</span> lifetime;</span><br><span class="line">                                                                          </span><br><span class="line">        <span class="comment">/* GENERATE RREP, i.e we have an ACTIVE route entry that is fresh</span></span><br><span class="line"><span class="comment">           enough (our destination sequence number for that route is</span></span><br><span class="line"><span class="comment">           larger than the one in the RREQ). */</span></span><br><span class="line">                                                                          </span><br><span class="line">        gettimeofday(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">                                                                          </span><br><span class="line">        <span class="comment">/* Respond only if the sequence number is fresh enough... */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd_rt-&gt;dest_seqno != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (<span class="keyword">int32_t</span>)fwd_rt-&gt;dest_seqno &gt;= (<span class="keyword">int32_t</span>)rreq_dest_seqno)</span><br><span class="line">        &#123;</span><br><span class="line">            lifetime = timeval_diff(&amp;fwd_rt-&gt;rt_timer.timeout, &amp;now);</span><br><span class="line">            rrep = rrep_create(<span class="number">0</span>, <span class="number">0</span>, fwd_rt-&gt;hcnt, fwd_rt-&gt;dest_addr,</span><br><span class="line">                               fwd_rt-&gt;dest_seqno, rev_rt-&gt;dest_addr,</span><br><span class="line">                               lifetime);</span><br><span class="line">            rrep_send(rrep, rev_rt, fwd_rt, rrep_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* If the GRATUITOUS flag is set, we must also unicast a</span></span><br><span class="line"><span class="comment">           gratuitous RREP to the destination. */</span></span><br><span class="line">        <span class="keyword">if</span> (rreq-&gt;g)</span><br><span class="line">        &#123;</span><br><span class="line">            rrep = rrep_create(<span class="number">0</span>, <span class="number">0</span>, rev_rt-&gt;hcnt, rev_rt-&gt;dest_addr,</span><br><span class="line">                               rev_rt-&gt;dest_seqno, fwd_rt-&gt;dest_addr,</span><br><span class="line">                               lifetime);</span><br><span class="line">                                                                          </span><br><span class="line">            rrep_send(rrep, fwd_rt, rev_rt, RREP_SIZE);</span><br><span class="line">                                                                          </span><br><span class="line">            DEBUG(LOG_INFO, <span class="number">0</span>, <span class="string">&quot;Sending G-RREP to %s with rte to %s&quot;</span>,</span><br><span class="line">                  ip_to_str(rreq_dest), ip_to_str(rreq_orig));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">forward:</span><br><span class="line">    <span class="keyword">if</span> (ip_ttl &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Update the sequence number in case the maintained one is</span></span><br><span class="line"><span class="comment">         * larger */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd_rt &amp;&amp; !(fwd_rt-&gt;flags &amp; RT_INET_DEST) &amp;&amp;</span><br><span class="line">            (<span class="keyword">int32_t</span>)fwd_rt-&gt;dest_seqno &gt; (<span class="keyword">int32_t</span>)rreq_dest_seqno)</span><br><span class="line">            rreq-&gt;dest_seqno = htonl(fwd_rt-&gt;dest_seqno);</span><br><span class="line">                                                                          </span><br><span class="line">        rreq_forward(rreq, rreqlen, --ip_ttl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        DEBUG(LOG_DEBUG, <span class="number">0</span>, <span class="string">&quot;RREQ not forwarded - ttl=0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><hr><h2 id="RREP"><a href="#RREP" class="headerlink" title="RREP"></a><code>RREP</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |R|A|    Reserved     |Prefix Sz|   Hop Count   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                     Destination IP address                    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                  Destination Sequence Number                  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Originator IP address                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           Lifetime                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><ul><li><p><code>rrep_create</code></p><ul><li><p>通过 <code>aodv_socket_new_msg</code> 创建 socket message，并进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rrep-&gt;type = AODV_RREP;</span><br><span class="line">rrep-&gt;res1 = <span class="number">0</span>;</span><br><span class="line">rrep-&gt;res2 = <span class="number">0</span>;</span><br><span class="line">rrep-&gt;prefix = prefix;</span><br><span class="line">rrep-&gt;hcnt = hcnt;</span><br><span class="line">rrep-&gt;dest_addr = dest_addr.s_addr;</span><br><span class="line">rrep-&gt;dest_seqno = htonl(dest_seqno);</span><br><span class="line">rrep-&gt;orig_addr = orig_addr.s_addr;</span><br><span class="line">rrep-&gt;lifetime = htonl(life);</span><br></pre></td></tr></table></figure></li><li><p>对 flag 进行位判断，并将对应在 message 中的位置 1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags &amp; RREP_REPAIR)</span><br><span class="line">    rrep-&gt;r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; RREP_ACK)</span><br><span class="line">    rrep-&gt;a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>rrep_ack_create</code></p><ul><li><p>创建 socket message，初始化仅需要将其类型设置为 ACK 包</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rrep_ack-&gt;type = AODV_RREP_ACK;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>rrep_ack_process</code></p><ul><li><p>处理 ACK 包时，先在路由表中查找其源 ip，然后删除这个 RREP_ACK 包还未到期的计时器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_remove(&amp;rt-&gt;ack_timer);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>rrep_add_ext</code></p><ul><li>通 RREQ 时的处理，在 <code>(AODV_ext *)((char *)rrep + offset)</code> 位置添加 extension 信息。存储类型和长度信息</li></ul></li><li><p><code>rrep_send</code></p><ul><li><p>检查我们是否应该请求 <code>RREP_ACK</code>。如果收到 RREQ 的节点是邻居，则可能面临单向链路，最好请求一个<code>RREP_ACK</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (neighbor &amp;&amp; neighbor-&gt;state == VALID &amp;&amp; !neighbor-&gt;ack_timer.used)</span><br><span class="line">&#123;</span><br><span class="line">    rrep_flags |= RREP_ACK;</span><br><span class="line">    neighbor-&gt;flags |= RT_UNIDIR;</span><br><span class="line">                                                                       </span><br><span class="line">    <span class="comment">/* Must remove any pending hello timeouts when we set the</span></span><br><span class="line"><span class="comment">       RT_UNIDIR flag, else the route may expire after we begin to</span></span><br><span class="line"><span class="comment">       ignore hellos... */</span></span><br><span class="line">    timer_remove(&amp;neighbor-&gt;hello_timer);</span><br><span class="line">    neighbor_link_break(neighbor);</span><br><span class="line">                                                                       </span><br><span class="line">    DEBUG(LOG_DEBUG, <span class="number">0</span>, <span class="string">&quot;Link to %s is unidirectional!&quot;</span>,</span><br><span class="line">          ip_to_str(neighbor-&gt;dest_addr));</span><br><span class="line">                                                                       </span><br><span class="line">    timer_set_timeout(&amp;neighbor-&gt;ack_timer, NEXT_HOP_WAIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置 <code>RT_UNIDIR</code> 标志时，必须删除所有待处理的 Hello 超时，否则路由可能会在开始忽略 Hello 之后终止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fwd_rt)</span><br><span class="line">&#123;</span><br><span class="line">    precursor_add(fwd_rt, rev_rt-&gt;next_hop);</span><br><span class="line">    precursor_add(rev_rt, fwd_rt-&gt;next_hop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>rrep_forward</code></p><ul><li><p>检查是否应该请求 <code>RREP_ACK</code>，如果RREP的来源不是一个邻居，我们必须找到邻居条目，它是通往 RREP 源的下一跳。如果我们接收到 RREQ 的节点是邻居，则我们可能正面临单向链路，最好请求一个 <code>RREP_ACK</code></p></li><li><p>疑问🤔️：AODV 源码的作者在这里也没有弄明白，他们认为这里存在一个单向的连接，于是作者暂且使用了 <code>if(0)</code> 让这段代码仅仅存在于程序中但是不会被执行</p><blockquote><p>we suspect a unidirectional link</p></blockquote></li></ul></li><li><p><code>rrep_process</code></p><ul><li><p>在 RREP 的处理中，将 RREP 包中的地址信息提取出来放入四元组中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rrep_dest.s_addr = rrep-&gt;dest_addr;</span><br><span class="line">rrep_orig.s_addr = rrep-&gt;orig_addr;</span><br><span class="line">rrep_seqno = ntohl(rrep-&gt;dest_seqno);</span><br><span class="line">rrep_lifetime = ntohl(rrep-&gt;lifetime);</span><br></pre></td></tr></table></figure></li><li><p>考虑到中间节点的情况，增加RREP跳数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rrep_new_hcnt = rrep-&gt;hcnt + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>在 RREQ 的处理时，会忽略那些旨在建立一条通往自我的路线的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rrep_dest.s_addr == DEV_IFINDEX(ifindex).ipaddr.s_addr)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></li><li><p>对 RREQ 包是否还有 extension 进行判断，并将其放入 ext 变量中</p></li><li><p>检查是否应该进行前进的路线。若没有现有条目，则插入一个新条目。若有，则更新条目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">fwd_rt = rt_table_find(rrep_dest);</span><br><span class="line">rev_rt = rt_table_find(rrep_orig);</span><br><span class="line">                                                                           </span><br><span class="line"><span class="keyword">if</span> (!fwd_rt)</span><br><span class="line">&#123;</span><br><span class="line">    fwd_rt = rt_table_insert(rrep_dest, ip_src, rrep_new_hcnt, rrep_seqno,</span><br><span class="line">                             rrep_lifetime, VALID, rt_flags, ifindex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fwd_rt-&gt;dest_seqno == <span class="number">0</span> ||</span><br><span class="line">         (<span class="keyword">int32_t</span>)rrep_seqno &gt; (<span class="keyword">int32_t</span>)fwd_rt-&gt;dest_seqno ||</span><br><span class="line">         (rrep_seqno == fwd_rt-&gt;dest_seqno &amp;&amp;</span><br><span class="line">          (fwd_rt-&gt;state == INVALID || fwd_rt-&gt;flags &amp; RT_UNIDIR ||</span><br><span class="line">           rrep_new_hcnt &lt; fwd_rt-&gt;hcnt)))</span><br><span class="line">&#123;</span><br><span class="line">    pre_repair_hcnt = fwd_rt-&gt;hcnt;</span><br><span class="line">    pre_repair_flags = fwd_rt-&gt;flags;</span><br><span class="line">                                                                           </span><br><span class="line">    fwd_rt =</span><br><span class="line">        rt_table_update(fwd_rt, ip_src, rrep_new_hcnt, rrep_seqno,</span><br><span class="line">                        rrep_lifetime, VALID, rt_flags | fwd_rt-&gt;flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fwd_rt-&gt;hcnt &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DEBUG(LOG_DEBUG, <span class="number">0</span>,</span><br><span class="line">              <span class="string">&quot;Dropping RREP, fwd_rt-&gt;hcnt=%d fwd_rt-&gt;seqno=%ld&quot;</span>,</span><br><span class="line">              fwd_rt-&gt;hcnt, fwd_rt-&gt;dest_seqno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果设置了 <code>RREP_ACK</code> 标志，将 RREP 确认发送到所答复的目的地，并移除 <code>RREP_ACK</code> 标志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rrep-&gt;a)</span><br><span class="line">&#123;</span><br><span class="line">    RREP_ack *rrep_ack;</span><br><span class="line">                                                                            </span><br><span class="line">    rrep_ack = rrep_ack_create();</span><br><span class="line">    aodv_socket_send((AODV_msg *)rrep_ack, fwd_rt-&gt;next_hop, NEXT_HOP_WAIT,</span><br><span class="line">                     MAXTTL, &amp;DEV_IFINDEX(fwd_rt-&gt;ifindex));</span><br><span class="line">    <span class="comment">/* Remove RREP_ACK flag... */</span></span><br><span class="line">    rrep-&gt;a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果路由以前处于修复状态，应该向路由源发送 <code>NO DELETE RERR</code>，这样它就可以选择为目的地重新启动路由发现。通过这样的方式可以修正一个导致修复标志未被设置和 <code>RERR</code> 从未被发送的错误。</p></li></ul></li></ul><hr><h2 id="RERR"><a href="#RERR" class="headerlink" title="RERR"></a><code>RERR</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |N|          Reserved           |   DestCount   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|            Unreachable Destination IP Address (1)             |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|         Unreachable Destination Sequence Number (1)           |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|</span><br><span class="line">|  Additional Unreachable Destination IP Addresses (if needed)  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Additional Unreachable Destination Sequence Numbers (if needed)|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><ul><li><code>rerr_create</code><ul><li>RERR 的创建和初始化与 RREQ 和 RREP 类似，故这里不再赘述</li></ul></li><li><code>rerr_add_udest</code><ul><li>添加 RERR 信息，与 RREQ 和 RREP 中的 ext 类似，均为在内存中结构体后面添加附加信息</li></ul></li><li><code>rerr_process</code><ul><li>在处理 RERR 消息时，会检查哪些目的节点时不可达的。根据作者的描述，这些内容仍然只是草案</li><li>使用数据包中的目标序列号更新相应的目标序列号。检查前驱列表是否为空。如果不为空，则将该目标作为 RERR 中的不可访问目标。确定是否有新的前驱使它成为非单播 RERR 并删除所有无法到达的目的地的先驱列表</li><li>如果创建了 RERR 消息，则立即发送，同样需要经过路由发现等过程。仅在具有中断路由的先驱节点的那些接口上发送 RERR</li></ul></li></ul><hr><h2 id="HELLO"><a href="#HELLO" class="headerlink" title="HELLO"></a><code>HELLO</code></h2><ul><li><p><code>hello_start</code></p><ul><li><p>若计时器 used 则消息已经发送</p></li><li><p>设定计时器，与 Hello 进行绑定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timer_init(&amp;hello_timer, &amp;NS_CLASS hello_send, <span class="literal">NULL</span>);</span><br><span class="line">hello_send(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>hello_stop</code></p><ul><li><p>移除计时器即为停止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_remove(&amp;hello_timer);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>hello_send</code></p><ul><li>检测发送 Hello 消息是否有必要，通过判断 <code>time_diff &gt;= HELLO_INTERVAL</code> 以防我们已经在HELLO_INTERVAL内发送了其他广播信息</li></ul></li><li><p><code>hello_process</code></p><ul><li><p>处理 Hello 消息时，仅需要存储目的节点的信息，不需要完整的四元组。同样经过路由发现过程，并检测是否有补充信息</p></li><li><p>邻居节点应该只在收到3个连续的 Hello 消息后才有效</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (receive_n_hellos)</span><br><span class="line">    state = INVALID;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    state = VALID;</span><br></pre></td></tr></table></figure></li><li><p>在对时间的判断上，Hello 消息的处理为允许的时延与发送包的数量相乘后加入路由的时延</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout = ALLOWED_HELLO_LOSS * hello_interval + ROUTE_TIMEOUT_SLACK;</span><br></pre></td></tr></table></figure></li><li><p>最后通过 <code>hello_update_timeout</code> 更新 timeout 信息，而 <code>hello_update_timeout</code> 函数调用计时器的更新方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_set_timeout(&amp;rt-&gt;hello_timer, time + HELLO_DELAY);</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="RREP-ACK"><a href="#RREP-ACK" class="headerlink" title="RREP_ACK"></a><code>RREP_ACK</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |   Reserved    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><hr><h2 id="关于-t后缀"><a href="#关于-t后缀" class="headerlink" title="关于_t后缀"></a>关于<code>_t</code>后缀</h2><blockquote><p>but most often you will use &lt;inttypes.h&gt; which (unusually for standard C headers) includes &lt;stdint.h&gt;. It (&lt;inttypes.h&gt;) also defines macros for use with the printf() and scanf().</p><p>As Matt Curtis noted, there is no significance to the compiler in the suffix; it is a human-oriented convention.</p><p>However, you should also note that POSIX defines a lot of extra type names ending in ‘_t’, and reserves the suffix for the implementation. That means that if you are working on POSIX-related systems, defining your own type names with the convention is ill-advised. The system I work on has done it (for more than 20 years); we regularly get tripped up by systems defining types with the same name as we define.</p><p>CesarB:</p><p>I use _type instead of _t on my typedefs precisely to avoid that.</p><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/231760/what-does-a-type-followed-by-t-underscore-t-represent">Reference</a></p></blockquote><p>推测 AODV 作者意为对本身 <code>struct struct_name</code> 的替换，使得所有 <code>struct_name_t</code> 都为对应 <code>struct struct_name</code> 的 <code>typedef</code>，但是根据网上所查阅的资料，除非对系统内核等有深入了解，对于非内核级别代码并不推荐这样命名，可能会与 POSIX 相关的代码起冲突</p><hr>
          </div>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Augists
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://augists.top/SELF/SHARING/STUDY/AODV-Source-Code-Analysis/" title="AODV Analysis">https://augists.top/SELF/SHARING/STUDY/AODV-Source-Code-Analysis/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/Augists">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="http://wpa.qq.com/msgrd?v=3&uin=2057240784&site=qq&menu=yes">
            <span class="icon">
              <i class="fab fa-qq"></i>
            </span>

            <span class="label">QQ</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://github.com/Augists">
            <span class="icon">
              <i class="fab fa-github"></i>
            </span>

            <span class="label">GitHub</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://gitee.com/Augists">
            <span class="icon">
              <i class="fab fa-git-alt"></i>
            </span>

            <span class="label">Gitee</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://blog.csdn.net/qq_45910536">
            <span class="icon">
              <i class="fab fa-cuttlefish"></i>
            </span>

            <span class="label">CSDN</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://augists.top/subscribe">
            <span class="icon">
              <i class="fab fa-mailchimp"></i>
            </span>

            <span class="label">Subscribe</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SHARING/" rel="tag"><i class="fa fa-tag"></i> SHARING</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/SELF/SHARING/STUDY/How-to-choose-your-own-courses-in-SSDUT/" rel="prev" title="How to Choose Your Own Courses in SSDUT">
      <i class="fa fa-chevron-left"></i> How to Choose Your Own Courses in SSDUT
    </a></div>
      <div class="post-nav-item">
    <a href="/SELF/SHARING/LIFE/Why-my-devices-cannot-automatically-connect-to-mbp/" rel="next" title="Why My Devices Cannot Automatically Connect to Mbp">
      Why My Devices Cannot Automatically Connect to Mbp <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="Augists/comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#AODV-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">AODV 协议基本原理及工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AODV-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">AODV 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AODV-%E7%89%B9%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">AODV 特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AODV-Message-Type"><span class="nav-number">1.3.</span> <span class="nav-text">AODV Message Type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AODV-%E6%96%87%E4%BB%B6%E6%A0%91%E5%88%86%E6%9E%90"><span class="nav-number">1.4.</span> <span class="nav-text">AODV 文件树分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#define-do-while-0"><span class="nav-number">1.5.</span> <span class="nav-text">#define do while (0)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list-c"><span class="nav-number">1.6.</span> <span class="nav-text">list.c</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Log-Path"><span class="nav-number">1.7.</span> <span class="nav-text">Log Path</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#defs-h"><span class="nav-number">1.8.</span> <span class="nav-text">defs.h</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9-list-t-%E5%92%8C-timer-%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.9.</span> <span class="nav-text">对 list_t 和 timer 嵌套结构体的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#timeval-%E7%BB%93%E6%9E%84%E4%BD%93%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E5%AE%9A%E4%B9%89"><span class="nav-number">1.10.</span> <span class="nav-text">timeval 结构体在不同系统中的不同定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#timer-queue-c"><span class="nav-number">1.11.</span> <span class="nav-text">timer_queue.c</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AODV-Socket"><span class="nav-number">1.12.</span> <span class="nav-text">AODV Socket</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RREQ"><span class="nav-number">1.13.</span> <span class="nav-text">RREQ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RREP"><span class="nav-number">1.14.</span> <span class="nav-text">RREP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RERR"><span class="nav-number">1.15.</span> <span class="nav-text">RERR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HELLO"><span class="nav-number">1.16.</span> <span class="nav-text">HELLO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RREP-ACK"><span class="nav-number">1.17.</span> <span class="nav-text">RREP_ACK</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-t%E5%90%8E%E7%BC%80"><span class="nav-number">1.18.</span> <span class="nav-text">关于_t后缀</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Augists"
      src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/2CCC8E38-15C8-4A70-A836-2DC4D988DD4E_1_105_c.jpeg">
  <p class="site-author-name" itemprop="name">Augists</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">171</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://augists.top/subscribe" title="Subscribe → https:&#x2F;&#x2F;augists.top&#x2F;subscribe"><i class="fab fa-mailchimp fa-fw"></i>Subscribe</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/Augists" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Augists" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:awzyc2010@163.com" title="E-Mail → mailto:awzyc2010@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/484868244" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;484868244" rel="noopener" target="_blank"><i class="fa fa-tv fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://t.me/Augists" title="Telegram → https:&#x2F;&#x2F;t.me&#x2F;Augists" rel="noopener" target="_blank"><i class="fab fa-telegram fa-fw"></i>Telegram</a>
      </span>
  </div>

<a href="https://www.foreverblog.cn/go.html" target="_blank"> <img src="https://img.foreverblog.cn/wormhole_2.gif" alt="" style="width:auto;height:32px;" title="穿梭虫洞-随机访问十年之约友链博客"></a>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Augists</span>
</div>
  <div class="powered-by">
    <!--
    <i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
      Click Number:<span id="busuanzi_value_site_pv"></span>次
    </span>Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
    -->
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


  <!-- TODO -->
  <!-- 动态线条 -->
  <!--  -->

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"scale":1,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":280,"height":300},"mobile":{"show":true,"scale":0.5},"log":false,"tagMode":false});</script></body>
</html>

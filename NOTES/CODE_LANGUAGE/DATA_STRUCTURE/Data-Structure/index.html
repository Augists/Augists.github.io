<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/32.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16.ico">
  <link rel="mask-icon" href="/images/32.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"augists.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

<script>
  (function() {
    if ('') {
      if (prompt('Please input password') !== '') {
        alert('Wrong password! ');
        history.back();
      }
    }
  })();
</script>

  <meta name="description" content="Data Structure note in C">
<meta property="og:type" content="article">
<meta property="og:title" content="Data Structure">
<meta property="og:url" content="https://augists.top/NOTES/CODE_LANGUAGE/DATA_STRUCTURE/Data-Structure/index.html">
<meta property="og:site_name" content="Augists-ZDCZ">
<meta property="og:description" content="Data Structure note in C">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-09-01T03:52:27.000Z">
<meta property="article:modified_time" content="2020-11-04T08:38:24.618Z">
<meta property="article:author" content="Augists">
<meta property="article:tag" content="CODE">
<meta property="article:tag" content="NOTE">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="DATASTRUCTURE">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://augists.top/NOTES/CODE_LANGUAGE/DATA_STRUCTURE/Data-Structure/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Data Structure | Augists-ZDCZ</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Augists-ZDCZ" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

	<!-- github icon -->
	<a target="_blank" rel="noopener" href="https://github.com/Augists" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Augists-ZDCZ</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">LESS is MORE</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-gallery">

    <a href="/gallery/" rel="section"><i class="fas fa-images fa-fw"></i>Gallery</a>

  </li>
        <li class="menu-item menu-item-f-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>F-links</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://augists.top/NOTES/CODE_LANGUAGE/DATA_STRUCTURE/Data-Structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/2CCC8E38-15C8-4A70-A836-2DC4D988DD4E_1_105_c.jpeg">
      <meta itemprop="name" content="Augists">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Augists-ZDCZ">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Data Structure
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-01 11:52:27" itemprop="dateCreated datePublished" datetime="2020-09-01T11:52:27+08:00">2020-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-04 16:38:24" itemprop="dateModified" datetime="2020-11-04T16:38:24+08:00">2020-11-04</time>
              </span>

          
            <div class="post-description">Data Structure note in C</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <div class="note warning">
            <div class="note ">            <p>原发布于7月21日，因期末考试影响这篇没有学完，现开始继续更新<br>代码部分一些内容进行了省略，</p>          </div><h1 id="数据结构-C语言版"><a href="#数据结构-C语言版" class="headerlink" title="数据结构 C语言版"></a>数据结构 C语言版</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>数据 Data：客观事物，所有能输入到计算机中并被计算机程序处理的符号的总称</li><li>数据元素 Data Element：数据基本单位，整体</li><li>数据项 Data Item：有独立含义，不可分割</li><li>数据对象 Data Object：性质相同的数据元素集合，数据的子集</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><ol><li>集合</li><li>线性</li><li>树</li><li>图、网状</li></ol><ul><li>线性结构：线性表、栈和队列、字符串、数组、广义表（线性表的推广</li><li>非线性结构：树、二叉树、有向图、无向图</li></ul><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>也称物理结构</p><ul><li>顺序存储结构：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，数组</li><li>链式存储结构：给每个结点附加指针字段，用于存储后继元素的存储地址，指针</li></ul><h3 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h3><ul><li>数据类型 Data Type：一个值的集合和定义在这个值集上的一组操作的总称</li><li>抽象数据类型 Abstract Data Type，ADT：用户定义，包括：数据对象、数据对象上关系的集合、对数据对象的基本操作的集合</li></ul><pre>ADT 抽象数据类型名<br>{<br>    数据对象：<数据对象的定义><br>    数据关系：<数据关系的定义><br>    基本操作：<基本操作的定义><br>} ADT 抽象数据类型名<br></pre><p>其中，基本操作的定义格式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本操作名(参数表)</span><br><span class="line">    初始条件：&lt;初始条件描述&gt;</span><br><span class="line">    操作结构：&lt;操作结果描述&gt;</span><br></pre></td></tr></table></figure><div class="note ">            <p>e.g. 复数</p><ol><li><p>定义部分</p><pre>ADT Complex<br>{<br> 数据对象：D = {e1, e2 | e1, e2 ∈ R}<br> 数据关系：S = {(e1, e2) | e1 是复数实部，e2 是复数虚部}<br> 基本操作：<br>   Create(&C, x, y)<br>     操作结果：构造复数C，其实部和虚部分别赋以参数x, y<br>   GetReal(C)<br>     初始条件：C已存在<br>     操作结果：返回C的实部值<br>   GetImage(C)<br>     初始条件：C已存在<br>     操作结果：返回C的虚部值<br>   Add(C1, C2)<br>     初始条件：C1, C2是复数<br>     操作结果：返回C1和C2的和<br>   Sub(C1, C2)<br>     初始条件：C1, C2是复数<br>     操作结果：返回C1和C2的差<br>} ADT Complex<br></pre></li><li><p>表示部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> Realpart;</span><br><span class="line">    <span class="keyword">float</span> Imagepart;</span><br><span class="line">&#125; Complex;</span><br></pre></td></tr></table></figure></li><li><p>实现部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">(&amp;Complex C, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="comment">// 构造一个复数</span></span><br><span class="line">    C.Realpart = x;</span><br><span class="line">    C.Imagepart = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetReal</span><span class="params">(Complex C)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="comment">// 取C的实部</span></span><br><span class="line">    <span class="keyword">return</span> C.Realpart;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetImag</span><span class="params">(Complex C)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="comment">// 取C的虚部</span></span><br><span class="line">    <span class="keyword">return</span> C.Imagepart;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Complex <span class="title">Add</span><span class="params">(Complex C1, Complex C2)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="comment">// 求两个复数的和</span></span><br><span class="line">    Complex sum;</span><br><span class="line">    sum.Realpart = C1.Realpart + C2.Realpart;</span><br><span class="line">    sum.Imagepart = C1.Imagepart + C2.Imagepart;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Complex <span class="title">Sub</span><span class="params">(Complex C1, Complex C2)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="comment">// 求两个复数的差</span></span><br><span class="line">    Complex difference;</span><br><span class="line">    difference.Realpart = C1.Realpart - C2.Realpart;</span><br><span class="line">    difference.Imagepart = C1.Imagepart - C2.Imagepart;</span><br><span class="line">    <span class="keyword">return</span> difference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>          </div><h3 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h3><h4 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h4><ol><li>有穷性</li><li>确定性</li><li>可行性</li><li>输入</li><li>输出</li></ol><h4 id="评价优劣的基本标准"><a href="#评价优劣的基本标准" class="headerlink" title="评价优劣的基本标准"></a>评价优劣的基本标准</h4><ol><li>正确性</li><li>可读性</li><li>健壮性（对输入非法数据的处理反应</li><li>高效性</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>问题规模：问题的输入量，问题大小的本质表示，一般用整数n</li><li>语句频度 <em>Frequency Count</em>：一条语句的重复执行次数</li></ul><p>数量级 <em>Order of Magnitude</em> 为 O</p><p>渐进时间复杂度，简称时间复杂度 <em>Time Complexity</em><br><code>T(n) = O(f(n))</code><br>旧博客：<a href="../Stack/Time-o">Time O</a></p><h4 id="最好、最坏和平均时间复杂度"><a href="#最好、最坏和平均时间复杂度" class="headerlink" title="最好、最坏和平均时间复杂度"></a>最好、最坏和平均时间复杂度</h4><ul><li>平均时间复杂度：在所有可能情况下，按照输入实例以等概率出现时，算法计算量的加权平均值</li></ul><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>渐进空间复杂度 <em>Space Complexity</em><br><code>S(n) = O(f(n))</code></p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="定义和特点"><a href="#定义和特点" class="headerlink" title="定义和特点"></a>定义和特点</h3><p>定义</p><ul><li>由 n 个数据特性相同的元素构成的有限序列</li><li>n = 0 时为空表</li></ul><p>非空线性表的特点</p><ol><li>存在唯一一个被称作“第一个”的数据元素</li><li>存在唯一一个被称作“最后一个”的数据元素</li><li>除第一个之外，结构中的每个数据元素均只有一个前驱</li><li>除最后一个之外，结构中的每个数据元素均只有一个后驱</li></ol><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><pre>ADT List<br>{<br>    数据对象：D = {a<sub>i</sub> | a<sub>i</sub>∈ElemSet, i=1, 2, …, n, n ≥ 0}<br>    数据关系：R = {(a<sub>i-1</sub>, a<sub>i</sub>) | a<sub>i-1</sub>, a<sub>i</sub>∈D, i=2, …, n}<br>    基本操作：<br>      InitList(&L)<br>        操作结果：构造一个空的线性表 L<br>      Destroylist(&L)<br>        初始条件：线性表 L 已存在<br>        操作结果：销毁线性表 L<br>      ClearList(&l)<br>        初始条件：线性表 L 已存在<br>        操作结果：将 L 重置为空表<br>      ListEmpty(L)<br>        初始条件：线性表 L 已存在<br>        操作结果：若 L 为空表，则返回 true，否则返回 false<br>      ListLength(L)<br>        初始条件：线性表 L 已存在<br>        操作结果：返回 L 中数据元素个数<br>      GetElem(L, i, &e)<br>        初始条件：线性表 L 已存在，且 1 ≤ i ≤ ListLength(L)<br>        操作结果：用 e 返回 L 中第 i 个数据元素的值<br>      LocateElem(L, e)<br>        初始条件：线性表 L 已存在<br>        操作结果：返回 L 中第1个值与 e 相同的元素在 L 中的位置，若数据不存在，返回值为0<br>      PriorElem(L, cur_e, &pre_e)<br>        初始条件：线性表 L 已存在<br>        操作结果：若 cur_e 是 L 的数据元素，且不是第一个，则用 pre_e 返回其前驱，否则操作失败，pre_e 无定义<br>      NextElem(L, cur_e, &next_e)<br>        初始条件：线性表 L 已存在<br>        操作结果：若 cur_e 是 L 的数据元素，且不是最后一个，则用 next_e 返回其后继，否则操作失败，next_e 无定义<br>      ListInsert(&L, i, e)<br>        初始条件：线性表 L 已存在，且 1 ≤ i ≤ ListLength(L) + 1<br>        操作结果：在 L 中第 i 个位置之前插入新的数据元素 e, L 的长度加1<br>      ListDelete(&L, i)<br>        初始条件：线性表 L 已存在且非空，且 1 ≤ i ≤ ListLength(L)<br>        操作结果：在 L 中第 i 个位置之前插入新的数据元素 e，L的长度都加1<br>      TraverseList(L)<br>        初始条件：线性表 L 已存在<br>        操作结果：对线性表 L 进行遍历，在遍历的过程中<br>} ADT List<br></pre><h3 id="顺序表示"><a href="#顺序表示" class="headerlink" title="顺序表示"></a>顺序表示</h3><p>每个存储元素占 l 个存储单元<br>LOC(a<sub>i</sub>) = LOC(a<sub>1</sub>) + (i - 1) * l</p><p>只要确定了存储线性表的起始位置，线性表中任一数据元素都可以随机存储，所以线性表的顺序存储结构是一种<strong>随机存储</strong>的存储结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100        <span class="comment">// 顺序表可能达到的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType *elem;        <span class="comment">// 存储空间的基地址</span></span><br><span class="line">    <span class="keyword">int</span> length;            <span class="comment">// 当前长度</span></span><br><span class="line">&#125; SqList                <span class="comment">// 顺序表的结构类型为 SqList</span></span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.elem = <span class="keyword">new</span> ElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span> (!L.elem) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = L.elem(i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (L.elem[i] == e) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(n)</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">1</span>) || (i &gt; L.length + <span class="number">1</span>)) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span> (L.length == MAXSIZE) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length - <span class="number">1</span>; j &gt;. i - <span class="number">1</span>; j--)</span><br><span class="line">        L.elem[j + <span class="number">1</span>] = L.elem[j];</span><br><span class="line">    L.elem[i - <span class="number">1</span>] = e;</span><br><span class="line">    ++L.length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(n)</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">1</span>) || (i &gt; L.length)) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= L.length - <span class="number">1</span>; j++)</span><br><span class="line">        L.elem[j - <span class="number">1</span>] = L.elem[j];</span><br><span class="line">    --L.length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(n)</p><h3 id="链式表示"><a href="#链式表示" class="headerlink" title="链式表示"></a>链式表示</h3><p>用一组任意的存储单元存储线性表的数据元素（可以不连续）</p><p><strong>结点</strong>包括<strong>数据域</strong>和<strong>指针域</strong>，指针域中存储的信息称作<strong>指针</strong>或<strong>链</strong></p><p>根据链表结点所含指针个数、指针指向和指针连接方式，将链表分为单链表、循环链表、双向链表、二叉链表、十字链表、邻接表、邻接多重表等，其中除单链表、循环链表、双向链表，其他用于树和图等结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br></pre></td></tr></table></figure><p>通常习惯上用 <code>LinkList</code> 定义单链表，强调定义的是某个单链表的头指针<br>用 <code>LNode *</code> 定义指向单链表任意结点的指针变量</p><p>通常增加一个多余的头结点</p><ul><li>便于首元结点的处理，对首元结点的操作与其他数据元素相同，无需特殊处理</li><li>便于空表和非空表的统一处理：无需判断头指针是否为 nullptr</li></ul><div class="note ">            <ul><li>首元结点：链表中存储第一个数据元素 a<sub>i</sub> 的结点</li><li>头结点：首元结点之前附设的一个结点，其指针域指向首元结点，数据域可以不存储任何信息，也可以存储与数据元素类型相同的其他附加信息</li><li>头指针：指向链表的第一个结点</li></ul>          </div><p>单链表是非随机存取的存储结构，要取得第 i 个数据元素必须从头指针出发顺链进行寻找，也称为<strong>顺序存取</strong>的存取结构</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L = <span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取值-1"><a href="#取值-1" class="headerlink" title="取值"></a>取值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(n)</p><h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;data != e)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(n)</p><h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i - <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    s = <span class="keyword">new</span> LNode;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(n)</p><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((p-&gt;next) &amp;&amp; (j &lt; i - <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(p-&gt;next) || (j &gt; i - <span class="number">1</span>)) <span class="keyword">return</span> ERROR;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(n)</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><h5 id="前插法"><a href="#前插法" class="headerlink" title="前插法"></a>前插法</h5><ol><li>创建一个只有头结点的空链表</li><li>根据待创建的元素个数 n 循环 n 次执行<ul><li>生成一个新结点 <code>*p</code></li><li>输入元素值赋给新结点 <code>*p</code> 的数据域</li><li>将新结点 <code>*p</code> 插入到头结点之后</li></ul></li></ol><p>逆位序输入数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_H</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L = <span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="keyword">new</span> LNode;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p-&gt;data;</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(n)</p><h5 id="后插法"><a href="#后插法" class="headerlink" title="后插法"></a>后插法</h5><ol><li>创建一个只有头结点的空链表</li><li>尾指针 r 初始化，指向头结点</li><li>根据创建链表包括的元素个数 n 循环 n 次执行<ul><li>生成一个新结点 <code>*p</code></li><li>输入元素值赋给新结点 <code>*p</code> 的数据域</li><li>将新结点 <code>*p</code> 插入到尾结点 <code>*r</code> 之后</li><li>尾指针 <code>r</code> 指向新的尾结点 <code>*p</code></li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_R</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L = <span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    r = L;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="keyword">new</span> LNode;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p-&gt;date;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>Circular Linked List<br>表中最后一个结点的指针域指向头结点</p><p>终止条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p != L || p-&gt;next != L</span><br></pre></td></tr></table></figure><p>合并两个表时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = B-&gt;next-&gt;next;</span><br><span class="line">B-&gt;next = A-&gt;next;</span><br><span class="line">A-&gt;next = p;</span><br></pre></td></tr></table></figure><p>O(1)</p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType date;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DeLNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; DuLNode, *DuLinkList;</span><br></pre></td></tr></table></figure><h5 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_DuL</span><span class="params">(DuLinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(p = GetElem_DuL(L, i))) <span class="keyword">return</span> ERROR;</span><br><span class="line">    s = <span class="keyword">new</span> DuLNode;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;prior = p-&gt;prior;</span><br><span class="line">    p-&gt;prior-&gt;next = s;</span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">    p-&gt;prior = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_DuL</span><span class="params">(DuLinkList &amp;L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(p = GetElem_DuL(L, i))) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h3><h4 id="空间性能"><a href="#空间性能" class="headerlink" title="空间性能"></a>空间性能</h4><ol><li>存储空间分配</li><li>存储密度大小</li></ol><p>存储密度 = 数据元素本身占用的存储量 / 结点结构占用的存储量</p><h4 id="时间性能"><a href="#时间性能" class="headerlink" title="时间性能"></a>时间性能</h4><ol><li>存取元素的效率</li><li>插入和删除操作的效率</li></ol><h3 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h3><h4 id="合并（去重）"><a href="#合并（去重）" class="headerlink" title="合并（去重）"></a>合并（去重）</h4><ol><li>分别获取 LA 表长 m 和 LB 表长 n</li><li>从 LB 中第1个数据元素开始，循环 n 次执行、<ul><li>从 LB 中查找第 i (1 ≤ i ≤ n)个数据元素赋给 e</li><li>在 LA 中查找元素 e，如果不存在，则将 e 插在表 LA 的最后</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(List &amp;LA, List LB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m = ListLength(LA);</span><br><span class="line">    n = ListLength(LB);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        GetElem(LB, i, e);</span><br><span class="line">        <span class="keyword">if</span> (!LocateElem(LA, e))</span><br><span class="line">            ListInsert(LA, ++m, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(m * n)</p><h4 id="合并（有序表-不去重）"><a href="#合并（有序表-不去重）" class="headerlink" title="合并（有序表 不去重）"></a>合并（有序表 不去重）</h4><h5 id="顺序有序表"><a href="#顺序有序表" class="headerlink" title="顺序有序表"></a>顺序有序表</h5><ol><li>创建一个表长为 m+n 的空表 LC</li><li>指针 pc 初始化，指向 LC 的第一个元素</li><li>指针 pa 和 pb 初始化，分别指向 LA 和 LB 的第一个元素</li><li>当指针 pa 和 pb 均未达到相应表尾时，则依次比较 pa 和 pb 所指向的元素值，从 LA 或 LB 中拿较小的结点插入到 LC 的最后</li><li>如果 pb 已到达 LB 的表尾，依次将 LA 的剩余元素插入 LC 的最后</li><li>如果 pa 已到达 LA 的表尾，依次将 LB 的剩余元素插入 LC 的最后</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_Sq</span><span class="params">(SqList LA, SqList LB, SqList &amp;LC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LC.length = LA.length + LB.length;</span><br><span class="line">    LC.elem = <span class="keyword">new</span> ElemType(LC.length);</span><br><span class="line">    pc = LC.elem;</span><br><span class="line">    pa = LA.elem;</span><br><span class="line">    pb = LB.elem;</span><br><span class="line">    pa_last = LA.elem + LA.length - <span class="number">1</span>;</span><br><span class="line">    pb_last = LB.elem + LB.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((pa &lt;= pa_last) &amp;&amp; (pb &lt;= pb_last))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pa &lt;= *pb) *pc++ = *pa++;</span><br><span class="line">        <span class="keyword">else</span> *pc++ = *pb++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pa &lt;= pa_last) *pc++ = *pa++;</span><br><span class="line">    <span class="keyword">while</span> (pb &lt;= pb_last) *pc++ = *pb++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(m + n)<br>O(m + n)</p><h5 id="链式有序表"><a href="#链式有序表" class="headerlink" title="链式有序表"></a>链式有序表</h5><ol><li>指针 pa 和 pb 初始化，分别指向 LA 和 LB 的第一个结点</li><li>LC 的结点取值为 LA 的头结点</li><li>指针 pc 初始化，指向 LC 的头结点</li><li>当指针 pa 和 pb 均未到达相应的表尾时，则依次比较 pa 和 pb 所指向的元素值，从 LA 或 LB 中拿较小的结点插入到 LC 的最后</li><li>将非空表的剩余段插入到 pc 所指结点之后</li><li>释放 LB 的头结点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_L</span><span class="params">(LinkList &amp;LA, LinkList &amp;LB, LinkList &amp;LC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pa = LA-&gt;next;</span><br><span class="line">    pb = LB-&gt;next;</span><br><span class="line">    LC = LA;</span><br><span class="line">    pc = LC;</span><br><span class="line">    <span class="keyword">while</span> (pa &amp;&amp; pb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pa-&gt;data &lt;= pb-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pc = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next = pb;</span><br><span class="line">            pc = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next = pa ? pa : pb;</span><br><span class="line">    <span class="keyword">delete</span> LB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(m + n)<br>O(1)</p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="定义和特点-1"><a href="#定义和特点-1" class="headerlink" title="定义和特点"></a>定义和特点</h3><ol><li>栈</li></ol><p><strong>栈 stack</strong> 仅在表尾进行插入或删除操作的线性表<br>表尾称为 <strong>栈顶 top</strong>，表头称为 <strong>栈底 bottom</strong>，不含元素的空表称为 <strong>空栈</strong><br><strong>后进先出 First In First Out (LIFO)</strong></p><ol start="2"><li>队列</li></ol><p><strong>队列 queue</strong> 是 <strong>先进先出 First In First Out (FIFO)</strong> 的线性表<br>队列中，允许插入的一端称为 <strong>队尾 rear</strong>，允许删除的一段称为 <strong>队头 front</strong></p><h3 id="栈的表示和操作"><a href="#栈的表示和操作" class="headerlink" title="栈的表示和操作"></a>栈的表示和操作</h3><pre>ADT Stack<br>{<br>    数据对象：D = {a<sub>i</sub> | a<sub>i</sub>∈ElemSet, i = 1, 2, …, n, n ≥ 0}<br>    数据关系：R = {<a<sub>i - 1</sub>, a<sub>i</sub>> | a<sub>i - 1</sub>, a<sub>i</sub>∈D, i = 2, …, n}<br>        a<sub>n</sub>为栈顶，a<sub>i</sub>为栈底<br>    基本操作：<br>        InitStack(&S)<br>            操作结果：构造一个空栈 S<br>        DestroyStack(&S)<br>            初始条件：栈 S 已存在<br>            操作结果：栈 S 被销毁<br>        ClearStack(&S)<br>            初始条件：栈 S 已存在<br>            操作结果：栈 S 清为空栈<br>        StackEmpty(S)<br>            初始条件：栈 S 已存在<br>            操作结果：若 S 为空栈，返回 true，否则返回 false<br>        StackLength(S)<br>            初始条件：栈 S 已存在<br>            操作结果：返回 S 的元素个数，即栈的长度<br>        GetTop(S)<br>            初始条件：栈 S 已存在且非空<br>            操作结果：返回 S 的栈顶元素，不修改栈顶指针<br>        Push(&S, e)<br>            初始条件：栈 S 已存在<br>            操作结果：插入 e 为新的栈顶元素<br>        Pop(&S, &e)<br>            初始条件：栈 S 已存在且非空<br>            操作结果：删除 S 的栈顶元素，并用 e 返回其值<br>        StackTraverse(S)<br>            初始条件：栈 S 已存在且非空<br>            操作结果：从栈底到栈顶依次对 S 的每个数据元素进行访问<br>} ADT Stack<br></pre><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType *base;    <span class="comment">// 栈底指针</span></span><br><span class="line">    SelemType *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure><h5 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h5><ol><li>为栈动态分配一个最大容量为 MAXSIZE 的数组空间，使 base 指向栈底</li><li>栈顶指针 top 初始为 base，即为空栈</li><li>stacksize 置为 MAXSIZE</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.base - enw SElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span> (!S.bash) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h5><ol><li>判断是否已满，若满返回 ERROR</li><li>将新元素压入栈顶，栈顶指针加1</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top - S.base == S.stacksize) <span class="keyword">return</span> ERROR;</span><br><span class="line">    *S.top++ = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h5><ol><li>判断栈是否空，若空返回 ERROR</li><li>栈顶指针减1，栈顶元素出栈</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *--S.top;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h5><ol><li>当栈非空时，返回栈顶元素的值</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SelemType <span class="title">GetTop</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top != S.base)</span><br><span class="line">        <span class="keyword">return</span> *(S.top - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StackNode, *LinkStack;</span><br></pre></td></tr></table></figure><h5 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h5><ol><li>没必要设头结点，直接将栈顶指针置空</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="入栈-1"><a href="#入栈-1" class="headerlink" title="入栈"></a>入栈</h5><p>不需要判断是否满</p><ol><li>为入栈元素 e 分配空间，用指针 p 指向</li><li>将新结点数据域置为 e</li><li>将新结点插入栈顶</li><li>修改栈顶指针为 p</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack &amp;S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = <span class="keyword">new</span> StackNode;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = S;</span><br><span class="line">    S = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h5><ol><li>判断栈是否为空，若空返回 ERROR</li><li>将栈顶元素赋给 e</li><li>临时保存栈顶元素的空间，以备释放</li><li>修改栈顶指针，指向新的栈顶元素</li><li>释放原栈顶元素的空间</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack &amp;S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S = <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = S-&gt;data;</span><br><span class="line">    p = S;</span><br><span class="line">    S = S-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="取栈顶元素-1"><a href="#取栈顶元素-1" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> S-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h3><p><strong>分治法</strong></p><ol><li>能将一个问题转变成一个新问题，解法相同或类同，不同的仅是处理的对象，并且这些处理对象更小且变化有规律</li><li>可以通过转化而使问题简化</li><li>必须有一个明确的递归出口，或称为递归的边界</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(参数表)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (递归结束条件成立) 可直接求解;</span><br><span class="line">    <span class="keyword">else</span> p(较小的参数);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当递归结束条件成立，只执行 <code>return</code> 操作时，分治法可以化简为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(参数表)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (递归结束条件不成立)</span><br><span class="line">        p(较小的参数);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note ">            <p>e.g. 遍历输出链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraverseList</span><span class="params">(LinkList p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        TraverseList(p-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>          </div><div class="note success">            <p>e.g. 汉诺塔问题</p><ul><li><p>问题描述</p><ol><li>每次只能移动一个圆盘</li><li>圆盘可以插在 A、B、C 中任一塔座上</li><li>任何时刻都不能将一个较大的圆盘压在较小的圆盘之上</li></ol></li><li><p>问题分析<br>设 A 柱上最初的盘子总数为 n，则当 n=1 时，只要将编号为 1 的圆盘从塔座 A 直接移至 C 上即可；否则，执行以下</p><ol><li>用 C 柱做过渡，将 A 柱上的 (n-1) 个盘子移到 B 柱上</li><li>将 A 柱上最后一个盘子直接移到 C 柱上</li><li>用 A 柱做过渡，将 B 柱上的 (n-1) 个盘子移到 C 柱上</li></ol></li><li><p>算法步骤</p><ol><li>如果 n=1，则直接将编号为 1 的圆盘从 A 移到 C，递归结束</li><li>否则<ul><li>递归，将 A 上编号为 1 至 n-1 的圆盘移到 B，C 做辅助塔</li><li>直接将编号为 n 的圆盘从 A 移到 C</li><li>递归，将 B 上编号为 1 至 n-1 的圆盘移到 C，A 做辅助塔</li></ul></li></ol></li><li><p>算法描述</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">char</span> A, <span class="keyword">int</span> n, <span class="keyword">char</span> C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ++m &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; A &lt;&lt; <span class="string">&quot;, &quot;</span> C &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> A, <span class="keyword">char</span> B, <span class="keyword">char</span> C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) move(A, <span class="number">1</span>, C);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Hanoi(n<span class="number">-1</span>, A, C, B);</span><br><span class="line">        move(A, n, C);</span><br><span class="line">        Hanoi(n<span class="number">-1</span>, B, A, C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>O(2<sup>n</sup>)          </div><h3 id="队列的表示和操作"><a href="#队列的表示和操作" class="headerlink" title="队列的表示和操作"></a>队列的表示和操作</h3><pre>ADT Queue<br>{<br>    数据对象：D = {a<sub>i</sub> | a<sub>i</sub>∈ElemSet, i = 1, 2, …, n, n ≥ 0}<br>    数据关系：R = {<a<sub>i-1</sub>, a<sub>i</sub>> | a<sub>i-1</sub>, a<sub>i</sub>∈D, i = 2, …, n}<br>            约定其中 a<sub>i</sub> 端为队列头，a<sub>n</sub> 为队列尾<br>    基本操作：<br>        InitQueue(&Q)<br>            操作结果：构造一个空队列 Q<br>        DestroyQueue(&Q)<br>            初始条件：队列 Q 已存在<br>            操作结果：队列 Q 被销毁<br>        ClearQueue(&Q)<br>            初始条件：队列 Q 已存在<br>            操作结果：将 Q 清为空队列<br>        QueueEmety(Q)<br>            初始条件：队列 Q 已存在<br>            操作结果：若 Q 为空队列，则返回 true，否则返回 false<br>        QueueLength(Q)<br>            初始条件：队列 Q 已存在<br>            操作结果：返回 Q 的元素个数，即队列的长度<br>        GetHead(Q)<br>            初始条件：Q 为非空队列<br>            操作结果：返回 Q 的队头元素<br>        EnQueue(&Q, e)<br>            初始条件：队列 Q 已存在<br>            操作结果：插入元素 e 为 Q 的新队尾元素<br>        DeQueue(&Q, &e)<br>            初始条件：Q 为非空队列<br>            操作结果：删除 Q 的队头元素，并用 e 返回其值<br>        QueueTraverse(Q)<br>            初始条件：Q 已存在且非空<br>            操作结果：从队头到队尾，依次对 Q 的每个数据元素访问<br>} ADT Queue<br></pre><h4 id="循环队列——队列的顺序表示和实现"><a href="#循环队列——队列的顺序表示和实现" class="headerlink" title="循环队列——队列的顺序表示和实现"></a>循环队列——队列的顺序表示和实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType *base;    <span class="comment">// 存储空间的基地址</span></span><br><span class="line">    <span class="keyword">int</span> front;            <span class="comment">// 头指针</span></span><br><span class="line">    <span class="keyword">int</span> rear;            <span class="comment">// 尾指针</span></span><br><span class="line">&#125; SqQueue</span><br></pre></td></tr></table></figure><p>初始化时，令 <code>front = rear = 0</code>；每当有新的队尾元素时，尾指针 rear 加一；每当删除队列队头元素时，头指针 front 加一</p><ul><li>假溢出：溢出 base</li><li>解决方案：通过取模实现头尾指针的循环</li><li>同时带来的问题：循环队列不能以头、尾指针的值是否相同来判别队列是否为空</li><li>处理方法</li></ul><div class="note info">            <p>少用一个元素空间，即队列空间大小为 m 时，有 m-1 个元素就认为是队满。这样判断队空的条件不变，即当头、尾指针的值相同时，则认为队空；而当尾指针在循环意义上加 1<br>后是等于头指针，则认为队满</p><ul><li>队空的条件：<code>Q.front == Q.rear</code></li><li>队满的条件：<code>(Q.rear + 1) % MAXQSIZE == Q.front</code></li></ul>          </div><div class="note info">            <p>设一个标志位以区别队列是空还是满</p>          </div><h5 id="初始化-4"><a href="#初始化-4" class="headerlink" title="初始化"></a>初始化</h5><ol><li>为队列分配一个最大容量为 MAXQSIZE 的数组空间，base 指向数据空间的首地址</li><li>头指针和尾指针置为零，表示队列为空</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.base = <span class="keyword">new</span> QElemType[MAXQSIZE];</span><br><span class="line">    <span class="keyword">if</span> (!Q.base) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="求队列长度"><a href="#求队列长度" class="headerlink" title="求队列长度"></a>求队列长度</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h5><ol><li>判断队列是否满，若满返回 ERROR</li><li>将新元素插入队尾</li><li>队尾指针加 1</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="constructor">EnQueue(SqQueue &amp;Q, QElemType <span class="params">e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear + <span class="number">1</span>) % MAXQSIZE<span class="operator"> == </span><span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front)</span><br><span class="line">        return ERROR;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>base<span class="literal">[Q.<span class="identifier">rear</span>]</span> = e;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear = (<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h5><ol><li>判断队列是否为空，若空返回 ERROR</li><li>保存队头元素</li><li>队头指针加 1</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = Q.base[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="取队头元素"><a href="#取队头元素" class="headerlink" title="取队头元素"></a>取队头元素</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QElemType <span class="title">GetHead</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front != Q.rear)</span><br><span class="line">        <span class="keyword">return</span> Q.base[Q.front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链队——队列的链式表示和实现"><a href="#链队——队列的链式表示和实现" class="headerlink" title="链队——队列的链式表示和实现"></a>链队——队列的链式表示和实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; QNode, *QueuePtr;</span><br><span class="line">type <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125; LinkQueue;</span><br></pre></td></tr></table></figure><h5 id="初始化-5"><a href="#初始化-5" class="headerlink" title="初始化"></a>初始化</h5><ol><li>生成新结点作为头结点，队头和队尾指针指向此结点</li><li>头结点的指针域置空</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.front = Q.rear = <span class="keyword">new</span> QNode;</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h5><ol><li>为入队元素分配结点空间，用指针 p 指向</li><li>将新结点数据域置为 e</li><li>将新结点插入到队尾</li><li>修改队尾指针为 p</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = <span class="keyword">new</span> QNode;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear -&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h5><ol><li>判断队列是否为空，若空返回 ERROR</li><li>临时保存队头元素的空间，以备释放</li><li>修改头结点的指针域，指向下一个结点</li><li>判断出队元素是否为最后一个元素，若是，则将队尾指针重新赋值，指向头结点</li><li>释放原队头元素的空间</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p = Q.front-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p) Q.rear = Q.front;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="取队头元素-1"><a href="#取队头元素-1" class="headerlink" title="取队头元素"></a>取队头元素</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QElemType <span class="title">GetHead</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front != Q.rear)</span><br><span class="line">        <span class="keyword">return</span> Q.front-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="串、数组和广义表"><a href="#串、数组和广义表" class="headerlink" title="串、数组和广义表"></a>串、数组和广义表</h2><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><p><strong>串</strong> string （或<strong>字符串</strong>）由零个或多个字符组成的有限序列，一般记为</p><div class="note ">            <p>s = “a<sub>i</sub>a<sub>2</sub> … a<sub>n</sub>“ (n ≥ 0)</p>          </div><p>串中字符的数目 n 称为串的 <strong>长度</strong><br>零个字符的串称为 <strong>空串</strong> null string <code>ø</code></p><p>串中任意个连续的字符组成的子序列称为该串的 <strong>子串</strong>，包含子串的串称为 <strong>主串</strong><br>通常称字符在序列中的序号为该字符在串中的 <strong>位置</strong><br>两串 <strong>相等</strong>，当且仅当两个串的值相等</p><p>由一个或多个空格组成的串 <code>&quot; &quot;</code> 称为 <strong>空格串</strong> <em>blank string</em></p><h4 id="抽象类型定义"><a href="#抽象类型定义" class="headerlink" title="抽象类型定义"></a>抽象类型定义</h4><pre>ADT String<br>{<br>    数据对象：D = {a<sub>i</sub> | a<sub>i</sub>∈CharacterSet, i = 1, 2, …, n, n≥0}<br>    数据关系：R1 = {(a<sub>i-1</sub>, a<sub>i</sub>) | a<sub>i-1</sub>, a<sub>i</sub>∈D, i = 2, …, n}<br>    基本操作：<br>        StrAssign(&T, chars)<br>            初始条件：chars 是字符串常量<br>            操作结果：生成一个其值等于 chars 的串 T<br>        StrCopy(&T, S)<br>            初始条件：串 S 已存在<br>            操作结果：由串 S 复制得串 T<br>        StrEmpty(S)<br>            初始条件：串 S 已存在<br>            操作结果：若 S 为空串，则返回 true，否则返回 false<br>        StrCompare(S, T)<br>            初始条件：串 S 和串 T 已存在<br>            操作结果：若 S > T，则返回值 > 0；若 S = T，则返回值 = 0；若 S < T，则返回值 < 0<br>        StrLength(S)<br>            初始条件：串 S 已存在<br>            操作结果：返回 S 的元素个数，称为串的长度<br>        ClearString(&S)<br>            初始条件：串 S 已存在<br>            操作结果：将 S 清为空串<br>        Concat(&T, S1, S2)<br>            初始条件：串 S1 和 S2 已存在<br>            操作结果：用 T 返回由 S1 和 S2 联接而成的新串<br>        SubString(&Sub, S, pos, len)<br>            初始条件：串 S 已存在，1 ≤ pos ≤ StrLength(S) 且 0 ≤ len ≤ StrLength(S) - pos + 1<br>            操作结果：用 Sub 返回串 S 的第 pos 个字符起长度为 len 的字串<br>        Index(S, T. pos)<br>            初始条件：串 S 和 T 已存在，T 是非空串，1 ≤ pos ≤ StrLength(S)<br>            操作结果：若主串 S 中存在和串 T 值相同的子串，则返回它在主串中 S 中第 pos 个字符之后第一次出现的位置；否则函数值为 0<br>        Replace(&S, T, V)<br>            初始条件：串 S T V 已存在，T 是非空串<br>            操作结果：用 V 替换主串 S 中出现的所有与 T 相等的不重叠的子串<br>        StrInsert(&S, pos, T)<br>            初始条件：串 S 和 T 已存在，1 ≤ pos ≤ StrLength(S) + 1<br>            操作结果：在串 S 的第 pos 个字符之前插入串 T<br>        StrDelete(&S, pos, len)<br>            初始条件：串 S 已存在，1 ≤ pos ≤ StrLength(S) - len + 1<br>            操作结果：从串 S 中删除第 pos 个字符起长度为 len 的子串<br>        DestroyString(&S)<br>            初始条件：串 S 已存在<br>            操作结果：串 S 被销毁<br>} ADT String<br></pre><h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h4><h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定长</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[MACLEN + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> lenth;</span><br><span class="line">&#125; SString;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ch;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; HString;</span><br></pre></td></tr></table></figure><h5 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE 80</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[CHUNKSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Chunk;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Chunk *head, *tail;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; LString;</span><br></pre></td></tr></table></figure><h4 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h4><p>子串的定位运算通常称为串的 <strong>模式匹配</strong> 或 <strong>串匹配</strong></p><h5 id="BF-算法"><a href="#BF-算法" class="headerlink" title="BF 算法"></a>BF 算法</h5><ol><li>分别利用计数指针 i 和 j 指示主串 S 和模式 T 中当前正待比较的字符位置，i 初始值为 pos，j 初始值为 1</li><li>如果两个串均未比较到串尾，即 i 和 j 均分别小于等于 S 和 T 的长度时，循环之行<ul><li>S.ch[i] 和 T.ch[j] 比较，若相等，则 i 和 j 分别指示串中下个位置，继续比较后续字符</li><li>若不等，指针后退重新开始匹配，从主串的下一个字符 (i = i - j + 2) 起再重新和模式的第一个字符 (j = 1) 比较</li></ul></li><li>如果 j &gt; T.length，说明模式 T 中第一个字符相等的字符在主串 S 中的序号 (i - T.length)；否则称匹配不成功，返回 0</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_BF</span><span class="params">(SString S, SString T, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = pos; j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[i] == T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">2</span>;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.length) <span class="keyword">return</span> i - T.length;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况 O(m + n)<br>最坏情况 O(m * n)</p><h5 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h5><p>Knuth, Morris, Pratt 共同设计实现的<br>改进在于，每当一趟匹配过程中出现字符比较不等时，不需回溯 i 指针，而是利用已经得到的“部分匹配”的结果将模式向右“滑动”尽可能远的一段距离后，继续进行比较</p><p>O(m + n)</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="类型定义-1"><a href="#类型定义-1" class="headerlink" title="类型定义"></a>类型定义</h4><p>类型相同<br>可以通过下标访问数据元素<br>当每个元素处于 n (n ≥ 1) 个关系中，称为 n 维数组</p><pre>ADT Array<br>{<br>    数据对象: j<sub>i</sub> = 0, ..., b<sub>i</sub> - 1, i = 1, 2, ..., n, D = {a<sub>j<sub>1</sub>j<sub>2</sub>...j<sub>n</sub></sub> | n (> 0) 称为数组的维数，b<sub>i</sub> 是数组第 i 维的长度，j<sub>i</sub> 是数组元素第 i 维的下标，a<sub>j<sub>1</sub>j<sub>2</sub>...j<sub>n</sub></sub> ∈ Elemset}<br>    数据关系: R = {R1, R2, ..., Rn}<br>    基本操作:<br>        InitArray(&A, n, boundi, ..., doundn)<br>            操作结果：若维数 n 和各维长度合法，则构造相应的数组 A，并返回 OK<br>        DestroyArray(&A)<br>            操作结果：销毁数组 A<br>        Value(A, &e, indexl, ..., indexn)<br>            初始条件：A 是 n 维数组，e 为元素变量，随后是 n 个下标值<br>            操作结果：若各下标不超界，则 e 赋值为所指定的 A 的元素值，并返回 OK<br>        Assign(&A, e, indexl, ..., indexn)<br>            初始条件：A 是 n 维数组，e 为元素变量，随后是 n 个下标值<br>            操作结果：若下标不越界，则将 e 的值赋给所指定的 A 的元素，并返回 OK<br>} ADT Array<br></pre><h4 id="顺序存储-1"><a href="#顺序存储-1" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>一旦建立了数组，结构中的数据元素个数和元素之间的关系就不再发生变动<br>在大部分语言中，都是以行序为主序的存储结构，而在如 FORTRAN 语言中，以列序为主序</p><p>LOC(i, j) = LOC(0, 0) + (n x i + j)L</p><h4 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h4><ul><li>对称矩阵</li><li>三角矩阵</li><li>对角矩阵</li><li>稀疏矩阵（较复杂</li></ul><h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>线性表的推广，也称为列表<br>LS = (a<sub>1</sub>, a<sub>2</sub>, …, a<sub>n</sub>)，其中 a<sub>i</sub>可以是单个元素，也可以是广义表，分别称为广义表 LS 的原子和子表<br>习惯上，用大写字母表示广义表的名称，用小写字母表示原子</p><p>定义是一个<strong>递归</strong>的过程<br>重要结论：</p><ol><li>广义表的元素可以是子表，子表的元素还可以是子表</li><li>广义表可以为其他广义表所共享（指可以不必列出子表的值，而是通过子表的名称来引用</li><li>广义表可以是一个递归的表，即可以是本身的一个子表</li></ol><p>最重要的两个运算：</p><ol><li>取表头 GetHead(LS): 取出的表头为非空广义表的第一个元素，可以是单原子，也可以是一个子表</li><li>取表尾 GetTail(LS): 取出的表尾为除去表头之外，由其余元素构成的表，即一定是一个广义表</li></ol><p>() 和 (()) 不同</p><h4 id="存储结构-2"><a href="#存储结构-2" class="headerlink" title="存储结构"></a>存储结构</h4><p>通常采用链式存储结构</p><h5 id="头尾链表的存储结构"><a href="#头尾链表的存储结构" class="headerlink" title="头尾链表的存储结构"></a>头尾链表的存储结构</h5><ul><li>表结点：标志域、指示表头的指针域、指示表尾的指针域</li><li>原子结点标志域、值域</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;ATOM, LIST&#125; ElemTag;    <span class="comment">// ATOM == 0: 原子, LIST == 1: 子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemTag tag;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        AtomType atom;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>, *<span class="title">tp</span>;</span></span><br><span class="line">        &#125; ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *GList;</span><br></pre></td></tr></table></figure><ol><li>除空表的表头指针为空外，对任何非空广义表，其表头指针均指向一个表结点，且该结点中的 hp 域指示广义表表头（或为原子结点，或为表结点），tp 域指向广义表表尾（除非表尾为空，则指针为空，否则必为表结点</li><li>容易分清列表中原子和子表所在层次</li><li>最高层的表结点个数即为广义表的长度</li></ol><h5 id="扩展线性链表的存储结构"><a href="#扩展线性链表的存储结构" class="headerlink" title="扩展线性链表的存储结构"></a>扩展线性链表的存储结构</h5><p>无论是原子结点还是表结点均由三个域组成，原子结点增加一个 tp</p><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p><strong>树</strong> <em>Tree</em> 是 n (n ≥ 0) 个结点的有限集，或为空树 (n = 0)，或为非空树<br>对于非空树 T：</p><ol><li>有且仅有一个称之为根的结点</li><li>除根结点外的其余结点可分为 m (m &gt; 0) 个互不相交的有限集 T<sub>1</sub>, T<sub>2</sub>, …, T<sub>m</sub>，其中每个集合本身又是一棵树，并称为根的<strong>子树</strong> <em>SubTree</em></li></ol><h4 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h4><ul><li><strong>结点</strong>：树中的一个独立单元，包含一个数据元素及若干指向其子树的分支</li><li><strong>结点的度</strong>：结点拥有的子树数</li><li><strong>树的度</strong>：树内各结点度的最大值</li><li><strong>叶子</strong>：度为 0 的结点（或称为终端结点</li><li><strong>非终端结点</strong>：度不为 0 的结点（或称为分支结点，除根结点外，非终端结点也称为内部结点</li><li><strong>双亲和孩子</strong>：结点的子树的根称为该结点的孩子，相应的，该结点称为孩子的双亲</li><li><strong>兄弟</strong>：同一个双亲的孩子之间互称兄弟</li><li><strong>祖先</strong>：从根到该结点所经分支上的所有节点</li><li><strong>子孙</strong>：以某结点为根的子树中的任一结点</li><li><strong>层次</strong>：结点的层次从根开始定义起，根为第一层</li><li><strong>堂兄弟</strong>：双亲在同一层的结点互为堂兄弟</li><li><strong>树的深度</strong>：树中结点的从最大层次（或称为树的高度</li><li><strong>有序树和无序树</strong>：从左到右是有次序的（不能交换），称为有序树，最左边的子树的根称为第一个孩子</li><li><strong>森林</strong>：m (m ≥ 0) 棵互不相交的树的集合。对树中的每个结点而言，其子树的集合即为森林</li></ul><p>就逻辑结构而言，任何一棵树都是一个二元组 Tree = (root, F)</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树 <em>Binary Tree</em> 是 n (n ≥ 0) 个结点所构成的集合<br>对于非空树 T：</p><ol><li>有且仅有一个称之为根的结点</li><li>除根结点之外的其余结点分为两个互不相交的子集 T<sub>1</sub> 和 T<sub>2</sub>，分别称为 T 的左子树和右子树，且 T<sub>1</sub> 和 T<sub>2</sub> 本身又都是二叉树</li></ol><p>与树的区别：</p><ol><li>二叉树每个结点至多只有两颗子树（即不存在度大于 2 的结点</li><li>二叉树的子树有左右之分，其次序不能任意颠倒</li></ol><h4 id="抽象数据类型定义"><a href="#抽象数据类型定义" class="headerlink" title="抽象数据类型定义"></a>抽象数据类型定义</h4><pre>ADT Tree<br>{<br>    数据对象：D 是具有相同特性的数据元素的集合<br>    基本操作：<br>        InitTree(&T)<br>            操作结果：构造空树 T<br>        DestroyTree(&T)<br>            初始条件：树 T 存在<br>            操作结果：销毁树 T<br>        CreateTree(&T, definition)<br>            初始条件：definition 给出树 T 的定义<br>            操作结果：按 definition 构造树 T<br>        Cleartree(&T)<br>            初始条件：树 T 存在<br>            操作结果：将树 T 清为空树<br>        TreeEmpty(T)<br>            初始条件：树 T 存在<br>            操作结果：若 T 为空树，则返回 true，否则 false<br>        TreeDepth(T)<br>            初始条件：树 T 存在<br>            操作结果：返回 T 的深度<br>        Root(T)<br>            初始条件：树 T 存在<br>            操作结果：返回 T 的根<br>        Value(T, cur_e)<br>            初始条件：树 T 存在，cur_e 是 T 中某个结点<br>            操作结果：返回 cur_e 的值<br>        Assign(T, cur_e, value)<br>            初始条件：树 T 存在，cur_e 是 T 中某个结点<br>            操作结果：结点 cur_e 赋值为 value<br>        Parent(T, cur_e)<br>            初始条件：树 T 存在，cur_e 是 T 中某个结点<br>            操作结果：若 cur_e 是 T 的非根结点，则返回它的双亲，否则函数值为空<br>        LeftChild(T, cur_e)<br>            初始条件：树 T 存在，cur_e 是 T 中的某个结点<br>            操作结果：若 cur_e 是 T 的非叶子结点，则返回它的最左孩子，否则返回空<br>        RightSibling(T, cur_e)<br>            初始条件：树 T 存在，cur_e 是 T 中某个结点<br>            操作结果：若 cur_e 有右兄弟，则返回它的右兄弟，否则函数值为空<br>        InsertChild(&T, p, i, c)<br>            初始条件：树 T 存在，p 指向 T 中某个结点，1 ≤ i ≤ p 所指结点的度 +1，非空树 c 与 T 不相交<br>            操作结果：插入 c 为 T 中 p 所指结点的第 i 棵子树<br>        DeleteChild(&T, p, i)<br>            初始条件：树 T 存在，p 指向 T 中某个结点，1 ≤ i ≤ p 所指结点的度<br>            操作结果：删除 T 中 p 所指结点的第 i 棵子树<br>        TraverseTree(T)<br>            初始条件：树 T 存在<br>            操作结果：按某种次序对 T 的每个结点访问一次<br>} ADT Tree<br></pre><pre>ADT BinaryTree<br>{<br>    数据对象：D 是具有相同特性的数据元素的集合<br>    基本操作：<br>        InitBiTree(&T)<br>            操作结果：构造空二叉树 T<br>        DestroyBiTree(&T)<br>            初始条件：二叉树 T 存在<br>            操作结果：销毁二叉树 T<br>        CreateBiTree(&T, definition)<br>            初始条件：definition 出二叉树 T 的定义<br>            操作结果：按 definition 构造二叉树 T<br>        ClearBiTree(&T)<br>            初始条件：二叉树存在<br>            操作结果：将二叉树 T 清为空树<br>        BiTreeEmpty(T)<br>            初始条件：二叉树 T 存在<br>            操作结果：若 T 为空二叉树，则返回 true，否则 false<br>        BiTreeDepth(T)<br>            初始条件：二叉树 T 存在<br>            操作结果：返回 T 的深度<br>        Root(T)<br>            初始条件：二叉树 T 存在<br>            操作结果：返回 T 的根<br>        Value(T, e)<br>            初始条件：二叉树 T 存在，e 是 T 中某个结点<br>            操作结果：返回 e 的值<br>        Assign(T, &e, value)<br>            初始条件：二叉树 T 存在，e 是 T 中某个节点<br>            操作结果：结点 e 赋值为 value<br>        Parent(T, e)<br>            初始条件：二叉树 T 存在，e 是 T 中某个结点<br>            操作结果：若 e 是 T 的非根结点，则返回它的双亲，否则返回空<br>        LeftChild(T, e)<br>            初始条件：二叉树 T 存在，e 是 T 中某个结点<br>            操作结果：返回 e 的左孩子，若 e 无左孩子，则返回空<br>        RightChild(T, e)<br>            初始条件：二叉树 T 存在，e 是 T 中某个结点<br>            操作结果：返回 e 的右孩子，若 e 无右孩子，则返回空<br>        LeftSibling(T, e)<br>            初始条件：二叉树 T 存在，e 是 T 中某个结点<br>            操作结果：返回 e 的左兄弟，若 e 是 T 的左孩子或无左兄弟，则返回空<br>        RightSibling(T, e)<br>            初始条件：二叉树 T 存在，e 是 T 中某个结点<br>            操作结果：返回 e 的右兄弟，若 e 是 T 的右孩子或无右兄弟，则返回空<br>        InsertChild(&T, p, LR, c)<br>            初始条件：二叉树 T 存在，p 指向 T 中某个结点，LR 为 0 或 1，非空二叉树 c 与 T 不相交且右子树为空<br>            操作结果：根据 LR 为 0 或 1，插入 c 为 T 中 p 所指结点的左或右子树，p 所指结点的原有左或右子树则成为 c 的右子树<br>        DeleteChild(&T, p, LR)<br>            初始条件：二叉树 T 存在，p 指向 T 中某个结点，LR 为 0 或 1<br>            操作结果：根据 LR 为 0 或 1，删除 T 中 p 所指结点的左或右子树<br>        PreOrderTraverse(T)<br>            初始条件：二叉树 T 存在<br>            操作结果：先序遍历 T，对每个结点访问一次<br>        InOrderTraverse(T)<br>            初始条件：二叉树 T 存在<br>            操作结果：中序遍历 T，对每个结点访问一次<br>        PostOrderTraverse(T)<br>            初始条件：二叉树 T 存在<br>            操作结果：后序遍历 T，对每个结点访问一次<br>        LevelOrderTraverse(T)<br>            初始条件：二叉树 T 存在<br>            操作结果：层序遍历 T，对每个结点访问一次<br>} ADT BinaryTree<br></pre><h4 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h4><ol><li>在二叉树的第 i 层上至多有 2<sup>i - 1</sup> 个结点 (i ≥ 1)</li><li>深度为 k 的二叉树至多有 w<sup>k</sup> - 1 个结点 (i ≥ 1)</li><li>对任何一棵二叉树 T，如果其终端结点数 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1</li></ol><div class="note info">            <ul><li><p>满二叉树：深度为 k 且含有 2<sup>k</sup> - 1 个结点的二叉树</p><ul><li>特点：<ul><li>每一层上的结点数都是最大结点数，即每一层 i 的结点数都具有最大值 2<sup>i - 1</sup></li></ul></li></ul></li><li><p>完全二叉树：深度为 k 的，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应</p><ul><li>特点：<ol><li>叶子结点只可能在层次最大的两层上出现</li><li>对任一结点，若其右分支下的子孙的最大层次为 l，则其左分支下的子孙的最大层次必为 l 或 l + 1</li></ol></li></ul></li></ul>          </div><ol start="4"><li>具有 n 个结点的完全二叉树的深度为 ⌊log<sub>2</sub>n⌋ + 1</li><li>如果对一棵有 n 个结点的完全二叉树的结点按层序编号，则对任一结点 i (1 ≤ i ≤ n) 有<ol><li>如果 i = 1，则结点 i 是二叉树的根，无双亲；如果 i &gt; 1，则其双亲 PARENT(i) 是结点 ⌊i / 2⌋</li><li>如果 2i &gt; n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子 LCHILD(i) 是结点 2i</li><li>如果 2i + 1 &gt; n，则结点 i 无右孩子；否则其右孩子 RCHILD(i) 是结点 2i + 1</li></ol></li></ol><h4 id="二叉树存储结构"><a href="#二叉树存储结构" class="headerlink" title="二叉树存储结构"></a>二叉树存储结构</h4><h5 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAXTSIZE];        <span class="comment">// 0 号单元存储根结点</span></span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure><p><strong>仅适用于完全二叉树</strong>，因为在最坏的情况下，一个深度为 k 且只有 k 个结点的单支树（树中不存在度为 2 的结点）却需要长度为 2<sup>k</sup> - 1 的一维数组</p><h5 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h5><p>二叉链表包含：</p><ul><li>数据域</li><li>左右指针域</li></ul><p>三叉链表增加一个指向双亲结点的指针域<br>在含有 n 个结点的二叉链表中有 n + 1 个空链域，可以利用这些空链域存储其他有用信息，从而得到<strong>线索链表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><h3 id="二叉树遍历和线索二叉树"><a href="#二叉树遍历和线索二叉树" class="headerlink" title="二叉树遍历和线索二叉树"></a>二叉树遍历和线索二叉树</h3><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p><em>traversing binary tree</em></p><ul><li>DLR</li><li>LDR</li><li>LRD</li><li>DRL</li><li>RDL</li><li>RLD</li></ul><div class="note info">            <p>先序遍历</p><p>若二叉树为空，则空操作；否则</p><ol><li>访问根结点</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ol>          </div><div class="note info">            <p>中序遍历</p><p>若二叉树为空，则空操作；否则</p><ol><li>中序遍历左子树</li><li>访问根结点</li><li>中序遍历右子树</li></ol>          </div><div class="note info">            <p>后序遍历</p><p>若二叉树为空，则空操作；否则</p><ol><li>后序遍历左子树</li><li>后序遍历右子树</li><li>访问根结点</li></ol>          </div><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p>递归算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; T-&gt;data;</span><br><span class="line">        InOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归算法</p><ol><li>初始化一个空栈 S，指针 p 指向根结点</li><li>申请一个结点空间 q，用来存放栈顶弹出的元素</li><li>当 p 非空或者栈 S 非空时，循环执行以下操作：<ul><li>如果 p 非空，则将 p 进栈，p 指向该结点的左孩子</li><li>如果 p 为空，则弹出栈顶元素并访问，将 p 指向该结点的右孩子</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitStack(S); p = T;</span><br><span class="line">    q = <span class="keyword">new</span> BiTNode;</span><br><span class="line">    <span class="keyword">while</span> (p || !StackEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            Push(S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Pop(S, q);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; q-&gt;data;</span><br><span class="line">            p = q-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间空间都为 O(n)</p><h5 id="先序遍历的顺序创建二叉链表"><a href="#先序遍历的顺序创建二叉链表" class="headerlink" title="先序遍历的顺序创建二叉链表"></a>先序遍历的顺序创建二叉链表</h5><ol><li>扫描字符序列，读入字符 ch</li><li>如果 ch 是一个 ‘#’ 字符，则表明该二叉树为空，即 T 为 NULL；否则执行以下操作<ul><li>申请一个结点空间 T</li><li>将 ch 赋给 <code>T-&gt;data</code></li><li>递归创建 T 的左子树</li><li>递归创建 T 的右子树</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = <span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data = ch;</span><br><span class="line">        CreateBiTree(T-&gt;lchild);</span><br><span class="line">        CreateBiTree(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复制二叉树"><a href="#复制二叉树" class="headerlink" title="复制二叉树"></a>复制二叉树</h5><p>如果是空树，递归结束，否则执行以下操作：</p><ul><li>申请一个新结点空间，复制根结点</li><li>递归复制左子树</li><li>递归复制右子树</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(BiTree T, BiTree &amp;NewT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        NewT = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        NewT = <span class="keyword">new</span> BiTNode;</span><br><span class="line">        NewT-&gt;data = T-&gt;data;</span><br><span class="line">        Copy(T-&gt;lchild, NewT-&gt;lchild);</span><br><span class="line">        Copy(T-&gt;rchild, NewT-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="计算二叉树深度"><a href="#计算二叉树深度" class="headerlink" title="计算二叉树深度"></a>计算二叉树深度</h5><p>如果是空树，递归结束，深度为 0，否则执行以下操作：</p><ul><li>递归计算左子树的深度记为 m</li><li>递归计算右子树的深度记为 n</li><li>如果 m 大于 n，二叉树的深度为 m + 1，否则为 n + 1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m = Depth(T-&gt;lchild);</span><br><span class="line">        n = Depth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">            <span class="keyword">return</span> (m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="统计二叉树中结点的个数"><a href="#统计二叉树中结点的个数" class="headerlink" title="统计二叉树中结点的个数"></a>统计二叉树中结点的个数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NodeCount</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><p>如果有 n 个结点的二叉链表中必定存在  n + 1 个空链域，因此可以充分利用这些空链域来存放结点的前驱和后继信息</p><div class="note info">            <p>试做如下规定：<br>若结点有左子树，则其 lchild 域指示其左孩子，否则令 lchild 域指示其前驱<br>若结点有右子树，则其 rchild 域指示其右孩子，否则令 rchild 域指示其后继<br>为了避免混淆，需要改变结点结构，增加两个标志域，</p><table><thead><tr><th>lchild</th><th>LTag</th><th>data</th><th>RTag</th><th>rchild</th></tr></thead></table><p>其中</p><p><code>LTag =</code></p><ul><li>0 lchild 域表示结点的左孩子</li><li>1 lchild 域表示结点的前驱</li></ul><p><code>RTag</code> 同理</p>          </div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> LTag, RTag;</span><br><span class="line">&#125; BiThrNode, *BiThrNode;</span><br></pre></td></tr></table></figure><ul><li><strong>线索链表</strong>：以这种结点结构构成的二叉链表</li><li><strong>线索</strong>：其中指向结点前驱和后继的指针</li><li><strong>线索二叉树</strong> (Threaded Binary Tree)：加上线索的二叉树</li><li><strong>线索化</strong>：对二叉树以某种次序遍历使其次序遍历使其变为线索二叉树的过程</li></ul><h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><h5 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h5><p>以一组连续的存储单元存储树的结点，每个结点除了数据域 <em>data</em> 外，还附设一个 <em>parent</em> 域用以指示其双亲结点的位置</p><h5 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h5><p>由于树中每个结点可能有多棵子树，则可用多重链表，即每个结点有多个指针域</p><p>若不存储 <em>degree</em>，则多重链表中的结点是同构的。会有很多空链域，空间较浪费。一棵有 n 个结点度为 k 的树中必有 n(k - 1) + 1 个空链域<br>若存储 <em>degree</em>，则多重链表中的结点是不同构的。虽然节约存储空间，但操作不方便</p><p>另一种办法是，把每个结点的孩子结点排列起来，看成是一个线性表，且以单链表做存储结构，则 n 个结点有 n 个孩子链表（叶子的孩子链表为空表）。而 n 个头指针又组成一个线性表，为了便于查找，可采用顺序存储结构</p>
          </div>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Augists
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://augists.top/NOTES/CODE_LANGUAGE/DATA_STRUCTURE/Data-Structure/" title="Data Structure">https://augists.top/NOTES/CODE_LANGUAGE/DATA_STRUCTURE/Data-Structure/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/Augists">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="http://wpa.qq.com/msgrd?v=3&uin=2057240784&site=qq&menu=yes">
            <span class="icon">
              <i class="fab fa-qq"></i>
            </span>

            <span class="label">QQ</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://github.com/Augists">
            <span class="icon">
              <i class="fab fa-github"></i>
            </span>

            <span class="label">GitHub</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://gitee.com/Augists">
            <span class="icon">
              <i class="fab fa-git-alt"></i>
            </span>

            <span class="label">Gitee</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://blog.csdn.net/qq_45910536">
            <span class="icon">
              <i class="fab fa-cuttlefish"></i>
            </span>

            <span class="label">CSDN</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://augists.top/subscribe">
            <span class="icon">
              <i class="fab fa-mailchimp"></i>
            </span>

            <span class="label">Subscribe</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CODE/" rel="tag"><i class="fa fa-tag"></i> CODE</a>
              <a href="/tags/NOTE/" rel="tag"><i class="fa fa-tag"></i> NOTE</a>
              <a href="/tags/C-C/" rel="tag"><i class="fa fa-tag"></i> C/C++</a>
              <a href="/tags/DATASTRUCTURE/" rel="tag"><i class="fa fa-tag"></i> DATASTRUCTURE</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/SELF/SHARING/LIFE/uPic-or-iPic-or-Picgo-That-is-a-question/" rel="prev" title="uPic or iPic or PicGo? That Is a Question">
      <i class="fa fa-chevron-left"></i> uPic or iPic or PicGo? That Is a Question
    </a></div>
      <div class="post-nav-item">
    <a href="/APPLE/ios-password-safety-for-wallet/" rel="next" title="IOS Password Safety for Wallet">
      IOS Password Safety for Wallet <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="Augists/comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C%E8%AF%AD%E8%A8%80%E7%89%88"><span class="nav-number">1.</span> <span class="nav-text">数据结构 C语言版</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%AA%E8%AE%BA"><span class="nav-number">1.1.</span> <span class="nav-text">绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.2.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">逻辑结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">存储结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">数据类型和抽象数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">1.1.4.</span> <span class="nav-text">算法和算法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">算法的特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%84%E4%BB%B7%E4%BC%98%E5%8A%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%87%E5%87%86"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">评价优劣的基本标准</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A5%BD%E3%80%81%E6%9C%80%E5%9D%8F%E5%92%8C%E5%B9%B3%E5%9D%87%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">最好、最坏和平均时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">空间复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">1.2.</span> <span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9"><span class="nav-number">1.2.1.</span> <span class="nav-text">定义和特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.2.</span> <span class="nav-text">类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.2.3.</span> <span class="nav-text">顺序表示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%96%E5%80%BC"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">取值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">插入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">删除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.2.4.</span> <span class="nav-text">链式表示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%96%E5%80%BC-1"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">取值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE-1"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5-1"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">插入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4-1"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA"><span class="nav-number">1.2.4.6.</span> <span class="nav-text">创建</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D%E6%8F%92%E6%B3%95"><span class="nav-number">1.2.4.6.1.</span> <span class="nav-text">前插法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8E%E6%8F%92%E6%B3%95"><span class="nav-number">1.2.4.6.2.</span> <span class="nav-text">后插法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.4.7.</span> <span class="nav-text">循环链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.4.8.</span> <span class="nav-text">双向链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%92%E5%85%A5-2"><span class="nav-number">1.2.4.8.1.</span> <span class="nav-text">插入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4-2"><span class="nav-number">1.2.4.8.2.</span> <span class="nav-text">删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">1.2.5.</span> <span class="nav-text">顺序表和链表的比较</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E6%80%A7%E8%83%BD"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">空间性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">时间性能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.2.6.</span> <span class="nav-text">线性表的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%EF%BC%88%E5%8E%BB%E9%87%8D%EF%BC%89"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">合并（去重）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%EF%BC%88%E6%9C%89%E5%BA%8F%E8%A1%A8-%E4%B8%8D%E5%8E%BB%E9%87%8D%EF%BC%89"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">合并（有序表 不去重）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%9C%89%E5%BA%8F%E8%A1%A8"><span class="nav-number">1.2.6.2.1.</span> <span class="nav-text">顺序有序表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E6%9C%89%E5%BA%8F%E8%A1%A8"><span class="nav-number">1.2.6.2.2.</span> <span class="nav-text">链式有序表</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">1.3.</span> <span class="nav-text">栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">定义和特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.2.</span> <span class="nav-text">栈的表示和操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">顺序栈</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="nav-number">1.3.2.1.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A5%E6%A0%88"><span class="nav-number">1.3.2.1.2.</span> <span class="nav-text">入栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BA%E6%A0%88"><span class="nav-number">1.3.2.1.3.</span> <span class="nav-text">出栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="nav-number">1.3.2.1.4.</span> <span class="nav-text">取栈顶元素</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%A0%88"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">链栈</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-3"><span class="nav-number">1.3.2.2.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A5%E6%A0%88-1"><span class="nav-number">1.3.2.2.2.</span> <span class="nav-text">入栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BA%E6%A0%88-1"><span class="nav-number">1.3.2.2.3.</span> <span class="nav-text">出栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0-1"><span class="nav-number">1.3.2.2.4.</span> <span class="nav-text">取栈顶元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92"><span class="nav-number">1.3.3.</span> <span class="nav-text">栈与递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.4.</span> <span class="nav-text">队列的表示和操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">循环队列——队列的顺序表示和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-4"><span class="nav-number">1.3.4.1.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B1%82%E9%98%9F%E5%88%97%E9%95%BF%E5%BA%A6"><span class="nav-number">1.3.4.1.2.</span> <span class="nav-text">求队列长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A5%E9%98%9F"><span class="nav-number">1.3.4.1.3.</span> <span class="nav-text">入队</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BA%E9%98%9F"><span class="nav-number">1.3.4.1.4.</span> <span class="nav-text">出队</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%96%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0"><span class="nav-number">1.3.4.1.5.</span> <span class="nav-text">取队头元素</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E9%98%9F%E2%80%94%E2%80%94%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">链队——队列的链式表示和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-5"><span class="nav-number">1.3.4.2.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A5%E9%98%9F-1"><span class="nav-number">1.3.4.2.2.</span> <span class="nav-text">入队</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BA%E9%98%9F-1"><span class="nav-number">1.3.4.2.3.</span> <span class="nav-text">出队</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%96%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0-1"><span class="nav-number">1.3.4.2.4.</span> <span class="nav-text">取队头元素</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-number">1.4.</span> <span class="nav-text">串、数组和广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2"><span class="nav-number">1.4.1.</span> <span class="nav-text">串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">抽象类型定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-1"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-number">1.4.1.2.1.</span> <span class="nav-text">顺序存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-number">1.4.1.2.2.</span> <span class="nav-text">链式存储</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">模式匹配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BF-%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.1.3.1.</span> <span class="nav-text">BF 算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#KMP-%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.1.3.2.</span> <span class="nav-text">KMP 算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.4.2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89-1"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">类型定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8-1"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">顺序存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">特殊矩阵的压缩存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-number">1.4.3.</span> <span class="nav-text">广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-2"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%B4%E5%B0%BE%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.3.2.1.</span> <span class="nav-text">头尾链表的存储结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.3.2.2.</span> <span class="nav-text">扩展线性链表的存储结构</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.5.</span> <span class="nav-text">树和二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">基本术语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">抽象数据类型定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A8"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">二叉树性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.1.6.</span> <span class="nav-text">二叉树存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.1.6.1.</span> <span class="nav-text">顺序存储结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.1.6.2.</span> <span class="nav-text">链式存储结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.5.2.</span> <span class="nav-text">二叉树遍历和线索二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.5.2.1.1.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="nav-number">1.5.2.1.2.</span> <span class="nav-text">先序遍历的顺序创建二叉链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.5.2.1.3.</span> <span class="nav-text">复制二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6"><span class="nav-number">1.5.2.1.4.</span> <span class="nav-text">计算二叉树深度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">1.5.2.1.5.</span> <span class="nav-text">统计二叉树中结点的个数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">线索二叉树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="nav-number">1.5.3.</span> <span class="nav-text">树和森林</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">1.5.3.1.1.</span> <span class="nav-text">双亲表示法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">1.5.3.1.2.</span> <span class="nav-text">孩子表示法</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Augists"
      src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/2CCC8E38-15C8-4A70-A836-2DC4D988DD4E_1_105_c.jpeg">
  <p class="site-author-name" itemprop="name">Augists</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">171</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://augists.top/subscribe" title="Subscribe → https:&#x2F;&#x2F;augists.top&#x2F;subscribe"><i class="fab fa-mailchimp fa-fw"></i>Subscribe</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/Augists" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Augists" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:awzyc2010@163.com" title="E-Mail → mailto:awzyc2010@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/484868244" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;484868244" rel="noopener" target="_blank"><i class="fa fa-tv fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://t.me/Augists" title="Telegram → https:&#x2F;&#x2F;t.me&#x2F;Augists" rel="noopener" target="_blank"><i class="fab fa-telegram fa-fw"></i>Telegram</a>
      </span>
  </div>

<a href="https://www.foreverblog.cn/go.html" target="_blank"> <img src="https://img.foreverblog.cn/wormhole_2.gif" alt="" style="width:auto;height:32px;" title="穿梭虫洞-随机访问十年之约友链博客"></a>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Augists</span>
</div>
  <div class="powered-by">
    <!--
    <i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
      Click Number:<span id="busuanzi_value_site_pv"></span>次
    </span>Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
    -->
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


  <!-- TODO -->
  <!-- 动态线条 -->
  <!--  -->

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"scale":1,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":280,"height":300},"mobile":{"show":true,"scale":0.5},"log":false,"tagMode":false});</script></body>
</html>

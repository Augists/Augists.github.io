<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/32.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16.ico">
  <link rel="mask-icon" href="/images/32.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"augists.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

<script>
  (function() {
    if ('') {
      if (prompt('Please input password') !== '') {
        alert('Wrong password! ');
        history.back();
      }
    }
  })();
</script>

  <meta name="description" content="Base on Copyright (c) DingsoulLink: https:&#x2F;&#x2F;dingiso.github.io&#x2F;2021&#x2F;03&#x2F;13&#x2F;UNIX%20%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%A4%8D%E4%B9%A0&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="Unix Network Programming Review">
<meta property="og:url" content="https://augists.top/NOTES/COURSES/Advanced_C/Unix-Network-Programming-Review/index.html">
<meta property="og:site_name" content="Augists-ZDCZ">
<meta property="og:description" content="Base on Copyright (c) DingsoulLink: https:&#x2F;&#x2F;dingiso.github.io&#x2F;2021&#x2F;03&#x2F;13&#x2F;UNIX%20%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%A4%8D%E4%B9%A0&#x2F;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2021/12/24/k7NsibMYlA4BnCG.jpg">
<meta property="og:image" content="https://s2.loli.net/2021/12/24/1Qs5ucmSPpXRVaD.jpg">
<meta property="og:image" content="https://s2.loli.net/2021/12/24/gFw2hGWOmPx1Mas.jpg">
<meta property="og:image" content="https://s2.loli.net/2021/12/24/xACoPEYT3g4prwD.jpg">
<meta property="og:image" content="https://s2.loli.net/2021/12/24/NBrtk7uoz5AKxlc.jpg">
<meta property="article:published_time" content="2021-12-16T07:52:12.000Z">
<meta property="article:modified_time" content="2021-12-26T16:07:58.299Z">
<meta property="article:author" content="Augists">
<meta property="article:tag" content="NOTE">
<meta property="article:tag" content="SHARING">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2021/12/24/k7NsibMYlA4BnCG.jpg">

<link rel="canonical" href="https://augists.top/NOTES/COURSES/Advanced_C/Unix-Network-Programming-Review/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Unix Network Programming Review | Augists-ZDCZ</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Augists-ZDCZ" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

	<!-- github icon -->
	<a target="_blank" rel="noopener" href="https://github.com/Augists" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Augists-ZDCZ</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">LESS is MORE</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-gallery">

    <a href="/gallery/" rel="section"><i class="fas fa-images fa-fw"></i>Gallery</a>

  </li>
        <li class="menu-item menu-item-f-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>F-links</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://augists.top/NOTES/COURSES/Advanced_C/Unix-Network-Programming-Review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/2CCC8E38-15C8-4A70-A836-2DC4D988DD4E_1_105_c.jpeg">
      <meta itemprop="name" content="Augists">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Augists-ZDCZ">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Unix Network Programming Review
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-16 15:52:12" itemprop="dateCreated datePublished" datetime="2021-12-16T15:52:12+08:00">2021-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-27 00:07:58" itemprop="dateModified" datetime="2021-12-27T00:07:58+08:00">2021-12-27</time>
              </span>

          
            <div class="post-description">Base on Copyright (c) Dingsoul<br>Link: https://dingiso.github.io/2021/03/13/UNIX%20%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%A4%8D%E4%B9%A0/</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <div class="note warning">
            <p>大小端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">union</span> un</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">short</span> a;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">  &#125;u;</span><br><span class="line"></span><br><span class="line">  u.a = <span class="number">0x0102</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(u.b[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; u.b[<span class="number">1</span>] == <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;big endian&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(u.b[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; u.b[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;small endian&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>intro/daytimetcpcli.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd, n;</span><br><span class="line">  <span class="keyword">char</span> recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;usage: a.out &lt;IPaddress&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = htons(<span class="number">13</span>);</span><br><span class="line">  <span class="keyword">if</span> (inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;inet_pton error for %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (connect(sockfd, (SA *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( (n = read(sockfd, recvline, MAXLINE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    recvline[n] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>) == EOF)</span><br><span class="line">      err_sys(<span class="string">&quot;fputs error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>intro/daytimetcpsrv.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">  <span class="keyword">char</span> buff[MAXLINE];</span><br><span class="line">  <span class="keyword">time_t</span> ticks;</span><br><span class="line"></span><br><span class="line">  listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  bzeros(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  servaddr.sin_port = htons(<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">  Bind(listenfd, (SA *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">  Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">    connfd = Accept(listenfd, (SA *) <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    ticks = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(buff, <span class="keyword">sizeof</span>(buff), <span class="string">&quot;%.24s\r\n&quot;</span>, ctime(&amp;ticks));</span><br><span class="line">    Write(connfd, buff, <span class="built_in">strlen</span>(buff));</span><br><span class="line"></span><br><span class="line">    Close(connfd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Concurrent Server</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> listenfd, connfd;</span><br><span class="line"></span><br><span class="line">listenfd = Socket ( ... );</span><br><span class="line"></span><br><span class="line">Bind(listenfd, ... );</span><br><span class="line">Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">  connfd = Accept(listenfd, ... );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (pid = Fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">    Close(listenfd);  <span class="comment">/* child closes listening socket */</span></span><br><span class="line">    doit(connfd);     <span class="comment">/* process the request */</span></span><br><span class="line">    Close(connfd);    <span class="comment">/* done with this client */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);          <span class="comment">/* child terminates */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   Close(connfd);     <span class="comment">/* parent close connected socket */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>TCP echo server<br><code>tcpdiserv/tcpserv01.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_echo</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> n;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">  <span class="keyword">while</span> ( (n = read(sockfd, buf, MAXLINE)) &gt; <span class="number">0</span>)</span><br><span class="line">    Writen(sockfd, buf, n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">    <span class="keyword">goto</span> again;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;str_echo: read error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">  <span class="keyword">pid_t</span> childpid;</span><br><span class="line">  <span class="keyword">socklen_t</span> clilen;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  listenfd = Socket (AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  servaddr.sin_port(SERV_PORT);</span><br><span class="line"></span><br><span class="line">  Bind(listenfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; ; )</span><br><span class="line">  &#123;</span><br><span class="line">    clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (childpid = fork()) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      Close(listenfd);</span><br><span class="line">      str_echo(connfd);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(connfd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tcpcliserv/tcpcli01.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    Writen(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Readline(sockfd, recvline, MAXLINE) == <span class="number">0</span>)</span><br><span class="line">      err_quit(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;usage: tcpcli &lt;IPaddress&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  sockfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">  Inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">  Connect(sockfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">  str_cli(<span class="built_in">stdin</span>, sockfd);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>UDP echo server<br><code>udpcliserv/udpserv01.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dg_echo</span><span class="params">(<span class="keyword">int</span> sockfd, SA *pcliaddr, <span class="keyword">socklen_t</span> clilen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">socklen_t</span> len;</span><br><span class="line">  <span class="keyword">char</span> mesg[MAXLINE];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; ; )</span><br><span class="line">  &#123;</span><br><span class="line">    len = clilen;</span><br><span class="line">    n = Recvfrom(sockfd, mesg, MAXLINE, <span class="number">0</span>, pcliaddr, &amp;len);</span><br><span class="line">    Sendto(sockfd, mesg, n, <span class="number">0</span>, pcliaddr, len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  sockfd = Socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">  Bind(sockfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">  dg_echo(sockfd, (SA *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UDP echo client<br><code>udpcliserv/udpcli01.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&quot;unp.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dg_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd, <span class="keyword">const</span> SA *pservaddr, <span class="keyword">socklen_t</span> servlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    Sendto(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>, pservaddr, servlen);</span><br><span class="line"></span><br><span class="line">    n = Recvfrom(sockfd, recvline, MAXLINE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    recvline[n] = <span class="number">0</span>;</span><br><span class="line">    Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;usage: udpcli &lt;IPaddress&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servadr.sin_port = htons(SERV_PORT);</span><br><span class="line">  Inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">  sockfd = Socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  dg_cli(<span class="built_in">stdin</span>, sockfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>信号处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用:Signal(SIGCHID,sig_chld);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_chld</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> stat;   <span class="comment">//value-result para</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>waitpid 可以通过指定 pid，指定终止某个子进程，wait 不能</li><li>在没有已经终止的子进程时，waitpid 可以不阻塞，但 wait 会阻塞，直到正在执行的子进程终止。</li></ul><hr><ul><li>解释datalink access，写出一个datalink access的实现<ul><li>操作系统为应用程序提供访问数据链路层的功能，这种功能可提供如下能力:<ul><li>能够监视由数据链路层接收的分组</li><li>能够作为普通应用进程而不是内核的一部分运行某些程序，例如: RARP<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL));</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><hr><ul><li>写出重启被中断的accept函数程序片段<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">  clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">  <span class="keyword">if</span> (connfd = accept(listenfd, (SA *)&amp;cliaddr, &amp;clilen) &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      err_sys(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>TCP echo 程序如何区分服务器进程终止和服务器崩溃<ul><li>进程终止: 客户端收到一个 FIN 并返回一个 ACK，但客户进程此时处于 fgets 调用的阻塞中，等待从客户端接收到一行文本。(此时客户端并不知道服务器子进程已经终止，只是单纯的接收到了一个 FIN) 而后，我们在客户上再键入一行文本。<code>str_cli</code> 调用 writen 发送数据给服务子进程，但由于服务子进程已经关闭，于是发送一个RST。我们客户端 readline 时若先收到第二步中的 FIN，则立即返回 0，如果先接收到 RST，则返回一个 <code>ECONNRESET</code> (对方复位连接错误)</li><li>服务器崩溃: 在客户端上键入一行文本，由 writen 写入内核。writen 成功返回后，客户随后阻塞于 readline 调用，客户端持续重传数据分节，试图从服务器上接收一个 ACK。然而服务器已崩坏，没有任何响应，最终 readline 调用上返回一个错误。如果是主机崩溃，则返回超时 <code>ETIMEOUT</code></li><li>进程终止: 服务器发送 FIN</li><li>崩溃: 服务器不会在已有网络上发送任何信号</li></ul></li></ul><hr><ul><li><code>fork()</code> 和 <code>exec()</code><ul><li>fork<ul><li>子进程复制父进程的所有进程内存到其内存地址空间。父，子进程的数据段，堆栈段和代码段完全相同</li><li>子进程拥有自己的进程ID</li></ul></li><li>exec<ul><li>进程调用 <code>exec()</code> 后，将在同一块进程内存里用一个新程序来代替调用 <code>exec()</code> 的那个进程，当前进程的“数据段”，“堆栈段”和“代码段”被新程序改写</li><li>新程序会保持调用 <code>exec()</code> 进程的 ID 不变</li></ul></li></ul></li></ul><hr><ul><li>原始套接字提供的三种UDP/TCP不具备的特点<ul><li>读写ICMPv4，ICMPv6，IGMPv4分组</li><li>读写内核不处理其协议字段的IPv4数据报</li><li>使用 <code>IP_HDRINCL</code> 套接字选项自行构造IPv4首部</li></ul></li></ul><hr><ul><li>defunct<ul><li>进程所谓的“僵死”状态。一个子进程结束了，但是它的父进程并没有 wait/waitpid 它，则它的状态是 defunct，进程早已死亡，但仍占有一个 pid</li></ul></li></ul><hr><ul><li>traceroute<ul><li>原理是利用了IPv4的TTL字段或IPv6的跳限字段，一开始设置为1，然后中间节点会返 回一个ICMP”time exceeded in transmit”(传输中超时)错误，接着逐渐增大TTL，从而逐 步确定下一跳路由地址。直至目的节点返回一个ICMP”port unreachable”(端口不可达)错 误，则表示到达目的节点(这要求目的节点没有在该端口上开启服务，即发送ICMP包时，目 的端口号应该选择一个未被目的主机使用的端口号 ==&gt; traceroute选择了一个大于30000值 作为目的端口号，因为UDP协议要求端口号必须小于30000，所以目的主机如果接收到必然 会会一个ICMP端口不可达错误)。</li><li>tracert 有一个固定的时间等待响应(ICMP TTL到期消息)。如果这个时间过了，它将打印出一系列的<code>*</code>号表明：在这个路径上，这个设备不能在给定的时间内发出ICMP TTL到期消息的响应。然后，Tracert给TTL记数器加1，继续进行</li></ul></li></ul><hr><p>setsockopt 和 getsockopt</p><table><thead><tr><th>level</th><th>optname</th><th>description</th></tr></thead><tbody><tr><td>SO_SOCKET</td><td>SO_KEEPALIVE</td><td>周期性测试连接是否还存在</td></tr><tr><td>SO_SOCKET</td><td>SO_LINGER</td><td>若有数据待发送则延迟关闭</td></tr><tr><td>IPPROTO_IP</td><td>IP_HDRINCL</td><td>随数据包含的IP首部</td></tr><tr><td>IPPROTO_IP</td><td>IP_TTL</td><td>Time to Live</td></tr><tr><td>IPPROTO_TCP</td><td>TCP_MAXSEG</td><td>TCP最大报文大小</td></tr><tr><td>IPPROTO_TCP</td><td>TCP_NODELAY</td><td>禁止nagle算法</td></tr></tbody></table><hr><h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><p>考著名的人物：</p><ul><li>K&amp;R: Kernighan 和 Ritchie</li><li>c语言作者，unix 作者: Ken Thompson 和 Dennis M. Ritchie</li><li>GNU 创建者/Emacs 作者: Richard Matthew Stallman </li><li>linux 作者: Linus Benedict Torvalds</li><li>vim 作者: Bram Moolenaar</li><li>Tex 作者: Donald Knuth 高德纳</li></ul><h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><p>TCP 状态转换图 ， 2.9 常用的Port Number ，2.10 Concurrent Server ， 2.12 services</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">21端口：FTP 文件传输服务</span><br><span class="line">22端口：SSH 端口</span><br><span class="line">23端口：TELNET 终端仿真服务</span><br><span class="line">25端口：SMTP 简单邮件传输服务</span><br><span class="line">53端口：DNS 域名解析服务</span><br><span class="line">80端口：HTTP 超文本传输服务</span><br><span class="line">110端口：POP3 “邮局协议版本3”使用的端口</span><br><span class="line">443端口：HTTPS 加密的超文本传输服务</span><br><span class="line">**********************************</span><br><span class="line">1433端口：MS SQL*SERVER数据库 默认端口号</span><br><span class="line">1521端口：Oracle数据库服务</span><br><span class="line">1863端口：MSN Messenger的文件传输功能所使用的端口</span><br><span class="line">3306端口：MYSQL 默认端口号</span><br><span class="line">3389端口：Microsoft RDP 微软远程桌面使用的端口</span><br><span class="line">5631端口：Symantec pcAnywhere 远程控制数据传输时使用的端口</span><br><span class="line">5632端口：Symantec pcAnywhere 主控端扫描被控端时使用的端口</span><br><span class="line">5000端口：MS SQL Server使用的端口</span><br><span class="line">8000端口：腾讯QQ</span><br></pre></td></tr></table></figure><h2 id="Chapter-3，4，5，6"><a href="#Chapter-3，4，5，6" class="headerlink" title="Chapter 3，4，5，6"></a>Chapter 3，4，5，6</h2><h3 id="Socket-Address-Structures"><a href="#Socket-Address-Structures" class="headerlink" title="Socket Address Structures"></a>Socket Address Structures</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span>         s_addr;           <span class="comment">/* 32-bit IPv4 address */</span></span><br><span class="line">                                <span class="comment">/* network byte ordered */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         sin_len;         <span class="comment">/* length of structure (16) */</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>       sin_family;   <span class="comment">/* AF_INET */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>            sin_port;       <span class="comment">/* 16-bit TCP or UDP port number */</span></span><br><span class="line">                                                <span class="comment">/* network byte ordered */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>        <span class="comment">/* 32-bit IPv4 address */</span></span><br><span class="line">                                                <span class="comment">/* network byte ordered */</span></span><br><span class="line">    <span class="keyword">char</span>                   sin_zero[<span class="number">8</span>];  <span class="comment">/* unused */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IPV4</span></span><br><span class="line">inet_addr inet_ntoa</span><br><span class="line"><span class="comment">// IPV4/6</span></span><br><span class="line">inet_pton inet_ntop</span><br></pre></td></tr></table></figure><ul><li>in_addr 是结构的原因是早期将其定义为 union 方便A，B，C类地址的访问</li><li>sin_zero 置0</li></ul><h3 id="Generic-socket-address-structure"><a href="#Generic-socket-address-structure" class="headerlink" title="Generic socket address structure"></a>Generic socket address structure</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>       sa_len;</span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;      <span class="comment">/* address family: AF_xxx value */</span></span><br><span class="line">    <span class="keyword">char</span>             sa_data[<span class="number">14</span>]; <span class="comment">/* protocol-specific address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span>, struct sockaddr *, <span class="keyword">socklen_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span>    <span class="comment">/* IPv4 socket address structure */</span></span><br><span class="line"><span class="comment">/* fill in serv&#123;&#125; */</span></span><br><span class="line">bind(sockfd, (struct sockaddr *) &amp;serv, <span class="keyword">sizeof</span>(serv));</span><br></pre></td></tr></table></figure><p>用于定义函数时适配各种不同类型的地址结构，</p><p>若不转换，编译器报 <code>warning: passing arg 2 of &#39;bind&#39; from incompatible pointer type</code></p><h3 id="Sockaddr-in6"><a href="#Sockaddr-in6" class="headerlink" title="Sockaddr_in6"></a>Sockaddr_in6</h3><p>128-bits ipv6 地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>     s6_addr[<span class="number">16</span>];  <span class="comment">/* 128-bit IPv6 address */</span></span><br><span class="line">                                        <span class="comment">/* network byte ordered */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIN6_LEN                 <span class="comment">/* required for compile-time tests */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>             sin6_len;           <span class="comment">/* length of this struct (28) */</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>       sin6_family;       <span class="comment">/* AF_INET6 */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>           sin6_port;           <span class="comment">/* transport layer port# */</span></span><br><span class="line">                                                    <span class="comment">/* network byte ordered */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>             sin6_flowinfo;  <span class="comment">/* flow information, undefined */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>           <span class="comment">/* IPv6 address */</span></span><br><span class="line">                                                    <span class="comment">/* network byte ordered */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>             sin6_scope_id;  <span class="comment">/* set of interfaces for a scope */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>The <code>sin6_flowinfo</code> member is divided into two fields:<ul><li>The low-order 20 bits are the flow label</li><li>The high-order 12 bits are reserved</li></ul></li></ul><h3 id="Value-Result"><a href="#Value-Result" class="headerlink" title="Value-Result"></a>Value-Result</h3><p>当我们把 <code>SA*</code> 从用户进程传入内核时长度作为值 value ，内核处理完返回时结构的大小可能会改变，因此长度作为一个结果 result 传回 , 引用是因为需要函数内部去赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户进程 =&gt; 内核</span></span><br><span class="line"><span class="comment">// bind connect sendto </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* fill in serv&#123;&#125; */</span></span><br><span class="line">connect(sockfd, (SA *) &amp;serv, <span class="keyword">sizeof</span>(serv));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核 =&gt; 用户进程</span></span><br><span class="line"><span class="comment">// accept recvfrom getsockname getpeername </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cli</span>;</span> <span class="comment">/* Unix domain */</span></span><br><span class="line"><span class="keyword">socklen_t</span> len;</span><br><span class="line"></span><br><span class="line">len = <span class="keyword">sizeof</span>(cli);           <span class="comment">/* len is a value */</span></span><br><span class="line">getpeername(unixfd, (SA *) &amp;cli, &amp;len);</span><br><span class="line"><span class="comment">/* len may have changed */</span></span><br></pre></td></tr></table></figure><h3 id="字节序-Byte-Ordering"><a href="#字节序-Byte-Ordering" class="headerlink" title="字节序 Byte Ordering"></a>字节序 Byte Ordering</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字节序转换函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> host16bitvalue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> host32bitvalue)</span></span>;</span><br><span class="line">                                     Both <span class="keyword">return</span>: value in network byte order</span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> net16bitvalue);</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> net32bitvalue)</span></span>;</span><br><span class="line">                                    Both <span class="keyword">return</span>: value in host byte order</span><br></pre></td></tr></table></figure><p>n - network , h - host , s - short 16 位, l - long 32 位</p><h3 id="Byte-Manipulation"><a href="#Byte-Manipulation" class="headerlink" title="Byte Manipulation"></a>Byte Manipulation</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bcopy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">void</span> *dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">bcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1, <span class="keyword">const</span> <span class="keyword">void</span> *ptr2, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line">                                    Returns: <span class="number">0</span> <span class="keyword">if</span> equal, nonzero <span class="keyword">if</span> unequal</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">int</span> c, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1, <span class="keyword">const</span> <span class="keyword">void</span> *ptr2, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line">                        Returns: <span class="number">0</span> <span class="keyword">if</span> equal, &lt;<span class="number">0</span> <span class="keyword">or</span> &gt;<span class="number">0</span> <span class="function"><span class="keyword">if</span> <span class="title">unequal</span> <span class="params">(see text)</span></span></span><br></pre></td></tr></table></figure><h3 id="地址转换函数"><a href="#地址转换函数" class="headerlink" title="地址转换函数"></a>地址转换函数</h3><h4 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// converts the C character string pointed to by strptr into</span></span><br><span class="line"><span class="comment">// its 32-bit binary network byte ordered value, </span></span><br><span class="line"><span class="comment">// which is stored through the pointer addrptr </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *strptr, struct in_addr *addrptr)</span></span>;</span><br><span class="line">                    Returns: <span class="number">1</span> <span class="keyword">if</span> <span class="built_in">string</span> was valid, <span class="number">0</span> on error</span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *strptr)</span></span>;</span><br><span class="line">                    Returns: <span class="number">32</span>-bit binary network byte ordered IPv4 address; INADDR_NONE <span class="keyword">if</span> error</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr inaddr)</span></span>;</span><br><span class="line">                    Returns: pointer to dotted-decimal <span class="built_in">string</span></span><br></pre></td></tr></table></figure><ul><li><p><code>inet_aton</code> 将字符串 <code>strptr</code> 转换为 32 比特二进制网络字节序地址 <code>addrptr</code></p></li><li><p><code>inet_addr</code> 作用同上，出错返回 <code>INADDR_NONE</code> 255.255.255.255, 所以不能处理该地址（被废弃）</p></li><li><p><code>inet_ntoa</code> 32bit 网络字节序到点分十进制 IPV4 字符串，储存在静态内存，不可重入</p></li></ul><h4 id="IPV4-6"><a href="#IPV4-6" class="headerlink" title="IPV4/6"></a>IPV4/6</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> *strptr, <span class="keyword">void</span> *addrptr)</span></span>;</span><br><span class="line">                                Returns: <span class="number">1</span> <span class="keyword">if</span> OK, <span class="number">0</span> <span class="keyword">if</span> input <span class="keyword">not</span> a valid presentation format, −<span class="number">1</span> on error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">void</span> *addrptr, <span class="keyword">char</span> *strptr, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line">                                Returns: pointer to result <span class="keyword">if</span> OK, <span class="literal">NULL</span> on error</span><br></pre></td></tr></table></figure><p>p - presentation , n - numeric</p><ul><li><code>family</code>: <code>AF_INET</code> / <code>AF_INET6</code> 不支持 errno= <code>EAFNOSUPPORT</code></li><li><code>inet_pton</code>: 字符串 strptr 转换为 addrptr 二进制地址结果</li><li><code>inet_ntop</code>: 相反，len 位 strptr 大小，防止溢出 - len太小，返回空指针 errno= <code>ENOSPC</code></li></ul><h3 id="读写函数"><a href="#读写函数" class="headerlink" title="读写函数"></a>读写函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writen</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readline</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> maxlen)</span></span>;</span><br><span class="line">                    All <span class="keyword">return</span>: number of bytes read <span class="keyword">or</span> written, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>readline 每次读一个字符，极端地慢</p><h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><p>基本 TCP 套接字编程</p><h3 id="Socket-函数"><a href="#Socket-函数" class="headerlink" title="Socket 函数"></a>Socket 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">                Returns: non-negative descriptor <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>AF_INET</th><th>AF_INET6</th><th>AF_LOCAL</th><th>AF_ROUTE</th><th>AF_KEY</th></tr></thead><tbody><tr><td>SOCK_STREAM</td><td>TCP SCTP</td><td>TCP SCTP</td><td>YES</td><td></td><td></td></tr><tr><td>SOCK_DGRAM</td><td>UDP</td><td>UDP</td><td>YES</td><td></td><td></td></tr><tr><td>SOCK_SEQPACKET</td><td>SCTP</td><td>SCTP</td><td>YES</td><td></td><td></td></tr><tr><td>SOCK_RAW</td><td>IPV4</td><td>IPV6</td><td></td><td>YES</td><td>YES</td></tr></tbody></table><h3 id="Connect-函数"><a href="#Connect-函数" class="headerlink" title="Connect 函数"></a>Connect 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">                                    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>client 用于与 server 连接，内核会自己选择临时端口</p><ul><li>75 s 无响应后返回 <code>ETIMEDOUT</code></li><li>若相应 RST 则马上返回 <code>ECONNREFUSED</code> - 指定端口没有等待连接</li><li>目的不可达，返回 <code>EHOSTUNREACH</code>, <code>ENETUNREACH</code></li></ul><p>错误</p><ul><li>如果给不存在的机器发送，因为没有 ARP reply , <code>ETIMEOUT</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect error: Connection timed out</span><br></pre></td></tr></table></figure><ul><li>如果给未运行 server 的机器发送，收到 RST ，<code>ECONNREFUSED</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect error: Connection refused</span><br></pre></td></tr></table></figure><ul><li>给不可达发送， 收到 ICMP 不可达错误，<code>EHOSTUNREACH</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect error: No route to host</span><br></pre></td></tr></table></figure><p>每次 connect 失败后，都需要关闭 sockfd 重新调用 socket 函数</p><h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind 函数"></a>bind 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">                                    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>32b ipv4 / 128b ipv6 + 16b TCP/UDP port number</p><p>Servers 会在启动时调用 bind 端口（程序定义） ，若没有则当调用 connect 或 listen 时，内核会选择一个临时端口 或 根据 SYN 的目的地址</p><p>Client 通常不会 bind 而是 connect 时由内核根据路径选择</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>wildcard 通配符</p><p>ipv4 : <code>INADDR_ANY</code> 0.0.0.0，内核等到TCP连接，UDP报文发送后选择ip地址</p><p>ipv6 : <code>in6addr_any</code> 由系统预先分配并置为 <code>IN6ADDR_ANY_INIT</code></p><p>RPC 例外，会通过 端口映射器注册</p><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p><code>EADDRINUSE</code> : <code>Address already in use</code> 地址已使用</p><h3 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen 函数"></a>listen 函数</h3><p>Server : convert unconnected socket into a passive socket</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line">                    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p><code>backlog</code> : 内核队列中排队的最大连接数</p><p>调用时间： socket bind 后， accept 前</p><p>为 listening socket 保持两个队列</p><ul><li><code>incomplete connection queue</code> 未完成连接队列，未完成握手，<code>SYN_RCVD</code> 态</li><li><code>completed connection queue</code> 已完成连接队列，完成握手，<code>ESTABLISHED</code> 态</li></ul><p>两队之和不超过 backlog</p><h3 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept 函数"></a>accept 函数</h3><p>返回已完成连接队列队头，如果为空，进程睡眠</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *cliaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">                        Returns: non-negative descriptor <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><ul><li><code>sockfd</code> : listening socket 监听</li><li><code>return</code> : connected socket 已连接</li><li><code>cliaddr</code> &amp; <code>addrlen</code> ：对端的地址和长度</li><li>一对多的关系，监听socket 保持打开，连接socket完成对一个客户的服务就关闭</li></ul><h4 id="bind-错误"><a href="#bind-错误" class="headerlink" title="bind 错误"></a>bind 错误</h4><ul><li>非超级用户：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> error: Permission denied</span><br></pre></td></tr></table></figure><h3 id="fork-和-exec-函数"><a href="#fork-和-exec-函数" class="headerlink" title="fork 和 exec 函数"></a>fork 和 exec 函数</h3><p>fork 是唯一生成新进程的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">            Returns: <span class="number">0</span> in child, process ID of child in parent, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><h3 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h3><p>父进程 listenfd 监听，子进程 connfd 负责接收数据和实际操作</p><h3 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line">                        Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>为了方便多个进程使用套接字，它是引用计数的。</p><p>内核会发完所有等待发送的数据，然后 TCP 连接终止过程</p><p>如果只想发送FIN，改用 <code>shutdown</code> 函数</p><h3 id="地址函数"><a href="#地址函数" class="headerlink" title="地址函数"></a>地址函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *localaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *peeraddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">                            Both <span class="keyword">return</span>: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>sock 本地，peer 连接对端</p><p>重点基本都要求掌握、5.13不要求掌握</p><p>6.9，6.20 不要求掌握</p><h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><h3 id="TCP-Echo-Server"><a href="#TCP-Echo-Server" class="headerlink" title="TCP Echo Server"></a>TCP Echo Server</h3><p>Port : 5000 - 49152</p><h3 id="Normal-Startup"><a href="#Normal-Startup" class="headerlink" title="Normal Startup"></a>Normal Startup</h3><p>server 阻塞在 accept （还未启动用户）</p><p>client 阻塞在 fgets 调用</p><p>连接</p><p>服务器阻塞在 read ，父进程阻塞在 accept</p><p>此时 三个进程 STAT 都是 S- sleeping - （已阻塞）</p><p>WCHAN 父进程 wait_for_connect , server tcp_data_wait , client - read_chan</p><h3 id="Normal-Termination"><a href="#Normal-Termination" class="headerlink" title="Normal Termination"></a>Normal Termination</h3><p>Client ： EOF 字符（Control+D) 终止服务器</p><p>客户端进入 <code>TIME_WAIT</code> 状态</p><h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><p><code>SIGKILL</code> &amp; <code>SIGSTOP</code> 不能被捕获</p><p>信号处理函数是一个仅有一个整数参数且不返回值的函数</p><h4 id="wait-amp-waitpid"><a href="#wait-amp-waitpid" class="headerlink" title="wait &amp; waitpid"></a>wait &amp; waitpid</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *statloc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line">                        Both <span class="keyword">return</span>: process ID <span class="keyword">if</span> OK, <span class="number">0</span> <span class="keyword">or</span> −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>处理已终止的子进程</p><ul><li>返回值： 已终止子进程的进程 ID 号，通过 statloc 指针返回的子进程终止状态（一个整数）</li><li>对于同种类型的信号，主机只会执行一次信号处理函数</li></ul><h4 id="accept-返回前连接中止"><a href="#accept-返回前连接中止" class="headerlink" title="accept 返回前连接中止"></a>accept 返回前连接中止</h4><p>connect 后，accept 前，客户端发送 RST 报文</p><p>POSIX : <code>ECONNABORTED</code> - <code>software caused connection abort</code></p><h4 id="服务器进程终止"><a href="#服务器进程终止" class="headerlink" title="服务器进程终止"></a>服务器进程终止</h4><p>服务器进程崩溃后，如果 client 不操作，会阻塞在 fgets，输入字符后，readline 因接收到 FIN 返回 0（EOF），client 返回 : <code>str_cli: server terminated prematurely</code> - 程序定义的并结束</p><p>如果先收到了 RST，会返回 <code>ECONNRESET</code> - <code>connection reset by peer</code></p><p>RST 会因为并没有与该客户端连接但是接收到该客户端发送的内容而被服务器发送</p><h4 id="服务器主机崩溃"><a href="#服务器主机崩溃" class="headerlink" title="服务器主机崩溃"></a>服务器主机崩溃</h4><p>同上面不同的是，服务器并不会有任何反应，会有以下两种情况：</p><ul><li>一直没有响应 <code>ETIMEOUT</code></li><li>中间路由器判断不可达，响应一个 <code>destination unreachable</code> 的 ICMP，返回的错误是 <code>EHOSTUNREACH</code> 或 <code>ENETUNREACH</code></li></ul><h4 id="服务器主机崩溃后重启"><a href="#服务器主机崩溃后重启" class="headerlink" title="服务器主机崩溃后重启"></a>服务器主机崩溃后重启</h4><p>当服务器主机崩溃后重启时，它的 TCP 丢失了崩溃前的所有连接信息，因此服务器 TCP 对于所收到的来自客户的数据分节响应以一个RST</p><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>服务器读入换行符，所搜索的只是换行符</p><p>二进制 : <code>sscanf</code> 转换到结构体 binary ，发送后，对方也用同样的结构体接收。</p><p>大小端不同 ， 同样 int 型长度不同，结构体的打包方式不同 都会导致负数不行，</p><p>解决方法： 发送 string ， 用 XDR（external data representation) 发送</p><h2 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h2><h3 id="I-O-Model"><a href="#I-O-Model" class="headerlink" title="I/O Model"></a>I/O Model</h3><p>分为两个部分：等待对端发送数据 ，将数据从内核拷贝到用户</p><ul><li>blocking: 调用接收函数后就一直等到两步都完成再返回</li></ul><p><img src="https://s2.loli.net/2021/12/24/k7NsibMYlA4BnCG.jpg" alt=""></p><ul><li>Nonblocking: 第一阶段不断循环 call，知道收到完整包</li></ul><p><img src="https://s2.loli.net/2021/12/24/1Qs5ucmSPpXRVaD.jpg" alt=""></p><ul><li>Multiplexing: 第一步调用 select，直到返回 readable，然后调用 recvfrom 完成第二步<ul><li>好处: 可以等待多个描述符</li></ul></li></ul><p><img src="https://s2.loli.net/2021/12/24/gFw2hGWOmPx1Mas.jpg" alt=""></p><ul><li>Signal-Driven: 调用后立即返回，signal handler 会在 data 准备好后发出信号，调用 recvfrom 完成第二步</li></ul><p><img src="https://s2.loli.net/2021/12/24/xACoPEYT3g4prwD.jpg" alt=""></p><ul><li>Asynchronous: 告知内核启动某个操作，并让内核在两步操作完成后通知我们</li></ul><p><img src="https://s2.loli.net/2021/12/24/NBrtk7uoz5AKxlc.jpg" alt=""></p><h3 id="select-函数"><a href="#select-函数" class="headerlink" title="select 函数"></a>select 函数</h3><p>告诉内核等待多个事件，有事件发生或 Timeout 后唤醒他</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br><span class="line">    Returns: positive count of ready descriptors, <span class="number">0</span> on timeout, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><ul><li><code>maxfdp1</code>: 待测试的最大描述符值 +1</li><li><code>set</code>: 告诉内核 what descriptors we are interested in ，不关心设为空，三个参数都是 value-result 类型的，调用时为关心的描述符的值，返回时指示哪些描述符已就绪<ul><li><code>readset</code>: Any of the descriptors in the readset are ready for reading</li><li><code>writeset</code>: Any of the descriptors in the writeset are ready for reading</li><li><code>exceptset</code>: Any of the descriptors in the exceptset have an exception condition pending</li></ul></li><li><code>timeout</code>: how long to wait - 信号中断 - 不准<ul><li>设置为空: 永远等待</li><li>值: 固定时间</li><li>0: 根本不等待- 轮询（polling）</li></ul></li><li><code>Returns</code>: 就绪的数目，timeout=0，error=-1</li><li>这是系统函数，descriptor 和 socket 无关，socket 可以 select 任意 descriptor</li><li>错误处理 - 不考</li></ul><h4 id="fd-set-数据结构"><a href="#fd-set-数据结构" class="headerlink" title="fd_set 数据结构"></a>fd_set 数据结构</h4><p>每一位代表一个描述符，每一bit为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;          <span class="comment">/* clear all bits in fdset */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">/* turn on the bit for fd in fdset */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">/* turn off the bit for fd in fdset */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">/* is the bit for fd on in fdset ? */</span></span><br></pre></td></tr></table></figure><ul><li>利用 <code>FD_ZERO</code> 进行初始化十分重要，因为是 value-result 值会变化</li><li><code>FD_SETSIZE</code>: 1024</li></ul><h4 id="读-ready-的条件"><a href="#读-ready-的条件" class="headerlink" title="读 ready 的条件"></a>读 ready 的条件</h4><ul><li>收到的数据高于 low-water 低水位了</li><li>连接关闭了，read 返回 0 （EOF）</li><li>是监听套接字，且有已完成的连接 ？</li><li>套接字有错误待处理，返回 -1 ， errno 设置成确切的错误条件</li></ul><h4 id="写-ready-的条件"><a href="#写-ready-的条件" class="headerlink" title="写 ready 的条件"></a>写 ready 的条件</h4><ul><li>已连接（udp不需要），可写空间超过 low-water</li><li>写半边关闭了 （有未完成发送的数据，要发送出去）</li><li>non-blocking connect 建立了连接或失败了</li><li>套接字有错误待处理，返回 -1 ， errno 设置成确切的错误条件</li></ul><h4 id="exceptiong-ready"><a href="#exceptiong-ready" class="headerlink" title="exceptiong ready"></a>exceptiong ready</h4><p>如果一个套接字存在带外数据或者仍处于带外标记，那么它有异常条件待处理</p><h3 id="str-cli"><a href="#str-cli" class="headerlink" title="str_cli"></a>str_cli</h3><p>阻塞在 select，将原本的待前后顺序的阻塞，变成同时的阻塞</p><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>给服务器发送一个FIN，告诉它我们已经完成了数据发送，但是 仍然保持套接字描述符打开以便读取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br><span class="line">                    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><ul><li>不动引用计数就激发 TCP 的正常连接终止序列</li><li>close 终止读和写两个方向的数据传送，shutdown 还可以继续读</li><li>三种可选项<ul><li><code>SHUT_RD</code>: 关闭连接的读这一半</li><li><code>SHUT_WR</code>: 关闭连接的写这一半</li><li><code>SHUT_RDWR</code>: 连接的读半部和写半部都关闭</li></ul></li></ul><h3 id="str-cli-pipeline版"><a href="#str-cli-pipeline版" class="headerlink" title="str_cli pipeline版"></a>str_cli pipeline版</h3><p>加入 shutdown，模拟先连续发送数据，关闭写半部，然后再连续接收返回数据的 pipeline 操作</p><h3 id="TCP-echo-程序-select-版"><a href="#TCP-echo-程序-select-版" class="headerlink" title="TCP echo 程序- select 版"></a>TCP echo 程序- select 版</h3><p>client 数组存储已连接 accept 描述符的值</p><p>省去了 fork 新进程的开销</p><p>rset 数组保存 0-stdin，1-stdout，2-stderr ，3–都是已连接描述符</p><ul><li>客户发送 FIN，4 变为可读 read 将返回 0。关闭该套接字并把 <code>client[0]</code> 的值置为 -1，把描述符集中描述符 4 的位设置为 0。注意，<strong>maxfd 的值没有改变</strong></li></ul><h2 id="Chapter-7"><a href="#Chapter-7" class="headerlink" title="Chapter 7"></a>Chapter 7</h2><h3 id="sockopt-函数"><a href="#sockopt-函数" class="headerlink" title="_sockopt 函数"></a>_sockopt 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line">                                    Both <span class="keyword">return</span>: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><ul><li>sockfd ： 打开的套接字描述符</li><li>level ：指代系统中解释该选项的代码</li><li>optval ：存储 option 的数据结构 - 是标志 0 为不启用，值为启用</li><li>optlen ：长度 - value-result</li></ul><p>sockopt :掌握 7.2 原理 - SO_LINGER / SO_KEEPALIVE / SO_DONTROUTE</p><h3 id="SO-KEEPALIVE"><a href="#SO-KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h3><p>保活</p><h3 id="SO-LINGER-？"><a href="#SO-LINGER-？" class="headerlink" title="SO_LINGER ？"></a>SO_LINGER ？</h3><p>关闭 close 时是否丢弃保留在套接字发送缓冲区中的任何数据，</p><p>设置正的延滞时间</p><h3 id="SO-DONTROUTE"><a href="#SO-DONTROUTE" class="headerlink" title="SO_DONTROUTE"></a>SO_DONTROUTE</h3><p>是否绕过下层协议的路由机制</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP : IP_HDRINCL / IP_TTL </span><br></pre></td></tr></table></figure><h3 id="IP-HDRINCL"><a href="#IP-HDRINCL" class="headerlink" title="IP_HDRINCL"></a>IP_HDRINCL</h3><p>设置了就需要自己构建IP头</p><h3 id="IP-TTL"><a href="#IP-TTL" class="headerlink" title="IP_TTL"></a>IP_TTL</h3><p>设置和获取系统用在从某个给定套接字的默认 TTL 值</p><h3 id="TCP-TCP-MAXSEG"><a href="#TCP-TCP-MAXSEG" class="headerlink" title="TCP : TCP_MAXSEG"></a>TCP : TCP_MAXSEG</h3><p>允许我们获取或设置TCP连接的最大分节大小</p><p>SYN中通告的MSS</p><h2 id="Chapter-8"><a href="#Chapter-8" class="headerlink" title="Chapter 8"></a>Chapter 8</h2><p>8.1 图，并发程序设计 - 重点注意区别</p><p><code>sendto()</code> <code>recvfrom()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct sockaddr *from, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> struct sockaddr *to, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">            Both <span class="keyword">return</span>: number of bytes read <span class="keyword">or</span> written <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>echo 程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="服务器进程未运行"><a href="#服务器进程未运行" class="headerlink" title="服务器进程未运行"></a>服务器进程未运行</h3><p>返回 ICMP 异步错误</p><p>sendto 成功返回仅表示接口输出队列中有存放数据报的空间</p><p>仅在进程已将其 UDP 套接字连接到一个对端后，这些异步错误才返回给进程</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><ul><li>不需要再指定目的 IP 和端口号</li><li>不用 recvfrom 用 read 就行</li><li>返回异步错误</li></ul><h2 id="Chapter-11"><a href="#Chapter-11" class="headerlink" title="Chapter 11"></a>Chapter 11</h2><p>简单前面部分 DNS 操作 11.3、11.4、11.5</p><p>使用 UDP 查询，如果答案太长，超出了 UDP 承载能力，换成 TCP</p><h3 id="gethostbyname"><a href="#gethostbyname" class="headerlink" title="gethostbyname"></a>gethostbyname</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *hostname)</span></span>;</span><br><span class="line">            Returns: non-null pointer <span class="keyword">if</span> OK, <span class="literal">NULL</span> on error with h_errno <span class="built_in">set</span></span><br></pre></td></tr></table></figure><p>只能返回 ipv4，getaddrinfo 能够处理 4 和 6</p><h3 id="gethostbyaddr"><a href="#gethostbyaddr" class="headerlink" title="gethostbyaddr"></a>gethostbyaddr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">socklen_t</span> len, <span class="keyword">int</span> family)</span></span>;</span><br><span class="line">            Returns: non-null pointer <span class="keyword">if</span> OK, <span class="literal">NULL</span> on error with h_errno <span class="built_in">set</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct servent *<span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *servname, <span class="keyword">const</span> <span class="keyword">char</span> *protoname)</span></span>;</span><br><span class="line">Returns: non-null pointer <span class="keyword">if</span> OK, <span class="literal">NULL</span> on erro</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct servent *<span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *protoname)</span></span>;</span><br><span class="line">Returns: non-null pointer <span class="keyword">if</span> OK, <span class="literal">NULL</span> on error</span><br></pre></td></tr></table></figure><h2 id="Part-3-Advanced-Sockets"><a href="#Part-3-Advanced-Sockets" class="headerlink" title="Part 3 Advanced Sockets"></a>Part 3 Advanced Sockets</h2><p>12，13，14，15 ，17，18.5,20,21,22,23,24，30，31不考 Daemon Process 了解一下</p><p>19 Introduction</p><p>特权 SA ， SADB</p><p>25 掌握，结合第 5 章看</p><p>26 掌握 基本概念，线程和进程区别</p><p>27 结合前面的 Options 一起看，简单看看。</p><p>28 重点掌握</p><p>读写ICMP，读写非内核处理的协议段的数据报，构建ip首部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sockfd = socket(AF_INET, SOCK_RAW, protocol)</span><br><span class="line"><span class="comment">// 例 ： protocol IPPROTO_ICMP</span></span><br><span class="line"><span class="comment">// 开启 IP_HDRINCL</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &amp;on, <span class="keyword">sizeof</span>(on)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 出错处理</span></span><br></pre></td></tr></table></figure><p>29 掌握 基本概念，如何抓包</p><p>libpcap 公开分组捕获函数库</p><p>A.3 C.1 netstat tcpdump</p><p>简答题（解释名词） ， 编程题（补充小的片段）上机+上课 ， 实验分析题（分析实验的结果）例如： 服务端没起来 报什么错误</p><p>最开始 那个 带函数的函数</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>P180，P165，LINGER 的意思是什么</p><p>ioctl 实现 sockopt 进行读写操作 - 了解功能</p><p>函数原型 ： 名字 + 参数</p><p>ping ， recvmsg 如果被中断 <code>EINTR</code>，continue 重新执行，函数重启</p><p>5.10 wait / waitpid 要求</p><p>server ， server host 情况</p><p>raw socket 适用于什么情况 routing 、key</p><p>29 introduction</p><p>信号处理函数 5 章 signal handler</p><p>signal driven 不要求</p><p>tcp函数的顺序图</p>
          </div>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Augists
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://augists.top/NOTES/COURSES/Advanced_C/Unix-Network-Programming-Review/" title="Unix Network Programming Review">https://augists.top/NOTES/COURSES/Advanced_C/Unix-Network-Programming-Review/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/Augists">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="http://wpa.qq.com/msgrd?v=3&uin=2057240784&site=qq&menu=yes">
            <span class="icon">
              <i class="fab fa-qq"></i>
            </span>

            <span class="label">QQ</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://github.com/Augists">
            <span class="icon">
              <i class="fab fa-github"></i>
            </span>

            <span class="label">GitHub</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://gitee.com/Augists">
            <span class="icon">
              <i class="fab fa-git-alt"></i>
            </span>

            <span class="label">Gitee</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://blog.csdn.net/qq_45910536">
            <span class="icon">
              <i class="fab fa-cuttlefish"></i>
            </span>

            <span class="label">CSDN</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://augists.top/subscribe">
            <span class="icon">
              <i class="fab fa-mailchimp"></i>
            </span>

            <span class="label">Subscribe</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/NOTE/" rel="tag"><i class="fa fa-tag"></i> NOTE</a>
              <a href="/tags/SHARING/" rel="tag"><i class="fa fa-tag"></i> SHARING</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/NOTES/CODE_LANGUAGE/GOLANG/Slice-Growth-in-Golang/" rel="prev" title="Slice Growth in Golang">
      <i class="fa fa-chevron-left"></i> Slice Growth in Golang
    </a></div>
      <div class="post-nav-item">
    <a href="/NOTES/COURSES/Software_Engineering/Software-Engineering-Review/" rel="next" title="Software Engineering Review">
      Software Engineering Review <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="Augists/comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-1"><span class="nav-number">1.</span> <span class="nav-text">Chapter 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-2"><span class="nav-number">2.</span> <span class="nav-text">Chapter 2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-3%EF%BC%8C4%EF%BC%8C5%EF%BC%8C6"><span class="nav-number">3.</span> <span class="nav-text">Chapter 3，4，5，6</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket-Address-Structures"><span class="nav-number">3.1.</span> <span class="nav-text">Socket Address Structures</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Generic-socket-address-structure"><span class="nav-number">3.2.</span> <span class="nav-text">Generic socket address structure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sockaddr-in6"><span class="nav-number">3.3.</span> <span class="nav-text">Sockaddr_in6</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Value-Result"><span class="nav-number">3.4.</span> <span class="nav-text">Value-Result</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F-Byte-Ordering"><span class="nav-number">3.5.</span> <span class="nav-text">字节序 Byte Ordering</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Byte-Manipulation"><span class="nav-number">3.6.</span> <span class="nav-text">Byte Manipulation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-number">3.7.</span> <span class="nav-text">地址转换函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IPV4"><span class="nav-number">3.7.1.</span> <span class="nav-text">IPV4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IPV4-6"><span class="nav-number">3.7.2.</span> <span class="nav-text">IPV4&#x2F;6</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0"><span class="nav-number">3.8.</span> <span class="nav-text">读写函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-4"><span class="nav-number">4.</span> <span class="nav-text">Chapter 4</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket-%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">Socket 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Connect-%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">Connect 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bind-%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text">bind 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="nav-number">4.3.1.</span> <span class="nav-text">IP地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF"><span class="nav-number">4.3.2.</span> <span class="nav-text">错误</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#listen-%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.</span> <span class="nav-text">listen 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#accept-%E5%87%BD%E6%95%B0"><span class="nav-number">4.5.</span> <span class="nav-text">accept 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bind-%E9%94%99%E8%AF%AF"><span class="nav-number">4.5.1.</span> <span class="nav-text">bind 错误</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fork-%E5%92%8C-exec-%E5%87%BD%E6%95%B0"><span class="nav-number">4.6.</span> <span class="nav-text">fork 和 exec 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">4.7.</span> <span class="nav-text">并发服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#close-%E5%87%BD%E6%95%B0"><span class="nav-number">4.8.</span> <span class="nav-text">close 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%87%BD%E6%95%B0"><span class="nav-number">4.9.</span> <span class="nav-text">地址函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-5"><span class="nav-number">5.</span> <span class="nav-text">Chapter 5</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-Echo-Server"><span class="nav-number">5.1.</span> <span class="nav-text">TCP Echo Server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Normal-Startup"><span class="nav-number">5.2.</span> <span class="nav-text">Normal Startup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Normal-Termination"><span class="nav-number">5.3.</span> <span class="nav-text">Normal Termination</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="nav-number">5.4.</span> <span class="nav-text">信号处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#wait-amp-waitpid"><span class="nav-number">5.4.1.</span> <span class="nav-text">wait &amp; waitpid</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#accept-%E8%BF%94%E5%9B%9E%E5%89%8D%E8%BF%9E%E6%8E%A5%E4%B8%AD%E6%AD%A2"><span class="nav-number">5.4.2.</span> <span class="nav-text">accept 返回前连接中止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-number">5.4.3.</span> <span class="nav-text">服务器进程终止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%BB%E6%9C%BA%E5%B4%A9%E6%BA%83"><span class="nav-number">5.4.4.</span> <span class="nav-text">服务器主机崩溃</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%BB%E6%9C%BA%E5%B4%A9%E6%BA%83%E5%90%8E%E9%87%8D%E5%90%AF"><span class="nav-number">5.4.5.</span> <span class="nav-text">服务器主机崩溃后重启</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.4.6.</span> <span class="nav-text">数据格式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-6"><span class="nav-number">6.</span> <span class="nav-text">Chapter 6</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O-Model"><span class="nav-number">6.1.</span> <span class="nav-text">I&#x2F;O Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.</span> <span class="nav-text">select 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fd-set-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">6.2.1.</span> <span class="nav-text">fd_set 数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB-ready-%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">6.2.2.</span> <span class="nav-text">读 ready 的条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99-ready-%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">6.2.3.</span> <span class="nav-text">写 ready 的条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exceptiong-ready"><span class="nav-number">6.2.4.</span> <span class="nav-text">exceptiong ready</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#str-cli"><span class="nav-number">6.3.</span> <span class="nav-text">str_cli</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shutdown"><span class="nav-number">6.4.</span> <span class="nav-text">shutdown</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#str-cli-pipeline%E7%89%88"><span class="nav-number">6.5.</span> <span class="nav-text">str_cli pipeline版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-echo-%E7%A8%8B%E5%BA%8F-select-%E7%89%88"><span class="nav-number">6.6.</span> <span class="nav-text">TCP echo 程序- select 版</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-7"><span class="nav-number">7.</span> <span class="nav-text">Chapter 7</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sockopt-%E5%87%BD%E6%95%B0"><span class="nav-number">7.1.</span> <span class="nav-text">_sockopt 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SO-KEEPALIVE"><span class="nav-number">7.2.</span> <span class="nav-text">SO_KEEPALIVE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SO-LINGER-%EF%BC%9F"><span class="nav-number">7.3.</span> <span class="nav-text">SO_LINGER ？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SO-DONTROUTE"><span class="nav-number">7.4.</span> <span class="nav-text">SO_DONTROUTE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP-HDRINCL"><span class="nav-number">7.5.</span> <span class="nav-text">IP_HDRINCL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP-TTL"><span class="nav-number">7.6.</span> <span class="nav-text">IP_TTL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-TCP-MAXSEG"><span class="nav-number">7.7.</span> <span class="nav-text">TCP : TCP_MAXSEG</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-8"><span class="nav-number">8.</span> <span class="nav-text">Chapter 8</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E7%A8%8B%E6%9C%AA%E8%BF%90%E8%A1%8C"><span class="nav-number">8.1.</span> <span class="nav-text">服务器进程未运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#connect"><span class="nav-number">8.2.</span> <span class="nav-text">connect</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-11"><span class="nav-number">9.</span> <span class="nav-text">Chapter 11</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gethostbyname"><span class="nav-number">9.1.</span> <span class="nav-text">gethostbyname</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gethostbyaddr"><span class="nav-number">9.2.</span> <span class="nav-text">gethostbyaddr</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-3-Advanced-Sockets"><span class="nav-number">10.</span> <span class="nav-text">Part 3 Advanced Sockets</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">11.</span> <span class="nav-text">问题</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Augists"
      src="https://augists-upic.oss-cn-qingdao.aliyuncs.com/uPic/2CCC8E38-15C8-4A70-A836-2DC4D988DD4E_1_105_c.jpeg">
  <p class="site-author-name" itemprop="name">Augists</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">171</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://augists.top/subscribe" title="Subscribe → https:&#x2F;&#x2F;augists.top&#x2F;subscribe"><i class="fab fa-mailchimp fa-fw"></i>Subscribe</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/Augists" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Augists" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:awzyc2010@163.com" title="E-Mail → mailto:awzyc2010@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/484868244" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;484868244" rel="noopener" target="_blank"><i class="fa fa-tv fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://t.me/Augists" title="Telegram → https:&#x2F;&#x2F;t.me&#x2F;Augists" rel="noopener" target="_blank"><i class="fab fa-telegram fa-fw"></i>Telegram</a>
      </span>
  </div>

<a href="https://www.foreverblog.cn/go.html" target="_blank"> <img src="https://img.foreverblog.cn/wormhole_2.gif" alt="" style="width:auto;height:32px;" title="穿梭虫洞-随机访问十年之约友链博客"></a>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Augists</span>
</div>
  <div class="powered-by">
    <!--
    <i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
      Click Number:<span id="busuanzi_value_site_pv"></span>次
    </span>Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
    -->
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


  <!-- TODO -->
  <!-- 动态线条 -->
  <!--  -->

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"scale":1,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":280,"height":300},"mobile":{"show":true,"scale":0.5},"log":false,"tagMode":false});</script></body>
</html>
